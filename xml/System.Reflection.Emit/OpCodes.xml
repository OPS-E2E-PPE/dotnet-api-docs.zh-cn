<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="76cf31c35ad94a83719988c90e476ffdd459c191" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75169328" /></Metadata><TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="02415-101">通过 <see cref="T:System.Reflection.Emit.ILGenerator" /> 类成员（例如 <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />）为发出提供 Microsoft 中间语言 (MSIL) 指令的字段表示形式。</span><span class="sxs-lookup"><span data-stu-id="02415-101">Provides field representations of the Microsoft Intermediate Language (MSIL) instructions for emission by the <see cref="T:System.Reflection.Emit.ILGenerator" /> class members (such as <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-102">有关成员操作码的详细说明，请参阅公共语言基础结构（CLI）文档，尤其是 "第三部分： CIL 指令集" 和 "第二部分：元数据定义和语义"。</span><span class="sxs-lookup"><span data-stu-id="02415-102">For a detailed description of the member opcodes, see the Common Language Infrastructure (CLI) documentation, especially "Partition III: CIL Instruction Set" and "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="02415-103">可联机获取该文档；请参阅 MSDN 上的 [ECMA C# 和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)和 Ecma International 网站上的[标准 ECMA-335 - 公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)。</span><span class="sxs-lookup"><span data-stu-id="02415-103">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02415-104">下面的示例演示如何使用 <xref:System.Reflection.Emit.ILGenerator> 将 `OpCodes` 发送到 <xref:System.Reflection.Emit.MethodBuilder>的动态方法。</span><span class="sxs-lookup"><span data-stu-id="02415-104">The following example demonstrates the construction of a dynamic method using <xref:System.Reflection.Emit.ILGenerator> to emit `OpCodes` into a <xref:System.Reflection.Emit.MethodBuilder>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-105">将两个值相加并将结果推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-105">Adds two values and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-106">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-106">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-107">格式</span><span class="sxs-lookup"><span data-stu-id="02415-107">Format</span></span>|<span data-ttu-id="02415-108">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-108">Assembly Format</span></span>|<span data-ttu-id="02415-109">说明</span><span class="sxs-lookup"><span data-stu-id="02415-109">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-110">58</span><span class="sxs-lookup"><span data-stu-id="02415-110">58</span></span>|<span data-ttu-id="02415-111">add</span><span class="sxs-lookup"><span data-stu-id="02415-111">add</span></span>|<span data-ttu-id="02415-112">将两个数值相加，并返回一个新的数值。</span><span class="sxs-lookup"><span data-stu-id="02415-112">Adds two numeric values, returning a new numeric value.</span></span>|  
  
 <span data-ttu-id="02415-113">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-113">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-114">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-114">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-115">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-115">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-116">从堆栈中弹出 `value2` 和 `value1`;`value1` 添加到 `value2`中。</span><span class="sxs-lookup"><span data-stu-id="02415-116">`value2` and `value1` are popped from the stack; `value1` is added to `value2`.</span></span>  
  
4.  <span data-ttu-id="02415-117">将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-117">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-118">未检测到用于整数运算的溢出（有关正确的溢出处理，请参阅 <xref:System.Reflection.Emit.OpCodes.Add_Ovf>）。</span><span class="sxs-lookup"><span data-stu-id="02415-118">Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).</span></span>  
  
 <span data-ttu-id="02415-119">整数加法换行，而不是尽量充满。</span><span class="sxs-lookup"><span data-stu-id="02415-119">Integer addition wraps, rather than saturates.</span></span> <span data-ttu-id="02415-120">例如，假设 `value1` 的8位整数设置为255，并且 `value2` 设置为1，则已包装的结果为0而不是256。</span><span class="sxs-lookup"><span data-stu-id="02415-120">For example, assuming 8-bit integers where `value1` is set to 255 and `value2` is set to 1, the wrapped result is 0 rather than 256.</span></span>  
  
 <span data-ttu-id="02415-121">浮点溢出返回 `+inf` （`PositiveInfinity`）或 `-inf` （`NegativeInfinity`）。</span><span class="sxs-lookup"><span data-stu-id="02415-121">Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).</span></span>  
  
 <span data-ttu-id="02415-122">下表列出了可接受的操作数类型及其对应的结果数据类型。</span><span class="sxs-lookup"><span data-stu-id="02415-122">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="02415-123">如果没有特定类型组合的条目（例如 `int32` 和 `float`; `int32` 和 `int64`），则它是无效的 Microsoft 中间语言（MSIL）并生成错误。</span><span class="sxs-lookup"><span data-stu-id="02415-123">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) and generates an error.</span></span>  
  
|<span data-ttu-id="02415-124">操作数</span><span class="sxs-lookup"><span data-stu-id="02415-124">operand</span></span>|<span data-ttu-id="02415-125">value1 类型</span><span class="sxs-lookup"><span data-stu-id="02415-125">value1 type</span></span>|<span data-ttu-id="02415-126">value2 类型</span><span class="sxs-lookup"><span data-stu-id="02415-126">value2 type</span></span>|<span data-ttu-id="02415-127">结果类型</span><span class="sxs-lookup"><span data-stu-id="02415-127">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="02415-128">add</span><span class="sxs-lookup"><span data-stu-id="02415-128">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="02415-129">add</span><span class="sxs-lookup"><span data-stu-id="02415-129">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="02415-130">add</span><span class="sxs-lookup"><span data-stu-id="02415-130">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="02415-131">add</span><span class="sxs-lookup"><span data-stu-id="02415-131">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="02415-132">add</span><span class="sxs-lookup"><span data-stu-id="02415-132">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="02415-133">add</span><span class="sxs-lookup"><span data-stu-id="02415-133">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="02415-134">add</span><span class="sxs-lookup"><span data-stu-id="02415-134">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="02415-135">add</span><span class="sxs-lookup"><span data-stu-id="02415-135">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="02415-136">add</span><span class="sxs-lookup"><span data-stu-id="02415-136">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="02415-137">add</span><span class="sxs-lookup"><span data-stu-id="02415-137">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="02415-138">add</span><span class="sxs-lookup"><span data-stu-id="02415-138">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="02415-139">add</span><span class="sxs-lookup"><span data-stu-id="02415-139">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="02415-140">add</span><span class="sxs-lookup"><span data-stu-id="02415-140">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="02415-141">add</span><span class="sxs-lookup"><span data-stu-id="02415-141">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="02415-142">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `add` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-142">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add` opcode:</span></span>  
  
-   <span data-ttu-id="02415-143">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-143">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-144">将两个整数相加，执行溢出检查，并且将结果推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-144">Adds two integers, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-145">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-145">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-146">格式</span><span class="sxs-lookup"><span data-stu-id="02415-146">Format</span></span>|<span data-ttu-id="02415-147">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-147">Assembly Format</span></span>|<span data-ttu-id="02415-148">说明</span><span class="sxs-lookup"><span data-stu-id="02415-148">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-149">D6</span><span class="sxs-lookup"><span data-stu-id="02415-149">D6</span></span>|<span data-ttu-id="02415-150">add.ovf</span><span class="sxs-lookup"><span data-stu-id="02415-150">add.ovf</span></span>|<span data-ttu-id="02415-151">使用溢出检查添加两个有符号整数值。</span><span class="sxs-lookup"><span data-stu-id="02415-151">Adds two signed integer values with an overflow check.</span></span>|  
  
 <span data-ttu-id="02415-152">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-152">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-153">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-153">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-154">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-154">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-155">从堆栈中弹出 `value2` 和 `value1`;将 `value1` 添加到具有溢出检查的 `value2` 中。</span><span class="sxs-lookup"><span data-stu-id="02415-155">`value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="02415-156">将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-156">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-157">如果结果类型中未表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-157"><xref:System.OverflowException> is thrown if the result is not represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-158">您可以对有符号整数执行此操作。</span><span class="sxs-lookup"><span data-stu-id="02415-158">You can perform this operation on signed integers.</span></span> <span data-ttu-id="02415-159">对于浮点值，请使用 <xref:System.Reflection.Emit.OpCodes.Add>。</span><span class="sxs-lookup"><span data-stu-id="02415-159">For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.</span></span>  
  
 <span data-ttu-id="02415-160">下表列出了可接受的操作数类型及其对应的结果数据类型。</span><span class="sxs-lookup"><span data-stu-id="02415-160">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="02415-161">如果没有特定类型组合的条目（例如 `int32` 和 `float`; `int32` 和 `int64`），则它是无效的 Microsoft 中间语言（MSIL）指令并生成错误。</span><span class="sxs-lookup"><span data-stu-id="02415-161">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</span></span>  
  
|<span data-ttu-id="02415-162">操作数</span><span class="sxs-lookup"><span data-stu-id="02415-162">operand</span></span>|<span data-ttu-id="02415-163">value1 类型</span><span class="sxs-lookup"><span data-stu-id="02415-163">value1 type</span></span>|<span data-ttu-id="02415-164">value2 类型</span><span class="sxs-lookup"><span data-stu-id="02415-164">value2 type</span></span>|<span data-ttu-id="02415-165">结果类型</span><span class="sxs-lookup"><span data-stu-id="02415-165">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="02415-166">add</span><span class="sxs-lookup"><span data-stu-id="02415-166">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="02415-167">add</span><span class="sxs-lookup"><span data-stu-id="02415-167">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="02415-168">add</span><span class="sxs-lookup"><span data-stu-id="02415-168">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="02415-169">add</span><span class="sxs-lookup"><span data-stu-id="02415-169">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="02415-170">add</span><span class="sxs-lookup"><span data-stu-id="02415-170">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="02415-171">add</span><span class="sxs-lookup"><span data-stu-id="02415-171">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="02415-172">add</span><span class="sxs-lookup"><span data-stu-id="02415-172">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="02415-173">add</span><span class="sxs-lookup"><span data-stu-id="02415-173">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="02415-174">add</span><span class="sxs-lookup"><span data-stu-id="02415-174">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="02415-175">add</span><span class="sxs-lookup"><span data-stu-id="02415-175">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="02415-176">add</span><span class="sxs-lookup"><span data-stu-id="02415-176">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="02415-177">add</span><span class="sxs-lookup"><span data-stu-id="02415-177">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="02415-178">add</span><span class="sxs-lookup"><span data-stu-id="02415-178">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="02415-179">add</span><span class="sxs-lookup"><span data-stu-id="02415-179">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="02415-180">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `add.ovf` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-180">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="02415-181">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-181">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-182">将两个无符号整数值相加，执行溢出检查，并且将结果推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-182">Adds two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-183">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-183">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-184">格式</span><span class="sxs-lookup"><span data-stu-id="02415-184">Format</span></span>|<span data-ttu-id="02415-185">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-185">Assembly Format</span></span>|<span data-ttu-id="02415-186">说明</span><span class="sxs-lookup"><span data-stu-id="02415-186">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-187">D7</span><span class="sxs-lookup"><span data-stu-id="02415-187">D7</span></span>|<span data-ttu-id="02415-188">add.ovf.un</span><span class="sxs-lookup"><span data-stu-id="02415-188">add.ovf.un</span></span>|<span data-ttu-id="02415-189">使用溢出检查添加两个无符号整数值。</span><span class="sxs-lookup"><span data-stu-id="02415-189">Adds two unsigned integer values with an overflow check.</span></span>|  
  
 <span data-ttu-id="02415-190">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-190">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-191">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-191">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-192">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-192">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-193">从堆栈中弹出 `value2` 和 `value1`;将 `value1` 添加到具有溢出检查的 `value2` 中。</span><span class="sxs-lookup"><span data-stu-id="02415-193">`value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="02415-194">将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-194">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-195">如果结果类型中未表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-195"><xref:System.OverflowException> is thrown if the result is not represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-196">您可以对有符号整数执行此操作。</span><span class="sxs-lookup"><span data-stu-id="02415-196">You can perform this operation on signed integers.</span></span> <span data-ttu-id="02415-197">对于浮点值，请使用 <xref:System.Reflection.Emit.OpCodes.Add>。</span><span class="sxs-lookup"><span data-stu-id="02415-197">For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.</span></span>  
  
 <span data-ttu-id="02415-198">下表列出了可接受的操作数类型及其对应的结果数据类型。</span><span class="sxs-lookup"><span data-stu-id="02415-198">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="02415-199">如果没有特定类型组合的条目（例如 `int32` 和 `float`; `int32` 和 `int64`），则它是无效的 Microsoft 中间语言（MSIL）指令并生成错误。</span><span class="sxs-lookup"><span data-stu-id="02415-199">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</span></span>  
  
|<span data-ttu-id="02415-200">操作数</span><span class="sxs-lookup"><span data-stu-id="02415-200">operand</span></span>|<span data-ttu-id="02415-201">value1 类型</span><span class="sxs-lookup"><span data-stu-id="02415-201">value1 type</span></span>|<span data-ttu-id="02415-202">value2 类型</span><span class="sxs-lookup"><span data-stu-id="02415-202">value2 type</span></span>|<span data-ttu-id="02415-203">结果类型</span><span class="sxs-lookup"><span data-stu-id="02415-203">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="02415-204">add</span><span class="sxs-lookup"><span data-stu-id="02415-204">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="02415-205">add</span><span class="sxs-lookup"><span data-stu-id="02415-205">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="02415-206">add</span><span class="sxs-lookup"><span data-stu-id="02415-206">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="02415-207">add</span><span class="sxs-lookup"><span data-stu-id="02415-207">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="02415-208">add</span><span class="sxs-lookup"><span data-stu-id="02415-208">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="02415-209">add</span><span class="sxs-lookup"><span data-stu-id="02415-209">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="02415-210">add</span><span class="sxs-lookup"><span data-stu-id="02415-210">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="02415-211">add</span><span class="sxs-lookup"><span data-stu-id="02415-211">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="02415-212">add</span><span class="sxs-lookup"><span data-stu-id="02415-212">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="02415-213">add</span><span class="sxs-lookup"><span data-stu-id="02415-213">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="02415-214">add</span><span class="sxs-lookup"><span data-stu-id="02415-214">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="02415-215">add</span><span class="sxs-lookup"><span data-stu-id="02415-215">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="02415-216">add</span><span class="sxs-lookup"><span data-stu-id="02415-216">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="02415-217">add</span><span class="sxs-lookup"><span data-stu-id="02415-217">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="02415-218">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `add.ovf.un` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-218">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="02415-219">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-219">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-220">计算两个值的按位“与”并将结果推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-220">Computes the bitwise AND of two values and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-221">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-221">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-222">格式</span><span class="sxs-lookup"><span data-stu-id="02415-222">Format</span></span>|<span data-ttu-id="02415-223">指令</span><span class="sxs-lookup"><span data-stu-id="02415-223">Instruction</span></span>|<span data-ttu-id="02415-224">说明</span><span class="sxs-lookup"><span data-stu-id="02415-224">Description</span></span>|  
|------------|-----------------|-----------------|  
|<span data-ttu-id="02415-225">5F</span><span class="sxs-lookup"><span data-stu-id="02415-225">5F</span></span>|<span data-ttu-id="02415-226">和</span><span class="sxs-lookup"><span data-stu-id="02415-226">and</span></span>|<span data-ttu-id="02415-227">确定两个整数值的按位 "与"。</span><span class="sxs-lookup"><span data-stu-id="02415-227">Determines the bitwise AND of two integer values.</span></span>|  
  
 <span data-ttu-id="02415-228">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-228">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-229">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-229">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-230">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-230">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-231">从堆栈中弹出 `value1` 和 `value2`;计算两个值的按位 "与"。</span><span class="sxs-lookup"><span data-stu-id="02415-231">`value1` and `value2` are popped from the stack; the bitwise AND of the two values is computed.</span></span>  
  
4.  <span data-ttu-id="02415-232">将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-232">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-233">`and` 指令计算堆栈上前两个值的按位 "与"，并将结果保留在堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-233">The `and` instruction computes the bitwise AND of the top two values on the stack and leaves the result on the stack.</span></span>  
  
 <span data-ttu-id="02415-234">`And` 是特定于整数的操作。</span><span class="sxs-lookup"><span data-stu-id="02415-234">`And` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="02415-235">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `and` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-235">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `and` opcode:</span></span>  
  
-   <span data-ttu-id="02415-236">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-236">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-237">返回指向当前方法的参数列表的非托管指针。</span><span class="sxs-lookup"><span data-stu-id="02415-237">Returns an unmanaged pointer to the argument list of the current method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-238">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-238">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-239">格式</span><span class="sxs-lookup"><span data-stu-id="02415-239">Format</span></span>|<span data-ttu-id="02415-240">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-240">Assembly Format</span></span>|<span data-ttu-id="02415-241">说明</span><span class="sxs-lookup"><span data-stu-id="02415-241">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-242">FE 00</span><span class="sxs-lookup"><span data-stu-id="02415-242">FE 00</span></span>|<span data-ttu-id="02415-243">arglist</span><span class="sxs-lookup"><span data-stu-id="02415-243">arglist</span></span>|<span data-ttu-id="02415-244">返回当前方法的参数列表句柄。</span><span class="sxs-lookup"><span data-stu-id="02415-244">Returns an argument list handle for the current method.</span></span>|  
  
 <span data-ttu-id="02415-245">此操作不会执行任何计算堆栈行为。</span><span class="sxs-lookup"><span data-stu-id="02415-245">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="02415-246">`arglist` 指令返回表示当前方法的参数列表的不透明的句柄（类型为 `native int`的非托管指针）。</span><span class="sxs-lookup"><span data-stu-id="02415-246">The `arglist` instruction returns an opaque handle (an unmanaged pointer, of type `native int`) that represents the argument list of the current method.</span></span> <span data-ttu-id="02415-247">此句柄仅在当前方法的生存期内有效。</span><span class="sxs-lookup"><span data-stu-id="02415-247">This handle is valid only during the lifetime of the current method.</span></span> <span data-ttu-id="02415-248">但是，只要当前方法在控制线程上，你就可以将该句柄传递给其他方法。</span><span class="sxs-lookup"><span data-stu-id="02415-248">You can, however, pass the handle to other methods as long as the current method is on the thread of control.</span></span> <span data-ttu-id="02415-249">只能在采用可变数目的参数的方法中执行 `arglist` 指令。</span><span class="sxs-lookup"><span data-stu-id="02415-249">You can only execute the `arglist` instruction within a method that takes a variable number of arguments.</span></span>  
  
 <span data-ttu-id="02415-250">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `arglist` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-250">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `arglist` opcode:</span></span>  
  
-   <span data-ttu-id="02415-251">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-251">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-252">如果两个值相等，则将控制转移到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-252">Transfers control to a target instruction if two values are equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-253">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-253">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-254">格式</span><span class="sxs-lookup"><span data-stu-id="02415-254">Format</span></span>|<span data-ttu-id="02415-255">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-255">Assembly Format</span></span>|<span data-ttu-id="02415-256">说明</span><span class="sxs-lookup"><span data-stu-id="02415-256">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-257">3B < `int32` ></span><span class="sxs-lookup"><span data-stu-id="02415-257">3B < `int32` ></span></span>|<span data-ttu-id="02415-258">beq `target`</span><span class="sxs-lookup"><span data-stu-id="02415-258">beq `target`</span></span>|<span data-ttu-id="02415-259">如果两个值相等，则在偏移 `target` 分支到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-259">Branch to the target instruction at offset `target` if the two values are equal.</span></span>|  
  
 <span data-ttu-id="02415-260">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-260">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-261">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-261">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-262">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-262">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-263">从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 等于 `value2`，则执行分支操作。</span><span class="sxs-lookup"><span data-stu-id="02415-263">`value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="02415-264">如果 `value1` 等于 `value2`，则 `beq` 指令将控制转移到指定的目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-264">The `beq` instruction transfers control to the specified target instruction if `value1` is equal to `value2`.</span></span> <span data-ttu-id="02415-265">其效果与执行 `ceq` 指令后跟特定目标指令的 `brtrue` 分支相同。</span><span class="sxs-lookup"><span data-stu-id="02415-265">The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="02415-266">目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-266">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-267">可接受的操作数类型如下所示：</span><span class="sxs-lookup"><span data-stu-id="02415-267">The acceptable operand types are encapsulated below:</span></span>  
  
 <span data-ttu-id="02415-268">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-268">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="02415-269">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制（此类传输受到严格限制，因此必须改用 <xref:System.Reflection.Emit.OpCodes.Leave> 指令）。</span><span class="sxs-lookup"><span data-stu-id="02415-269">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).</span></span>  
  
 <span data-ttu-id="02415-270">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `beq` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-270">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq` opcode:</span></span>  
  
-   <span data-ttu-id="02415-271">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-271">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-272">如果两个值相等，则将控制转移到目标指令（短格式）。</span><span class="sxs-lookup"><span data-stu-id="02415-272">Transfers control to a target instruction (short form) if two values are equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-273">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-273">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-274">格式</span><span class="sxs-lookup"><span data-stu-id="02415-274">Format</span></span>|<span data-ttu-id="02415-275">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-275">Assembly Format</span></span>|<span data-ttu-id="02415-276">说明</span><span class="sxs-lookup"><span data-stu-id="02415-276">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-277">2E < `int8` ></span><span class="sxs-lookup"><span data-stu-id="02415-277">2E < `int8` ></span></span>|<span data-ttu-id="02415-278">beq `target`</span><span class="sxs-lookup"><span data-stu-id="02415-278">beq.s `target`</span></span>|<span data-ttu-id="02415-279">如果相等，则分支到目标指令（如果相等） `target` 短格式</span><span class="sxs-lookup"><span data-stu-id="02415-279">Branch to the target instruction at offset `target` if equal, short form</span></span>|  
  
 <span data-ttu-id="02415-280">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-280">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-281">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-281">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-282">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-282">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-283">从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 等于 `value2`，则执行分支操作。</span><span class="sxs-lookup"><span data-stu-id="02415-283">`value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="02415-284">如果 `value1` 等于 `value2`，则 `beq.s` 指令将控制转移到指定的目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-284">The `beq.s` instruction transfers control to the specified target instruction if `value1` is equal to `value2`.</span></span> <span data-ttu-id="02415-285">其效果与执行 `ceq` 指令后跟特定目标指令的 `brtrue` 分支相同。</span><span class="sxs-lookup"><span data-stu-id="02415-285">The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="02415-286">目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-286">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-287">可接受的操作数类型如下所示：</span><span class="sxs-lookup"><span data-stu-id="02415-287">The acceptable operand types are encapsulated below:</span></span>  
  
 <span data-ttu-id="02415-288">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-288">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="02415-289">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制（此类传输受到严格限制，因此必须改用 <xref:System.Reflection.Emit.OpCodes.Leave> 指令）。</span><span class="sxs-lookup"><span data-stu-id="02415-289">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).</span></span>  
  
 <span data-ttu-id="02415-290">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `beq.s` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-290">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq.s` opcode:</span></span>  
  
-   <span data-ttu-id="02415-291">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-291">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-292">如果第一个值大于或等于第二个值，则将控制转移到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-292">Transfers control to a target instruction if the first value is greater than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-293">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-293">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-294">格式</span><span class="sxs-lookup"><span data-stu-id="02415-294">Format</span></span>|<span data-ttu-id="02415-295">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-295">Assembly Format</span></span>|<span data-ttu-id="02415-296">说明</span><span class="sxs-lookup"><span data-stu-id="02415-296">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-297">3C `<int32>`</span><span class="sxs-lookup"><span data-stu-id="02415-297">3C `<int32>`</span></span>|<span data-ttu-id="02415-298">bge `target`</span><span class="sxs-lookup"><span data-stu-id="02415-298">bge `target`</span></span>|<span data-ttu-id="02415-299">如果第一个值大于或等于第二个值，则按指定的偏移量分支到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-299">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value.</span></span>|  
  
 <span data-ttu-id="02415-300">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-300">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-301">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-301">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-302">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-302">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-303">从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 大于或等于 `value2`，则执行分支操作。</span><span class="sxs-lookup"><span data-stu-id="02415-303">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="02415-304">如果 `value1` 大于或等于 `value2`，则 `bge` 指令将控制转移到指定的目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-304">The `bge` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`.</span></span> <span data-ttu-id="02415-305">其效果与执行 `clt.un` 指令后跟特定目标指令的 `brfalse` 分支相同。</span><span class="sxs-lookup"><span data-stu-id="02415-305">The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="02415-306">目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-306">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-307">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-307">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="02415-308">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。</span><span class="sxs-lookup"><span data-stu-id="02415-308">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="02415-309">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `bge` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-309">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge` opcode:</span></span>  
  
-   <span data-ttu-id="02415-310">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-310">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-311">如果第一个值大于或等于第二个值，则将控制转移到目标指令（短格式）。</span><span class="sxs-lookup"><span data-stu-id="02415-311">Transfers control to a target instruction (short form) if the first value is greater than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-312">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-312">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-313">格式</span><span class="sxs-lookup"><span data-stu-id="02415-313">Format</span></span>|<span data-ttu-id="02415-314">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-314">Assembly Format</span></span>|<span data-ttu-id="02415-315">说明</span><span class="sxs-lookup"><span data-stu-id="02415-315">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-316">2F `<int8>`</span><span class="sxs-lookup"><span data-stu-id="02415-316">2F `<int8>`</span></span>|<span data-ttu-id="02415-317">bge `target`</span><span class="sxs-lookup"><span data-stu-id="02415-317">bge.s `target`</span></span>|<span data-ttu-id="02415-318">如果第一个值大于或等于第二个值，则按指定的偏移量分支到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-318">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value, short form.</span></span>|  
  
 <span data-ttu-id="02415-319">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-319">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-320">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-320">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-321">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-321">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-322">从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 大于或等于 `value2`，则执行分支操作。</span><span class="sxs-lookup"><span data-stu-id="02415-322">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="02415-323">如果 `value1` 大于或等于 `value2`，则 `bge.s` 指令将控制转移到指定的目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-323">The `bge.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`.</span></span> <span data-ttu-id="02415-324">其效果与执行 `clt.un` 指令后跟特定目标指令的 `brfalse` 分支相同。</span><span class="sxs-lookup"><span data-stu-id="02415-324">The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="02415-325">目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-325">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-326">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-326">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="02415-327">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。</span><span class="sxs-lookup"><span data-stu-id="02415-327">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="02415-328">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `bge.s` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-328">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.s` opcode:</span></span>  
  
-   <span data-ttu-id="02415-329">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-329">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-330">当比较无符号整数值或未经排序的浮点值时，如果第一个值大于第二个值，则将控制转移到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-330">Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-331">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-331">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-332">格式</span><span class="sxs-lookup"><span data-stu-id="02415-332">Format</span></span>|<span data-ttu-id="02415-333">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-333">Assembly Format</span></span>|<span data-ttu-id="02415-334">说明</span><span class="sxs-lookup"><span data-stu-id="02415-334">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-335">41 `<int32>`</span><span class="sxs-lookup"><span data-stu-id="02415-335">41 `<int32>`</span></span>|<span data-ttu-id="02415-336">bge `target`</span><span class="sxs-lookup"><span data-stu-id="02415-336">bge.un `target`</span></span>|<span data-ttu-id="02415-337">如果第一个值大于或等于第二个值（无符号值），则按指定的偏移量分支到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-337">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="02415-338">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-338">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-339">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-339">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-340">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-340">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-341">从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 大于或等于 `value2`，则执行分支操作。</span><span class="sxs-lookup"><span data-stu-id="02415-341">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="02415-342">如果 `value1` 大于或等于 `value2`，则在使用无符号整数或无序浮点值进行比较时，`bge.un` 指令将控制转移到指定的目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-342">The `bge.un` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="02415-343">其效果与执行 `clt` 指令后跟特定目标指令的 `brfalse` 分支相同。</span><span class="sxs-lookup"><span data-stu-id="02415-343">The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="02415-344">目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-344">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-345">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-345">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="02415-346">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。</span><span class="sxs-lookup"><span data-stu-id="02415-346">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="02415-347">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `bge.un` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-347">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un` opcode:</span></span>  
  
-   <span data-ttu-id="02415-348">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-348">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-349">当比较无符号整数值或未经排序的浮点值时，如果第一个值大于第二个值，则将控制转移到目标指令（短格式）。</span><span class="sxs-lookup"><span data-stu-id="02415-349">Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-350">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-350">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-351">格式</span><span class="sxs-lookup"><span data-stu-id="02415-351">Format</span></span>|<span data-ttu-id="02415-352">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-352">Assembly Format</span></span>|<span data-ttu-id="02415-353">说明</span><span class="sxs-lookup"><span data-stu-id="02415-353">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-354">34 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="02415-354">34 < `int8` ></span></span>|<span data-ttu-id="02415-355">bge `target`</span><span class="sxs-lookup"><span data-stu-id="02415-355">bge.un.s `target`</span></span>|<span data-ttu-id="02415-356">如果第一个值大于或等于第二个值（无符号值），则按指定的偏移量分支到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-356">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="02415-357">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-357">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-358">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-358">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-359">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-359">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-360">从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 大于或等于 `value2`，则执行分支操作。</span><span class="sxs-lookup"><span data-stu-id="02415-360">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="02415-361">如果 `value1` 大于或等于 `value2`，则在使用无符号整数或无序浮点值进行比较时，`bge.un.s` 指令将控制转移到指定的目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-361">The `bge.un.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="02415-362">其效果与执行 `clt` 指令后跟特定目标指令的 `brfalse` 分支相同。</span><span class="sxs-lookup"><span data-stu-id="02415-362">The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="02415-363">目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-363">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-364">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-364">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="02415-365">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。</span><span class="sxs-lookup"><span data-stu-id="02415-365">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="02415-366">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `bge.un.s` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-366">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="02415-367">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-367">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-368">如果第一个值大于第二个值，则将控制转移到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-368">Transfers control to a target instruction if the first value is greater than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-369">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-369">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-370">格式</span><span class="sxs-lookup"><span data-stu-id="02415-370">Format</span></span>|<span data-ttu-id="02415-371">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-371">Assembly Format</span></span>|<span data-ttu-id="02415-372">说明</span><span class="sxs-lookup"><span data-stu-id="02415-372">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-373">3D < `int32` ></span><span class="sxs-lookup"><span data-stu-id="02415-373">3D < `int32` ></span></span>|<span data-ttu-id="02415-374">预算 `target`</span><span class="sxs-lookup"><span data-stu-id="02415-374">bgt `target`</span></span>|<span data-ttu-id="02415-375">如果第一个值大于第二个值，则按指定的偏移量分支到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-375">Branch to the target instruction at the specified offset if the first value is greater than the second value.</span></span>|  
  
 <span data-ttu-id="02415-376">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-376">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-377">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-377">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-378">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-378">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-379">从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 大于 `value2`，则执行分支操作。</span><span class="sxs-lookup"><span data-stu-id="02415-379">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="02415-380">如果 `value1` 大于 `value2`，则 `bgt` 指令将控制转移到指定的目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-380">The `bgt` instruction transfers control to the specified target instruction if `value1` is greater than `value2`.</span></span> <span data-ttu-id="02415-381">其效果与执行 `cgt` 指令后跟特定目标指令的 `brtrue` 分支相同。</span><span class="sxs-lookup"><span data-stu-id="02415-381">The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="02415-382">目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-382">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-383">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-383">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="02415-384">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。</span><span class="sxs-lookup"><span data-stu-id="02415-384">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="02415-385">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `bgt` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-385">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt` opcode:</span></span>  
  
-   <span data-ttu-id="02415-386">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-386">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-387">如果第一个值大于第二个值，则将控制转移到目标指令（短格式）。</span><span class="sxs-lookup"><span data-stu-id="02415-387">Transfers control to a target instruction (short form) if the first value is greater than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-388">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-388">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-389">格式</span><span class="sxs-lookup"><span data-stu-id="02415-389">Format</span></span>|<span data-ttu-id="02415-390">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-390">Assembly Format</span></span>|<span data-ttu-id="02415-391">说明</span><span class="sxs-lookup"><span data-stu-id="02415-391">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-392">30 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="02415-392">30 < `int8` ></span></span>|<span data-ttu-id="02415-393">预算 `target`</span><span class="sxs-lookup"><span data-stu-id="02415-393">bgt.s `target`</span></span>|<span data-ttu-id="02415-394">如果第一个值大于第二个值，则按指定的偏移量分支到目标指令（缩写形式）。</span><span class="sxs-lookup"><span data-stu-id="02415-394">Branch to the target instruction at the specified offset if the first value is greater than the second value, short form.</span></span>|  
  
 <span data-ttu-id="02415-395">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-395">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-396">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-396">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-397">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-397">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-398">从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 大于 `value2`，则执行分支操作。</span><span class="sxs-lookup"><span data-stu-id="02415-398">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="02415-399">如果 `value1` 大于 `value2`，则 `bgt.s` 指令将控制转移到指定的目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-399">The `bgt.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`.</span></span> <span data-ttu-id="02415-400">其效果与执行 `cgt` 指令后跟特定目标指令的 `brtrue` 分支相同。</span><span class="sxs-lookup"><span data-stu-id="02415-400">The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="02415-401">目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-401">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-402">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-402">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="02415-403">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。</span><span class="sxs-lookup"><span data-stu-id="02415-403">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="02415-404">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `bgt.s` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-404">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.s` opcode:</span></span>  
  
-   <span data-ttu-id="02415-405">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-405">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-406">当比较无符号整数值或未经排序的浮点值时，如果第一个值大于第二个值，则将控制转移到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-406">Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-407">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-407">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-408">格式</span><span class="sxs-lookup"><span data-stu-id="02415-408">Format</span></span>|<span data-ttu-id="02415-409">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-409">Assembly Format</span></span>|<span data-ttu-id="02415-410">说明</span><span class="sxs-lookup"><span data-stu-id="02415-410">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-411">42 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="02415-411">42 < `int32` ></span></span>|<span data-ttu-id="02415-412">预算 `target`</span><span class="sxs-lookup"><span data-stu-id="02415-412">bgt.un `target`</span></span>|<span data-ttu-id="02415-413">如果第一个值大于第二个值（无符号值），则按指定的偏移量分支到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-413">Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="02415-414">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-414">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-415">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-415">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-416">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-416">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-417">从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 大于 `value2`，则执行分支操作。</span><span class="sxs-lookup"><span data-stu-id="02415-417">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="02415-418">当使用无符号整数或无序浮点值进行比较时，如果 `value1` 大于 `value2`，则 `bgt.un` 指令将控制转移到指定的目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-418">The `bgt.un` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="02415-419">其效果与执行 `cgt.un` 指令后跟特定目标指令的 `brtrue` 分支相同。</span><span class="sxs-lookup"><span data-stu-id="02415-419">The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="02415-420">目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-420">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-421">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-421">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="02415-422">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。</span><span class="sxs-lookup"><span data-stu-id="02415-422">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="02415-423">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `bgt.un` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-423">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un` opcode:</span></span>  
  
-   <span data-ttu-id="02415-424">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-424">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-425">当比较无符号整数值或未经排序的浮点值时，如果第一个值大于第二个值，则将控制转移到目标指令（短格式）。</span><span class="sxs-lookup"><span data-stu-id="02415-425">Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-426">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-426">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-427">格式</span><span class="sxs-lookup"><span data-stu-id="02415-427">Format</span></span>|<span data-ttu-id="02415-428">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-428">Assembly Format</span></span>|<span data-ttu-id="02415-429">说明</span><span class="sxs-lookup"><span data-stu-id="02415-429">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-430">35 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="02415-430">35 < `int8` ></span></span>|<span data-ttu-id="02415-431">预算 `target`</span><span class="sxs-lookup"><span data-stu-id="02415-431">bgt.un.s `target`</span></span>|<span data-ttu-id="02415-432">如果第一个值大于第二个值（无符号值），则按指定的偏移量分支到目标指令（短格式）。</span><span class="sxs-lookup"><span data-stu-id="02415-432">Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="02415-433">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-433">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-434">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-434">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-435">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-435">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-436">从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 大于 `value2`，则执行分支操作。</span><span class="sxs-lookup"><span data-stu-id="02415-436">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="02415-437">当使用无符号整数或无序浮点值进行比较时，如果 `value1` 大于 `value2`，则 `bgt.un.s` 指令将控制转移到指定的目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-437">The `bgt.un.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="02415-438">其效果与执行 `cgt.un` 指令后跟特定目标指令的 `brtrue` 分支相同。</span><span class="sxs-lookup"><span data-stu-id="02415-438">The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="02415-439">目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-439">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-440">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-440">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="02415-441">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。</span><span class="sxs-lookup"><span data-stu-id="02415-441">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="02415-442">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `bgt.un.s` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-442">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="02415-443">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-443">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-444">如果第一个值小于或等于第二个值，则将控制转移到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-444">Transfers control to a target instruction if the first value is less than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-445">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-445">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-446">格式</span><span class="sxs-lookup"><span data-stu-id="02415-446">Format</span></span>|<span data-ttu-id="02415-447">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-447">Assembly Format</span></span>|<span data-ttu-id="02415-448">说明</span><span class="sxs-lookup"><span data-stu-id="02415-448">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-449">3E `<int32>`</span><span class="sxs-lookup"><span data-stu-id="02415-449">3E `<int32>`</span></span>|<span data-ttu-id="02415-450">ble `target`</span><span class="sxs-lookup"><span data-stu-id="02415-450">ble `target`</span></span>|<span data-ttu-id="02415-451">如果第一个值小于或等于第二个值，则按指定的偏移量分支到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-451">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value.</span></span>|  
  
 <span data-ttu-id="02415-452">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-452">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-453">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-453">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-454">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-454">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-455">从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 小于或等于 `value2`，则执行分支操作。</span><span class="sxs-lookup"><span data-stu-id="02415-455">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="02415-456">如果 `value1` 小于或等于 `value2`，则 `ble` 指令将控制转移到指定的目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-456">The `ble` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="02415-457">此效果等同于执行 `cgt` 指令（`cgt.un` 对于浮点数），后跟一个 `brfalse` 分支到特定目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-457">The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="02415-458">目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-458">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-459">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-459">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="02415-460">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。</span><span class="sxs-lookup"><span data-stu-id="02415-460">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="02415-461">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ble` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-461">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble` opcode:</span></span>  
  
-   <span data-ttu-id="02415-462">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-462">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-463">如果第一个值小于或等于第二个值，则将控制转移到目标指令（短格式）。</span><span class="sxs-lookup"><span data-stu-id="02415-463">Transfers control to a target instruction (short form) if the first value is less than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-464">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-464">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-465">格式</span><span class="sxs-lookup"><span data-stu-id="02415-465">Format</span></span>|<span data-ttu-id="02415-466">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-466">Assembly Format</span></span>|<span data-ttu-id="02415-467">说明</span><span class="sxs-lookup"><span data-stu-id="02415-467">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-468">31 `<int8>`</span><span class="sxs-lookup"><span data-stu-id="02415-468">31 `<int8>`</span></span>|<span data-ttu-id="02415-469">ble `target`</span><span class="sxs-lookup"><span data-stu-id="02415-469">ble.s `target`</span></span>|<span data-ttu-id="02415-470">如果第一个值小于或等于第二个值，则按指定的偏移量分支到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-470">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value, short form.</span></span>|  
  
 <span data-ttu-id="02415-471">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-471">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-472">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-472">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-473">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-473">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-474">从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 小于或等于 `value2`，则执行分支操作。</span><span class="sxs-lookup"><span data-stu-id="02415-474">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="02415-475">如果 `value1` 小于或等于 `value2`，则 `ble.s` 指令将控制转移到指定的目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-475">The `ble.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="02415-476">其效果与执行 `cgt` 指令（`cgt.un` 对于浮点数）指令相同，后面跟有`brfalse` 分支到特定目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-476">The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) instruction followed by a`brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="02415-477">目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-477">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-478">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-478">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="02415-479">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。</span><span class="sxs-lookup"><span data-stu-id="02415-479">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="02415-480">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ble.s` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.s` opcode:</span></span>  
  
-   <span data-ttu-id="02415-481">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-481">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-482">当比较无符号整数值或未经排序的浮点值时，如果第一个值小于或等于第二个值，则将控制转移到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-482">Transfers control to a target instruction if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-483">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-484">格式</span><span class="sxs-lookup"><span data-stu-id="02415-484">Format</span></span>|<span data-ttu-id="02415-485">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-485">Assembly Format</span></span>|<span data-ttu-id="02415-486">说明</span><span class="sxs-lookup"><span data-stu-id="02415-486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-487">43 `<int32>`</span><span class="sxs-lookup"><span data-stu-id="02415-487">43 `<int32>`</span></span>|<span data-ttu-id="02415-488">ble `target`</span><span class="sxs-lookup"><span data-stu-id="02415-488">ble.un `target`</span></span>|<span data-ttu-id="02415-489">如果第一个值小于或等于第二个值（无符号值），则按指定的偏移量分支到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-489">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="02415-490">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-491">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-491">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-492">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-492">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-493">从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 小于或等于 `value2`，则执行分支操作。</span><span class="sxs-lookup"><span data-stu-id="02415-493">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="02415-494">当使用无符号整数或无序浮点值进行比较时，如果 `value1` 小于或等于 `value2`，则 `ble.un` 指令将控制转移到指定的目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-494">The `ble.un` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="02415-495">此效果等同于执行 `cgt.un` 指令（`cgt` 对于浮点数），后跟一个 `brfalse` 分支到特定目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-495">The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="02415-496">目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-496">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-497">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-497">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="02415-498">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。</span><span class="sxs-lookup"><span data-stu-id="02415-498">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="02415-499">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ble.un` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-499">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un` opcode:</span></span>  
  
-   <span data-ttu-id="02415-500">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-500">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-501">当比较无符号整数值或未经排序的浮点值时，如果第一个值小于或等于第二个值，则将控制转移到目标指令（短格式）。</span><span class="sxs-lookup"><span data-stu-id="02415-501">Transfers control to a target instruction (short form) if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-502">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-502">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-503">格式</span><span class="sxs-lookup"><span data-stu-id="02415-503">Format</span></span>|<span data-ttu-id="02415-504">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-504">Assembly Format</span></span>|<span data-ttu-id="02415-505">说明</span><span class="sxs-lookup"><span data-stu-id="02415-505">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-506">36 `<int8>`</span><span class="sxs-lookup"><span data-stu-id="02415-506">36 `<int8>`</span></span>|<span data-ttu-id="02415-507">ble `target`</span><span class="sxs-lookup"><span data-stu-id="02415-507">ble.un.s `target`</span></span>|<span data-ttu-id="02415-508">如果第一个值小于或等于第二个值（无符号值），则按指定的偏移量分支到目标指令（短格式）。</span><span class="sxs-lookup"><span data-stu-id="02415-508">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="02415-509">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-509">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-510">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-510">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-511">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-511">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-512">从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 小于或等于 `value2`，则执行分支操作。</span><span class="sxs-lookup"><span data-stu-id="02415-512">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="02415-513">当使用无符号整数或无序浮点值进行比较时，如果 `value1` 小于或等于 `value2`，则 `ble.un.s` 指令将控制转移到指定的目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-513">The `ble.un.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="02415-514">此效果等同于执行 `cgt.un` 指令（`cgt` 对于浮点数），后跟一个 `brfalse` 分支到特定目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-514">The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="02415-515">目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-515">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-516">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-516">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="02415-517">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。</span><span class="sxs-lookup"><span data-stu-id="02415-517">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="02415-518">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ble.un.s` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-518">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="02415-519">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-519">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-520">如果第一个值小于第二个值，则将控制转移到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-520">Transfers control to a target instruction if the first value is less than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-521">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-521">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-522">格式</span><span class="sxs-lookup"><span data-stu-id="02415-522">Format</span></span>|<span data-ttu-id="02415-523">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-523">Assembly Format</span></span>|<span data-ttu-id="02415-524">说明</span><span class="sxs-lookup"><span data-stu-id="02415-524">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-525">3F < `int32` ></span><span class="sxs-lookup"><span data-stu-id="02415-525">3F < `int32` ></span></span>|<span data-ttu-id="02415-526">blt `target`</span><span class="sxs-lookup"><span data-stu-id="02415-526">blt `target`</span></span>|<span data-ttu-id="02415-527">如果第一个值小于第二个值，则按指定的偏移量分支到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-527">Branch to the target instruction at the specified offset if the first value is less than the second value.</span></span>|  
  
 <span data-ttu-id="02415-528">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-528">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-529">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-529">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-530">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-530">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-531">从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 小于 `value2`，则执行分支操作。</span><span class="sxs-lookup"><span data-stu-id="02415-531">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="02415-532">如果 `value1` 小于或等于 `value2`，则 `blt` 指令将控制转移到指定的目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-532">The `blt` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="02415-533">其效果与执行 `clt` 指令后跟特定目标指令的 `brtrue` 分支相同。</span><span class="sxs-lookup"><span data-stu-id="02415-533">The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="02415-534">目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-534">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-535">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-535">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="02415-536">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。</span><span class="sxs-lookup"><span data-stu-id="02415-536">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="02415-537">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `blt` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-537">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt` opcode:</span></span>  
  
-   <span data-ttu-id="02415-538">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-538">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-539">如果第一个值小于第二个值，则将控制转移到目标指令（短格式）。</span><span class="sxs-lookup"><span data-stu-id="02415-539">Transfers control to a target instruction (short form) if the first value is less than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-540">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-540">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-541">格式</span><span class="sxs-lookup"><span data-stu-id="02415-541">Format</span></span>|<span data-ttu-id="02415-542">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-542">Assembly Format</span></span>|<span data-ttu-id="02415-543">说明</span><span class="sxs-lookup"><span data-stu-id="02415-543">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-544">32 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="02415-544">32 < `int8` ></span></span>|<span data-ttu-id="02415-545">blt `target`</span><span class="sxs-lookup"><span data-stu-id="02415-545">blt.s `target`</span></span>|<span data-ttu-id="02415-546">如果第一个值小于第二个值，则按指定的偏移量分支到目标指令（缩写形式）。</span><span class="sxs-lookup"><span data-stu-id="02415-546">Branch to the target instruction at the specified offset if the first value is less than the second value, short form.</span></span>|  
  
 <span data-ttu-id="02415-547">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-547">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-548">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-548">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-549">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-549">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-550">从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 小于 `value2`，则执行分支操作。</span><span class="sxs-lookup"><span data-stu-id="02415-550">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="02415-551">如果 `value1` 小于 `value2`，则 `blt.s` 指令将控制转移到指定的目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-551">The `blt.s` instruction transfers control to the specified target instruction if `value1` is less than `value2`.</span></span> <span data-ttu-id="02415-552">其效果与执行 `clt` 指令后跟特定目标指令的 `brtrue` 分支相同。</span><span class="sxs-lookup"><span data-stu-id="02415-552">The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="02415-553">目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-553">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-554">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-554">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="02415-555">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。</span><span class="sxs-lookup"><span data-stu-id="02415-555">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="02415-556">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `blt.s` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-556">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.s` opcode:</span></span>  
  
-   <span data-ttu-id="02415-557">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-557">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-558">当比较无符号整数值或未经排序的浮点值时，如果第一个值小于第二个值，则将控制转移到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-558">Transfers control to a target instruction if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-559">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-559">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-560">格式</span><span class="sxs-lookup"><span data-stu-id="02415-560">Format</span></span>|<span data-ttu-id="02415-561">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-561">Assembly Format</span></span>|<span data-ttu-id="02415-562">说明</span><span class="sxs-lookup"><span data-stu-id="02415-562">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-563">44 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="02415-563">44 < `int32` ></span></span>|<span data-ttu-id="02415-564">blt `target`</span><span class="sxs-lookup"><span data-stu-id="02415-564">blt.un `target`</span></span>|<span data-ttu-id="02415-565">如果第一个值小于第二个值（无符号值），则按指定的偏移量分支到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-565">Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="02415-566">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-566">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-567">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-567">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-568">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-568">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-569">从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 小于 `value2`，则执行分支操作。</span><span class="sxs-lookup"><span data-stu-id="02415-569">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="02415-570">当使用无符号整数或无序浮点值进行比较时，如果 `value1` 小于 `value2`，则 `blt.un` 指令将控制转移到指定的目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-570">The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="02415-571">其效果与执行 `clt.un` 指令后跟特定目标指令的 `brtrue` 分支相同。</span><span class="sxs-lookup"><span data-stu-id="02415-571">The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="02415-572">目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-572">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-573">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-573">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="02415-574">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。</span><span class="sxs-lookup"><span data-stu-id="02415-574">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="02415-575">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `blt.un` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-575">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un` opcode:</span></span>  
  
-   <span data-ttu-id="02415-576">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-576">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-577">当比较无符号整数值或未经排序的浮点值时，如果第一个值小于第二个值，则将控制转移到目标指令（短格式）。</span><span class="sxs-lookup"><span data-stu-id="02415-577">Transfers control to a target instruction (short form) if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-578">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-578">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-579">格式</span><span class="sxs-lookup"><span data-stu-id="02415-579">Format</span></span>|<span data-ttu-id="02415-580">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-580">Assembly Format</span></span>|<span data-ttu-id="02415-581">说明</span><span class="sxs-lookup"><span data-stu-id="02415-581">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-582">37 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="02415-582">37 < `int8` ></span></span>|<span data-ttu-id="02415-583">blt `target`</span><span class="sxs-lookup"><span data-stu-id="02415-583">blt.un.s `target`</span></span>|<span data-ttu-id="02415-584">如果第一个值小于第二个值（无符号值），则按指定的偏移量分支到目标指令（短格式）。</span><span class="sxs-lookup"><span data-stu-id="02415-584">Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="02415-585">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-585">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-586">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-586">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-587">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-587">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-588">从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 小于 `value2`，则执行分支操作。</span><span class="sxs-lookup"><span data-stu-id="02415-588">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="02415-589">当使用无符号整数或无序浮点值进行比较时，如果 `value1` 小于 `value2`，则 `blt.un` 指令将控制转移到指定的目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-589">The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="02415-590">其效果与执行 `clt.un` 指令后跟特定目标指令的 `brtrue` 分支相同。</span><span class="sxs-lookup"><span data-stu-id="02415-590">The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="02415-591">目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-591">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-592">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-592">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="02415-593">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。</span><span class="sxs-lookup"><span data-stu-id="02415-593">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="02415-594">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `blt.un.s` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-594">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="02415-595">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-595">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-596">当两个无符号整数值或未经排序的浮点值不相等时，将控制转移到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-596">Transfers control to a target instruction when two unsigned integer values or unordered float values are not equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-597">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-597">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-598">格式</span><span class="sxs-lookup"><span data-stu-id="02415-598">Format</span></span>|<span data-ttu-id="02415-599">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-599">Assembly Format</span></span>|<span data-ttu-id="02415-600">说明</span><span class="sxs-lookup"><span data-stu-id="02415-600">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-601">40 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="02415-601">40 < `int32` ></span></span>|<span data-ttu-id="02415-602">bne `target`</span><span class="sxs-lookup"><span data-stu-id="02415-602">bne.un `target`</span></span>|<span data-ttu-id="02415-603">如果两个无符号整数值不相等（无符号值），则按指定的偏移量分支到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-603">Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values).</span></span>|  
  
 <span data-ttu-id="02415-604">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-604">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-605">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-605">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-606">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-606">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-607">从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 不等于 `value2`，则执行分支操作。</span><span class="sxs-lookup"><span data-stu-id="02415-607">`value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="02415-608">当使用无符号整数或无序浮点值进行比较时，如果 `value1` 不等于 `value2`，则 `bne.un` 指令将控制转移到指定的目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-608">The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="02415-609">其效果与执行 `ceq` 指令后跟特定目标指令的 `brfalse` 分支相同。</span><span class="sxs-lookup"><span data-stu-id="02415-609">The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="02415-610">目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-610">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-611">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-611">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="02415-612">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。</span><span class="sxs-lookup"><span data-stu-id="02415-612">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="02415-613">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `bne.un` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-613">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un` opcode:</span></span>  
  
-   <span data-ttu-id="02415-614">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-614">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-615">当两个无符号整数值或未经排序的浮点值不相等时，将控制转移到目标指令（短格式）。</span><span class="sxs-lookup"><span data-stu-id="02415-615">Transfers control to a target instruction (short form) when two unsigned integer values or unordered float values are not equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-616">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-616">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-617">格式</span><span class="sxs-lookup"><span data-stu-id="02415-617">Format</span></span>|<span data-ttu-id="02415-618">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-618">Assembly Format</span></span>|<span data-ttu-id="02415-619">说明</span><span class="sxs-lookup"><span data-stu-id="02415-619">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-620">33 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="02415-620">33 < `int8` ></span></span>|<span data-ttu-id="02415-621">bne `target`</span><span class="sxs-lookup"><span data-stu-id="02415-621">bne.un.s `target`</span></span>|<span data-ttu-id="02415-622">如果两个无符号整数值不相等（无符号值），则按指定的偏移量分支到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-622">Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="02415-623">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-623">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-624">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-624">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-625">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-625">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-626">从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 不等于 `value2`，则执行分支操作。</span><span class="sxs-lookup"><span data-stu-id="02415-626">`value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="02415-627">当使用无符号整数或无序浮点值进行比较时，如果 `value1` 不等于 `value2`，则 `bne.un` 指令将控制转移到指定的目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-627">The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="02415-628">其效果与执行 `ceq` 指令后跟特定目标指令的 `brfalse` 分支相同。</span><span class="sxs-lookup"><span data-stu-id="02415-628">The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="02415-629">目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-629">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-630">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-630">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="02415-631">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。</span><span class="sxs-lookup"><span data-stu-id="02415-631">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="02415-632">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `bne.un.s` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-632">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="02415-633">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-633">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-634">将值类转换为对象引用（<see langword="O" /> 类型）。</span><span class="sxs-lookup"><span data-stu-id="02415-634">Converts a value type to an object reference (type <see langword="O" />).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-635">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-635">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-636">格式</span><span class="sxs-lookup"><span data-stu-id="02415-636">Format</span></span>|<span data-ttu-id="02415-637">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-637">Assembly Format</span></span>|<span data-ttu-id="02415-638">说明</span><span class="sxs-lookup"><span data-stu-id="02415-638">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-639">8C < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-639">8C < `T` ></span></span>|<span data-ttu-id="02415-640">box `valTypeToken`</span><span class="sxs-lookup"><span data-stu-id="02415-640">box `valTypeToken`</span></span>|<span data-ttu-id="02415-641">将值类型（在 `valTypeToken`中指定的类型）转换为真正的对象引用。</span><span class="sxs-lookup"><span data-stu-id="02415-641">Convert a value type (of the type specified in `valTypeToken`) to a true object reference.</span></span>|  
  
 <span data-ttu-id="02415-642">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-642">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-643">值类型被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-643">A value type is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-644">从堆栈中弹出值类型;执行 `box` 操作。</span><span class="sxs-lookup"><span data-stu-id="02415-644">The value type is popped from the stack; the `box` operation is performed.</span></span>  
  
3.  <span data-ttu-id="02415-645">对生成的 "装箱" 值类型的对象引用被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-645">An object reference to the resulting "boxed" value type is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-646">值类型在公共语言基础结构（CLI）中具有两种不同的表示形式：</span><span class="sxs-lookup"><span data-stu-id="02415-646">A value type has two separate representations within the Common Language Infrastructure (CLI):</span></span>  
  
-   <span data-ttu-id="02415-647">当值类型嵌入到另一个对象或堆栈上时使用的 "原始" 窗体。</span><span class="sxs-lookup"><span data-stu-id="02415-647">A 'raw' form used when a value type is embedded within another object or on the stack.</span></span>  
  
-   <span data-ttu-id="02415-648">"装箱" 窗体，其中值类型中的数据被包装（装箱）到对象中，因此它可以作为独立实体存在。</span><span class="sxs-lookup"><span data-stu-id="02415-648">A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</span></span>  
  
 <span data-ttu-id="02415-649">`box` 指令将 "raw" （未装箱）值类型转换为对象引用（类型 `O`）。</span><span class="sxs-lookup"><span data-stu-id="02415-649">The `box` instruction converts the 'raw' (unboxed) value type into an object reference (type `O`).</span></span> <span data-ttu-id="02415-650">为此，可以创建一个新的对象，并将数据从值类型复制到新分配的对象。</span><span class="sxs-lookup"><span data-stu-id="02415-650">This is accomplished by creating a new object and copying the data from the value type into the newly allocated object.</span></span> <span data-ttu-id="02415-651">`valTypeToken` 是指示堆栈上值类型类型的元数据标记。</span><span class="sxs-lookup"><span data-stu-id="02415-651">`valTypeToken` is a metadata token indicating the type of the value type on the stack.</span></span>  
  
 <span data-ttu-id="02415-652">如果内存不足，无法满足请求，则会引发 <xref:System.OutOfMemoryException>。</span><span class="sxs-lookup"><span data-stu-id="02415-652"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="02415-653">如果找不到类，则会引发 <xref:System.TypeLoadException>。</span><span class="sxs-lookup"><span data-stu-id="02415-653"><xref:System.TypeLoadException> is thrown if the class cannot be found.</span></span> <span data-ttu-id="02415-654">当 Microsoft 中间语言（MSIL）转换为本机代码而不是运行时，通常会检测到此情况。</span><span class="sxs-lookup"><span data-stu-id="02415-654">This is typically detected when Microsoft Intermediate Language (MSIL) is converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="02415-655">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `box` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-655">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `box` opcode:</span></span>  
  
-   <span data-ttu-id="02415-656">ILGenerator （OpCode，Type）</span><span class="sxs-lookup"><span data-stu-id="02415-656">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-657">无条件地将控制转移到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-657">Unconditionally transfers control to a target instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-658">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-658">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-659">格式</span><span class="sxs-lookup"><span data-stu-id="02415-659">Format</span></span>|<span data-ttu-id="02415-660">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-660">Assembly Format</span></span>|<span data-ttu-id="02415-661">说明</span><span class="sxs-lookup"><span data-stu-id="02415-661">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-662">38 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="02415-662">38 < `int32` ></span></span>|<span data-ttu-id="02415-663">br `target`</span><span class="sxs-lookup"><span data-stu-id="02415-663">br `target`</span></span>|<span data-ttu-id="02415-664">按指定的偏移量分支到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-664">Branches to a target instruction at the specified offset.</span></span>|  
  
 <span data-ttu-id="02415-665">此操作不会执行任何计算堆栈行为。</span><span class="sxs-lookup"><span data-stu-id="02415-665">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="02415-666">`br` 指令无条件地将控制转移到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-666">The `br` instruction unconditionally transfers control to a target instruction.</span></span> <span data-ttu-id="02415-667">目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-667">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-668">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-668">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="02415-669">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。</span><span class="sxs-lookup"><span data-stu-id="02415-669">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="02415-670">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `br` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-670">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br` opcode:</span></span>  
  
-   <span data-ttu-id="02415-671">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-671">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-672">无条件地将控制转移到目标指令（短格式）。</span><span class="sxs-lookup"><span data-stu-id="02415-672">Unconditionally transfers control to a target instruction (short form).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-673">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-673">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-674">格式</span><span class="sxs-lookup"><span data-stu-id="02415-674">Format</span></span>|<span data-ttu-id="02415-675">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-675">Assembly Format</span></span>|<span data-ttu-id="02415-676">说明</span><span class="sxs-lookup"><span data-stu-id="02415-676">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-677">2B < `int8` ></span><span class="sxs-lookup"><span data-stu-id="02415-677">2B < `int8` ></span></span>|<span data-ttu-id="02415-678">br `target`</span><span class="sxs-lookup"><span data-stu-id="02415-678">br.s `target`</span></span>|<span data-ttu-id="02415-679">按指定的偏移量（短格式）分支到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-679">Branches to a target instruction at the specified offset, short form.</span></span>|  
  
 <span data-ttu-id="02415-680">此操作不会执行任何计算堆栈行为。</span><span class="sxs-lookup"><span data-stu-id="02415-680">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="02415-681">`br.s` 指令无条件地将控制转移到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-681">The `br.s` instruction unconditionally transfers control to a target instruction.</span></span> <span data-ttu-id="02415-682">目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-682">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-683">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-683">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="02415-684">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。</span><span class="sxs-lookup"><span data-stu-id="02415-684">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="02415-685">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `br.s` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-685">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br.s` opcode:</span></span>  
  
-   <span data-ttu-id="02415-686">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-686">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-687">向公共语言结构 (CLI) 发出信号以通知调试器已撞上了一个断点。</span><span class="sxs-lookup"><span data-stu-id="02415-687">Signals the Common Language Infrastructure (CLI) to inform the debugger that a break point has been tripped.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-688">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-688">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-689">格式</span><span class="sxs-lookup"><span data-stu-id="02415-689">Format</span></span>|<span data-ttu-id="02415-690">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-690">Assembly Format</span></span>|<span data-ttu-id="02415-691">说明</span><span class="sxs-lookup"><span data-stu-id="02415-691">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-692">01</span><span class="sxs-lookup"><span data-stu-id="02415-692">01</span></span>|<span data-ttu-id="02415-693">break</span><span class="sxs-lookup"><span data-stu-id="02415-693">break</span></span>|<span data-ttu-id="02415-694">通知调试器已达到断点。</span><span class="sxs-lookup"><span data-stu-id="02415-694">inform a debugger that a breakpoint has been reached.</span></span>|  
  
 <span data-ttu-id="02415-695">此操作不会执行任何计算堆栈行为。</span><span class="sxs-lookup"><span data-stu-id="02415-695">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="02415-696">`break` 指令用于调试支持。</span><span class="sxs-lookup"><span data-stu-id="02415-696">The `break` instruction is for debugging support.</span></span> <span data-ttu-id="02415-697">它向 CLI 发出信号，通知调试器中断点已被终止。</span><span class="sxs-lookup"><span data-stu-id="02415-697">It signals the CLI to inform the debugger that a break point has been tripped.</span></span> <span data-ttu-id="02415-698">它对解释器状态没有其他影响。</span><span class="sxs-lookup"><span data-stu-id="02415-698">It has no other effect on the interpreter state.</span></span>  
  
 <span data-ttu-id="02415-699">`break` 指令的最小可能的指令大小，这使得代码可以使用断点进行修补，并为环绕代码生成最小的干扰。</span><span class="sxs-lookup"><span data-stu-id="02415-699">The `break` instruction has the smallest possible instruction size enabling code patching with a break point and generating minimal disturbance to the surrounding code.</span></span>  
  
 <span data-ttu-id="02415-700">`break` 指令可以捕获调试器、不执行任何操作，或者引发安全异常。</span><span class="sxs-lookup"><span data-stu-id="02415-700">The `break` instruction can trap to a debugger, do nothing, or raise a security exception.</span></span> <span data-ttu-id="02415-701">确切的行为是实现定义的。</span><span class="sxs-lookup"><span data-stu-id="02415-701">The exact behavior is implementation-defined.</span></span>  
  
 <span data-ttu-id="02415-702">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `break` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-702">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `break` opcode:</span></span>  
  
-   <span data-ttu-id="02415-703">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-703">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-704">如果 <paramref name="value" /> 为 <see langword="false" />、空引用（Visual Basic 中的 <see langword="Nothing" />）或零，则将控制转移到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-704">Transfers control to a target instruction if <paramref name="value" /> is <see langword="false" />, a null reference (<see langword="Nothing" /> in Visual Basic), or zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-705">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-705">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-706">格式</span><span class="sxs-lookup"><span data-stu-id="02415-706">Format</span></span>|<span data-ttu-id="02415-707">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-707">Assembly Format</span></span>|<span data-ttu-id="02415-708">说明</span><span class="sxs-lookup"><span data-stu-id="02415-708">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-709">39 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="02415-709">39 < `int32` ></span></span>|<span data-ttu-id="02415-710">brfalse `target`</span><span class="sxs-lookup"><span data-stu-id="02415-710">brfalse `target`</span></span><br /><br /> <span data-ttu-id="02415-711">brnull `target`</span><span class="sxs-lookup"><span data-stu-id="02415-711">brnull `target`</span></span><br /><br /> <span data-ttu-id="02415-712">brzero `target`</span><span class="sxs-lookup"><span data-stu-id="02415-712">brzero `target`</span></span>|<span data-ttu-id="02415-713">如果 `false`，则按指定的偏移量分支到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-713">Branches to a target instruction at the specified offset if `false`.</span></span>|  
  
 <span data-ttu-id="02415-714">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-714">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-715">之前的操作将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-715">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="02415-716">从堆栈中弹出 `value`;如果 `false``value`，则分支到 `target`。</span><span class="sxs-lookup"><span data-stu-id="02415-716">`value` is popped from the stack; if `value` is `false`, branch to `target`.</span></span>  
  
 <span data-ttu-id="02415-717">如果 `value` （类型 `int32`、`int64`、对象引用 `O`、托管指针 `&`、暂时性指针 `*`、`native int`）为零（`false`），则 `brfalse` 指令（及其别名 `brnull` 和 `brzero`）将控制转移到指定的目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-717">The `brfalse` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`).</span></span> <span data-ttu-id="02415-718">如果 `value` 为非零（`true`），则在下一条指令处继续执行。</span><span class="sxs-lookup"><span data-stu-id="02415-718">If `value` is non-zero (`true`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="02415-719">目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-719">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-720">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-720">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="02415-721">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。</span><span class="sxs-lookup"><span data-stu-id="02415-721">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="02415-722">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `brfalse` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-722">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse` opcode:</span></span>  
  
-   <span data-ttu-id="02415-723">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-723">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-724">如果 <paramref name="value" /> 为 <see langword="false" />、空引用或零，则将控制转移到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-724">Transfers control to a target instruction if <paramref name="value" /> is <see langword="false" />, a null reference, or zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-725">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-725">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-726">格式</span><span class="sxs-lookup"><span data-stu-id="02415-726">Format</span></span>|<span data-ttu-id="02415-727">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-727">Assembly Format</span></span>|<span data-ttu-id="02415-728">说明</span><span class="sxs-lookup"><span data-stu-id="02415-728">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-729">2C <`int8` ></span><span class="sxs-lookup"><span data-stu-id="02415-729">2C <`int8` ></span></span>|<span data-ttu-id="02415-730">brfalse `target`</span><span class="sxs-lookup"><span data-stu-id="02415-730">brfalse.s `target`</span></span><br /><br /> <span data-ttu-id="02415-731">brnull `target`</span><span class="sxs-lookup"><span data-stu-id="02415-731">brnull.s `target`</span></span><br /><br /> <span data-ttu-id="02415-732">brzero `target`</span><span class="sxs-lookup"><span data-stu-id="02415-732">brzero.s `target`</span></span>|<span data-ttu-id="02415-733">如果 `false`，则按指定的偏移量分支到目标指令（缩写形式）。</span><span class="sxs-lookup"><span data-stu-id="02415-733">Branches to a target instruction at the specified offset if `false`, short form.</span></span>|  
  
 <span data-ttu-id="02415-734">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-734">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-735">之前的操作将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-735">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="02415-736">从堆栈中弹出 `value`;如果 `false``value`，则分支到 `target`。</span><span class="sxs-lookup"><span data-stu-id="02415-736">`value` is popped from the stack; if `value` is `false`, branch to `target`.</span></span>  
  
 <span data-ttu-id="02415-737">如果 `value` （类型 `int32`、`int64`、对象引用 `O`、托管指针 `&`、暂时性指针 `*`、`native int`）为零（`false`），则 `brfalse.s` 指令（及其别名 `brnull` 和 `brzero`）将控制转移到指定的目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-737">The `brfalse.s` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`).</span></span> <span data-ttu-id="02415-738">如果 `value` 为非零（`true`），则在下一条指令处继续执行。</span><span class="sxs-lookup"><span data-stu-id="02415-738">If `value` is non-zero (`true`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="02415-739">目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-739">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-740">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-740">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="02415-741">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。</span><span class="sxs-lookup"><span data-stu-id="02415-741">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="02415-742">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `brfalse.s` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-742">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse.s` opcode:</span></span>  
  
-   <span data-ttu-id="02415-743">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-743">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-744">如果 <paramref name="value" /> 为 <see langword="true" />、非空或非零，则将控制转移到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-744">Transfers control to a target instruction if <paramref name="value" /> is <see langword="true" />, not null, or non-zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-745">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-745">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-746">格式</span><span class="sxs-lookup"><span data-stu-id="02415-746">Format</span></span>|<span data-ttu-id="02415-747">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-747">Assembly Format</span></span>|<span data-ttu-id="02415-748">说明</span><span class="sxs-lookup"><span data-stu-id="02415-748">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-749">3A < `int32` ></span><span class="sxs-lookup"><span data-stu-id="02415-749">3A < `int32` ></span></span>|<span data-ttu-id="02415-750">brtrue `target`</span><span class="sxs-lookup"><span data-stu-id="02415-750">brtrue `target`</span></span><br /><br /> <span data-ttu-id="02415-751">brinst `target`</span><span class="sxs-lookup"><span data-stu-id="02415-751">brinst `target`</span></span>|<span data-ttu-id="02415-752">如果非零（`true`），则按指定的偏移量分支到目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-752">Branch to a target instruction at the specified offset if non-zero (`true`).</span></span>|  
  
 <span data-ttu-id="02415-753">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-753">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-754">之前的操作将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-754">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="02415-755">从堆栈中弹出 `value`;如果 `true``value`，则分支到 `target`。</span><span class="sxs-lookup"><span data-stu-id="02415-755">`value` is popped from the stack; if `value` is `true`, branch to `target`.</span></span>  
  
 <span data-ttu-id="02415-756">如果 `value` （类型 `native int`）为非零（`true`），则 `brtrue` 指令将控制转移到指定的目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-756">The `brtrue` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`).</span></span> <span data-ttu-id="02415-757">如果 `value` 为零（`false`），则在下一条指令处继续执行。</span><span class="sxs-lookup"><span data-stu-id="02415-757">If `value` is zero (`false`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="02415-758">如果 `value` 是对象引用（键入 `O`），则 `brinst` （`brtrue`的别名）在表示对象的实例的情况下传输控制（例如，如果它不是 null 对象引用，请参阅 <xref:System.Reflection.Emit.OpCodes.Ldnull>）。</span><span class="sxs-lookup"><span data-stu-id="02415-758">If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span></span>  
  
 <span data-ttu-id="02415-759">目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-759">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-760">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-760">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="02415-761">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。</span><span class="sxs-lookup"><span data-stu-id="02415-761">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="02415-762">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `brtrue` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-762">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue` opcode:</span></span>  
  
-   <span data-ttu-id="02415-763">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-763">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-764">如果 <paramref name="value" /> 为 <see langword="true" />、非空或非零，则将控制转移到目标指令（短格式）。</span><span class="sxs-lookup"><span data-stu-id="02415-764">Transfers control to a target instruction (short form) if <paramref name="value" /> is <see langword="true" />, not null, or non-zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-765">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-765">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-766">格式</span><span class="sxs-lookup"><span data-stu-id="02415-766">Format</span></span>|<span data-ttu-id="02415-767">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-767">Assembly Format</span></span>|<span data-ttu-id="02415-768">说明</span><span class="sxs-lookup"><span data-stu-id="02415-768">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-769">2D < `int8` ></span><span class="sxs-lookup"><span data-stu-id="02415-769">2D < `int8` ></span></span>|<span data-ttu-id="02415-770">brtrue `target`</span><span class="sxs-lookup"><span data-stu-id="02415-770">brtrue.s `target`</span></span><br /><br /> <span data-ttu-id="02415-771">brinst `target`</span><span class="sxs-lookup"><span data-stu-id="02415-771">brinst.s `target`</span></span>|<span data-ttu-id="02415-772">如果非零（`true`），则按指定的偏移量分支到目标指令（缩写形式）。</span><span class="sxs-lookup"><span data-stu-id="02415-772">Branch to a target instruction at the specified offset if non-zero (`true`), short form.</span></span>|  
  
 <span data-ttu-id="02415-773">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-773">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-774">之前的操作将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-774">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="02415-775">从堆栈中弹出 `value`;如果 `true``value`，则分支到 `target`。</span><span class="sxs-lookup"><span data-stu-id="02415-775">`value` is popped from the stack; if `value` is `true`, branch to `target`.</span></span>  
  
 <span data-ttu-id="02415-776">如果 `value` （类型 `native int`）为非零（`true`），则 `brtrue.s` 指令将控制转移到指定的目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-776">The `brtrue.s` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`).</span></span> <span data-ttu-id="02415-777">如果 `value` 为零（`false`），则在下一条指令处继续执行。</span><span class="sxs-lookup"><span data-stu-id="02415-777">If `value` is zero (`false`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="02415-778">如果 `value` 是对象引用（键入 `O`），则 `brinst` （`brtrue`的别名）在表示对象的实例的情况下传输控制（例如，如果它不是 null 对象引用，请参阅 <xref:System.Reflection.Emit.OpCodes.Ldnull>）。</span><span class="sxs-lookup"><span data-stu-id="02415-778">If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span></span>  
  
 <span data-ttu-id="02415-779">目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-779">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-780">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-780">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="02415-781">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。</span><span class="sxs-lookup"><span data-stu-id="02415-781">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="02415-782">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `brtrue.s` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-782">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue.s` opcode:</span></span>  
  
-   <span data-ttu-id="02415-783">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-783">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-784">调用由传递的方法说明符指示的方法。</span><span class="sxs-lookup"><span data-stu-id="02415-784">Calls the method indicated by the passed method descriptor.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-785">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-785">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-786">格式</span><span class="sxs-lookup"><span data-stu-id="02415-786">Format</span></span>|<span data-ttu-id="02415-787">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-787">Assembly Format</span></span>|<span data-ttu-id="02415-788">说明</span><span class="sxs-lookup"><span data-stu-id="02415-788">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-789">28 < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-789">28 < `T` ></span></span>|<span data-ttu-id="02415-790">调用 `methodDesc`</span><span class="sxs-lookup"><span data-stu-id="02415-790">call `methodDesc`</span></span>|<span data-ttu-id="02415-791">调用 `methodDesc`描述的方法。</span><span class="sxs-lookup"><span data-stu-id="02415-791">Call the method described by `methodDesc`.</span></span>|  
  
 <span data-ttu-id="02415-792">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-792">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-793">通过 `argN` `arg1` 的方法参数被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-793">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-794">从堆栈中弹出 `argN` `arg1` 的方法参数;使用这些参数执行方法调用，并将控件传输到方法说明符所引用的方法。</span><span class="sxs-lookup"><span data-stu-id="02415-794">Method arguments `arg1` through `argN` are popped from the stack; the method call is performed with these arguments and control is transferred to the method referred to by the method descriptor.</span></span> <span data-ttu-id="02415-795">完成后，调用方方法将生成一个返回值，并将其发送给调用方。</span><span class="sxs-lookup"><span data-stu-id="02415-795">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
3.  <span data-ttu-id="02415-796">将返回值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-796">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-797">`call` 指令调用通过指令传递的方法说明符指示的方法。</span><span class="sxs-lookup"><span data-stu-id="02415-797">The `call` instruction calls the method indicated by the method descriptor passed with the instruction.</span></span> <span data-ttu-id="02415-798">方法描述符是一种元数据标记，用于指示要调用的方法，以及要传递到该方法的堆栈上的参数的数量、类型和顺序，以及要使用的调用约定。</span><span class="sxs-lookup"><span data-stu-id="02415-798">The method descriptor is a metadata token that indicates the method to call and the number, type, and order of the arguments that have been placed on the stack to be passed to that method as well as the calling convention to be used.</span></span> <span data-ttu-id="02415-799">`call` 指令前面可以跟 `tail` （<xref:System.Reflection.Emit.OpCodes.Tailcall>）前缀指令，以指定在传输控制之前应释放当前方法状态。</span><span class="sxs-lookup"><span data-stu-id="02415-799">The `call` instruction can be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix instruction to specify that the current method state should be released before transferring control.</span></span> <span data-ttu-id="02415-800">如果调用将控制转移到比源方法更高的信任方法，则不会释放堆栈帧。</span><span class="sxs-lookup"><span data-stu-id="02415-800">If the call transfers control to a method of higher trust than the origin method, the stack frame is not released.</span></span> <span data-ttu-id="02415-801">相反，执行将以无提示方式继续，就好像尚未提供 `tail`。</span><span class="sxs-lookup"><span data-stu-id="02415-801">Instead, the execution continues silently as if the `tail` had not been supplied.</span></span> <span data-ttu-id="02415-802">元数据标记携带足够的信息来确定调用是静态方法、实例方法、虚方法还是全局函数。</span><span class="sxs-lookup"><span data-stu-id="02415-802">The metadata token carries sufficient information to determine whether the call is to a static method, an instance method, a virtual method, or a global function.</span></span> <span data-ttu-id="02415-803">在所有这些情况下，均从方法描述符完全确定目标地址（与此与调用虚拟方法的 <xref:System.Reflection.Emit.OpCodes.Callvirt> 指令比较），其中目标地址还依赖于在 <xref:System.Reflection.Emit.OpCodes.Callvirt>之前推送的实例引用的运行时类型。</span><span class="sxs-lookup"><span data-stu-id="02415-803">In all of these cases the destination address is determined entirely from the method descriptor (contrast this with the <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction for calling virtual methods, where the destination address also depends upon the runtime type of the instance reference pushed before the <xref:System.Reflection.Emit.OpCodes.Callvirt>).</span></span>  
  
 <span data-ttu-id="02415-804">自变量以从左到右的顺序放置在堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-804">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="02415-805">也就是说，第一个参数是计算并放置在堆栈上，然后是第三个参数，然后是第三个参数，直到所有必需的参数按降序排列。</span><span class="sxs-lookup"><span data-stu-id="02415-805">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="02415-806">有三个重要的特殊情况：</span><span class="sxs-lookup"><span data-stu-id="02415-806">There are three important special cases:</span></span>  
  
 1. <span data-ttu-id="02415-807">对实例（或虚拟）方法的调用必须将该实例引用推送到任何用户可见参数之前。</span><span class="sxs-lookup"><span data-stu-id="02415-807">Calls to an instance (or virtual) method must push that instance reference before any of the user-visible arguments.</span></span> <span data-ttu-id="02415-808">实例引用不得为空引用。</span><span class="sxs-lookup"><span data-stu-id="02415-808">The instance reference must not be a null reference.</span></span> <span data-ttu-id="02415-809">在元数据中携带的签名在 `this` 指针的参数列表中不包含项;相反，它使用一个位来指示方法是否要求传递 `this` 指针。</span><span class="sxs-lookup"><span data-stu-id="02415-809">The signature carried in the metadata does not contain an entry in the parameter list for the `this` pointer; instead, it uses a bit to indicate whether the method requires passing the `this` pointer.</span></span>  
  
 2. <span data-ttu-id="02415-810">使用 `call` （而不是 `callvirt`）调用虚拟方法是有效的;这表示使用方法指定的类（而不是从所调用的对象动态指定）解析方法。</span><span class="sxs-lookup"><span data-stu-id="02415-810">It is valid to call a virtual method using `call` (rather than `callvirt`); this indicates that the method is to be resolved using the class specified by method rather than as specified dynamically from the object being invoked.</span></span>  
  
 3. <span data-ttu-id="02415-811">请注意，可以使用 `call` 或 `callvirt` 指令调用委托的 `Invoke` 方法。</span><span class="sxs-lookup"><span data-stu-id="02415-811">Note that a delegate's `Invoke` method can be called with either the `call` or `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="02415-812">如果系统安全不允许调用方访问调用的方法，则可能会引发 <xref:System.Security.SecurityException>。</span><span class="sxs-lookup"><span data-stu-id="02415-812"><xref:System.Security.SecurityException> may be thrown if system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="02415-813">当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是运行时，可能会进行安全检查。</span><span class="sxs-lookup"><span data-stu-id="02415-813">The security check may occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="02415-814">当在值类型上调用 System.object 的方法时，请考虑将 `constrained` 前缀与 `callvirt` 指令一起使用，而不是发出 `call` 指令。</span><span class="sxs-lookup"><span data-stu-id="02415-814">When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction instead of emitting a `call` instruction.</span></span> <span data-ttu-id="02415-815">这就不必发出不同的 IL，具体取决于值类型是否重写方法，避免出现潜在的版本控制问题。</span><span class="sxs-lookup"><span data-stu-id="02415-815">This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</span></span> <span data-ttu-id="02415-816">当对值类型调用接口方法时，请考虑使用 `constrained` 前缀，因为实现接口方法的值类型方法可以使用 `MethodImpl`进行更改。</span><span class="sxs-lookup"><span data-stu-id="02415-816">Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="02415-817"><xref:System.Reflection.Emit.OpCodes.Constrained> opcode 中更详细地介绍了这些问题。</span><span class="sxs-lookup"><span data-stu-id="02415-817">These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span></span>  
  
 <span data-ttu-id="02415-818">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `call` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-818">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `call` opcode:</span></span>  
  
-   <span data-ttu-id="02415-819">ILGenerator （操作码，MethodInfo）</span><span class="sxs-lookup"><span data-stu-id="02415-819">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="02415-820">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span><span class="sxs-lookup"><span data-stu-id="02415-820">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="02415-821">提供 `varargs` 调用的 <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="02415-821">The <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> method is provided for `varargs` calls.</span></span> <span data-ttu-id="02415-822">使用 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法进行正常调用。</span><span class="sxs-lookup"><span data-stu-id="02415-822">Use the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method for normal calls.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-823">通过调用约定描述的参数调用在计算堆栈上指示的方法（作为指向入口点的指针）。</span><span class="sxs-lookup"><span data-stu-id="02415-823">Calls the method indicated on the evaluation stack (as a pointer to an entry point) with arguments described by a calling convention.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-824">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-824">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-825">格式</span><span class="sxs-lookup"><span data-stu-id="02415-825">Format</span></span>|<span data-ttu-id="02415-826">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-826">Assembly Format</span></span>|<span data-ttu-id="02415-827">说明</span><span class="sxs-lookup"><span data-stu-id="02415-827">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-828">29 < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-828">29 < `T` ></span></span>|<span data-ttu-id="02415-829">calli `callSiteDescr`</span><span class="sxs-lookup"><span data-stu-id="02415-829">calli `callSiteDescr`</span></span>|<span data-ttu-id="02415-830">使用调用约定描述的参数调用指向的方法。</span><span class="sxs-lookup"><span data-stu-id="02415-830">Calls the method pointed to with arguments described by the calling convention.</span></span>|  
  
 <span data-ttu-id="02415-831">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-831">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-832">通过 `argN` `arg1` 的方法参数被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-832">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-833">方法输入指针被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-833">The method entry pointer is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-834">通过 `argN` `arg1` 方法参数，并从堆栈中弹出方法输入指针;执行对方法的调用。</span><span class="sxs-lookup"><span data-stu-id="02415-834">Method arguments `arg1` through `argN` and the method entry pointer are popped from the stack; the call to the method is performed.</span></span> <span data-ttu-id="02415-835">完成后，调用方方法将生成一个返回值，并将其发送给调用方。</span><span class="sxs-lookup"><span data-stu-id="02415-835">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
4.  <span data-ttu-id="02415-836">将返回值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-836">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-837">`calli` 指令使用 `arg1` 通过 `argN`的参数调用方法输入指针。</span><span class="sxs-lookup"><span data-stu-id="02415-837">The `calli` instruction calls the method entry pointer with the arguments `arg1` through `argN`.</span></span> <span data-ttu-id="02415-838">这些参数的类型由特定的调用约定（`callSiteDesc`）描述。</span><span class="sxs-lookup"><span data-stu-id="02415-838">The types of these arguments are described by the specific calling convention (`callSiteDesc`).</span></span> <span data-ttu-id="02415-839">`calli` 指令前面可以跟 `tail` 前缀（<xref:System.Reflection.Emit.OpCodes.Tailcall>），以指定在传输控制之前应释放当前方法状态。</span><span class="sxs-lookup"><span data-stu-id="02415-839">The `calli` instruction may be immediately preceded by a `tail` prefix (<xref:System.Reflection.Emit.OpCodes.Tailcall>) to specify that the current method state should be released before transferring control.</span></span> <span data-ttu-id="02415-840">如果调用会将控制传输到比源方法更高的信任方法，则不会释放堆栈帧;相反，执行将会以静默方式继续，就好像尚未提供 `tail`。</span><span class="sxs-lookup"><span data-stu-id="02415-840">If the call would transfer control to a method of higher trust than the origin method the stack frame will not be released; instead, the execution will continue silently as if the `tail` had not been supplied.</span></span>  
  
 <span data-ttu-id="02415-841">假定方法输入指针是指向本机代码（目标计算机）的特定指针，该指针可以使用调用约定描述的参数（独立签名的元数据标记）合法调用。</span><span class="sxs-lookup"><span data-stu-id="02415-841">The method entry pointer is assumed to be a specific pointer to native code (of the target machine) that can be legitimately called with the arguments described by the calling convention (a metadata token for a stand-alone signature).</span></span> <span data-ttu-id="02415-842">此类指针可使用 <xref:System.Reflection.Emit.OpCodes.Ldftn> 或 <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> 说明创建，或通过本机代码传入。</span><span class="sxs-lookup"><span data-stu-id="02415-842">Such a pointer can be created using the <xref:System.Reflection.Emit.OpCodes.Ldftn> or <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> instructions, or passed in from native code.</span></span>  
  
 <span data-ttu-id="02415-843">不动态检查调用约定，因此，如果目标不实际使用指定的调用约定，则使用 `calli` 指令的代码将无法正常运行。</span><span class="sxs-lookup"><span data-stu-id="02415-843">The calling convention is not checked dynamically, so code that uses a `calli` instruction does not work correctly if the destination does not actually use the specified calling convention.</span></span>  
  
 <span data-ttu-id="02415-844">自变量以从左到右的顺序放置在堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-844">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="02415-845">也就是说，第一个参数是计算并放置在堆栈上，然后是第三个参数，然后是第三个参数，直到所有必需的参数按降序排列。</span><span class="sxs-lookup"><span data-stu-id="02415-845">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="02415-846">实例或虚方法的参数生成代码序列必须在任何用户可见参数之前推送该实例引用（不得为空引用）。</span><span class="sxs-lookup"><span data-stu-id="02415-846">The argument-building code sequence for an instance or virtual method must push that instance reference (which must not be a null reference) before any of the user-visible arguments.</span></span>  
  
 <span data-ttu-id="02415-847">如果系统安全不允许调用方访问调用的方法，则可能会引发 <xref:System.Security.SecurityException>。</span><span class="sxs-lookup"><span data-stu-id="02415-847"><xref:System.Security.SecurityException> may be thrown if the system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="02415-848">当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是运行时时，可能会进行安全检查。</span><span class="sxs-lookup"><span data-stu-id="02415-848">The security check can occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="02415-849">以下 <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> 方法可用于对堆栈执行 `calli` 指令。</span><span class="sxs-lookup"><span data-stu-id="02415-849">The following <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> methods can be used to perform a `calli` instruction on the stack.</span></span> <span data-ttu-id="02415-850">请注意，`calli` 应通过以下方法调用，而不是使用 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 类将指令直接放置在堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-850">Note that `calli` should be called through the below methods rather than using the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> class to place the instruction directly on the stack.</span></span>  
  
-   <span data-ttu-id="02415-851">对于使用托管调用约定的调用，EmitCalli （操作码、CallingConventions、Type、type []、Type []）。</span><span class="sxs-lookup"><span data-stu-id="02415-851">ILGenerator.EmitCalli(Opcode, CallingConventions, Type, Type[], Type[]) for calls using a managed calling convention.</span></span>  
  
-   <span data-ttu-id="02415-852">ILGenerator 使用非托管调用约定调用 EmitCalli （Opcode，CallingConvention，Type，Type []）。</span><span class="sxs-lookup"><span data-stu-id="02415-852">ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls using an unmanaged calling convention.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-853">对对象调用后期绑定方法，并且将返回值推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-853">Calls a late-bound method on an object, pushing the return value onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-854">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-854">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-855">格式</span><span class="sxs-lookup"><span data-stu-id="02415-855">Format</span></span>|<span data-ttu-id="02415-856">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-856">Assembly Format</span></span>|<span data-ttu-id="02415-857">说明</span><span class="sxs-lookup"><span data-stu-id="02415-857">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-858">6F < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-858">6F < `T` ></span></span>|<span data-ttu-id="02415-859">callvirt `method`</span><span class="sxs-lookup"><span data-stu-id="02415-859">callvirt `method`</span></span>|<span data-ttu-id="02415-860">调用与 `obj`相关联的特定方法。</span><span class="sxs-lookup"><span data-stu-id="02415-860">Calls a specific method associated with `obj`.</span></span>|  
  
 <span data-ttu-id="02415-861">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-861">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-862">对象引用 `obj` 被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-862">An object reference `obj` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-863">通过 `argN` `arg1` 的方法参数被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-863">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-864">通过 `argN` `arg1` 方法参数，并从堆栈中弹出对象引用 `obj`;使用这些参数执行方法调用，并将控件传输到方法元数据标记所引用 `obj` 中的方法。</span><span class="sxs-lookup"><span data-stu-id="02415-864">Method arguments `arg1` through `argN` and the object reference `obj` are popped from the stack; the method call is performed with these arguments and control is transferred to the method in `obj` referred to by the method metadata token.</span></span> <span data-ttu-id="02415-865">完成后，调用方方法将生成一个返回值，并将其发送给调用方。</span><span class="sxs-lookup"><span data-stu-id="02415-865">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
4.  <span data-ttu-id="02415-866">将返回值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-866">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-867">`callvirt` 指令对对象调用后期绑定方法。</span><span class="sxs-lookup"><span data-stu-id="02415-867">The `callvirt` instruction calls a late-bound method on an object.</span></span> <span data-ttu-id="02415-868">也就是说，将根据 `obj` 的运行时类型而不是方法指针中的编译时类选择方法。</span><span class="sxs-lookup"><span data-stu-id="02415-868">That is, the method is chosen based on the runtime type of `obj` rather than the compile-time class visible in the method pointer.</span></span> <span data-ttu-id="02415-869">`Callvirt` 可用于调用虚拟方法和实例方法。</span><span class="sxs-lookup"><span data-stu-id="02415-869">`Callvirt` can be used to call both virtual and instance methods.</span></span> <span data-ttu-id="02415-870">`callvirt` 指令前面可能紧跟 `tail` （<xref:System.Reflection.Emit.OpCodes.Tailcall>）前缀，以指定在传输控制之前应释放当前堆栈帧。</span><span class="sxs-lookup"><span data-stu-id="02415-870">The `callvirt` instruction may be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix to specify that the current stack frame should be released before transferring control.</span></span> <span data-ttu-id="02415-871">如果调用会将控制传输到比原始方法更高的信任方法，则不会释放堆栈帧。</span><span class="sxs-lookup"><span data-stu-id="02415-871">If the call would transfer control to a method of higher trust than the original method the stack frame will not be released.</span></span>  
  
 <span data-ttu-id="02415-872">方法元数据标记提供要调用的方法的名称、类和签名。</span><span class="sxs-lookup"><span data-stu-id="02415-872">The method metadata token provides the name, class and signature of the method to call.</span></span> <span data-ttu-id="02415-873">与 `obj` 关联的类是它作为其实例的类。</span><span class="sxs-lookup"><span data-stu-id="02415-873">The class associated with `obj` is the class of which it is an instance.</span></span> <span data-ttu-id="02415-874">如果类定义了与指定方法名称和签名匹配的非静态方法，则会调用此方法。</span><span class="sxs-lookup"><span data-stu-id="02415-874">If the class defines a non-static method that matches the indicated method name and signature, this method is called.</span></span> <span data-ttu-id="02415-875">否则，会按顺序检查此类的基类链中的所有类。</span><span class="sxs-lookup"><span data-stu-id="02415-875">Otherwise all classes in the base class chain of this class are checked in order.</span></span> <span data-ttu-id="02415-876">如果未找到任何方法，则是错误的。</span><span class="sxs-lookup"><span data-stu-id="02415-876">It is an error if no method is found.</span></span>  
  
 <span data-ttu-id="02415-877">`Callvirt` 在调用方法之前，将对象和关联参数从计算堆栈中弹出。</span><span class="sxs-lookup"><span data-stu-id="02415-877">`Callvirt` pops the object and the associated arguments off the evaluation stack before calling the method.</span></span> <span data-ttu-id="02415-878">如果该方法具有返回值，则在方法完成后将其推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-878">If the method has a return value, it is pushed on the stack upon method completion.</span></span> <span data-ttu-id="02415-879">在被调用方方，`obj` 参数作为参数0进行访问，`arg1` 为参数1，依此类推。</span><span class="sxs-lookup"><span data-stu-id="02415-879">On the callee side, the `obj` parameter is accessed as argument 0, `arg1` as argument 1, and so on.</span></span>  
  
 <span data-ttu-id="02415-880">自变量以从左到右的顺序放置在堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-880">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="02415-881">也就是说，第一个参数是计算并放置在堆栈上，然后是第三个参数，然后是第三个参数，直到所有必需的参数按降序排列。</span><span class="sxs-lookup"><span data-stu-id="02415-881">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="02415-882">实例引用 `obj` （始终需要用于 `callvirt`）必须在任何用户可见参数之前推送。</span><span class="sxs-lookup"><span data-stu-id="02415-882">The instance reference `obj` (always required for `callvirt`) must be pushed before any of the user-visible arguments.</span></span> <span data-ttu-id="02415-883">签名（包含在元数据标记中）不需要包含在此指针的参数列表中的条目。</span><span class="sxs-lookup"><span data-stu-id="02415-883">The signature (carried in the metadata token) need not contain an entry in the parameter list for the this pointer.</span></span>  
  
 <span data-ttu-id="02415-884">请注意，还可以使用 <xref:System.Reflection.Emit.OpCodes.Call> 指令调用虚拟方法。</span><span class="sxs-lookup"><span data-stu-id="02415-884">Note that a virtual method can also be called using the <xref:System.Reflection.Emit.OpCodes.Call> instruction.</span></span>  
  
 <span data-ttu-id="02415-885">如果在与 `obj` 或其任何基类关联的类中找不到具有指定名称和签名的非静态方法，则会引发 <xref:System.MissingMethodException>。</span><span class="sxs-lookup"><span data-stu-id="02415-885"><xref:System.MissingMethodException> is thrown if a non-static method with the indicated name and signature could not be found in the class associated with `obj` or any of its base classes.</span></span> <span data-ttu-id="02415-886">当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是运行时，通常会检测到此情况。</span><span class="sxs-lookup"><span data-stu-id="02415-886">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="02415-887">如果 obj 为 null，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-887"><xref:System.NullReferenceException> is thrown if obj is null.</span></span>  
  
 <span data-ttu-id="02415-888">如果系统安全不向调用方授予对所调用方法的访问权限，则会引发 <xref:System.Security.SecurityException>。</span><span class="sxs-lookup"><span data-stu-id="02415-888"><xref:System.Security.SecurityException> is thrown if system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="02415-889">当 CIL 转换为本机代码而不是运行时，可能会进行安全检查。</span><span class="sxs-lookup"><span data-stu-id="02415-889">The security check may occur when the CIL is converted to native code rather than at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="02415-890">当在值类型上调用 System.object 的方法时，请考虑将 `constrained` 前缀与 `callvirt` 指令一起使用。</span><span class="sxs-lookup"><span data-stu-id="02415-890">When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction.</span></span> <span data-ttu-id="02415-891">这就不必发出不同的 IL，具体取决于值类型是否重写方法，避免出现潜在的版本控制问题。</span><span class="sxs-lookup"><span data-stu-id="02415-891">This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</span></span> <span data-ttu-id="02415-892">当对值类型调用接口方法时，请考虑使用 `constrained` 前缀，因为实现接口方法的值类型方法可以使用 `MethodImpl`进行更改。</span><span class="sxs-lookup"><span data-stu-id="02415-892">Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="02415-893"><xref:System.Reflection.Emit.OpCodes.Constrained> opcode 中更详细地介绍了这些问题。</span><span class="sxs-lookup"><span data-stu-id="02415-893">These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span></span>  
  
 <span data-ttu-id="02415-894">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `callvirt` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-894">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `callvirt` opcode:</span></span>  
  
-   <span data-ttu-id="02415-895">ILGenerator （操作码，MethodInfo）</span><span class="sxs-lookup"><span data-stu-id="02415-895">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="02415-896">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span><span class="sxs-lookup"><span data-stu-id="02415-896">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-897">尝试将引用传递的对象转换为指定的类。</span><span class="sxs-lookup"><span data-stu-id="02415-897">Attempts to cast an object passed by reference to the specified class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-898">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-898">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-899">格式</span><span class="sxs-lookup"><span data-stu-id="02415-899">Format</span></span>|<span data-ttu-id="02415-900">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-900">Assembly Format</span></span>|<span data-ttu-id="02415-901">说明</span><span class="sxs-lookup"><span data-stu-id="02415-901">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-902">74 < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-902">74 < `T` ></span></span>|<span data-ttu-id="02415-903">castclass `class`</span><span class="sxs-lookup"><span data-stu-id="02415-903">castclass `class`</span></span>|<span data-ttu-id="02415-904">将对象强制转换为类型 `class`的新对象。</span><span class="sxs-lookup"><span data-stu-id="02415-904">Casts an object to a new object of type `class`.</span></span>|  
  
 <span data-ttu-id="02415-905">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-905">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-906">对象引用被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-906">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-907">从堆栈中弹出对象引用;被引用对象被强制转换为指定的 `class`。</span><span class="sxs-lookup"><span data-stu-id="02415-907">The object reference is popped from the stack; the referenced object is cast as the specified `class`.</span></span>  
  
3.  <span data-ttu-id="02415-908">如果成功，则将新的对象引用推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-908">If successful, a new object reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-909">`castclass` 指令尝试将堆栈顶部的对象引用（类型 `O`）强制转换为指定的类。</span><span class="sxs-lookup"><span data-stu-id="02415-909">The `castclass` instruction attempts to cast the object reference (type `O`) atop the stack to a specified class.</span></span> <span data-ttu-id="02415-910">新类由指示所需类的元数据标记指定。</span><span class="sxs-lookup"><span data-stu-id="02415-910">The new class is specified by a metadata token indicating the desired class.</span></span> <span data-ttu-id="02415-911">如果堆栈顶部对象的类未实现新类（假定新类为接口），并且不是新类的派生类，则会引发 <xref:System.InvalidCastException>。</span><span class="sxs-lookup"><span data-stu-id="02415-911">If the class of the object on the top of the stack does not implement the new class (assuming the new class is an interface) and is not a derived class of the new class then an <xref:System.InvalidCastException> is thrown.</span></span> <span data-ttu-id="02415-912">如果对象引用为空引用，则 `castclass` 成功，并返回新的对象作为空引用。</span><span class="sxs-lookup"><span data-stu-id="02415-912">If the object reference is a null reference, `castclass` succeeds and returns the new object as a null reference.</span></span>  
  
 <span data-ttu-id="02415-913">如果无法将 obj 强制转换为类，则会引发 <xref:System.InvalidCastException>。</span><span class="sxs-lookup"><span data-stu-id="02415-913"><xref:System.InvalidCastException> is thrown if obj cannot be cast to class.</span></span>  
  
 <span data-ttu-id="02415-914">如果找不到类，则会引发 <xref:System.TypeLoadException>。</span><span class="sxs-lookup"><span data-stu-id="02415-914"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="02415-915">当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是运行时，通常会检测到此情况。</span><span class="sxs-lookup"><span data-stu-id="02415-915">This is typically detected when a Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="02415-916">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `castclass` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-916">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `castclass` opcode:</span></span>  
  
-   <span data-ttu-id="02415-917">ILGenerator （OpCode，Type）</span><span class="sxs-lookup"><span data-stu-id="02415-917">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-918">比较两个值。</span><span class="sxs-lookup"><span data-stu-id="02415-918">Compares two values.</span></span> <span data-ttu-id="02415-919">如果这两个值相等，则将整数值 1 <see langword="(int32" />) 推送到计算堆栈上；否则，将 0 (<see langword="int32" />) 推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-919">If they are equal, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-920">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-920">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-921">格式</span><span class="sxs-lookup"><span data-stu-id="02415-921">Format</span></span>|<span data-ttu-id="02415-922">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-922">Assembly Format</span></span>|<span data-ttu-id="02415-923">说明</span><span class="sxs-lookup"><span data-stu-id="02415-923">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-924">FE 01</span><span class="sxs-lookup"><span data-stu-id="02415-924">FE 01</span></span>|<span data-ttu-id="02415-925">ceq</span><span class="sxs-lookup"><span data-stu-id="02415-925">ceq</span></span>|<span data-ttu-id="02415-926">如果 `value1` 等于 `value2`，则推送 1;else 将0推送。</span><span class="sxs-lookup"><span data-stu-id="02415-926">Pushes 1 if `value1` equals `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="02415-927">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-927">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-928">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-928">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-929">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-929">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-930">从堆栈中弹出 `value2` 和 `value1`;将 `value1` 与 `value2`进行比较。</span><span class="sxs-lookup"><span data-stu-id="02415-930">`value2` and `value1` are popped from the stack; `value1` is compared to `value2`.</span></span>  
  
4.  <span data-ttu-id="02415-931">如果 `value1` 等于 `value2`，则将1推送到堆栈上;否则，将0推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-931">If `value1` is equal to `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-932">`ceq` 指令比较 `value1` 和 `value2`。</span><span class="sxs-lookup"><span data-stu-id="02415-932">The `ceq` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="02415-933">如果 `value1` 等于 `value2`，则将1（类型 `int32`）推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-933">If `value1` is equal to `value2`, then 1 (of type `int32`) is pushed on the stack.</span></span> <span data-ttu-id="02415-934">否则，将0（类型 `int32`）推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-934">Otherwise 0 (of type `int32`) is pushed on the stack.</span></span>  
  
 <span data-ttu-id="02415-935">对于浮点数，如果数字未排序（或两者均为 NaN），`ceq` 将返回0。</span><span class="sxs-lookup"><span data-stu-id="02415-935">For floating-point number, `ceq` will return 0 if the numbers are unordered (either or both are NaN).</span></span> <span data-ttu-id="02415-936">无限值等于自身。</span><span class="sxs-lookup"><span data-stu-id="02415-936">The infinite values are equal to themselves.</span></span>  
  
 <span data-ttu-id="02415-937">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ceq` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-937">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ceq` opcode:</span></span>  
  
-   <span data-ttu-id="02415-938">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-938">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-939">比较两个值。</span><span class="sxs-lookup"><span data-stu-id="02415-939">Compares two values.</span></span> <span data-ttu-id="02415-940">如果第一个值大于第二个值，则将整数值 1 <see langword="(int32" />) 推送到计算堆栈上；反之，将 0 (<see langword="int32" />) 推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-940">If the first value is greater than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-941">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-941">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-942">格式</span><span class="sxs-lookup"><span data-stu-id="02415-942">Format</span></span>|<span data-ttu-id="02415-943">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-943">Assembly Format</span></span>|<span data-ttu-id="02415-944">说明</span><span class="sxs-lookup"><span data-stu-id="02415-944">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-945">FE 02</span><span class="sxs-lookup"><span data-stu-id="02415-945">FE 02</span></span>|<span data-ttu-id="02415-946">cgt</span><span class="sxs-lookup"><span data-stu-id="02415-946">cgt</span></span>|<span data-ttu-id="02415-947">如果 `value1` 大于 `value2`，则推送 1;else 将0推送。</span><span class="sxs-lookup"><span data-stu-id="02415-947">Pushes 1 if `value1` is greater than `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="02415-948">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-948">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-949">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-949">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-950">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-950">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-951">从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 大于 `value2`，则测试 `cgt`。</span><span class="sxs-lookup"><span data-stu-id="02415-951">`value2` and `value1` are popped from the stack; `cgt` tests if `value1` is greater than `value2`.</span></span>  
  
4.  <span data-ttu-id="02415-952">如果 `value1` 大于 `value2`，则将1推送到堆栈上;否则，将0推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-952">If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-953">`cgt` 指令比较 `value1` 和 `value2`。</span><span class="sxs-lookup"><span data-stu-id="02415-953">The `cgt` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="02415-954">如果 `value1` 严格大于 `value2`，则将 `int32` 值1推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-954">If `value1` is strictly greater than `value2`, then an `int32` value of 1 is pushed on the stack.</span></span> <span data-ttu-id="02415-955">否则，在堆栈上推送 `int32` 值0。</span><span class="sxs-lookup"><span data-stu-id="02415-955">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
-   <span data-ttu-id="02415-956">对于浮点数，如果数字未排序（也就是说，如果一个参数或两个参数均为 NaN），`cgt` 将返回0。</span><span class="sxs-lookup"><span data-stu-id="02415-956">For floating-point numbers, `cgt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</span></span>  
  
 <span data-ttu-id="02415-957">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `cgt` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-957">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt` opcode:</span></span>  
  
-   <span data-ttu-id="02415-958">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-958">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-959">比较两个无符号的或未经排序的值。</span><span class="sxs-lookup"><span data-stu-id="02415-959">Compares two unsigned or unordered values.</span></span> <span data-ttu-id="02415-960">如果第一个值大于第二个值，则将整数值 1 <see langword="(int32" />) 推送到计算堆栈上；反之，将 0 (<see langword="int32" />) 推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-960">If the first value is greater than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-961">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-961">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-962">格式</span><span class="sxs-lookup"><span data-stu-id="02415-962">Format</span></span>|<span data-ttu-id="02415-963">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-963">Assembly Format</span></span>|<span data-ttu-id="02415-964">说明</span><span class="sxs-lookup"><span data-stu-id="02415-964">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-965">FE 03</span><span class="sxs-lookup"><span data-stu-id="02415-965">FE 03</span></span>|<span data-ttu-id="02415-966">cgt.un</span><span class="sxs-lookup"><span data-stu-id="02415-966">cgt.un</span></span>|<span data-ttu-id="02415-967">如果 `value1` 大于 `value2`，则推送 1;else 将0（无符号值）推送。</span><span class="sxs-lookup"><span data-stu-id="02415-967">Pushes 1 if `value1` is greater than `value2`; else pushes 0 (unsigned values).</span></span>|  
  
 <span data-ttu-id="02415-968">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-968">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-969">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-969">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-970">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-970">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-971">从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 大于 `value2`，则测试 `cgt.un`。</span><span class="sxs-lookup"><span data-stu-id="02415-971">`value2` and `value1` are popped from the stack; `cgt.un` tests if `value1` is greater than `value2`.</span></span>  
  
4.  <span data-ttu-id="02415-972">如果 `value1` 大于 `value2`，则将1推送到堆栈上;否则，将0推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-972">If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-973">如果 `true` 以下任意一项，则将 `int32` 值1推送到堆栈上：</span><span class="sxs-lookup"><span data-stu-id="02415-973">An `int32` value of 1 is pushed on the stack if any of the following is `true` :</span></span>  
  
 <span data-ttu-id="02415-974">对于浮点数，`value1` 不按 `value2`排序。</span><span class="sxs-lookup"><span data-stu-id="02415-974">For floating-point numbers, `value1` is not ordered with respect to `value2`.</span></span>  
  
 <span data-ttu-id="02415-975">对于整数值，当被视为无符号数字时，`value1` 严格大于 `value2`。</span><span class="sxs-lookup"><span data-stu-id="02415-975">For integer values, `value1` is strictly greater than `value2` when considered as unsigned numbers.</span></span>  
  
 <span data-ttu-id="02415-976">否则，在堆栈上推送 `int32` 值0。</span><span class="sxs-lookup"><span data-stu-id="02415-976">Otherwise an `int32` value of 0 is pushed on the stack.</span></span>  
  
 <span data-ttu-id="02415-977">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `cgt.un` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-977">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt.un` opcode:</span></span>  
  
-   <span data-ttu-id="02415-978">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-978">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-979">如果值不是有限数，则引发 <see cref="T:System.ArithmeticException" />。</span><span class="sxs-lookup"><span data-stu-id="02415-979">Throws <see cref="T:System.ArithmeticException" /> if value is not a finite number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-980">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-980">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-981">格式</span><span class="sxs-lookup"><span data-stu-id="02415-981">Format</span></span>|<span data-ttu-id="02415-982">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-982">Assembly Format</span></span>|<span data-ttu-id="02415-983">说明</span><span class="sxs-lookup"><span data-stu-id="02415-983">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-984">C3</span><span class="sxs-lookup"><span data-stu-id="02415-984">C3</span></span>|<span data-ttu-id="02415-985">ckfinite</span><span class="sxs-lookup"><span data-stu-id="02415-985">ckfinite</span></span>|<span data-ttu-id="02415-986">如果值不是有限数，则引发 <xref:System.ArithmeticException>。</span><span class="sxs-lookup"><span data-stu-id="02415-986">throw <xref:System.ArithmeticException> if value is not a finite number.</span></span>|  
  
 <span data-ttu-id="02415-987">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-987">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-988">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-988">`value` is pushed onto the stack.</span></span> 
  
2.  <span data-ttu-id="02415-989">`value` 从堆栈中弹出，并对其执行 `ckfinite` 指令。</span><span class="sxs-lookup"><span data-stu-id="02415-989">`value` is popped from the stack and the `ckfinite` instruction is performed on it.</span></span>  
  
3.  <span data-ttu-id="02415-990">如果未引发异常，则将 `value` 推送回堆栈。</span><span class="sxs-lookup"><span data-stu-id="02415-990">`value` is pushed back onto the stack if no exception is thrown.</span></span>  
  
 <span data-ttu-id="02415-991">如果 `value` （浮点数）为 "不是数字" 值（NaN）或 `+-` 无穷值，则 `ckfinite instruction` 引发 <xref:System.ArithmeticException>。</span><span class="sxs-lookup"><span data-stu-id="02415-991">The `ckfinite instruction` throws <xref:System.ArithmeticException> if `value` (a floating-point number) is either a "not a number" value (NaN) or a `+-` infinity value.</span></span> <span data-ttu-id="02415-992">如果未引发异常，`Ckfinite` 将值保留在堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-992">`Ckfinite` leaves the value on the stack if no exception is thrown.</span></span> <span data-ttu-id="02415-993">如果 `value` 不是浮点数，则不指定执行。</span><span class="sxs-lookup"><span data-stu-id="02415-993">Execution is unspecified if `value` is not a floating-point number.</span></span>  
  
 <span data-ttu-id="02415-994">如果 `value` 不是 "normal" 数字，则会引发 <xref:System.ArithmeticException>。</span><span class="sxs-lookup"><span data-stu-id="02415-994"><xref:System.ArithmeticException> is thrown if `value` is not a 'normal' number.</span></span>  
  
 <span data-ttu-id="02415-995">请注意，特殊的异常或派生类 <xref:System.ArithmeticException> 可能更合适，将错误值传递到异常处理程序。</span><span class="sxs-lookup"><span data-stu-id="02415-995">Note that a special exception or a derived class of <xref:System.ArithmeticException> may be more appropriate, passing the incorrect value to the exception handler.</span></span>  
  
 <span data-ttu-id="02415-996">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ckfinite` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-996">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ckfinite` opcode:</span></span>  
  
-   <span data-ttu-id="02415-997">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-997">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-998">比较两个值。</span><span class="sxs-lookup"><span data-stu-id="02415-998">Compares two values.</span></span> <span data-ttu-id="02415-999">如果第一个值小于第二个值，则将整数值 1 <see langword="(int32" />) 推送到计算堆栈上；反之，将 0 (<see langword="int32" />) 推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-999">If the first value is less than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1000">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1000">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1001">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1001">Format</span></span>|<span data-ttu-id="02415-1002">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1002">Assembly Format</span></span>|<span data-ttu-id="02415-1003">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1003">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1004">FE 04</span><span class="sxs-lookup"><span data-stu-id="02415-1004">FE 04</span></span>|<span data-ttu-id="02415-1005">clt</span><span class="sxs-lookup"><span data-stu-id="02415-1005">clt</span></span>|<span data-ttu-id="02415-1006">如果 `value1` 小于 `value2`，则推送 1;else 将0推送。</span><span class="sxs-lookup"><span data-stu-id="02415-1006">Pushes 1 if `value1` is less than `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="02415-1007">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1007">The stack transitional behavior, in sequential order, is:</span></span> 

1.  <span data-ttu-id="02415-1008">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1008">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1009">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1009">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-1010">从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 小于 `value2`，则 `clt` 测试。</span><span class="sxs-lookup"><span data-stu-id="02415-1010">`value2` and `value1` are popped from the stack; `clt` tests if `value1` is less than `value2`.</span></span>  
  
4.  <span data-ttu-id="02415-1011">如果 `value1` 小于 `value2`，则将1推送到堆栈上;否则，将0推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1011">If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1012">`clt` 指令比较 `value1` 和 `value2`。</span><span class="sxs-lookup"><span data-stu-id="02415-1012">The `clt` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="02415-1013">如果 `value1` 严格小于 `value2`，则将 `int32` 值1推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1013">If `value1` is strictly less than `value2`, then an `int32` value of 1 is pushed on the stack.</span></span> <span data-ttu-id="02415-1014">否则，在堆栈上推送 `int32` 值0。</span><span class="sxs-lookup"><span data-stu-id="02415-1014">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
-   <span data-ttu-id="02415-1015">对于浮点数，如果数字未排序（也就是说，如果一个参数或两个参数均为 NaN），`clt` 将返回0。</span><span class="sxs-lookup"><span data-stu-id="02415-1015">For floating-point numbers, `clt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</span></span>  
  
 <span data-ttu-id="02415-1016">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `clt` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1016">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1017">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1017">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1018">比较无符号的或不可排序的值 <paramref name="value1" /> 和 <paramref name="value2" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1018">Compares the unsigned or unordered values <paramref name="value1" /> and <paramref name="value2" />.</span></span> <span data-ttu-id="02415-1019">如果 <paramref name="value1" /> 小于 <paramref name="value2" />，则将整数值 1 <see langword="(int32" /> ) 推送到计算堆栈上；反之，将 0 ( <see langword="int32" /> ) 推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1019">If <paramref name="value1" /> is less than <paramref name="value2" />, then the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1020">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1020">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1021">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1021">Format</span></span>|<span data-ttu-id="02415-1022">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1022">Assembly Format</span></span>|<span data-ttu-id="02415-1023">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1023">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1024">FE 05</span><span class="sxs-lookup"><span data-stu-id="02415-1024">FE 05</span></span>|<span data-ttu-id="02415-1025">clt.un</span><span class="sxs-lookup"><span data-stu-id="02415-1025">clt.un</span></span>|<span data-ttu-id="02415-1026">如果 `value1` 小于 `value2`，则推送 1;else 将0（无符号值）推送。</span><span class="sxs-lookup"><span data-stu-id="02415-1026">Pushes 1 if `value1` is less than `value2`; else pushes 0 (unsigned values).</span></span>|  
  
 <span data-ttu-id="02415-1027">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1027">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1028">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1028">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1029">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1029">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-1030">从堆栈中弹出 `value2` 和 `value1`;如果 `value1` 小于 `value2`，则 `clt.un` 测试。</span><span class="sxs-lookup"><span data-stu-id="02415-1030">`value2` and `value1` are popped from the stack; `clt.un` tests if `value1` is less than `value2`.</span></span>  
  
4.  <span data-ttu-id="02415-1031">如果 `value1` 小于 `value2`，则将1推送到堆栈上;否则，将0推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1031">If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1032">`clt.un` 指令比较 `value1` 和 `value2`。</span><span class="sxs-lookup"><span data-stu-id="02415-1032">The `clt.un` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="02415-1033">如果满足以下任一条件，则将 `int32` 值1推送到堆栈上：</span><span class="sxs-lookup"><span data-stu-id="02415-1033">An `int32` value of 1 is pushed on the stack if any of the following is true:</span></span>  
  
-   <span data-ttu-id="02415-1034">`value1` 严格低于 `value2` （`clt`）。</span><span class="sxs-lookup"><span data-stu-id="02415-1034">`value1` is strictly less than `value2` (as for `clt`).</span></span>  
  
-   <span data-ttu-id="02415-1035">对于浮点数，`value1` 不按 `value2`排序。</span><span class="sxs-lookup"><span data-stu-id="02415-1035">For floating-point numbers, `value1` is not ordered with respect to `value2`.</span></span>  
  
-   <span data-ttu-id="02415-1036">对于整数值，当被视为无符号数字时，`value1` 严格小于 `value2`。</span><span class="sxs-lookup"><span data-stu-id="02415-1036">For integer values, `value1` is strictly less than `value2` when considered as unsigned numbers.</span></span>  
  
 <span data-ttu-id="02415-1037">否则，在堆栈上推送 `int32` 值0。</span><span class="sxs-lookup"><span data-stu-id="02415-1037">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
 <span data-ttu-id="02415-1038">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `clt.un` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1038">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt.un` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1039">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1039">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1040">约束要对其进行虚方法调用的类型。</span><span class="sxs-lookup"><span data-stu-id="02415-1040">Constrains the type on which a virtual method call is made.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1041">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1041">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1042">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1042">Format</span></span>|<span data-ttu-id="02415-1043">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1043">Assembly Format</span></span>|<span data-ttu-id="02415-1044">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1044">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1045">FE 16 < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-1045">FE 16 < `T` ></span></span>|<span data-ttu-id="02415-1046">有限.</span><span class="sxs-lookup"><span data-stu-id="02415-1046">constrained.</span></span> `thisType`|<span data-ttu-id="02415-1047">对被约束为类型 `T`的类型调用虚拟方法。</span><span class="sxs-lookup"><span data-stu-id="02415-1047">Call a virtual method on a type constrained to be type `T`.</span></span>|  
  
 <span data-ttu-id="02415-1048">仅对 `callvirt` 指令允许 `constrained` 前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-1048">The `constrained` prefix is permitted only on a `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="02415-1049">此时 MSIL 堆栈的状态必须如下所示：</span><span class="sxs-lookup"><span data-stu-id="02415-1049">The state of the MSIL stack at this point must be as follows:</span></span>  
  
1.  <span data-ttu-id="02415-1050">托管指针 `ptr`被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1050">A managed pointer, `ptr`, is pushed onto the stack.</span></span> <span data-ttu-id="02415-1051">`ptr` 的类型必须是 `thisType`的托管指针（`&`）。</span><span class="sxs-lookup"><span data-stu-id="02415-1051">The type of `ptr` must be a managed pointer (`&`) to `thisType`.</span></span> <span data-ttu-id="02415-1052">请注意，这与没有前缀 `callvirt` 指令的情况不同，后者需要 `thisType`的引用。</span><span class="sxs-lookup"><span data-stu-id="02415-1052">Note that this is different from the case of an unprefixed `callvirt` instruction, which expects a reference of `thisType`.</span></span>  
  
2.  <span data-ttu-id="02415-1053">`arg1` 通过 `argN` 将方法参数推送到堆栈上，就像没有前缀的 `callvirt` 指令一样。</span><span class="sxs-lookup"><span data-stu-id="02415-1053">Method arguments `arg1` through `argN` are pushed onto the stack, just as with an unprefixed `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="02415-1054">`constrained` 前缀旨在允许 `callvirt` 指令以统一的方式进行，而不管 `thisType` 是值类型还是引用类型。</span><span class="sxs-lookup"><span data-stu-id="02415-1054">The `constrained` prefix is designed to allow `callvirt` instructions to be made in a uniform way independent of whether `thisType` is a value type or a reference type.</span></span>  
  
 <span data-ttu-id="02415-1055">如果 `callvirt` `method` 指令以 `constrained` `thisType`为前缀，则按如下方式执行指令：</span><span class="sxs-lookup"><span data-stu-id="02415-1055">When a `callvirt` `method` instruction has been prefixed by `constrained` `thisType`, the instruction is executed as follows:</span></span>  
  
-   <span data-ttu-id="02415-1056">如果 `thisType` 是引用类型（而不是值类型），则 `ptr` 被取消引用并作为 "this" 指针传递到 `method`的 `callvirt`。</span><span class="sxs-lookup"><span data-stu-id="02415-1056">If `thisType` is a reference type (as opposed to a value type) then `ptr` is dereferenced and passed as the 'this' pointer to the `callvirt` of `method`.</span></span>  
  
-   <span data-ttu-id="02415-1057">如果 `thisType` 是值类型，并且 `thisType` 实现 `method` 那么，`ptr` 将作为 "this" 指针传递到 `call` `method` 指令，以 `method` `thisType`的实现实现。</span><span class="sxs-lookup"><span data-stu-id="02415-1057">If `thisType` is a value type and `thisType` implements `method` then `ptr` is passed unmodified as the 'this' pointer to a `call` `method` instruction, for the implementation of `method` by `thisType`.</span></span>  
  
-   <span data-ttu-id="02415-1058">如果 `thisType` 是值类型，并且 `thisType` 未实现 `method`，则 `ptr` 是取消引用并装箱，并作为 "this" 指针传递到 `callvirt` `method` 指令。</span><span class="sxs-lookup"><span data-stu-id="02415-1058">If `thisType` is a value type and `thisType` does not implement `method` then `ptr` is dereferenced, boxed, and passed as the 'this' pointer to the `callvirt` `method` instruction.</span></span>  
  
 <span data-ttu-id="02415-1059">仅当在 <xref:System.Object>、<xref:System.ValueType>或 <xref:System.Enum> 上定义 `method`，而不是 `thisType`重写时，才会出现这种情况。</span><span class="sxs-lookup"><span data-stu-id="02415-1059">This last case can occur only when `method` was defined on <xref:System.Object>, <xref:System.ValueType>, or <xref:System.Enum> and not overridden by `thisType`.</span></span> <span data-ttu-id="02415-1060">在这种情况下，装箱会导致生成原始对象的副本。</span><span class="sxs-lookup"><span data-stu-id="02415-1060">In this case, the boxing causes a copy of the original object to be made.</span></span> <span data-ttu-id="02415-1061">但是，因为没有 <xref:System.Object>、<xref:System.ValueType>和 <xref:System.Enum> 的方法修改对象的状态，所以无法检测到这种情况。</span><span class="sxs-lookup"><span data-stu-id="02415-1061">However, because none of the methods of <xref:System.Object>, <xref:System.ValueType>, and <xref:System.Enum> modify the state of the object, this fact cannot be detected.</span></span>  
  
 <span data-ttu-id="02415-1062">`constrained` 前缀支持创建泛型代码的 IL 生成器。</span><span class="sxs-lookup"><span data-stu-id="02415-1062">The `constrained` prefix supports IL generators that create generic code.</span></span> <span data-ttu-id="02415-1063">通常，`callvirt` 指令对值类型无效。</span><span class="sxs-lookup"><span data-stu-id="02415-1063">Normally the `callvirt` instruction is not valid on value types.</span></span> <span data-ttu-id="02415-1064">相反，IL 编译器必须在编译时有效地执行上述 "this" 转换，具体取决于 `ptr` 的类型和所调用的方法。</span><span class="sxs-lookup"><span data-stu-id="02415-1064">Instead it is required that IL compilers effectively perform the 'this' transformation outlined above at compile time, depending on the type of `ptr` and the method being called.</span></span> <span data-ttu-id="02415-1065">但是，如果 `ptr` 是在编译时未知的泛型类型，则不能在编译时进行此转换。</span><span class="sxs-lookup"><span data-stu-id="02415-1065">However, when `ptr` is a generic type that is unknown at compile time, it is not possible to make this transformation at compile time.</span></span>  
  
 <span data-ttu-id="02415-1066">`constrained` opcode 允许 IL 编译器以统一的方式对虚拟函数进行调用，而不管 `ptr` 是值类型还是引用类型。</span><span class="sxs-lookup"><span data-stu-id="02415-1066">The `constrained` opcode allows IL compilers to make a call to a virtual function in a uniform way independent of whether `ptr` is a value type or a reference type.</span></span> <span data-ttu-id="02415-1067">尽管它适用于 `thisType` 为泛型类型变量的情况，但 `constrained` 前缀还适用于非泛型类型，并且可以降低以隐藏值类型和引用类型之间的区别的语言生成虚拟调用的复杂性。</span><span class="sxs-lookup"><span data-stu-id="02415-1067">Although it is intended for the case where `thisType` is a generic type variable, the `constrained` prefix also works for nongeneric types and can reduce the complexity of generating virtual calls in languages that hide the distinction between value types and reference types.</span></span>  
  
 <span data-ttu-id="02415-1068">使用 `constrained` 前缀还可以避免值类型出现潜在的版本管理问题。</span><span class="sxs-lookup"><span data-stu-id="02415-1068">Using the `constrained` prefix also avoids potential versioning problems with value types.</span></span> <span data-ttu-id="02415-1069">如果未使用 `constrained` 前缀，则必须根据值类型是否覆盖 System.object 的方法来发出不同的 IL。</span><span class="sxs-lookup"><span data-stu-id="02415-1069">If the `constrained` prefix is not used, different IL must be emitted depending on whether or not a value type overrides a method of System.Object.</span></span> <span data-ttu-id="02415-1070">例如，如果值类型 `V` 重写对象的 ToString （）方法，则会发出 `call` `V.ToString()` 指令;如果没有，则发出 `box` 指令和 `callvirt` `Object.ToString()` 指令。</span><span class="sxs-lookup"><span data-stu-id="02415-1070">For example, if a value type `V` overrides the Object.ToString() method, a `call` `V.ToString()` instruction is emitted; if it does not, a `box` instruction and a `callvirt` `Object.ToString()` instruction are emitted.</span></span> <span data-ttu-id="02415-1071">如果稍后要删除重写，并且在后一种情况下，如果后来添加了替代，则可能会出现版本控制问题。</span><span class="sxs-lookup"><span data-stu-id="02415-1071">A versioning problem can arise in the former case if the override is later removed, and in the latter case if an override is later added.</span></span>  
  
 <span data-ttu-id="02415-1072">`constrained` 前缀还可用于对值类型调用接口方法，因为实现接口方法的值类型方法可以使用 `MethodImpl`进行更改。</span><span class="sxs-lookup"><span data-stu-id="02415-1072">The `constrained` prefix can also be used for invocation of interface methods on value types, because the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="02415-1073">如果未使用 `constrained` 前缀，则强制编译器选择要在编译时绑定到的值类型的方法。</span><span class="sxs-lookup"><span data-stu-id="02415-1073">If the `constrained` prefix is not used, the compiler is forced to choose which of the value type's methods to bind to at compile time.</span></span> <span data-ttu-id="02415-1074">使用 `constrained` 前缀允许 MSIL 绑定到在运行时（而不是在编译时）实现接口方法的方法。</span><span class="sxs-lookup"><span data-stu-id="02415-1074">Using the `constrained` prefix allows the MSIL to bind to the method that implements the interface method at run time, rather than at compile time.</span></span>  
  
 <span data-ttu-id="02415-1075">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `constrained` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1075">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `constrained` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1076">ILGenerator （OpCode，Type）</span><span class="sxs-lookup"><span data-stu-id="02415-1076">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1077">将位于计算堆栈顶部的值转换为 <see langword="native int" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1077">Converts the value on top of the evaluation stack to <see langword="native int" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1078">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1078">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1079">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1079">Format</span></span>|<span data-ttu-id="02415-1080">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1080">Assembly Format</span></span>|<span data-ttu-id="02415-1081">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1081">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1082">D3</span><span class="sxs-lookup"><span data-stu-id="02415-1082">D3</span></span>|<span data-ttu-id="02415-1083">约定</span><span class="sxs-lookup"><span data-stu-id="02415-1083">conv.i</span></span>|<span data-ttu-id="02415-1084">转换为 `native int`，将 `native int` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1084">Convert to `native int`, pushing `native int` on stack.</span></span>|  
  
 <span data-ttu-id="02415-1085">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1085">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1086">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1086">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1087">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1087">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="02415-1088">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1088">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1089">`conv.i` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1089">The `conv.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1090">小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1090">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="02415-1091">将浮点值转换为 `F` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-1091">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="02415-1092">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1092">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="02415-1093">从 `float64` 转换到 `float32`时，精度可能会丢失。</span><span class="sxs-lookup"><span data-stu-id="02415-1093">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="02415-1094">如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。</span><span class="sxs-lookup"><span data-stu-id="02415-1094">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="02415-1095">如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。</span><span class="sxs-lookup"><span data-stu-id="02415-1095">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="02415-1096">如果结果小于 `int32`，则值将进行符号扩展以填充槽。</span><span class="sxs-lookup"><span data-stu-id="02415-1096">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="02415-1097">如果发生溢出，将浮点类型转换为整数，则返回的值是未指定的。</span><span class="sxs-lookup"><span data-stu-id="02415-1097">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="02415-1098">使用此字段时，不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1098">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="02415-1099">有关在结果类型无法正确表示结果值时将引发异常的等效说明，请参阅 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> 和 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>。</span><span class="sxs-lookup"><span data-stu-id="02415-1099">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="02415-1100">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.i` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1100">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1101">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1101">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1102">将位于计算堆栈顶部的值转换为 <see langword="int8" />，然后将其扩展（填充）为 <see langword="int32" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1102">Converts the value on top of the evaluation stack to <see langword="int8" />, then extends (pads) it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1103">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1103">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1104">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1104">Format</span></span>|<span data-ttu-id="02415-1105">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1105">Assembly Format</span></span>|<span data-ttu-id="02415-1106">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1106">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1107">67</span><span class="sxs-lookup"><span data-stu-id="02415-1107">67</span></span>|<span data-ttu-id="02415-1108">约定 i1</span><span class="sxs-lookup"><span data-stu-id="02415-1108">conv.i1</span></span>|<span data-ttu-id="02415-1109">转换为 `int8`，将 `int32` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1109">Convert to `int8`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="02415-1110">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1110">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1111">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1111">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1112">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1112">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="02415-1113">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1113">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1114">`conv.i1` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1114">The `conv.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1115">小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1115">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="02415-1116">将浮点值转换为 `F` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-1116">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="02415-1117">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1117">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="02415-1118">从 `float64` 转换到 `float32`时，精度可能会丢失。</span><span class="sxs-lookup"><span data-stu-id="02415-1118">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="02415-1119">如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。</span><span class="sxs-lookup"><span data-stu-id="02415-1119">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="02415-1120">如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。</span><span class="sxs-lookup"><span data-stu-id="02415-1120">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="02415-1121">如果结果小于 `int32`，则值将进行符号扩展以填充槽。</span><span class="sxs-lookup"><span data-stu-id="02415-1121">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="02415-1122">如果发生溢出，将浮点类型转换为整数，则返回的值是未指定的。</span><span class="sxs-lookup"><span data-stu-id="02415-1122">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="02415-1123">使用此字段时，不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1123">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="02415-1124">有关在结果类型无法正确表示结果值时将引发异常的等效说明，请参阅 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> 和 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>。</span><span class="sxs-lookup"><span data-stu-id="02415-1124">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="02415-1125">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.i1` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1125">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i1` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1126">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1126">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1127">将位于计算堆栈顶部的值转换为 <see langword="int16" />，然后将其扩展（填充）为 <see langword="int32" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1127">Converts the value on top of the evaluation stack to <see langword="int16" />, then extends (pads) it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1128">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1128">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1129">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1129">Format</span></span>|<span data-ttu-id="02415-1130">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1130">Assembly Format</span></span>|<span data-ttu-id="02415-1131">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1131">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1132">68</span><span class="sxs-lookup"><span data-stu-id="02415-1132">68</span></span>|<span data-ttu-id="02415-1133">约定</span><span class="sxs-lookup"><span data-stu-id="02415-1133">conv.i2</span></span>|<span data-ttu-id="02415-1134">转换为 `int16`，将 `int32` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1134">Convert to `int16`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="02415-1135">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1135">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1136">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1136">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1137">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1137">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="02415-1138">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1138">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1139">`conv.i2` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1139">The `conv.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1140">小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1140">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="02415-1141">将浮点值转换为 `F` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-1141">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="02415-1142">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1142">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="02415-1143">从 `float64` 转换到 `float32`时，精度可能会丢失。</span><span class="sxs-lookup"><span data-stu-id="02415-1143">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="02415-1144">如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。</span><span class="sxs-lookup"><span data-stu-id="02415-1144">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="02415-1145">如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。</span><span class="sxs-lookup"><span data-stu-id="02415-1145">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="02415-1146">如果结果小于 `int32`，则值将进行符号扩展以填充槽。</span><span class="sxs-lookup"><span data-stu-id="02415-1146">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="02415-1147">如果发生溢出，将浮点类型转换为整数，则返回的值是未指定的。</span><span class="sxs-lookup"><span data-stu-id="02415-1147">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="02415-1148">使用此字段时，不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1148">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="02415-1149">有关在结果类型无法正确表示结果值时将引发异常的等效说明，请参阅 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> 和 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>。</span><span class="sxs-lookup"><span data-stu-id="02415-1149">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="02415-1150">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.i2` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1150">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i2` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1151">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1151">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1152">将位于计算堆栈顶部的值转换为 <see langword="int32" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1152">Converts the value on top of the evaluation stack to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1153">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1153">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1154">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1154">Format</span></span>|<span data-ttu-id="02415-1155">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1155">Assembly Format</span></span>|<span data-ttu-id="02415-1156">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1156">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1157">69</span><span class="sxs-lookup"><span data-stu-id="02415-1157">69</span></span>|<span data-ttu-id="02415-1158">i4</span><span class="sxs-lookup"><span data-stu-id="02415-1158">conv.i4</span></span>|<span data-ttu-id="02415-1159">转换为 `int32`，将 `int32` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1159">Convert to `int32`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="02415-1160">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1160">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1161">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1161">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1162">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1162">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="02415-1163">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1163">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1164">`conv.i4` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1164">The `conv.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1165">小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1165">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="02415-1166">将浮点值转换为 `F` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-1166">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="02415-1167">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1167">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="02415-1168">从 `float64` 转换到 `float32`时，精度可能会丢失。</span><span class="sxs-lookup"><span data-stu-id="02415-1168">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="02415-1169">如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。</span><span class="sxs-lookup"><span data-stu-id="02415-1169">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="02415-1170">如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。</span><span class="sxs-lookup"><span data-stu-id="02415-1170">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="02415-1171">如果结果小于 `int32`，则值将进行符号扩展以填充槽。</span><span class="sxs-lookup"><span data-stu-id="02415-1171">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="02415-1172">如果发生溢出，将浮点类型转换为整数，则返回的值是未指定的。</span><span class="sxs-lookup"><span data-stu-id="02415-1172">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="02415-1173">使用此字段时，不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1173">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="02415-1174">有关在结果类型无法正确表示结果值时将引发异常的等效说明，请参阅 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> 和 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>。</span><span class="sxs-lookup"><span data-stu-id="02415-1174">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="02415-1175">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.i4` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1175">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i4` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1176">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1176">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1177">将位于计算堆栈顶部的值转换为 <see langword="int64" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1177">Converts the value on top of the evaluation stack to <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1178">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1178">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1179">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1179">Format</span></span>|<span data-ttu-id="02415-1180">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1180">Assembly Format</span></span>|<span data-ttu-id="02415-1181">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1181">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1182">6A</span><span class="sxs-lookup"><span data-stu-id="02415-1182">6A</span></span>|<span data-ttu-id="02415-1183">i8</span><span class="sxs-lookup"><span data-stu-id="02415-1183">conv.i8</span></span>|<span data-ttu-id="02415-1184">转换为 `int64`，将 `int64` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1184">Convert to `int64`, pushing `int64` on stack.</span></span>|  
  
 <span data-ttu-id="02415-1185">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1185">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1186">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1186">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1187">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1187">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="02415-1188">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1188">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1189">`conv.i8` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1189">The `conv.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1190">小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1190">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="02415-1191">将浮点值转换为 `F` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-1191">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="02415-1192">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1192">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="02415-1193">从 `float64` 转换到 `float32`时，精度可能会丢失。</span><span class="sxs-lookup"><span data-stu-id="02415-1193">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="02415-1194">如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。</span><span class="sxs-lookup"><span data-stu-id="02415-1194">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="02415-1195">如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。</span><span class="sxs-lookup"><span data-stu-id="02415-1195">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="02415-1196">如果结果小于 `int32`，则值将进行符号扩展以填充槽。</span><span class="sxs-lookup"><span data-stu-id="02415-1196">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="02415-1197">如果发生溢出，将浮点类型转换为整数，则返回的值是未指定的。</span><span class="sxs-lookup"><span data-stu-id="02415-1197">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="02415-1198">使用此字段时，不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1198">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="02415-1199">有关在结果类型无法正确表示结果值时将引发异常的等效说明，请参阅 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> 和 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>。</span><span class="sxs-lookup"><span data-stu-id="02415-1199">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="02415-1200">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.i8` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1200">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i8` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1201">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1201">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1202">将位于计算堆栈顶部的有符号值转换为有符号 <see langword="native int" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1202">Converts the signed value on top of the evaluation stack to signed <see langword="native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1203">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1203">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1204">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1204">Format</span></span>|<span data-ttu-id="02415-1205">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1205">Assembly Format</span></span>|<span data-ttu-id="02415-1206">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1206">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1207">D4</span><span class="sxs-lookup"><span data-stu-id="02415-1207">D4</span></span>|<span data-ttu-id="02415-1208">ovf。 i</span><span class="sxs-lookup"><span data-stu-id="02415-1208">conv.ovf.i</span></span>|<span data-ttu-id="02415-1209">转换为 `native int` （在堆栈上为 `native int`）并在溢出时引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1209">Convert to a `native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="02415-1210">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1210">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1211">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1211">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1212">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1212">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="02415-1213">如果发生溢出，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1213">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="02415-1214">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1214">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1215">`conv.ovf.i` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1215">The `conv.ovf.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1216">如果值太大或太小而无法由目标类型表示，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1216">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="02415-1217">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1217">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="02415-1218">请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1218">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="02415-1219">如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-1219"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-1220">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.i` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1220">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1221">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1221">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1222">将位于计算堆栈顶部的无符号值转换为有符号 <see langword="native int" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1222">Converts the unsigned value on top of the evaluation stack to signed <see langword="native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1223">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1223">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1224">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1224">Format</span></span>|<span data-ttu-id="02415-1225">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1225">Assembly Format</span></span>|<span data-ttu-id="02415-1226">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1226">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1227">8A</span><span class="sxs-lookup"><span data-stu-id="02415-1227">8A</span></span>|<span data-ttu-id="02415-1228">将 ovf</span><span class="sxs-lookup"><span data-stu-id="02415-1228">conv.ovf.i.un</span></span>|<span data-ttu-id="02415-1229">将无符号值转换为 `native int` （在堆栈上为 `native int`）并在溢出时引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1229">Converts an unsigned value to a `native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="02415-1230">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1230">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1231">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1231">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1232">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1232">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="02415-1233">如果发生溢出，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1233">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="02415-1234">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1234">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1235">`conv.ovf.i.un` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1235">The `conv.ovf.i.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1236">如果值太大或太小而无法由目标类型表示，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1236">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="02415-1237">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1237">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="02415-1238">请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1238">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="02415-1239">如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-1239"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-1240">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.i.un` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1240">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i.un` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1241">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1241">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1242">将位于计算堆栈顶部的有符号值转换为有符号的 <see langword="int8" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1242">Converts the signed value on top of the evaluation stack to signed <see langword="int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1243">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1243">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1244">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1244">Format</span></span>|<span data-ttu-id="02415-1245">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1245">Assembly Format</span></span>|<span data-ttu-id="02415-1246">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1246">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1247">B3</span><span class="sxs-lookup"><span data-stu-id="02415-1247">B3</span></span>|<span data-ttu-id="02415-1248">conv.ovf.i1</span><span class="sxs-lookup"><span data-stu-id="02415-1248">conv.ovf.i1</span></span>|<span data-ttu-id="02415-1249">转换为 `int8` （在堆栈上为 `int32`）并在溢出时引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1249">Convert to an `int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="02415-1250">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1250">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1251">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1251">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1252">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1252">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="02415-1253">如果发生溢出，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1253">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="02415-1254">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1254">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1255">`conv.ovf.i1` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1255">The `conv.ovf.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1256">如果值太大或太小而无法由目标类型表示，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1256">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="02415-1257">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1257">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="02415-1258">请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1258">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="02415-1259">如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-1259"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-1260">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.i1` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1260">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1261">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1261">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1262">将位于计算堆栈顶部的无符号值转换为有符号 <see langword="int8" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1262">Converts the unsigned value on top of the evaluation stack to signed <see langword="int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1263">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1263">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1264">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1264">Format</span></span>|<span data-ttu-id="02415-1265">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1265">Assembly Format</span></span>|<span data-ttu-id="02415-1266">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1266">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1267">82</span><span class="sxs-lookup"><span data-stu-id="02415-1267">82</span></span>|<span data-ttu-id="02415-1268">conv.ovf.i1.un</span><span class="sxs-lookup"><span data-stu-id="02415-1268">conv.ovf.i1.un</span></span>|<span data-ttu-id="02415-1269">将无符号值转换为 `int8` （在堆栈上为 `int32`）并在溢出时引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1269">Converts an unsigned value to an `int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="02415-1270">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1270">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1271">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1271">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1272">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1272">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="02415-1273">如果发生溢出，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1273">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="02415-1274">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1274">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1275">`conv.ovf.i1.un` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1275">The `conv.ovf.i1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1276">如果值太大或太小而无法由目标类型表示，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1276">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="02415-1277">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1277">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="02415-1278">请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1278">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="02415-1279">如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-1279"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-1280">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.i1.un` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1280">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1.un` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1281">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1281">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1282">将位于计算堆栈顶部的有符号值转换为有符号 <see langword="int16" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1282">Converts the signed value on top of the evaluation stack to signed <see langword="int16" /> and extending it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1283">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1283">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1284">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1284">Format</span></span>|<span data-ttu-id="02415-1285">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1285">Assembly Format</span></span>|<span data-ttu-id="02415-1286">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1286">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1287">B5</span><span class="sxs-lookup"><span data-stu-id="02415-1287">B5</span></span>|<span data-ttu-id="02415-1288">conv.ovf.i2</span><span class="sxs-lookup"><span data-stu-id="02415-1288">conv.ovf.i2</span></span>|<span data-ttu-id="02415-1289">转换为 `int16` （在堆栈上为 `int32`）并在溢出时引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1289">Convert to an `int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="02415-1290">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1290">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1291">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1291">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1292">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1292">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="02415-1293">如果发生溢出，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1293">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="02415-1294">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1294">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1295">`conv.ovf.i2` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1295">The `conv.ovf.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1296">如果值太大或太小而无法由目标类型表示，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1296">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="02415-1297">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1297">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="02415-1298">请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1298">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="02415-1299">如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-1299"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-1300">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.i2` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1300">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1301">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1301">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1302">将位于计算堆栈顶部的无符号值转换为有符号 <see langword="int16" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1302">Converts the unsigned value on top of the evaluation stack to signed <see langword="int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1303">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1303">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1304">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1304">Format</span></span>|<span data-ttu-id="02415-1305">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1305">Assembly Format</span></span>|<span data-ttu-id="02415-1306">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1306">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1307">83</span><span class="sxs-lookup"><span data-stu-id="02415-1307">83</span></span>|<span data-ttu-id="02415-1308">conv.ovf.i2.un</span><span class="sxs-lookup"><span data-stu-id="02415-1308">conv.ovf.i2.un</span></span>|<span data-ttu-id="02415-1309">将无符号值转换为 `int16` （在堆栈上为 `int32`）并在溢出时引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1309">Converts an unsigned value to an `int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="02415-1310">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1310">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1311">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1311">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1312">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1312">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="02415-1313">如果发生溢出，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1313">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="02415-1314">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1314">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1315">`conv.ovf.i2.un` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1315">The `conv.ovf.i2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1316">如果值太大或太小而无法由目标类型表示，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1316">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="02415-1317">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1317">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="02415-1318">请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1318">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="02415-1319">如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-1319"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-1320">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.i2.un` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1320">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2.un` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1321">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1321">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1322">将位于计算堆栈顶部的有符号值转换为有符号 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1322">Converts the signed value on top of the evaluation stack to signed <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1323">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1323">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1324">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1324">Format</span></span>|<span data-ttu-id="02415-1325">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1325">Assembly Format</span></span>|<span data-ttu-id="02415-1326">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1326">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1327">B7</span><span class="sxs-lookup"><span data-stu-id="02415-1327">B7</span></span>|<span data-ttu-id="02415-1328">conv.ovf.i4</span><span class="sxs-lookup"><span data-stu-id="02415-1328">conv.ovf.i4</span></span>|<span data-ttu-id="02415-1329">转换为 `int32` （在堆栈上为 `int32`）并在溢出时引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1329">Convert to an `int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="02415-1330">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1330">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1331">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1331">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1332">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1332">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="02415-1333">如果发生溢出，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1333">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="02415-1334">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1334">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1335">`conv.ovf.i4` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1335">The `conv.ovf.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1336">如果值太大或太小而无法由目标类型表示，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1336">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="02415-1337">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1337">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="02415-1338">请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1338">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="02415-1339">如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-1339"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-1340">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.i4` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1340">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1341">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1341">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1342">将位于计算堆栈顶部的无符号值转换为有符号 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1342">Converts the unsigned value on top of the evaluation stack to signed <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1343">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1343">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1344">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1344">Format</span></span>|<span data-ttu-id="02415-1345">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1345">Assembly Format</span></span>|<span data-ttu-id="02415-1346">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1346">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1347">84</span><span class="sxs-lookup"><span data-stu-id="02415-1347">84</span></span>|<span data-ttu-id="02415-1348">conv.ovf.i4.un</span><span class="sxs-lookup"><span data-stu-id="02415-1348">conv.ovf.i4.un</span></span>|<span data-ttu-id="02415-1349">将无符号值转换为 `int32` （在堆栈上为 `int32`）并在溢出时引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1349">Converts an unsigned value to an `int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="02415-1350">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1350">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1351">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1351">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1352">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1352">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="02415-1353">如果发生溢出，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1353">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="02415-1354">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1354">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1355">`conv.ovf.i4.un` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1355">The `conv.ovf.i4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1356">如果值太大或太小而无法由目标类型表示，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1356">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="02415-1357">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1357">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="02415-1358">请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1358">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="02415-1359">如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-1359"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-1360">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.i4.un` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1360">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4.un` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1361">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1361">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1362">将位于计算堆栈顶部的有符号值转换为有符号 <see langword="int64" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1362">Converts the signed value on top of the evaluation stack to signed <see langword="int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1363">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1363">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1364">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1364">Format</span></span>|<span data-ttu-id="02415-1365">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1365">Assembly Format</span></span>|<span data-ttu-id="02415-1366">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1366">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1367">B9</span><span class="sxs-lookup"><span data-stu-id="02415-1367">B9</span></span>|<span data-ttu-id="02415-1368">conv.ovf.i8</span><span class="sxs-lookup"><span data-stu-id="02415-1368">conv.ovf.i8</span></span>|<span data-ttu-id="02415-1369">转换为 `int64` （在堆栈上为 `int64`）并在溢出时引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1369">Convert to an `int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="02415-1370">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1370">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1371">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1371">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1372">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1372">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="02415-1373">如果发生溢出，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1373">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="02415-1374">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1374">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1375">`conv.ovf.i8` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1375">The `conv.ovf.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1376">如果值太大或太小而无法由目标类型表示，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1376">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="02415-1377">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1377">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="02415-1378">请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1378">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="02415-1379">如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-1379"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-1380">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.i8` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1380">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1381">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1381">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1382">将位于计算堆栈顶部的无符号值转换为有符号 <see langword="int64" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1382">Converts the unsigned value on top of the evaluation stack to signed <see langword="int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1383">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1383">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1384">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1384">Format</span></span>|<span data-ttu-id="02415-1385">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1385">Assembly Format</span></span>|<span data-ttu-id="02415-1386">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1386">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1387">85</span><span class="sxs-lookup"><span data-stu-id="02415-1387">85</span></span>|<span data-ttu-id="02415-1388">conv.ovf.i8.un</span><span class="sxs-lookup"><span data-stu-id="02415-1388">conv.ovf.i8.un</span></span>|<span data-ttu-id="02415-1389">将无符号值转换为 `int64` （在堆栈上为 `int64`）并在溢出时引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1389">Converts an unsigned value to an `int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="02415-1390">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1390">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1391">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1391">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1392">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1392">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="02415-1393">如果发生溢出，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1393">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="02415-1394">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1394">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1395">`conv.ovf.i8.un` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1395">The `conv.ovf.i8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1396">如果值太大或太小而无法由目标类型表示，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1396">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="02415-1397">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1397">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="02415-1398">请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1398">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="02415-1399">如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-1399"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-1400">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.i8.un` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1400">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8.un` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1401">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1401">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1402">将位于计算堆栈顶部的有符号值转换为 <see langword="unsigned native int" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1402">Converts the signed value on top of the evaluation stack to <see langword="unsigned native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1403">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1403">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1404">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1404">Format</span></span>|<span data-ttu-id="02415-1405">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1405">Assembly Format</span></span>|<span data-ttu-id="02415-1406">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1406">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1407">D5</span><span class="sxs-lookup"><span data-stu-id="02415-1407">D5</span></span>|<span data-ttu-id="02415-1408">conv.ovf.u</span><span class="sxs-lookup"><span data-stu-id="02415-1408">conv.ovf.u</span></span>|<span data-ttu-id="02415-1409">转换为 `unsigned native int` （在堆栈上为 `native int`）并在溢出时引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1409">Convert to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="02415-1410">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1410">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1411">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1411">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1412">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1412">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="02415-1413">如果发生溢出，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1413">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="02415-1414">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1414">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1415">`conv.ovf.u` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1415">The `conv.ovf.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1416">如果值太大或太小而无法由目标类型表示，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1416">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="02415-1417">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1417">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="02415-1418">请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1418">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="02415-1419">如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-1419"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-1420">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.u` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1420">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1421">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1421">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1422">将位于计算堆栈顶部的无符号值转换为 <see langword="unsigned native int" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1422">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1423">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1423">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1424">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1424">Format</span></span>|<span data-ttu-id="02415-1425">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1425">Assembly Format</span></span>|<span data-ttu-id="02415-1426">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1426">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1427">8B</span><span class="sxs-lookup"><span data-stu-id="02415-1427">8B</span></span>|<span data-ttu-id="02415-1428">conv.ovf.u.un</span><span class="sxs-lookup"><span data-stu-id="02415-1428">conv.ovf.u.un</span></span>|<span data-ttu-id="02415-1429">将无符号值转换为 `unsigned native int` （在堆栈上为 `native int`），并在溢出时引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1429">Converts un unsigned value to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="02415-1430">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1430">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1431">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1431">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1432">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1432">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="02415-1433">如果发生溢出，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1433">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="02415-1434">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1434">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1435">`conv.ovf.u.un` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1435">The `conv.ovf.u.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1436">如果值太大或太小而无法由目标类型表示，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1436">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="02415-1437">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1437">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="02415-1438">请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1438">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="02415-1439">如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-1439"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-1440">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.uvf.u.un` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1440">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.uvf.u.un` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1441">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1441">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1442">将位于计算堆栈顶部的有符号值转换为 <see langword="unsigned int8" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1442">Converts the signed value on top of the evaluation stack to <see langword="unsigned int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1443">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1443">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1444">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1444">Format</span></span>|<span data-ttu-id="02415-1445">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1445">Assembly Format</span></span>|<span data-ttu-id="02415-1446">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1446">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1447">B4</span><span class="sxs-lookup"><span data-stu-id="02415-1447">B4</span></span>|<span data-ttu-id="02415-1448">conv.ovf.u1</span><span class="sxs-lookup"><span data-stu-id="02415-1448">conv.ovf.u1</span></span>|<span data-ttu-id="02415-1449">转换为 `unsigned int8` （在堆栈上为 `int32`）并在溢出时引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1449">Convert to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="02415-1450">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1450">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1451">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1451">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1452">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1452">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="02415-1453">如果发生溢出，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1453">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="02415-1454">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1454">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1455">`conv.ovf.u1` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1455">The `conv.ovf.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1456">如果值太大或太小而无法由目标类型表示，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1456">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="02415-1457">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1457">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="02415-1458">请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1458">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="02415-1459">如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-1459"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-1460">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.u1` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1460">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1461">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1461">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1462">将位于计算堆栈顶部的无符号值转换为 <see langword="unsigned int8" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1462">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1463">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1463">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1464">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1464">Format</span></span>|<span data-ttu-id="02415-1465">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1465">Assembly Format</span></span>|<span data-ttu-id="02415-1466">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1466">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1467">86</span><span class="sxs-lookup"><span data-stu-id="02415-1467">86</span></span>|<span data-ttu-id="02415-1468">conv.ovf.u1.un</span><span class="sxs-lookup"><span data-stu-id="02415-1468">conv.ovf.u1.un</span></span>|<span data-ttu-id="02415-1469">将无符号值转换为 `unsigned int8` （在堆栈上为 `int32`）并在溢出时引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1469">Converts an unsigned value to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="02415-1470">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1470">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1471">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1471">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1472">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1472">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="02415-1473">如果发生溢出，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1473">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="02415-1474">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1474">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1475">`conv.ovf.u1.un` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1475">The `conv.ovf.u1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1476">如果值太大或太小而无法由目标类型表示，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1476">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="02415-1477">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1477">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="02415-1478">请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1478">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="02415-1479">如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-1479"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-1480">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.u1.un` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1.un` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1481">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1481">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1482">将位于计算堆栈顶部的有符号值转换为 <see langword="unsigned int16" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1482">Converts the signed value on top of the evaluation stack to <see langword="unsigned int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1483">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1484">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1484">Format</span></span>|<span data-ttu-id="02415-1485">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1485">Assembly Format</span></span>|<span data-ttu-id="02415-1486">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1487">B6</span><span class="sxs-lookup"><span data-stu-id="02415-1487">B6</span></span>|<span data-ttu-id="02415-1488">conv.ovf.u2</span><span class="sxs-lookup"><span data-stu-id="02415-1488">conv.ovf.u2</span></span>|<span data-ttu-id="02415-1489">转换为 `unsigned int16` （在堆栈上为 `int32`）并在溢出时引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1489">Convert to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="02415-1490">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1491">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1491">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1492">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1492">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="02415-1493">如果发生溢出，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1493">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="02415-1494">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1494">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1495">`conv.ovf.u2` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1495">The `conv.ovf.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1496">如果值太大或太小而无法由目标类型表示，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1496">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="02415-1497">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1497">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="02415-1498">请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1498">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="02415-1499">如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-1499"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-1500">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.u2` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1500">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1501">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1501">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1502">将位于计算堆栈顶部的无符号值转换为 <see langword="unsigned int16" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1502">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1503">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1503">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1504">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1504">Format</span></span>|<span data-ttu-id="02415-1505">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1505">Assembly Format</span></span>|<span data-ttu-id="02415-1506">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1506">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1507">87</span><span class="sxs-lookup"><span data-stu-id="02415-1507">87</span></span>|<span data-ttu-id="02415-1508">conv.ovf.u2.un</span><span class="sxs-lookup"><span data-stu-id="02415-1508">conv.ovf.u2.un</span></span>|<span data-ttu-id="02415-1509">将无符号值转换为 `unsigned int16` （在堆栈上为 `int32`）并在溢出时引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1509">Converts an unsigned value to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="02415-1510">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1510">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1511">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1511">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1512">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1512">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="02415-1513">如果发生溢出，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1513">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="02415-1514">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1514">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1515">`conv.ovf.u2.un` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1515">The `conv.ovf.u2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1516">如果值太大或太小而无法由目标类型表示，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1516">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="02415-1517">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1517">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="02415-1518">请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1518">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="02415-1519">如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-1519"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-1520">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.u2.un` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1520">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2.un` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1521">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1521">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1522">将位于计算堆栈顶部的有符号值转换为 <see langword="unsigned int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1522">Converts the signed value on top of the evaluation stack to <see langword="unsigned int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1523">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1523">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1524">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1524">Format</span></span>|<span data-ttu-id="02415-1525">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1525">Assembly Format</span></span>|<span data-ttu-id="02415-1526">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1526">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1527">B8</span><span class="sxs-lookup"><span data-stu-id="02415-1527">B8</span></span>|<span data-ttu-id="02415-1528">conv.ovf.u4</span><span class="sxs-lookup"><span data-stu-id="02415-1528">conv.ovf.u4</span></span>|<span data-ttu-id="02415-1529">转换为 `unsigned int32` （在堆栈上为 `int32`）并在溢出时引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1529">Convert to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="02415-1530">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1530">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1531">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1531">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1532">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1532">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="02415-1533">如果发生溢出，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1533">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="02415-1534">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1534">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1535">`conv.ovf.u4` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1535">The `conv.ovf.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1536">如果值太大或太小而无法由目标类型表示，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1536">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="02415-1537">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1537">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="02415-1538">请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1538">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="02415-1539">如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-1539"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-1540">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.u4` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1540">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1541">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1541">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1542">将位于计算堆栈顶部的无符号值转换为 <see langword="unsigned int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1542">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1543">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1543">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1544">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1544">Format</span></span>|<span data-ttu-id="02415-1545">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1545">Assembly Format</span></span>|<span data-ttu-id="02415-1546">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1546">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1547">88</span><span class="sxs-lookup"><span data-stu-id="02415-1547">88</span></span>|<span data-ttu-id="02415-1548">conv.ovf.u4.un</span><span class="sxs-lookup"><span data-stu-id="02415-1548">conv.ovf.u4.un</span></span>|<span data-ttu-id="02415-1549">将无符号值转换为 `unsigned int32` （在堆栈上为 `int32`）并在溢出时引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1549">Converts an unsigned value to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="02415-1550">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1550">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1551">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1551">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1552">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1552">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="02415-1553">如果发生溢出，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1553">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="02415-1554">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1554">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1555">`conv.ovf.u4.un` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1555">The `conv.ovf.u4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1556">如果值太大或太小而无法由目标类型表示，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1556">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="02415-1557">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1557">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="02415-1558">请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1558">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="02415-1559">如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-1559"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-1560">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.u4.un` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1560">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4.un` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1561">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1561">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1562">将位于计算堆栈顶部的有符号值转换为 <see langword="unsigned int64" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1562">Converts the signed value on top of the evaluation stack to <see langword="unsigned int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1563">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1563">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1564">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1564">Format</span></span>|<span data-ttu-id="02415-1565">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1565">Assembly Format</span></span>|<span data-ttu-id="02415-1566">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1566">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1567">BA</span><span class="sxs-lookup"><span data-stu-id="02415-1567">BA</span></span>|<span data-ttu-id="02415-1568">conv.ovf.u8</span><span class="sxs-lookup"><span data-stu-id="02415-1568">conv.ovf.u8</span></span>|<span data-ttu-id="02415-1569">转换为 `unsigned int64` （在堆栈上为 `int64`）并在溢出时引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1569">Convert to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="02415-1570">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1570">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1571">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1571">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1572">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1572">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="02415-1573">如果发生溢出，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1573">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="02415-1574">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1574">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1575">`conv.ovf.u8` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1575">The `conv.ovf.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1576">如果值太大或太小而无法由目标类型表示，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1576">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="02415-1577">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1577">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="02415-1578">请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1578">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="02415-1579">如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-1579"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-1580">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.u8` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1580">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1581">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1581">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1582">将位于计算堆栈顶部的无符号值转换为 <see langword="unsigned int64" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1582">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1583">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1583">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1584">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1584">Format</span></span>|<span data-ttu-id="02415-1585">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1585">Assembly Format</span></span>|<span data-ttu-id="02415-1586">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1586">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1587">89</span><span class="sxs-lookup"><span data-stu-id="02415-1587">89</span></span>|<span data-ttu-id="02415-1588">conv.ovf.u8.un</span><span class="sxs-lookup"><span data-stu-id="02415-1588">conv.ovf.u8.un</span></span>|<span data-ttu-id="02415-1589">将无符号值转换为 `unsigned int64` （在堆栈上为 `int64`）并在溢出时引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1589">Converts an unsigned value to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="02415-1590">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1590">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1591">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1591">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1592">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1592">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="02415-1593">如果发生溢出，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1593">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="02415-1594">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1594">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1595">`conv.ovf.u8.un` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值放在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1595">The `conv.ovf.u8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1596">如果值太大或太小而无法由目标类型表示，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1596">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="02415-1597">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1597">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="02415-1598">请注意，小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.ovf.i` 或 `conv.ovf.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1598">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="02415-1599">如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-1599"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-1600">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.ovf.u8.un` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1600">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8.un` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1601">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1601">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1602">将位于计算堆栈顶部的无符号整数值转换为 <see langword="float32" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1602">Converts the unsigned integer value on top of the evaluation stack to <see langword="float32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1603">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1603">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1604">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1604">Format</span></span>|<span data-ttu-id="02415-1605">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1605">Assembly Format</span></span>|<span data-ttu-id="02415-1606">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1606">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1607">76</span><span class="sxs-lookup"><span data-stu-id="02415-1607">76</span></span>|<span data-ttu-id="02415-1608">约定</span><span class="sxs-lookup"><span data-stu-id="02415-1608">conv.r.un</span></span>|<span data-ttu-id="02415-1609">将无符号整数转换为浮点，并将 `F` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1609">Convert unsigned integer to floating-point, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="02415-1610">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1610">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1611">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1611">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1612">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1612">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="02415-1613">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1613">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1614">`conv.r.un` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1614">The `conv.r.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1615">小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1615">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="02415-1616">将浮点值转换为 `F` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-1616">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="02415-1617">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1617">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="02415-1618">从 `float64` 转换到 `float32`时，精度可能会丢失。</span><span class="sxs-lookup"><span data-stu-id="02415-1618">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="02415-1619">如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。</span><span class="sxs-lookup"><span data-stu-id="02415-1619">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="02415-1620">如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。</span><span class="sxs-lookup"><span data-stu-id="02415-1620">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="02415-1621">如果结果小于 `int32`，则值将进行符号扩展以填充槽。</span><span class="sxs-lookup"><span data-stu-id="02415-1621">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="02415-1622">如果在将浮点类型转换为整数时出现溢出，则不指定返回的 `result`。</span><span class="sxs-lookup"><span data-stu-id="02415-1622">If overflow occurs converting a floating-point type to an integer the `result` returned is unspecified.</span></span> <span data-ttu-id="02415-1623">`conv.r.un` 操作从堆栈中提取一个整数，将其解释为无符号的整数，并将其替换为浮点数以表示整数：无论是 `float32`，只要这种宽度足以表示整数而不丢失精度，或者 `float64`。</span><span class="sxs-lookup"><span data-stu-id="02415-1623">The `conv.r.un` operation takes an integer off the stack, interprets it as unsigned, and replaces it with a floating-point number to represent the integer: either a `float32`, if this is wide enough to represent the integer without loss of precision, or else a `float64`.</span></span>  
  
 <span data-ttu-id="02415-1624">使用此字段时，不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1624">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="02415-1625">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.r.un` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1625">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r.un` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1626">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1626">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1627">将位于计算堆栈顶部的值转换为 <see langword="float32" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1627">Converts the value on top of the evaluation stack to <see langword="float32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1628">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1628">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1629">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1629">Format</span></span>|<span data-ttu-id="02415-1630">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1630">Assembly Format</span></span>|<span data-ttu-id="02415-1631">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1631">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1632">6B</span><span class="sxs-lookup"><span data-stu-id="02415-1632">6B</span></span>|<span data-ttu-id="02415-1633">conv.r4</span><span class="sxs-lookup"><span data-stu-id="02415-1633">conv.r4</span></span>|<span data-ttu-id="02415-1634">转换为 `float32`，将 `F` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1634">Convert to `float32`, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="02415-1635">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1635">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1636">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1636">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1637">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1637">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="02415-1638">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1638">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1639">`conv.r4` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1639">The `conv.r4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1640">小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1640">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="02415-1641">将浮点值转换为 `F` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-1641">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="02415-1642">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1642">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="02415-1643">从 `float64` 转换到 `float32`时，精度可能会丢失。</span><span class="sxs-lookup"><span data-stu-id="02415-1643">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="02415-1644">如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。</span><span class="sxs-lookup"><span data-stu-id="02415-1644">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="02415-1645">如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。</span><span class="sxs-lookup"><span data-stu-id="02415-1645">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="02415-1646">如果结果小于 `int32`，则值将进行符号扩展以填充槽。</span><span class="sxs-lookup"><span data-stu-id="02415-1646">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="02415-1647">如果发生溢出，将浮点类型转换为整数，则返回的值是未指定的。</span><span class="sxs-lookup"><span data-stu-id="02415-1647">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="02415-1648">使用此字段时，不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1648">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="02415-1649">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.r4` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1649">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r4` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1650">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1650">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1651">将位于计算堆栈顶部的值转换为 <see langword="float64" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1651">Converts the value on top of the evaluation stack to <see langword="float64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1652">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1652">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1653">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1653">Format</span></span>|<span data-ttu-id="02415-1654">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1654">Assembly Format</span></span>|<span data-ttu-id="02415-1655">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1655">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1656">6C</span><span class="sxs-lookup"><span data-stu-id="02415-1656">6C</span></span>|<span data-ttu-id="02415-1657">conv.r8</span><span class="sxs-lookup"><span data-stu-id="02415-1657">conv.r8</span></span>|<span data-ttu-id="02415-1658">转换为 `float64`，将 `F` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1658">Convert to `float64`, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="02415-1659">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1659">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1660">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1660">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1661">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1661">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="02415-1662">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1662">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1663">`conv.r8` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1663">The `conv.r8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1664">小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1664">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="02415-1665">将浮点值转换为 `F` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-1665">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="02415-1666">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1666">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="02415-1667">从 `float64` 转换到 `float32`时，精度可能会丢失。</span><span class="sxs-lookup"><span data-stu-id="02415-1667">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="02415-1668">如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。</span><span class="sxs-lookup"><span data-stu-id="02415-1668">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="02415-1669">如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。</span><span class="sxs-lookup"><span data-stu-id="02415-1669">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="02415-1670">如果结果小于 `int32`，则值将进行符号扩展以填充槽。</span><span class="sxs-lookup"><span data-stu-id="02415-1670">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="02415-1671">如果发生溢出，将浮点类型转换为整数，则返回的值是未指定的。</span><span class="sxs-lookup"><span data-stu-id="02415-1671">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="02415-1672">使用此字段时，不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1672">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="02415-1673">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.r8` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1673">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r8` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1674">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1674">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1675">将位于计算堆栈顶部的值转换为 <see langword="unsigned native int" />，然后将其扩展为 <see langword="native int" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1675">Converts the value on top of the evaluation stack to <see langword="unsigned native int" />, and extends it to <see langword="native int" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1676">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1676">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1677">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1677">Format</span></span>|<span data-ttu-id="02415-1678">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1678">Assembly Format</span></span>|<span data-ttu-id="02415-1679">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1679">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1680">E0</span><span class="sxs-lookup"><span data-stu-id="02415-1680">E0</span></span>|<span data-ttu-id="02415-1681">约定</span><span class="sxs-lookup"><span data-stu-id="02415-1681">conv.u</span></span>|<span data-ttu-id="02415-1682">转换为 `unsigned native int`，将 `native int` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1682">Convert to `unsigned native int`, pushing `native int` on stack.</span></span>|  
  
 <span data-ttu-id="02415-1683">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1683">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1684">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1684">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1685">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1685">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="02415-1686">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1686">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1687">`conv.u` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1687">The `conv.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1688">小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1688">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="02415-1689">将浮点值转换为 `F` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-1689">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="02415-1690">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1690">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="02415-1691">从 `float64` 转换到 `float32`时，精度可能会丢失。</span><span class="sxs-lookup"><span data-stu-id="02415-1691">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="02415-1692">如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。</span><span class="sxs-lookup"><span data-stu-id="02415-1692">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="02415-1693">如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。</span><span class="sxs-lookup"><span data-stu-id="02415-1693">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="02415-1694">如果结果小于 `int32`，则值将进行符号扩展以填充槽。</span><span class="sxs-lookup"><span data-stu-id="02415-1694">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="02415-1695">如果发生溢出，将浮点类型转换为整数，则返回的值是未指定的。</span><span class="sxs-lookup"><span data-stu-id="02415-1695">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="02415-1696">使用此字段时，不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1696">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="02415-1697">有关在结果类型无法正确表示结果值时将引发异常的等效说明，请参阅 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> 和 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>。</span><span class="sxs-lookup"><span data-stu-id="02415-1697">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="02415-1698">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.u` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1698">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1699">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1699">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1700">将位于计算堆栈顶部的值转换为 <see langword="unsigned int8" />，然后将其扩展为 <see langword="int32" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1700">Converts the value on top of the evaluation stack to <see langword="unsigned int8" />, and extends it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1701">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1701">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1702">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1702">Format</span></span>|<span data-ttu-id="02415-1703">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1703">Assembly Format</span></span>|<span data-ttu-id="02415-1704">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1704">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1705">D2</span><span class="sxs-lookup"><span data-stu-id="02415-1705">D2</span></span>|<span data-ttu-id="02415-1706">约定</span><span class="sxs-lookup"><span data-stu-id="02415-1706">conv.u1</span></span>|<span data-ttu-id="02415-1707">转换为 `int8`，将 `int32` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1707">Convert to `int8`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="02415-1708">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1708">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1709">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1709">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1710">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1710">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="02415-1711">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1711">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1712">`conv.u1` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1712">The `conv.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1713">小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1713">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="02415-1714">将浮点值转换为 `F` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-1714">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="02415-1715">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1715">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="02415-1716">从 `float64` 转换到 `float32`时，精度可能会丢失。</span><span class="sxs-lookup"><span data-stu-id="02415-1716">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="02415-1717">如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。</span><span class="sxs-lookup"><span data-stu-id="02415-1717">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="02415-1718">如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。</span><span class="sxs-lookup"><span data-stu-id="02415-1718">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="02415-1719">如果结果小于 `int32`，则值将进行符号扩展以填充槽。</span><span class="sxs-lookup"><span data-stu-id="02415-1719">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="02415-1720">如果发生溢出，将浮点类型转换为整数，则返回的值是未指定的。</span><span class="sxs-lookup"><span data-stu-id="02415-1720">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="02415-1721">使用此字段时，不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1721">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="02415-1722">有关在结果类型无法正确表示结果值时将引发异常的等效说明，请参阅 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> 和 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>。</span><span class="sxs-lookup"><span data-stu-id="02415-1722">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="02415-1723">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.u1` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1723">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u1` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1724">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1724">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1725">将位于计算堆栈顶部的值转换为 <see langword="unsigned int16" />，然后将其扩展为 <see langword="int32" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1725">Converts the value on top of the evaluation stack to <see langword="unsigned int16" />, and extends it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1726">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1726">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1727">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1727">Format</span></span>|<span data-ttu-id="02415-1728">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1728">Assembly Format</span></span>|<span data-ttu-id="02415-1729">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1729">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1730">D1</span><span class="sxs-lookup"><span data-stu-id="02415-1730">D1</span></span>|<span data-ttu-id="02415-1731">约定</span><span class="sxs-lookup"><span data-stu-id="02415-1731">conv.u2</span></span>|<span data-ttu-id="02415-1732">转换为 `int16`，将 `int32` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1732">Convert to `int16`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="02415-1733">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1733">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1734">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1734">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1735">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1735">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="02415-1736">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1736">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1737">`conv.u2` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1737">The `conv.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1738">小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1738">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="02415-1739">将浮点值转换为 `F` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-1739">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="02415-1740">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1740">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="02415-1741">从 `float64` 转换到 `float32`时，精度可能会丢失。</span><span class="sxs-lookup"><span data-stu-id="02415-1741">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="02415-1742">如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。</span><span class="sxs-lookup"><span data-stu-id="02415-1742">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="02415-1743">如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。</span><span class="sxs-lookup"><span data-stu-id="02415-1743">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="02415-1744">如果结果小于 `int32`，则值将进行符号扩展以填充槽。</span><span class="sxs-lookup"><span data-stu-id="02415-1744">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="02415-1745">如果发生溢出，将浮点类型转换为整数，则返回的值是未指定的。</span><span class="sxs-lookup"><span data-stu-id="02415-1745">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="02415-1746">使用此字段时，不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1746">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="02415-1747">有关在结果类型无法正确表示结果值时将引发异常的等效说明，请参阅 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> 和 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>。</span><span class="sxs-lookup"><span data-stu-id="02415-1747">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="02415-1748">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.u2` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1748">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u2` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1749">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1749">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1750">将位于计算堆栈顶部的值转换为 <see langword="unsigned int32" />，然后将其扩展为 <see langword="int32" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1750">Converts the value on top of the evaluation stack to <see langword="unsigned int32" />, and extends it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1751">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1751">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1752">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1752">Format</span></span>|<span data-ttu-id="02415-1753">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1753">Assembly Format</span></span>|<span data-ttu-id="02415-1754">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1754">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1755">6D</span><span class="sxs-lookup"><span data-stu-id="02415-1755">6D</span></span>|<span data-ttu-id="02415-1756">u4</span><span class="sxs-lookup"><span data-stu-id="02415-1756">conv.u4</span></span>|<span data-ttu-id="02415-1757">转换为 `unsigned int32`，将 `int32` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1757">Convert to `unsigned int32`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="02415-1758">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1758">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1759">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1759">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1760">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1760">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="02415-1761">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1761">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1762">`conv.u4` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1762">The `conv.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1763">小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1763">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="02415-1764">将浮点值转换为 `F` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-1764">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="02415-1765">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1765">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="02415-1766">从 `float64` 转换到 `float32`时，精度可能会丢失。</span><span class="sxs-lookup"><span data-stu-id="02415-1766">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="02415-1767">如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。</span><span class="sxs-lookup"><span data-stu-id="02415-1767">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="02415-1768">如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。</span><span class="sxs-lookup"><span data-stu-id="02415-1768">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="02415-1769">如果结果小于 `int32`，则值将进行符号扩展以填充槽。</span><span class="sxs-lookup"><span data-stu-id="02415-1769">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="02415-1770">如果发生溢出，将浮点类型转换为整数，则返回的值是未指定的。</span><span class="sxs-lookup"><span data-stu-id="02415-1770">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="02415-1771">使用此字段时，不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1771">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="02415-1772">有关在结果类型无法正确表示结果值时将引发异常的等效说明，请参阅 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> 和 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>。</span><span class="sxs-lookup"><span data-stu-id="02415-1772">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="02415-1773">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.u4` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1773">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u4` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1774">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1774">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1775">将位于计算堆栈顶部的值转换为 <see langword="unsigned int64" />，然后将其扩展为 <see langword="int64" />。</span><span class="sxs-lookup"><span data-stu-id="02415-1775">Converts the value on top of the evaluation stack to <see langword="unsigned int64" />, and extends it to <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1776">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1776">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1777">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1777">Format</span></span>|<span data-ttu-id="02415-1778">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1778">Assembly Format</span></span>|<span data-ttu-id="02415-1779">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1779">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1780">6E</span><span class="sxs-lookup"><span data-stu-id="02415-1780">6E</span></span>|<span data-ttu-id="02415-1781">u8</span><span class="sxs-lookup"><span data-stu-id="02415-1781">conv.u8</span></span>|<span data-ttu-id="02415-1782">转换为 `int64`，将 `int64` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1782">Convert to `int64`, pushing `int64` on stack.</span></span>|  
  
 <span data-ttu-id="02415-1783">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1783">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1784">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1784">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1785">从堆栈中弹出 `value`，并尝试执行转换操作。</span><span class="sxs-lookup"><span data-stu-id="02415-1785">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="02415-1786">如果转换成功，则将结果值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1786">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1787">`conv.u8` opcode 将堆栈顶部的 `value` 转换为操作码中指定的类型，并将转换后的值保留在堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1787">The `conv.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="02415-1788">小于4个字节的整数值将在加载到计算堆栈时被扩展到 `int32` （除非使用 `conv.i` 或 `conv.u`，在这种情况下，结果也是 `native int`的）。</span><span class="sxs-lookup"><span data-stu-id="02415-1788">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="02415-1789">将浮点值转换为 `F` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-1789">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="02415-1790">从浮点数到整数值的转换会将数字截断到零。</span><span class="sxs-lookup"><span data-stu-id="02415-1790">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="02415-1791">从 `float64` 转换到 `float32`时，精度可能会丢失。</span><span class="sxs-lookup"><span data-stu-id="02415-1791">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="02415-1792">如果 `value` 太大而无法容纳在 `float32 (F)`中，则返回正无穷（如果 `value` 为正）或负无穷（如果 `value` 为负数）。</span><span class="sxs-lookup"><span data-stu-id="02415-1792">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="02415-1793">如果在将一个整数类型转换为另一个整数类型时发生溢出，则会截断高序位。</span><span class="sxs-lookup"><span data-stu-id="02415-1793">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="02415-1794">如果结果小于 `int32`，则值将进行符号扩展以填充槽。</span><span class="sxs-lookup"><span data-stu-id="02415-1794">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="02415-1795">如果发生溢出，将浮点类型转换为整数，则返回的值是未指定的。</span><span class="sxs-lookup"><span data-stu-id="02415-1795">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="02415-1796">使用此字段时，不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-1796">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="02415-1797">有关在结果类型无法正确表示结果值时将引发异常的等效说明，请参阅 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> 和 <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>。</span><span class="sxs-lookup"><span data-stu-id="02415-1797">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="02415-1798">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `conv.u8` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1798">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u8` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1799">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1799">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1800">将指定数目的字节从源地址复制到目标地址。</span><span class="sxs-lookup"><span data-stu-id="02415-1800">Copies a specified number bytes from a source address to a destination address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1801">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1801">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1802">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1802">Format</span></span>|<span data-ttu-id="02415-1803">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1803">Assembly Format</span></span>|<span data-ttu-id="02415-1804">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1804">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1805">FE 17</span><span class="sxs-lookup"><span data-stu-id="02415-1805">FE 17</span></span>|<span data-ttu-id="02415-1806">cpblk</span><span class="sxs-lookup"><span data-stu-id="02415-1806">cpblk</span></span>|<span data-ttu-id="02415-1807">将数据从一个内存块复制到另一个内存块。</span><span class="sxs-lookup"><span data-stu-id="02415-1807">Copy data from one memory block to another.</span></span>|  
  
 <span data-ttu-id="02415-1808">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1808">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1809">目标地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1809">The destination address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1810">源地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1810">The source address is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-1811">要复制的字节数将被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1811">The number of bytes to copy is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="02415-1812">从堆栈中弹出的字节数、源地址和目标地址;指定的字节数从源地址复制到目标地址。</span><span class="sxs-lookup"><span data-stu-id="02415-1812">The number of bytes, the source address, and the destination address are popped from the stack; the specified number of bytes are copied from the source address to the destination address.</span></span>  
  
 <span data-ttu-id="02415-1813">`cpblk` 指令将字节数（类型 `unsigned int32`）从源地址（类型为 `*`、`native int`或 `&`）复制到目标地址（类型为 `*`、`native int`或 `&`）。</span><span class="sxs-lookup"><span data-stu-id="02415-1813">The `cpblk` instruction copies a number (type `unsigned int32`) of bytes from a source address (of type `*`, `native int`, or `&`) to a destination address (of type `*`, `native int`, or `&`).</span></span> <span data-ttu-id="02415-1814">如果源区域和目标区域重叠，则未指定 `cpblk` 的行为。</span><span class="sxs-lookup"><span data-stu-id="02415-1814">The behavior of `cpblk` is unspecified if the source and destination areas overlap.</span></span>  
  
 <span data-ttu-id="02415-1815">`cpblk` 假设源和目标均与计算机的自然大小对齐。</span><span class="sxs-lookup"><span data-stu-id="02415-1815">`cpblk` assumes that both the source and destination addressed are aligned to the natural size of the machine.</span></span> <span data-ttu-id="02415-1816">`cpblk` 指令前面可以紧跟 `unaligned.<prefix>` 指令，以指示源或目标是不对齐的。</span><span class="sxs-lookup"><span data-stu-id="02415-1816">The `cpblk` instruction can be immediately preceded by the `unaligned.<prefix>` instruction to indicate that either the source or the destination is unaligned.</span></span>  
  
 <span data-ttu-id="02415-1817">`cpblk` 指令的操作可以通过紧挨着 <xref:System.Reflection.Emit.OpCodes.Volatile> 或 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀指令来更改。</span><span class="sxs-lookup"><span data-stu-id="02415-1817">The operation of the `cpblk` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="02415-1818">如果检测到无效地址，则可能会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-1818"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="02415-1819">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `cpblk` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1819">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpblk` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1820">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1820">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1821">将位于对象（<see langword="&amp;" />、<see langword="*" /> 或 <see langword="native int" /> 类型）地址的值类型复制到目标对象（<see langword="&amp;" />、<see langword="*" /> 或 <see langword="native int" /> 类型）的地址。</span><span class="sxs-lookup"><span data-stu-id="02415-1821">Copies the value type located at the address of an object (type <see langword="&amp;" />, <see langword="*" /> or <see langword="native int" />) to the address of the destination object (type <see langword="&amp;" />, <see langword="*" /> or <see langword="native int" />).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1822">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1822">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1823">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1823">Format</span></span>|<span data-ttu-id="02415-1824">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1824">Assembly Format</span></span>|<span data-ttu-id="02415-1825">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1825">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1826">70 < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-1826">70 < `T` ></span></span>|<span data-ttu-id="02415-1827">cpobj `classTok`</span><span class="sxs-lookup"><span data-stu-id="02415-1827">cpobj `classTok`</span></span>|<span data-ttu-id="02415-1828">将值类型从源对象复制到目标对象。</span><span class="sxs-lookup"><span data-stu-id="02415-1828">Copies a value type from a source object to a destination object.</span></span>|  
  
 <span data-ttu-id="02415-1829">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1829">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1830">目标对象引用被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1830">The destination object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1831">源对象引用被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1831">The source object reference is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-1832">从堆栈中弹出两个对象引用;将源对象地址的值类型复制到目标对象的地址。</span><span class="sxs-lookup"><span data-stu-id="02415-1832">The two object references are popped from the stack; the value type at the address of the source object is copied to the address of the destination object.</span></span>  
  
 <span data-ttu-id="02415-1833">如果源对象和目标对象引用不是指向类标记所表示的类的实例的指针 `classTok` （`typeref` 或 `typedef`），或者如果 `classTok` 不表示值类型，则未指定 `cpobj` 的行为。</span><span class="sxs-lookup"><span data-stu-id="02415-1833">The behavior of `cpobj` is unspecified if the source and destination object references are not pointers to instances of the class represented by the class token `classTok` (a `typeref` or `typedef`), or if `classTok` does not represent a value type.</span></span>  
  
 <span data-ttu-id="02415-1834">如果检测到无效地址，则可能会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-1834"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="02415-1835">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `cpobj` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1835">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpobj` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1836">ILGenerator （OpCode，Type）</span><span class="sxs-lookup"><span data-stu-id="02415-1836">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1837">将两个值相除并将结果作为浮点（<see langword="F" /> 类型）或商（<see langword="int32" /> 类型）推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1837">Divides two values and pushes the result as a floating-point (type <see langword="F" />) or quotient (type <see langword="int32" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1838">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1838">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1839">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1839">Format</span></span>|<span data-ttu-id="02415-1840">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1840">Assembly Format</span></span>|<span data-ttu-id="02415-1841">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1841">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1842">5B</span><span class="sxs-lookup"><span data-stu-id="02415-1842">5B</span></span>|<span data-ttu-id="02415-1843">div</span><span class="sxs-lookup"><span data-stu-id="02415-1843">div</span></span>|<span data-ttu-id="02415-1844">将两个值相除以返回商或浮点结果。</span><span class="sxs-lookup"><span data-stu-id="02415-1844">Divides two values to return a quotient or floating-point result.</span></span>|  
  
 <span data-ttu-id="02415-1845">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1845">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1846">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1846">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1847">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1847">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-1848">从堆栈中弹出 `value2` 和 `value1`;`value1` 除以 `value2`。</span><span class="sxs-lookup"><span data-stu-id="02415-1848">`value2` and `value1` are popped from the stack; `value1` is divided by `value2`.</span></span>  
  
4.  <span data-ttu-id="02415-1849">将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1849">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1850">`value1` div value2 `result` = 满足以下条件：</span><span class="sxs-lookup"><span data-stu-id="02415-1850">`result` = `value1` div value2 satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="02415-1851">&#124;`result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;，以及：</span><span class="sxs-lookup"><span data-stu-id="02415-1851">&#124; `result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, and:</span></span>  
  
 <span data-ttu-id="02415-1852">sign （`result`） = +，if sign （`value1`） = sign （`value2`）或-，if sign （`value1`） ~ = sign （`value2`）</span><span class="sxs-lookup"><span data-stu-id="02415-1852">sign(`result`) = +, if sign(`value1`) = sign(`value2`), or -, if sign(`value1`) ~= sign(`value2`)</span></span>  
  
 <span data-ttu-id="02415-1853">`div` 指令计算结果并将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1853">The `div` instruction computes the result and pushes it on the stack.</span></span>  
  
 <span data-ttu-id="02415-1854">整数除法向零截断。</span><span class="sxs-lookup"><span data-stu-id="02415-1854">Integer division truncates towards zero.</span></span>  
  
 <span data-ttu-id="02415-1855">有限数除以零会生成正确的无符号无限值。</span><span class="sxs-lookup"><span data-stu-id="02415-1855">Division of a finite number by zero produces the correctly signed infinite value.</span></span>  
  
 <span data-ttu-id="02415-1856">零除以零或无穷大按无穷产生 NaN （非数字）值。</span><span class="sxs-lookup"><span data-stu-id="02415-1856">Dividing zero by zero or infinity by infinity produces the NaN (Not-A-Number) value.</span></span> <span data-ttu-id="02415-1857">除以无限大的任何数字都会产生零值。</span><span class="sxs-lookup"><span data-stu-id="02415-1857">Any number divided by infinity will produce a zero value.</span></span>  
  
 <span data-ttu-id="02415-1858">如果结果不能用结果类型表示，则整型运算将引发 <xref:System.ArithmeticException>。</span><span class="sxs-lookup"><span data-stu-id="02415-1858">Integral operations throw <xref:System.ArithmeticException> if the result cannot be represented in the result type.</span></span> <span data-ttu-id="02415-1859">如果 `value1` 是最大负值，并且 `value2` 为-1，则可能会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="02415-1859">This can happen if `value1` is the maximum negative value, and `value2` is -1.</span></span>  
  
 <span data-ttu-id="02415-1860">如果 `value2` 为零，则整型运算引发 <xref:System.DivideByZeroException>。</span><span class="sxs-lookup"><span data-stu-id="02415-1860">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="02415-1861">请注意，在基于 Intel 的平台上，计算时将引发 <xref:System.OverflowException> （minint div-1）。</span><span class="sxs-lookup"><span data-stu-id="02415-1861">Note that on Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint div -1).</span></span> <span data-ttu-id="02415-1862">浮点运算永远不会引发异常（而是生成 Nan 或无穷大）。</span><span class="sxs-lookup"><span data-stu-id="02415-1862">Floating-point operations never throw an exception (they produce NaNs or infinities instead).</span></span>  
  
 <span data-ttu-id="02415-1863">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `div` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1863">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1864">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1864">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1865">两个无符号整数值相除并将结果 ( <see langword="int32" /> ) 推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1865">Divides two unsigned integer values and pushes the result (<see langword="int32" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1866">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1866">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1867">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1867">Format</span></span>|<span data-ttu-id="02415-1868">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1868">Assembly Format</span></span>|<span data-ttu-id="02415-1869">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1869">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1870">5C</span><span class="sxs-lookup"><span data-stu-id="02415-1870">5C</span></span>|<span data-ttu-id="02415-1871">div. un</span><span class="sxs-lookup"><span data-stu-id="02415-1871">div.un</span></span>|<span data-ttu-id="02415-1872">将两个值相除，并返回商。</span><span class="sxs-lookup"><span data-stu-id="02415-1872">Divides two values, unsigned, returning a quotient.</span></span>|  
  
 <span data-ttu-id="02415-1873">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1873">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1874">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1874">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1875">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1875">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-1876">从堆栈中弹出 `value2` 和 `value1`;`value1` 除以 `value2`。</span><span class="sxs-lookup"><span data-stu-id="02415-1876">`value2` and `value1` are popped from the stack; `value1` is divided by `value2`.</span></span>  
  
4.  <span data-ttu-id="02415-1877">将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1877">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1878">`div.un` 指令计算 `value1` 除以 `value2`，并将其作为无符号整数进行计算，并将 `result` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1878">The `div.un` instruction computes `value1` divided by `value2`, both taken as unsigned integers, and pushes the `result` on the stack.</span></span>  
  
 <span data-ttu-id="02415-1879">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `div.un` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1879">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div.un` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1880">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1880">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1881">复制计算堆栈上当前最顶端的值，然后将副本推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1881">Copies the current topmost value on the evaluation stack, and then pushes the copy onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1882">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1882">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1883">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1883">Format</span></span>|<span data-ttu-id="02415-1884">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1884">Assembly Format</span></span>|<span data-ttu-id="02415-1885">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1885">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1886">25</span><span class="sxs-lookup"><span data-stu-id="02415-1886">25</span></span>|<span data-ttu-id="02415-1887">dup</span><span class="sxs-lookup"><span data-stu-id="02415-1887">dup</span></span>|<span data-ttu-id="02415-1888">复制堆栈顶部的值。</span><span class="sxs-lookup"><span data-stu-id="02415-1888">Duplicates the value on the top of the stack.</span></span>|  
  
 <span data-ttu-id="02415-1889">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1889">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1890">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1890">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1891">从堆栈中弹出 `value` 以进行复制。</span><span class="sxs-lookup"><span data-stu-id="02415-1891">`value` is popped off of the stack for duplication.</span></span>  
  
3.  <span data-ttu-id="02415-1892">`value` 被推送回堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1892">`value` is pushed back onto the stack.</span></span>  
  
4.  <span data-ttu-id="02415-1893">将重复的值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1893">A duplicate value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1894">`dup` 指令复制堆栈的顶部元素，并将两个相同的值留在其顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-1894">The `dup` instruction duplicates the top element of the stack, and leaves two identical values atop it.</span></span>  
  
 <span data-ttu-id="02415-1895">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `dup` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1895">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `dup` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1896">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1896">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1897">将控制从异常的 <see langword="filter" /> 子句转移回公共语言结构 (CLI) 异常处理程序。</span><span class="sxs-lookup"><span data-stu-id="02415-1897">Transfers control from the <see langword="filter" /> clause of an exception back to the Common Language Infrastructure (CLI) exception handler.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1898">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1898">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1899">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1899">Format</span></span>|<span data-ttu-id="02415-1900">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1900">Assembly Format</span></span>|<span data-ttu-id="02415-1901">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1901">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1902">FE 11</span><span class="sxs-lookup"><span data-stu-id="02415-1902">FE 11</span></span>|<span data-ttu-id="02415-1903">执行 endfilter</span><span class="sxs-lookup"><span data-stu-id="02415-1903">endfilter</span></span>|<span data-ttu-id="02415-1904">SEH 异常处理的结束筛选器子句。</span><span class="sxs-lookup"><span data-stu-id="02415-1904">End filter clause of SEH exception handling.</span></span>|  
  
 <span data-ttu-id="02415-1905">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1905">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1906">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1906">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1907">从堆栈中弹出 `value`;执行 `endfilter`，并将控制传输到异常处理程序。</span><span class="sxs-lookup"><span data-stu-id="02415-1907">`value` is popped from the stack; `endfilter` is executed and control is transferred to the exception handler.</span></span>  
  
 <span data-ttu-id="02415-1908">从 filter 子句返回 `Value` （必须是 `int32` 类型，并且是一组特定的值）。</span><span class="sxs-lookup"><span data-stu-id="02415-1908">`Value` (which must be of type `int32` and is one of a specific set of values) is returned from the filter clause.</span></span> <span data-ttu-id="02415-1909">它应该是以下其中之一：</span><span class="sxs-lookup"><span data-stu-id="02415-1909">It should be one of:</span></span>  
  
-   <span data-ttu-id="02415-1910">`exception_continue_search` （`value` = 0）以继续搜索异常处理程序</span><span class="sxs-lookup"><span data-stu-id="02415-1910">`exception_continue_search` (`value` = 0) to continue searching for an exception handler</span></span>  
  
-   <span data-ttu-id="02415-1911">`exception_execute_handler` （`value` = 1）以启动异常处理的第二个阶段，其中 finally 块将一直运行，直到找到与此筛选器子句关联的处理程序。</span><span class="sxs-lookup"><span data-stu-id="02415-1911">`exception_execute_handler` (`value` = 1) to start the second phase of exception handling where finally blocks are run until the handler associated with this filter clause is located.</span></span> <span data-ttu-id="02415-1912">发现后，将执行处理程序。</span><span class="sxs-lookup"><span data-stu-id="02415-1912">Upon discovery, the handler is executed.</span></span>  
  
 <span data-ttu-id="02415-1913">其他整数值将产生未指定的结果。</span><span class="sxs-lookup"><span data-stu-id="02415-1913">Other integer values will produce unspecified results.</span></span>  
  
 <span data-ttu-id="02415-1914">筛选器的入口点（如方法的异常表中所示）必须是筛选器的代码块中的第一个指令。</span><span class="sxs-lookup"><span data-stu-id="02415-1914">The entry point of a filter, as shown in the method's exception table, must be the first instruction in the filter's code block.</span></span> <span data-ttu-id="02415-1915">`endfilter` 指令必须是筛选器的代码块中的最后一个指令（因此任何单个筛选器块只能有一个 `endfilter`）。</span><span class="sxs-lookup"><span data-stu-id="02415-1915">The `endfilter` instruction must be the last instruction in the filter's code block (hence there can only be one `endfilter` for any single filter block).</span></span> <span data-ttu-id="02415-1916">执行 `endfilter` 指令后，控件将以逻辑方式流回 CLI 异常处理机制。</span><span class="sxs-lookup"><span data-stu-id="02415-1916">After executing the `endfilter` instruction, control logically flows back to the CLI exception handling mechanism.</span></span>  
  
 <span data-ttu-id="02415-1917">不能将控件传输到筛选器块中，除非通过异常机制。</span><span class="sxs-lookup"><span data-stu-id="02415-1917">Control cannot be transferred into a filter block except through the exception mechanism.</span></span> <span data-ttu-id="02415-1918">除了通过使用 `throw` 指令或通过执行最终 `endfilter` 指令以外，无法将控制转移出筛选器块。</span><span class="sxs-lookup"><span data-stu-id="02415-1918">Control cannot be transferred out of a filter block except through the use of a `throw` instruction or by executing the final `endfilter` instruction.</span></span> <span data-ttu-id="02415-1919">不能将 `try` 块嵌入 `filter` 块中。</span><span class="sxs-lookup"><span data-stu-id="02415-1919">You cannot embed a `try` block within a `filter` block.</span></span> <span data-ttu-id="02415-1920">如果在 `filter` 块内引发异常，则将截获该异常，并返回值0（`exception_continue_search`）。</span><span class="sxs-lookup"><span data-stu-id="02415-1920">If an exception is thrown inside the `filter` block, it is intercepted and a value of 0 (`exception_continue_search`) is returned.</span></span>  
  
 <span data-ttu-id="02415-1921">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `endfilter` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1921">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfilter` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1922">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1922">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1923">将控制从异常块的 <see langword="fault" /> 或 <see langword="finally" /> 子句转移回公共语言结构 (CLI) 异常处理程序。</span><span class="sxs-lookup"><span data-stu-id="02415-1923">Transfers control from the <see langword="fault" /> or <see langword="finally" /> clause of an exception block back to the Common Language Infrastructure (CLI) exception handler.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1924">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1924">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1925">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1925">Format</span></span>|<span data-ttu-id="02415-1926">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1926">Assembly Format</span></span>|<span data-ttu-id="02415-1927">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1927">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1928">DC</span><span class="sxs-lookup"><span data-stu-id="02415-1928">DC</span></span>|<span data-ttu-id="02415-1929">执行 endfinally</span><span class="sxs-lookup"><span data-stu-id="02415-1929">endfinally</span></span><br /><br /> <span data-ttu-id="02415-1930">endfault</span><span class="sxs-lookup"><span data-stu-id="02415-1930">endfault</span></span>|<span data-ttu-id="02415-1931">结束异常块的 `finally` 或 `fault` 子句。</span><span class="sxs-lookup"><span data-stu-id="02415-1931">Ends the `finally` or `fault` clause of an exception block.</span></span>|  
  
 <span data-ttu-id="02415-1932">此指令没有堆栈转换行为。</span><span class="sxs-lookup"><span data-stu-id="02415-1932">There are no stack transition behaviors for this instruction.</span></span>  
  
 <span data-ttu-id="02415-1933">`Endfinally` 和 `endfault` 信号结束 `finally` 或 `fault` 子句的末尾，以便堆栈展开可以继续，直到调用异常处理程序。</span><span class="sxs-lookup"><span data-stu-id="02415-1933">`Endfinally` and `endfault` signal the end of the `finally` or `fault` clause so that stack unwinding can continue until the exception handler is invoked.</span></span> <span data-ttu-id="02415-1934">`endfinally` 或 `endfault` 指令将控制转移回 CLI 异常机制。</span><span class="sxs-lookup"><span data-stu-id="02415-1934">The `endfinally` or `endfault` instruction transfers control back to the CLI exception mechanism.</span></span> <span data-ttu-id="02415-1935">然后，当受保护的块退出并带有 leave 指令时，该机制会搜索链中的下一个 `finally` 子句。</span><span class="sxs-lookup"><span data-stu-id="02415-1935">The mechanism then searches for the next `finally` clause in the chain if the protected block was exited with a leave instruction.</span></span> <span data-ttu-id="02415-1936">如果被保护的块退出但出现异常，CLI 将搜索下一 `finally` 或 `fault`，或者输入在第一次处理异常过程中选择的异常处理程序。</span><span class="sxs-lookup"><span data-stu-id="02415-1936">If the protected block was exited with an exception, the CLI will search for the next `finally` or `fault`, or enter the exception handler chosen during the first pass of exception handling.</span></span>  
  
 <span data-ttu-id="02415-1937">`endfinally` 指令可能仅在 `finally` 块中以词法上出现。</span><span class="sxs-lookup"><span data-stu-id="02415-1937">An `endfinally` instruction might only appear lexically within a `finally` block.</span></span> <span data-ttu-id="02415-1938">与 `endfilter` 指令不同，块以 `endfinally` 指令结束，并且在所需的块中可能有尽可能多的 `endfinally` 指令。</span><span class="sxs-lookup"><span data-stu-id="02415-1938">Unlike the `endfilter` instruction, there is no requirement that the block end with an `endfinally` instruction, and there can be as many `endfinally` instructions within the block as required.</span></span> <span data-ttu-id="02415-1939">这些相同的限制适用于 `endfault` 指令和 `fault` 块。</span><span class="sxs-lookup"><span data-stu-id="02415-1939">These same restrictions apply to the `endfault` instruction and the `fault` block.</span></span>  
  
 <span data-ttu-id="02415-1940">不能将控件传输到 `finally` （或 `fault`）块中，除非通过异常机制。</span><span class="sxs-lookup"><span data-stu-id="02415-1940">Control cannot be transferred into a `finally` (or `fault`) block except through the exception mechanism.</span></span> <span data-ttu-id="02415-1941">除了通过使用 `throw` 指令或执行 `endfinally` （或 `endfault`）指令以外，不能从 `finally` （或 `fault`）块中传出控制。</span><span class="sxs-lookup"><span data-stu-id="02415-1941">Control cannot be transferred out of a `finally` (or `fault`) block except through the use of a `throw` instruction or executing the `endfinally` (or `endfault`) instruction.</span></span> <span data-ttu-id="02415-1942">特别是，不能 "`finally` （或 `fault`）块的" 跳出 "或在 `finally` （或 `fault`）块中执行 <xref:System.Reflection.Emit.OpCodes.Ret> 或 <xref:System.Reflection.Emit.OpCodes.Leave> 指令。</span><span class="sxs-lookup"><span data-stu-id="02415-1942">In particular, you cannot "fall out" of a `finally` (or `fault`) block or to execute a <xref:System.Reflection.Emit.OpCodes.Ret> or <xref:System.Reflection.Emit.OpCodes.Leave> instruction within a `finally` (or `fault`) block.</span></span>  
  
 <span data-ttu-id="02415-1943">请注意，`endfault` 和 `endfinally` 说明是别名，它们对应于相同的操作码。</span><span class="sxs-lookup"><span data-stu-id="02415-1943">Note that the `endfault` and `endfinally` instructions are aliases - they correspond to the same opcode.</span></span>  
  
 <span data-ttu-id="02415-1944">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `endfinally` （`endfault`）操作码，并 <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>的 `ILGenerator` 方法。</span><span class="sxs-lookup"><span data-stu-id="02415-1944">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfinally` (`endfault`) opcode, as well as the `ILGenerator` method <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.</span></span>  
  
-   <span data-ttu-id="02415-1945">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1945">ILGenerator.Emit(OpCode)</span></span>  
  
-   <span data-ttu-id="02415-1946">ILGenerator.EndExceptionBlock()</span><span class="sxs-lookup"><span data-stu-id="02415-1946">ILGenerator.EndExceptionBlock()</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1947">将位于特定地址的内存的指定块初始化为给定大小和初始值。</span><span class="sxs-lookup"><span data-stu-id="02415-1947">Initializes a specified block of memory at a specific address to a given size and initial value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1948">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1948">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1949">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1949">Format</span></span>|<span data-ttu-id="02415-1950">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1950">Assembly Format</span></span>|<span data-ttu-id="02415-1951">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1951">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1952">FE 18</span><span class="sxs-lookup"><span data-stu-id="02415-1952">FE 18</span></span>|<span data-ttu-id="02415-1953">initblk</span><span class="sxs-lookup"><span data-stu-id="02415-1953">initblk</span></span>|<span data-ttu-id="02415-1954">将内存块中的每个位置设置为给定值。</span><span class="sxs-lookup"><span data-stu-id="02415-1954">Set each location in a block of memory to a given value.</span></span>|  
  
 <span data-ttu-id="02415-1955">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1955">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1956">起始地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1956">A starting address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1957">将初始化值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1957">An initialization value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-1958">要初始化的字节数将被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1958">The number of bytes to initialize is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="02415-1959">从堆栈中弹出字节数、初始化值和起始地址，并按它们的值执行初始化。</span><span class="sxs-lookup"><span data-stu-id="02415-1959">The number of bytes, the initialization value, and the starting address are popped from the stack, and the initialization is performed as per their values.</span></span>  
  
 <span data-ttu-id="02415-1960">`initblk` 指令将从指定的地址（类型为 `native int`、`&`或 `*`）开始的字节数（`unsigned int32`）设置为初始化值（类型为 `unsigned int8`）。</span><span class="sxs-lookup"><span data-stu-id="02415-1960">The `initblk` instruction sets the number (`unsigned int32`) of bytes starting at the specified address (of type `native int`, `&`, or `*`) to the initialization value (of type `unsigned int8`).</span></span> <span data-ttu-id="02415-1961">`initblk` 假设起始地址与计算机的自然大小对齐。</span><span class="sxs-lookup"><span data-stu-id="02415-1961">`initblk` assumes that the starting address is aligned to the natural size of the machine.</span></span>  
  
 <span data-ttu-id="02415-1962">`initblk` 指令的操作可以通过紧挨着 <xref:System.Reflection.Emit.OpCodes.Volatile> 或 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀指令来更改。</span><span class="sxs-lookup"><span data-stu-id="02415-1962">The operation of the `initblk` instructions can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="02415-1963">如果检测到无效地址，则可能会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-1963"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="02415-1964">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `initblk` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1964">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initblk` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1965">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-1965">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1966">将位于指定地址的值类型的每个字段初始化为空引用或适当的基元类型的 0。</span><span class="sxs-lookup"><span data-stu-id="02415-1966">Initializes each field of the value type at a specified address to a null reference or a 0 of the appropriate primitive type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1967">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1967">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1968">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1968">Format</span></span>|<span data-ttu-id="02415-1969">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1969">Assembly Format</span></span>|<span data-ttu-id="02415-1970">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1970">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1971">FE 15 < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-1971">FE 15 < `T` ></span></span>|<span data-ttu-id="02415-1972">`initobj` `typeTok`</span><span class="sxs-lookup"><span data-stu-id="02415-1972">`initobj` `typeTok`</span></span>|<span data-ttu-id="02415-1973">初始化值类型。</span><span class="sxs-lookup"><span data-stu-id="02415-1973">Initializes a value type.</span></span>|  
  
 <span data-ttu-id="02415-1974">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1974">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1975">要初始化的值类型的地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1975">The address of the value type to initialize is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1976">从堆栈中弹出该地址;指定地址处的值类型初始化为 `typeTok`类型。</span><span class="sxs-lookup"><span data-stu-id="02415-1976">The address is popped from the stack; the value type at the specified address is initialized as type `typeTok`.</span></span>  
  
 <span data-ttu-id="02415-1977">`initobj` 指令将推送地址（类型为 `native int`、`&`或 `*`）指定的值类型的每个字段初始化为空引用或适当的基元类型的0。</span><span class="sxs-lookup"><span data-stu-id="02415-1977">The `initobj` instruction initializes each field of the value type specified by the pushed address (of type `native int`, `&`, or `*`) to a null reference or a 0 of the appropriate primitive type.</span></span> <span data-ttu-id="02415-1978">调用此方法后，该实例已准备好调用构造函数方法。</span><span class="sxs-lookup"><span data-stu-id="02415-1978">After this method is called, the instance is ready for a constructor method to be called.</span></span> <span data-ttu-id="02415-1979">如果 `typeTok` 是引用类型，则此指令与 `ldnull` 后跟 `stind.ref`相同。</span><span class="sxs-lookup"><span data-stu-id="02415-1979">If `typeTok` is a reference type, this instruction has the same effect as `ldnull` followed by `stind.ref`.</span></span>  
  
 <span data-ttu-id="02415-1980">与 <xref:System.Reflection.Emit.OpCodes.Newobj>不同，`initobj` 不调用构造函数方法。</span><span class="sxs-lookup"><span data-stu-id="02415-1980">Unlike <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` does not call the constructor method.</span></span> <span data-ttu-id="02415-1981">`Initobj` 用于初始化值类型，而 `newobj` 用于分配和初始化对象。</span><span class="sxs-lookup"><span data-stu-id="02415-1981">`Initobj` is intended for initializing value types, while `newobj` is used to allocate and initialize objects.</span></span>  
  
 <span data-ttu-id="02415-1982">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `initobj` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-1982">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initobj` opcode:</span></span>  
  
-   <span data-ttu-id="02415-1983">ILGenerator （OpCode，Type）</span><span class="sxs-lookup"><span data-stu-id="02415-1983">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-1984">测试对象引用（<see langword="O" /> 类型）是否为特定类的实例。</span><span class="sxs-lookup"><span data-stu-id="02415-1984">Tests whether an object reference (type <see langword="O" />) is an instance of a particular class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-1985">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-1985">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-1986">格式</span><span class="sxs-lookup"><span data-stu-id="02415-1986">Format</span></span>|<span data-ttu-id="02415-1987">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-1987">Assembly Format</span></span>|<span data-ttu-id="02415-1988">说明</span><span class="sxs-lookup"><span data-stu-id="02415-1988">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-1989">75 < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-1989">75 < `T` ></span></span>|<span data-ttu-id="02415-1990">isinst `class`</span><span class="sxs-lookup"><span data-stu-id="02415-1990">isinst `class`</span></span>|<span data-ttu-id="02415-1991">测试对象引用是否为 `class`的实例，同时返回空引用或该类或接口的实例。</span><span class="sxs-lookup"><span data-stu-id="02415-1991">Tests if an object reference is an instance of `class`, returning either a null reference or an instance of that class or interface.</span></span>|  
  
 <span data-ttu-id="02415-1992">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-1992">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-1993">对象引用被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1993">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-1994">从堆栈中弹出对象引用并对其进行测试，以查看它是否是 `class`中传递的类的实例。</span><span class="sxs-lookup"><span data-stu-id="02415-1994">The object reference is popped from the stack and tested to see if it is an instance of the class passed in `class`.</span></span>  
  
3.  <span data-ttu-id="02415-1995">结果（对象引用或空引用）被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-1995">The result (either an object reference or a null reference) is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-1996">`Class` 是指明所需类的元数据标记。</span><span class="sxs-lookup"><span data-stu-id="02415-1996">`Class` is a metadata token indicating the desired class.</span></span> <span data-ttu-id="02415-1997">如果堆栈顶部对象的类实现 `class` （如果 `class` 为接口），或者是 `class` 的派生类（如果 `class` 是一个常规类），则会将其强制转换为类型 `class`，并将结果推送到堆栈上，就像调用 <xref:System.Reflection.Emit.OpCodes.Castclass> 一样。</span><span class="sxs-lookup"><span data-stu-id="02415-1997">If the class of the object on the top of the stack implements `class` (if `class` is an interface) or is a derived class of `class` (if `class` is a regular class) then it is cast to type `class` and the result is pushed on the stack, exactly as though <xref:System.Reflection.Emit.OpCodes.Castclass> had been called.</span></span> <span data-ttu-id="02415-1998">否则，在堆栈上推送空引用。</span><span class="sxs-lookup"><span data-stu-id="02415-1998">Otherwise, a null reference is pushed on the stack.</span></span> <span data-ttu-id="02415-1999">如果对象引用本身为空引用，则 `isinst` 同样返回空引用。</span><span class="sxs-lookup"><span data-stu-id="02415-1999">If the object reference itself is a null reference, then `isinst` likewise returns a null reference.</span></span>  
  
 <span data-ttu-id="02415-2000">如果找不到类，则会引发 <xref:System.TypeLoadException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2000"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="02415-2001">当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是运行时，通常会检测到此情况。</span><span class="sxs-lookup"><span data-stu-id="02415-2001">This is typically detected when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="02415-2002">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `isinst` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2002">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `isinst` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2003">ILGenerator （OpCode，Type）</span><span class="sxs-lookup"><span data-stu-id="02415-2003">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2004">退出当前方法并跳至指定方法。</span><span class="sxs-lookup"><span data-stu-id="02415-2004">Exits current method and jumps to specified method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2005">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2005">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2006">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2006">Format</span></span>|<span data-ttu-id="02415-2007">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2007">Assembly Format</span></span>|<span data-ttu-id="02415-2008">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2008">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2009">27 < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-2009">27 < `T` ></span></span>|<span data-ttu-id="02415-2010">跳转 `method`</span><span class="sxs-lookup"><span data-stu-id="02415-2010">jmp `method`</span></span>|<span data-ttu-id="02415-2011">退出当前方法并跳至指定方法。</span><span class="sxs-lookup"><span data-stu-id="02415-2011">Exit current method and jump to specified method.</span></span>|  
  
 <span data-ttu-id="02415-2012">此指令没有堆栈转换行为。</span><span class="sxs-lookup"><span data-stu-id="02415-2012">There are no stack transition behaviors for this instruction.</span></span>  
  
 <span data-ttu-id="02415-2013">`jmp` （跳转）指令将控制转移到 `method`指定的方法，该方法是方法引用的元数据标记。</span><span class="sxs-lookup"><span data-stu-id="02415-2013">The `jmp` (jump) instruction transfers control to the method specified by `method`, which is a metadata token for a method reference.</span></span> <span data-ttu-id="02415-2014">当前参数将传输到目标方法。</span><span class="sxs-lookup"><span data-stu-id="02415-2014">The current arguments are transferred to the destination method.</span></span>  
  
 <span data-ttu-id="02415-2015">执行此指令时，计算堆栈必须为空。</span><span class="sxs-lookup"><span data-stu-id="02415-2015">The evaluation stack must be empty when this instruction is executed.</span></span> <span data-ttu-id="02415-2016">目标地址的调用约定、数量和参数类型必须与当前方法的参数匹配。</span><span class="sxs-lookup"><span data-stu-id="02415-2016">The calling convention, number and type of arguments at the destination address must match that of the current method.</span></span>  
  
 <span data-ttu-id="02415-2017">`jmp` 指令不能用于将控制转移出 `try`、`filter`、`catch`或 `finally` 块。</span><span class="sxs-lookup"><span data-stu-id="02415-2017">The `jmp` instruction cannot be used to transferred control out of a `try`, `filter`, `catch`, or `finally` block.</span></span>  
  
 <span data-ttu-id="02415-2018">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `jmp` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2018">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `jmp` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2019">ILGenerator （操作码，MethodInfo）</span><span class="sxs-lookup"><span data-stu-id="02415-2019">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2020">将参数（由指定索引值引用）加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2020">Loads an argument (referenced by a specified index value) onto the stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2021">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2021">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2022">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2022">Format</span></span>|<span data-ttu-id="02415-2023">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2023">Assembly Format</span></span>|<span data-ttu-id="02415-2024">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2024">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2025">FE 09 < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="02415-2025">FE 09 < `unsigned int16` ></span></span>|<span data-ttu-id="02415-2026">ldarg `index`</span><span class="sxs-lookup"><span data-stu-id="02415-2026">ldarg `index`</span></span>|<span data-ttu-id="02415-2027">将 `index` 上的参数加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2027">Load argument at `index` onto stack.</span></span>|  
  
 <span data-ttu-id="02415-2028">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2028">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2029">`index` 中的参数值被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2029">The argument value at `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2030">`ldarg` 指令将在 `index`中编制索引的自变量推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2030">The `ldarg` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack.</span></span> <span data-ttu-id="02415-2031">`ldarg` 指令可用于将值类型或基元值从传入参数复制到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2031">The `ldarg` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="02415-2032">参数值的类型与参数的类型相同，后者由当前方法的签名指定。</span><span class="sxs-lookup"><span data-stu-id="02415-2032">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="02415-2033">对于采用可变长度参数列表的过程，`ldarg` 指令只能用于初始固定参数，而不能用于签名的变量部分的参数（有关详细信息，请参阅 <xref:System.Reflection.Emit.OpCodes.Arglist> 指令）。</span><span class="sxs-lookup"><span data-stu-id="02415-2033">For procedures that take a variable-length argument list, the `ldarg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).</span></span>  
  
 <span data-ttu-id="02415-2034">保留小于4个字节的整数值的参数将在加载到堆栈上时展开为类型 `int32`。</span><span class="sxs-lookup"><span data-stu-id="02415-2034">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="02415-2035">浮点值将扩展为其本机大小（类型 `F`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2035">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="02415-2036">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldarg` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2036">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2037">ILGenerator （操作码，short）</span><span class="sxs-lookup"><span data-stu-id="02415-2037">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2038">将索引为 0 的自变量加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2038">Loads the argument at index 0 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2039">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2039">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2040">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2040">Format</span></span>|<span data-ttu-id="02415-2041">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2041">Assembly Format</span></span>|<span data-ttu-id="02415-2042">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2042">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2043">02</span><span class="sxs-lookup"><span data-stu-id="02415-2043">02</span></span>|<span data-ttu-id="02415-2044">ldarg</span><span class="sxs-lookup"><span data-stu-id="02415-2044">ldarg.0</span></span>|<span data-ttu-id="02415-2045">将参数0加载到堆栈上</span><span class="sxs-lookup"><span data-stu-id="02415-2045">Load argument 0 onto stack</span></span>|  
  
 <span data-ttu-id="02415-2046">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2046">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2047">将索引0处的参数值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2047">The argument value at index 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2048">`ldarg.0` 指令是用于在索引0处加载参数值的有效编码。</span><span class="sxs-lookup"><span data-stu-id="02415-2048">The `ldarg.0` instruction is an efficient encoding for loading the argument value at index 0.</span></span>  
  
 <span data-ttu-id="02415-2049">`ldarg.0` 指令将索引为0的参数推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2049">The `ldarg.0` instruction pushes the argument indexed at 0 onto the evaluation stack.</span></span> <span data-ttu-id="02415-2050">`ldarg.0` 指令可用于将值类型或基元值从传入参数复制到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2050">The `ldarg.0` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="02415-2051">参数值的类型与参数的类型相同，后者由当前方法的签名指定。</span><span class="sxs-lookup"><span data-stu-id="02415-2051">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="02415-2052">保留小于4个字节的整数值的参数将在加载到堆栈上时展开为类型 `int32`。</span><span class="sxs-lookup"><span data-stu-id="02415-2052">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="02415-2053">浮点值将扩展为其本机大小（类型 `F`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2053">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="02415-2054">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldarg.0` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2054">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.0` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2055">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2055">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2056">将索引为 1 的自变量加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2056">Loads the argument at index 1 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2057">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2057">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2058">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2058">Format</span></span>|<span data-ttu-id="02415-2059">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2059">Assembly Format</span></span>|<span data-ttu-id="02415-2060">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2060">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2061">03</span><span class="sxs-lookup"><span data-stu-id="02415-2061">03</span></span>|<span data-ttu-id="02415-2062">ldarg</span><span class="sxs-lookup"><span data-stu-id="02415-2062">ldarg.1</span></span>|<span data-ttu-id="02415-2063">将参数1加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2063">Load argument 1 onto stack.</span></span>|  
  
 <span data-ttu-id="02415-2064">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2064">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2065">将索引为1的参数值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2065">The argument value at index 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2066">`ldarg.1` 指令是用于在索引1处加载参数值的有效编码。</span><span class="sxs-lookup"><span data-stu-id="02415-2066">The `ldarg.1` instruction is an efficient encoding for loading the argument value at index 1.</span></span>  
  
 <span data-ttu-id="02415-2067">`ldarg.1` 指令将索引为1的参数推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2067">The `ldarg.1` instruction pushes the argument indexed at 1 onto the evaluation stack.</span></span> <span data-ttu-id="02415-2068">`ldarg.1` 指令可用于将值类型或基元值从传入参数复制到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2068">The `ldarg.1` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="02415-2069">参数值的类型与参数的类型相同，后者由当前方法的签名指定。</span><span class="sxs-lookup"><span data-stu-id="02415-2069">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="02415-2070">保留小于4个字节的整数值的参数将在加载到堆栈上时展开为类型 `int32`。</span><span class="sxs-lookup"><span data-stu-id="02415-2070">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="02415-2071">浮点值将扩展为其本机大小（类型 `F`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2071">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="02415-2072">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldarg.1` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2072">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.1` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2073">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2073">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2074">将索引为 2 的自变量加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2074">Loads the argument at index 2 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2075">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2075">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2076">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2076">Format</span></span>|<span data-ttu-id="02415-2077">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2077">Assembly Format</span></span>|<span data-ttu-id="02415-2078">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2078">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2079">04</span><span class="sxs-lookup"><span data-stu-id="02415-2079">04</span></span>|<span data-ttu-id="02415-2080">ldarg</span><span class="sxs-lookup"><span data-stu-id="02415-2080">ldarg.2</span></span>|<span data-ttu-id="02415-2081">将参数2加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2081">Load argument 2 onto stack.</span></span>|  
  
 <span data-ttu-id="02415-2082">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2082">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2083">索引2处的参数值被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2083">The argument value at index 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2084">`ldarg.2` 指令是用于在索引2处加载参数值的有效编码。</span><span class="sxs-lookup"><span data-stu-id="02415-2084">The `ldarg.2` instruction is an efficient encoding for loading the argument value at index 2.</span></span>  
  
 <span data-ttu-id="02415-2085">`ldarg.2` 指令将索引为2的参数推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2085">The `ldarg.2` instruction pushes the argument indexed at 2 onto the evaluation stack.</span></span> <span data-ttu-id="02415-2086">`ldarg.2` 指令可用于将值类型或基元值从传入参数复制到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2086">The `ldarg.2` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="02415-2087">参数值的类型与参数的类型相同，后者由当前方法的签名指定。</span><span class="sxs-lookup"><span data-stu-id="02415-2087">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="02415-2088">保留小于4个字节的整数值的参数将在加载到堆栈上时展开为类型 `int32`。</span><span class="sxs-lookup"><span data-stu-id="02415-2088">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="02415-2089">浮点值将扩展为其本机大小（类型 `F`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2089">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="02415-2090">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldarg.2` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2090">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.2` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2091">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2091">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2092">将索引为 3 的参数加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2092">Loads the argument at index 3 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2093">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2093">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2094">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2094">Format</span></span>|<span data-ttu-id="02415-2095">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2095">Assembly Format</span></span>|<span data-ttu-id="02415-2096">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2096">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2097">05</span><span class="sxs-lookup"><span data-stu-id="02415-2097">05</span></span>|<span data-ttu-id="02415-2098">ldarg</span><span class="sxs-lookup"><span data-stu-id="02415-2098">ldarg.3</span></span>|<span data-ttu-id="02415-2099">将参数3加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2099">Load argument 3 onto stack.</span></span>|  
  
 <span data-ttu-id="02415-2100">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2100">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2101">将索引为3的参数值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2101">The argument value at index 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2102">`ldarg.3` 指令是用于在索引3处加载参数值的有效编码。</span><span class="sxs-lookup"><span data-stu-id="02415-2102">The `ldarg.3` instruction is an efficient encoding for loading the argument value at index 3.</span></span>  
  
 <span data-ttu-id="02415-2103">`ldarg.3` 指令将索引为3的参数推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2103">The `ldarg.3` instruction pushes the argument indexed at 3 onto the evaluation stack.</span></span> <span data-ttu-id="02415-2104">`ldarg.3` 指令可用于将值类型或基元值从传入参数复制到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2104">The `ldarg.3` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="02415-2105">参数值的类型与参数的类型相同，后者由当前方法的签名指定。</span><span class="sxs-lookup"><span data-stu-id="02415-2105">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="02415-2106">保留小于4个字节的整数值的参数将在加载到堆栈上时展开为类型 `int32`。</span><span class="sxs-lookup"><span data-stu-id="02415-2106">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="02415-2107">浮点值将扩展为其本机大小（类型 `F`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2107">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="02415-2108">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldarg.3` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2108">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.3` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2109">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2109">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2110">将参数（由指定的短格式索引引用）加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2110">Loads the argument (referenced by a specified short form index) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2111">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2111">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2112">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2112">Format</span></span>|<span data-ttu-id="02415-2113">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2113">Assembly Format</span></span>|<span data-ttu-id="02415-2114">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2114">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2115">0E < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="02415-2115">0E < `unsigned int8` ></span></span>|<span data-ttu-id="02415-2116">ldarg `index`</span><span class="sxs-lookup"><span data-stu-id="02415-2116">ldarg.s `index`</span></span>|<span data-ttu-id="02415-2117">将 `index` 上的参数加载到堆栈上（短格式）。</span><span class="sxs-lookup"><span data-stu-id="02415-2117">Load argument at `index` onto stack, short form.</span></span>|  
  
 <span data-ttu-id="02415-2118">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2118">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2119">`index` 中的参数值被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2119">The argument value at `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2120">`ldarg.s` 指令是用于加载从4到255的索引参数的有效编码。</span><span class="sxs-lookup"><span data-stu-id="02415-2120">The `ldarg.s` instruction is an efficient encoding for loading arguments indexed from 4 through 255.</span></span>  
  
 <span data-ttu-id="02415-2121">`ldarg.s` 指令将在 `index`中编制索引的自变量推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2121">The `ldarg.s` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack.</span></span> <span data-ttu-id="02415-2122">`ldarg.s` 指令可用于将值类型或基元值从传入参数复制到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2122">The `ldarg.s` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="02415-2123">参数值的类型与参数的类型相同，后者由当前方法的签名指定。</span><span class="sxs-lookup"><span data-stu-id="02415-2123">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="02415-2124">对于采用可变长度参数列表的过程，`ldarg.s` 指令只能用于初始固定参数，而不能用于签名的变量部分的参数（有关详细信息，请参阅 <xref:System.Reflection.Emit.OpCodes.Arglist> 指令）。</span><span class="sxs-lookup"><span data-stu-id="02415-2124">For procedures that take a variable-length argument list, the `ldarg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).</span></span>  
  
 <span data-ttu-id="02415-2125">保留小于4个字节的整数值的参数将在加载到堆栈上时展开为类型 `int32`。</span><span class="sxs-lookup"><span data-stu-id="02415-2125">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="02415-2126">浮点值将扩展为其本机大小（类型 `F`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2126">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="02415-2127">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldarg.s` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2127">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.s` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2128">ILGenerator （OpCode，byte）</span><span class="sxs-lookup"><span data-stu-id="02415-2128">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2129">将参数地址加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2129">Load an argument address onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2130">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2130">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2131">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2131">Format</span></span>|<span data-ttu-id="02415-2132">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2132">Assembly Format</span></span>|<span data-ttu-id="02415-2133">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2133">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2134">FE 0A < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="02415-2134">FE 0A < `unsigned int16` ></span></span>|<span data-ttu-id="02415-2135">ldarga `index`</span><span class="sxs-lookup"><span data-stu-id="02415-2135">ldarga `index`</span></span>|<span data-ttu-id="02415-2136">提取 `index`索引的参数的地址。</span><span class="sxs-lookup"><span data-stu-id="02415-2136">Fetch the address of argument indexed by `index`.</span></span>|  
  
 <span data-ttu-id="02415-2137">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2137">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2138">将 `index` 索引的参数的地址 `addr` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2138">The address `addr` of the argument indexed by `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2139">`ldarga` 指令提取按 `index`编制索引的自变量的地址（类型 `*`），其中参数从0开始编制索引。</span><span class="sxs-lookup"><span data-stu-id="02415-2139">The `ldarga` instruction fetches the address (of type `*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards.</span></span> <span data-ttu-id="02415-2140">地址 `addr` 始终与目标计算机上的自然边界对齐。</span><span class="sxs-lookup"><span data-stu-id="02415-2140">The address `addr` is always aligned to a natural boundary on the target machine.</span></span>  
  
 <span data-ttu-id="02415-2141">对于采用可变长度参数列表的过程，`ldarga` 指令只能用于初始固定参数，而不能用于签名的变量部分。</span><span class="sxs-lookup"><span data-stu-id="02415-2141">For procedures that take a variable-length argument list, the `ldarga` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="02415-2142">`ldarga` 用于通过引用传递的参数。</span><span class="sxs-lookup"><span data-stu-id="02415-2142">`ldarga` is used for by-ref parameter passing.</span></span> <span data-ttu-id="02415-2143">对于其他情况，应使用 <xref:System.Reflection.Emit.OpCodes.Ldarg> 和 <xref:System.Reflection.Emit.OpCodes.Starg>。</span><span class="sxs-lookup"><span data-stu-id="02415-2143">For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg> and <xref:System.Reflection.Emit.OpCodes.Starg> should be used.</span></span>  
  
 <span data-ttu-id="02415-2144">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldarga` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2144">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2145">ILGenerator （操作码，short）</span><span class="sxs-lookup"><span data-stu-id="02415-2145">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2146">以短格式将自变量地址加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2146">Load an argument address, in short form, onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2147">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2147">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2148">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2148">Format</span></span>|<span data-ttu-id="02415-2149">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2149">Assembly Format</span></span>|<span data-ttu-id="02415-2150">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2150">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2151">0F < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="02415-2151">0F < `unsigned int8` ></span></span>|<span data-ttu-id="02415-2152">ldarga `index`</span><span class="sxs-lookup"><span data-stu-id="02415-2152">ldarga.s `index`</span></span>|<span data-ttu-id="02415-2153">提取 `index`的索引的参数地址（缩写形式）。</span><span class="sxs-lookup"><span data-stu-id="02415-2153">Fetch the address of argument indexed by `index`, short form.</span></span>|  
  
 <span data-ttu-id="02415-2154">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2154">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2155">将 `index` 索引的参数的地址 `addr` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2155">The address `addr` of the argument indexed by `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2156">`ldarga.s` （`ldarga`的缩写形式）应用于0到255之间的参数编号，并且是一种更有效的编码。</span><span class="sxs-lookup"><span data-stu-id="02415-2156">`ldarga.s` (the short form of `ldarga`) should be used for argument numbers 0 through 255, and is a more efficient encoding.</span></span>  
  
 <span data-ttu-id="02415-2157">`ldarga.s` 指令提取按 `index`编制索引的自变量的地址（类型`*`），其中参数从0开始编制索引。</span><span class="sxs-lookup"><span data-stu-id="02415-2157">The `ldarga.s` instruction fetches the address (of type`*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards.</span></span> <span data-ttu-id="02415-2158">地址 `addr` 始终与目标计算机上的自然边界对齐。</span><span class="sxs-lookup"><span data-stu-id="02415-2158">The address `addr` is always aligned to a natural boundary on the target machine.</span></span>  
  
 <span data-ttu-id="02415-2159">对于采用可变长度参数列表的过程，`ldarga.s` 指令只能用于初始固定参数，而不能用于签名的变量部分。</span><span class="sxs-lookup"><span data-stu-id="02415-2159">For procedures that take a variable-length argument list, the `ldarga.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="02415-2160">`ldarga.s` 用于通过引用传递的参数。</span><span class="sxs-lookup"><span data-stu-id="02415-2160">`ldarga.s` is used for by-ref parameter passing.</span></span> <span data-ttu-id="02415-2161">对于其他情况，应使用 <xref:System.Reflection.Emit.OpCodes.Ldarg_S> 和 <xref:System.Reflection.Emit.OpCodes.Starg_S>。</span><span class="sxs-lookup"><span data-stu-id="02415-2161">For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg_S> and <xref:System.Reflection.Emit.OpCodes.Starg_S> should be used.</span></span>  
  
 <span data-ttu-id="02415-2162">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldarga.s` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2162">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga.s` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2163">ILGenerator （OpCode，byte）</span><span class="sxs-lookup"><span data-stu-id="02415-2163">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2164">将所提供的 <see langword="int32" /> 类型的值作为 <see langword="int32" /> 推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2164">Pushes a supplied value of type <see langword="int32" /> onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2165">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2165">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2166">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2166">Format</span></span>|<span data-ttu-id="02415-2167">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2167">Assembly Format</span></span>|<span data-ttu-id="02415-2168">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2168">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2169">20 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="02415-2169">20 < `int32` ></span></span>|<span data-ttu-id="02415-2170">ldc. i4 `num`</span><span class="sxs-lookup"><span data-stu-id="02415-2170">ldc.i4 `num`</span></span>|<span data-ttu-id="02415-2171">将值 `num` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2171">Pushes the value `num` onto the stack.</span></span>|  
  
 <span data-ttu-id="02415-2172">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2172">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2173">`num` 的值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2173">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2174">请注意，对于从-128 到127的整数，会有特殊的简短编码（因而更有效），尤其是-1 到8的短编码。</span><span class="sxs-lookup"><span data-stu-id="02415-2174">Note that there are special short (and hence more efficient) encodings for the integers -128 through 127, and especially short encodings for -1 through 8.</span></span> <span data-ttu-id="02415-2175">所有短编码将4字节整数推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2175">All short encodings push 4 byte integers on the stack.</span></span> <span data-ttu-id="02415-2176">较长的编码用于8字节整数、4字节和8字节浮点数，以及不符合短格式的4字节值。</span><span class="sxs-lookup"><span data-stu-id="02415-2176">Longer encodings are used for 8 byte integers and 4 and 8 byte floating-point numbers, as well as 4-byte values that do not fit in the short forms.</span></span> <span data-ttu-id="02415-2177">有三种方法可将8字节整数常量推送到堆栈上</span><span class="sxs-lookup"><span data-stu-id="02415-2177">There are three ways to push an 8 byte integer constant onto the stack</span></span>  
  
 1. <span data-ttu-id="02415-2178">对于必须以32多位表示的常量，请使用 <xref:System.Reflection.Emit.OpCodes.Ldc_I8> 指令。</span><span class="sxs-lookup"><span data-stu-id="02415-2178">Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I8> instruction for constants that must be expressed in more than 32 bits.</span></span>  
  
 2. <span data-ttu-id="02415-2179">使用 <xref:System.Reflection.Emit.OpCodes.Ldc_I4> 指令，后跟需要9到32位的常量的 <xref:System.Reflection.Emit.OpCodes.Conv_I8>。</span><span class="sxs-lookup"><span data-stu-id="02415-2179">Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I4> instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that require 9 to 32 bits.</span></span>  
  
 3. <span data-ttu-id="02415-2180">使用简短的窗体指令，后面跟有可以用8个或更少位表示的常量的 <xref:System.Reflection.Emit.OpCodes.Conv_I8>。</span><span class="sxs-lookup"><span data-stu-id="02415-2180">Use a short form instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that can be expressed in 8 or fewer bits.</span></span>  
  
 <span data-ttu-id="02415-2181">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i4` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2181">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2182">ILGenerator （OpCode，int）</span><span class="sxs-lookup"><span data-stu-id="02415-2182">ILGenerator.Emit(OpCode, int)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2183">将整数值 0 作为 <see langword="int32" /> 推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2183">Pushes the integer value of 0 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2184">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2184">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2185">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2185">Format</span></span>|<span data-ttu-id="02415-2186">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2186">Assembly Format</span></span>|<span data-ttu-id="02415-2187">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2187">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2188">16</span><span class="sxs-lookup"><span data-stu-id="02415-2188">16</span></span>|<span data-ttu-id="02415-2189">ldc.i4.0</span><span class="sxs-lookup"><span data-stu-id="02415-2189">ldc.i4.0</span></span>|<span data-ttu-id="02415-2190">将0推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2190">Pushes 0 onto the stack.</span></span>|  
  
 <span data-ttu-id="02415-2191">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2191">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2192">值0被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2192">The value 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2193">这是一个用于推送整数值0的特殊短编码。</span><span class="sxs-lookup"><span data-stu-id="02415-2193">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="02415-2194">所有特殊的短编码将4字节整数推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2194">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="02415-2195">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i4.0` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2195">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.0` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2196">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2196">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2197">将整数值 1 作为 <see langword="int32" /> 推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2197">Pushes the integer value of 1 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2198">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2198">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2199">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2199">Format</span></span>|<span data-ttu-id="02415-2200">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2200">Assembly Format</span></span>|<span data-ttu-id="02415-2201">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2201">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2202">17</span><span class="sxs-lookup"><span data-stu-id="02415-2202">17</span></span>|<span data-ttu-id="02415-2203">ldc.i4.1</span><span class="sxs-lookup"><span data-stu-id="02415-2203">ldc.i4.1</span></span>|<span data-ttu-id="02415-2204">将1推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2204">Pushes 1 onto the stack.</span></span>|  
  
 <span data-ttu-id="02415-2205">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2205">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2206">值1被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2206">The value 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2207">这是用于推送整数值1的特殊短编码。</span><span class="sxs-lookup"><span data-stu-id="02415-2207">This is a special short encoding for the push of the integer value 1.</span></span> <span data-ttu-id="02415-2208">所有特殊的短编码将4字节整数推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2208">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="02415-2209">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i4.1` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2209">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.1` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2210">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2210">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2211">将整数值 2 作为 <see langword="int32" /> 推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2211">Pushes the integer value of 2 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2212">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2212">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2213">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2213">Format</span></span>|<span data-ttu-id="02415-2214">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2214">Assembly Format</span></span>|<span data-ttu-id="02415-2215">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2215">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2216">18</span><span class="sxs-lookup"><span data-stu-id="02415-2216">18</span></span>|<span data-ttu-id="02415-2217">ldc.i4.2</span><span class="sxs-lookup"><span data-stu-id="02415-2217">ldc.i4.2</span></span>|<span data-ttu-id="02415-2218">将2推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2218">Pushes 2 onto the stack.</span></span>|  
  
 <span data-ttu-id="02415-2219">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2219">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2220">值2被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2220">The value 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2221">这是用于推送整数值2的特殊短编码。</span><span class="sxs-lookup"><span data-stu-id="02415-2221">This is a special short encoding for the push of the integer value 2.</span></span> <span data-ttu-id="02415-2222">所有特殊的短编码将4字节整数推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2222">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="02415-2223">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i4.2` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2223">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.2` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2224">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2224">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2225">将整数值 3 作为 <see langword="int32" /> 推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2225">Pushes the integer value of 3 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2226">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2226">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2227">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2227">Format</span></span>|<span data-ttu-id="02415-2228">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2228">Assembly Format</span></span>|<span data-ttu-id="02415-2229">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2229">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2230">19</span><span class="sxs-lookup"><span data-stu-id="02415-2230">19</span></span>|<span data-ttu-id="02415-2231">ldc.i4.3</span><span class="sxs-lookup"><span data-stu-id="02415-2231">ldc.i4.3</span></span>|<span data-ttu-id="02415-2232">将3推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2232">Pushes 3 onto the stack.</span></span>|  
  
 <span data-ttu-id="02415-2233">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2233">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2234">值3被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2234">The value 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2235">这是用于推送整数值3的特殊短编码。</span><span class="sxs-lookup"><span data-stu-id="02415-2235">This is a special short encoding for the push of the integer value 3.</span></span> <span data-ttu-id="02415-2236">所有特殊的短编码将4字节整数推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2236">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="02415-2237">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i4.3` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2237">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.3` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2238">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2238">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2239">将整数值 4 作为 <see langword="int32" /> 推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2239">Pushes the integer value of 4 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2240">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2240">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2241">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2241">Format</span></span>|<span data-ttu-id="02415-2242">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2242">Assembly Format</span></span>|<span data-ttu-id="02415-2243">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2243">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2244">1A</span><span class="sxs-lookup"><span data-stu-id="02415-2244">1A</span></span>|<span data-ttu-id="02415-2245">ldc.i4.4</span><span class="sxs-lookup"><span data-stu-id="02415-2245">ldc.i4.4</span></span>|<span data-ttu-id="02415-2246">将4推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2246">Pushes 4 onto the stack.</span></span>|  
  
 <span data-ttu-id="02415-2247">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2247">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2248">值4被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2248">The value 4 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2249">这是一个用于推送整数值4的特殊短编码。</span><span class="sxs-lookup"><span data-stu-id="02415-2249">This is a special short encoding for the push of the integer value 4.</span></span> <span data-ttu-id="02415-2250">所有特殊的短编码将4字节整数推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2250">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="02415-2251">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i4.4` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2251">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.4` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2252">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2252">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2253">将整数值 5 作为 <see langword="int32" /> 推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2253">Pushes the integer value of 5 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2254">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2254">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2255">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2255">Format</span></span>|<span data-ttu-id="02415-2256">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2256">Assembly Format</span></span>|<span data-ttu-id="02415-2257">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2257">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2258">1B</span><span class="sxs-lookup"><span data-stu-id="02415-2258">1B</span></span>|<span data-ttu-id="02415-2259">ldc.i4.5</span><span class="sxs-lookup"><span data-stu-id="02415-2259">ldc.i4.5</span></span>|<span data-ttu-id="02415-2260">将5推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2260">Pushes 5 onto the stack.</span></span>|  
  
 <span data-ttu-id="02415-2261">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2261">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2262">值5被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2262">The value 5 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2263">这是一个用于推送整数值5的特殊短编码。</span><span class="sxs-lookup"><span data-stu-id="02415-2263">This is a special short encoding for the push of the integer value 5.</span></span> <span data-ttu-id="02415-2264">所有特殊的短编码将4字节整数推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2264">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="02415-2265">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i4.5` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2265">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.5` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2266">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2266">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2267">将整数值 6 作为 <see langword="int32" /> 推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2267">Pushes the integer value of 6 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2268">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2268">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2269">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2269">Format</span></span>|<span data-ttu-id="02415-2270">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2270">Assembly Format</span></span>|<span data-ttu-id="02415-2271">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2271">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2272">1C</span><span class="sxs-lookup"><span data-stu-id="02415-2272">1C</span></span>|<span data-ttu-id="02415-2273">ldc.i4.6</span><span class="sxs-lookup"><span data-stu-id="02415-2273">ldc.i4.6</span></span>|<span data-ttu-id="02415-2274">将6推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2274">Pushes 6 onto the stack.</span></span>|  
  
 <span data-ttu-id="02415-2275">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2275">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2276">值6被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2276">The value 6 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2277">这是一个用于推送整数值6的特殊短编码。</span><span class="sxs-lookup"><span data-stu-id="02415-2277">This is a special short encoding for the push of the integer value 6.</span></span> <span data-ttu-id="02415-2278">所有特殊的短编码将4字节整数推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2278">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="02415-2279">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i4.6` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2279">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.6` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2280">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2280">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2281">将整数值 7 作为 <see langword="int32" /> 推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2281">Pushes the integer value of 7 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2282">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2282">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2283">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2283">Format</span></span>|<span data-ttu-id="02415-2284">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2284">Assembly Format</span></span>|<span data-ttu-id="02415-2285">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2285">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2286">1D</span><span class="sxs-lookup"><span data-stu-id="02415-2286">1D</span></span>|<span data-ttu-id="02415-2287">ldc.i4.7</span><span class="sxs-lookup"><span data-stu-id="02415-2287">ldc.i4.7</span></span>|<span data-ttu-id="02415-2288">将7推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2288">Pushes 7 onto the stack.</span></span>|  
  
 <span data-ttu-id="02415-2289">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2289">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2290">值7被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2290">The value 7 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2291">这是一个用于推送整数值7的特殊短编码。</span><span class="sxs-lookup"><span data-stu-id="02415-2291">This is a special short encoding for the push of the integer value 7.</span></span> <span data-ttu-id="02415-2292">所有特殊的短编码将4字节整数推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2292">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="02415-2293">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i4.7` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2293">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.7` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2294">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2294">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2295">将整数值 8 作为 <see langword="int32" /> 推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2295">Pushes the integer value of 8 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2296">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2296">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2297">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2297">Format</span></span>|<span data-ttu-id="02415-2298">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2298">Assembly Format</span></span>|<span data-ttu-id="02415-2299">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2299">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2300">1E</span><span class="sxs-lookup"><span data-stu-id="02415-2300">1E</span></span>|<span data-ttu-id="02415-2301">ldc.i4.8</span><span class="sxs-lookup"><span data-stu-id="02415-2301">ldc.i4.8</span></span>|<span data-ttu-id="02415-2302">将8推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2302">Pushes 8 onto the stack.</span></span>|  
  
 <span data-ttu-id="02415-2303">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2303">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2304">值8被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2304">The value 8 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2305">这是用于推送整数值8的特殊短编码。</span><span class="sxs-lookup"><span data-stu-id="02415-2305">This is a special short encoding for the push of the integer value 8.</span></span> <span data-ttu-id="02415-2306">所有特殊的短编码将4字节整数推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2306">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="02415-2307">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i4.8` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2307">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.8` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2308">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2308">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2309">将整数值 -1 作为 <see langword="int32" /> 推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2309">Pushes the integer value of -1 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2310">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2310">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2311">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2311">Format</span></span>|<span data-ttu-id="02415-2312">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2312">Assembly Format</span></span>|<span data-ttu-id="02415-2313">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2313">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2314">15</span><span class="sxs-lookup"><span data-stu-id="02415-2314">15</span></span>|<span data-ttu-id="02415-2315">ldc.i4.m1</span><span class="sxs-lookup"><span data-stu-id="02415-2315">ldc.i4.m1</span></span>|<span data-ttu-id="02415-2316">将-1 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2316">Pushes -1 onto the stack.</span></span>|  
  
 <span data-ttu-id="02415-2317">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2317">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2318">值-1 被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2318">The value -1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2319">这是用于推送整数值-1 的特殊短编码。</span><span class="sxs-lookup"><span data-stu-id="02415-2319">This is a special short encoding for the push of the integer value -1.</span></span> <span data-ttu-id="02415-2320">所有特殊的短编码将4字节整数推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2320">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="02415-2321">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i4.m1` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2321">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.m1` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2322">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2322">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2323">将提供的 <see langword="int8" /> 值作为 <see langword="int32" /> 推送到计算堆栈上（短格式）。</span><span class="sxs-lookup"><span data-stu-id="02415-2323">Pushes the supplied <see langword="int8" /> value onto the evaluation stack as an <see langword="int32" />, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2324">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2324">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2325">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2325">Format</span></span>|<span data-ttu-id="02415-2326">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2326">Assembly Format</span></span>|<span data-ttu-id="02415-2327">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2327">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2328">1F < `int8` ></span><span class="sxs-lookup"><span data-stu-id="02415-2328">1F < `int8` ></span></span>|<span data-ttu-id="02415-2329">ldc. i4 `num`</span><span class="sxs-lookup"><span data-stu-id="02415-2329">ldc.i4.s `num`</span></span>|<span data-ttu-id="02415-2330">将 `num` 作为 `int32`的短格式推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2330">Pushes `num` onto the stack as `int32`, short form.</span></span>|  
  
 <span data-ttu-id="02415-2331">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2331">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2332">`num` 的值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2332">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2333">`ldc.i4.s` 是一种更有效的编码方式，用于将从-128 到127的整数推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2333">`ldc.i4.s` is a more efficient encoding for pushing the integers from -128 to 127 onto the evaluation stack.</span></span>  
  
<span data-ttu-id="02415-2334">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i4.s` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2334">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldc.i4.s` opcode:</span></span>
  
- <xref:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Byte)?displayProperty=nameWithType>
- <xref:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.SByte)?displayProperty=nameWithType>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2335">将所提供的 <see langword="int64" /> 类型的值作为 <see langword="int64" /> 推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2335">Pushes a supplied value of type <see langword="int64" /> onto the evaluation stack as an <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2336">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2336">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2337">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2337">Format</span></span>|<span data-ttu-id="02415-2338">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2338">Assembly Format</span></span>|<span data-ttu-id="02415-2339">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2339">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2340">21 < `int64` ></span><span class="sxs-lookup"><span data-stu-id="02415-2340">21 < `int64` ></span></span>|<span data-ttu-id="02415-2341">ldc. i8 `num`</span><span class="sxs-lookup"><span data-stu-id="02415-2341">ldc.i8 `num`</span></span>|<span data-ttu-id="02415-2342">将 `num` 作为 `int64`推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2342">Pushes `num` onto the stack as `int64`.</span></span>|  
  
 <span data-ttu-id="02415-2343">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2343">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2344">`num` 的值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2344">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2345">此编码将 `int64` 值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2345">This encoding pushes an `int64` value onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2346">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.i8` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2346">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i8` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2347">ILGenerator （操作码，长）</span><span class="sxs-lookup"><span data-stu-id="02415-2347">ILGenerator.Emit(OpCode, long)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2348">将所提供的 <see langword="float32" /> 类型的值作为 <see langword="F" /> (float) 类型推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2348">Pushes a supplied value of type <see langword="float32" /> onto the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2349">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2349">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2350">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2350">Format</span></span>|<span data-ttu-id="02415-2351">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2351">Assembly Format</span></span>|<span data-ttu-id="02415-2352">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2352">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2353">22 < `float32` ></span><span class="sxs-lookup"><span data-stu-id="02415-2353">22 < `float32` ></span></span>|<span data-ttu-id="02415-2354">ldc. r4 `num`</span><span class="sxs-lookup"><span data-stu-id="02415-2354">ldc.r4 `num`</span></span>|<span data-ttu-id="02415-2355">将 `num` 作为 `F`推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2355">Pushes `num` onto the stack as `F`.</span></span>|  
  
 <span data-ttu-id="02415-2356">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2356">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2357">`num` 的值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2357">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2358">此编码将 `float32` 值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2358">This encoding pushes a `float32` value onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2359">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.r4` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2359">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r4` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2360">ILGenerator （操作码，single）</span><span class="sxs-lookup"><span data-stu-id="02415-2360">ILGenerator.Emit(OpCode, single)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2361">将所提供的 <see langword="float64" /> 类型的值作为 <see langword="F" /> (float) 类型推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2361">Pushes a supplied value of type <see langword="float64" /> onto the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2362">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2362">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2363">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2363">Format</span></span>|<span data-ttu-id="02415-2364">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2364">Assembly Format</span></span>|<span data-ttu-id="02415-2365">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2365">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2366">23 < `float64` ></span><span class="sxs-lookup"><span data-stu-id="02415-2366">23 < `float64` ></span></span>|<span data-ttu-id="02415-2367">ldc. r8 `num`</span><span class="sxs-lookup"><span data-stu-id="02415-2367">ldc.r8 `num`</span></span>|<span data-ttu-id="02415-2368">将 `num` 作为 `F`推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2368">Pushes `num` onto the stack as `F`.</span></span>|  
  
 <span data-ttu-id="02415-2369">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2369">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2370">`num` 的值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2370">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2371">此编码将 `float64` 值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2371">This encoding pushes a `float64` value onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2372">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldc.r8` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2372">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r8` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2373">ILGenerator （操作码，双精度）</span><span class="sxs-lookup"><span data-stu-id="02415-2373">ILGenerator.Emit(OpCode, double)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2374">按照指令中指定的类型，将指定数组索引中的元素加载到计算堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2374">Loads the element at a specified array index onto the top of the evaluation stack as the type specified in the instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2375">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2375">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2376">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2376">Format</span></span>|<span data-ttu-id="02415-2377">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2377">Assembly Format</span></span>|<span data-ttu-id="02415-2378">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2378">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2379">A3 < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-2379">A3 < `T` ></span></span>|<span data-ttu-id="02415-2380">ldelem `typeTok`</span><span class="sxs-lookup"><span data-stu-id="02415-2380">ldelem `typeTok`</span></span>|<span data-ttu-id="02415-2381">将 `index` 中的元素加载到堆栈顶部作为 `typeTok`类型。</span><span class="sxs-lookup"><span data-stu-id="02415-2381">Loads the element at `index` onto the top of the stack as type `typeTok`.</span></span>|  
  
 <span data-ttu-id="02415-2382">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2382">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2383">对象引用 `array` 被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2383">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2384">将 `index` 的索引值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2384">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-2385">从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的值。</span><span class="sxs-lookup"><span data-stu-id="02415-2385">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="02415-2386">值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2386">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2387">`ldelem` 指令在从零开始的一维 `array` 数组中加载具有索引 `index` （类型 `native int`）的元素的值，并将其放在堆栈顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2387">The `ldelem` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="02415-2388">数组是对象，因此由 `O`类型的值表示。</span><span class="sxs-lookup"><span data-stu-id="02415-2388">Arrays are objects, and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="02415-2389">返回值的类型由指令中的 `typeTok` 标记指定。</span><span class="sxs-lookup"><span data-stu-id="02415-2389">The type of the return value is specified by the token `typeTok` in the instruction.</span></span>  
  
 <span data-ttu-id="02415-2390">如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2390"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="02415-2391">如果 `index` 为负数或大于 `array`的上限，则会引发 <xref:System.IndexOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2391"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the upper bound of `array`.</span></span>  
  
 <span data-ttu-id="02415-2392">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelem` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2392">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2393">ILGenerator （OpCode，Type）</span><span class="sxs-lookup"><span data-stu-id="02415-2393">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2394">将位于指定数组索引处的 <see langword="native int" /> 类型的元素作为 <see langword="native int" /> 加载到计算堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2394">Loads the element with type <see langword="native int" /> at a specified array index onto the top of the evaluation stack as a <see langword="native int" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2395">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2395">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2396">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2396">Format</span></span>|<span data-ttu-id="02415-2397">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2397">Assembly Format</span></span>|<span data-ttu-id="02415-2398">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2398">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2399">97</span><span class="sxs-lookup"><span data-stu-id="02415-2399">97</span></span>|<span data-ttu-id="02415-2400">ldelem。 i</span><span class="sxs-lookup"><span data-stu-id="02415-2400">ldelem.i</span></span>|<span data-ttu-id="02415-2401">将 `index` 类型 `native int` 的元素作为 `native int`加载到堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2401">Loads the element with type `native int` at `index` onto the top of the stack as a `native int`.</span></span>|  
  
 <span data-ttu-id="02415-2402">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2402">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2403">对象引用 `array` 被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2403">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2404">将 `index` 的索引值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2404">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-2405">从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的值。</span><span class="sxs-lookup"><span data-stu-id="02415-2405">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="02415-2406">值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2406">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2407">`ldelem.i` 指令在从零开始的一维 `array` 数组中加载具有索引 `index` （类型 `native int`）的元素的值，并将其放在堆栈顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2407">The `ldelem.i` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="02415-2408">数组是对象，因此由 `O`类型的值表示。</span><span class="sxs-lookup"><span data-stu-id="02415-2408">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="02415-2409">`ldelem.i` 的返回值为 `native int`。</span><span class="sxs-lookup"><span data-stu-id="02415-2409">The return value for `ldelem.i` is `native int`.</span></span>  
  
 <span data-ttu-id="02415-2410">请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2410">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="02415-2411">如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2411"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="02415-2412">如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2412"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="02415-2413">如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2413"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="02415-2414">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelem.i` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2414">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2415">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2415">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2416">将位于指定数组索引处的 <see langword="int8" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2416">Loads the element with type <see langword="int8" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2417">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2417">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2418">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2418">Format</span></span>|<span data-ttu-id="02415-2419">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2419">Assembly Format</span></span>|<span data-ttu-id="02415-2420">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2420">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2421">90</span><span class="sxs-lookup"><span data-stu-id="02415-2421">90</span></span>|<span data-ttu-id="02415-2422">ldelem.i1</span><span class="sxs-lookup"><span data-stu-id="02415-2422">ldelem.i1</span></span>|<span data-ttu-id="02415-2423">将 `index` 类型 `int8` 的元素作为 `int32`加载到堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2423">Loads the element with type `int8` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="02415-2424">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2424">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2425">对象引用 `array` 被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2425">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2426">将 `index` 的索引值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2426">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-2427">从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的值。</span><span class="sxs-lookup"><span data-stu-id="02415-2427">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="02415-2428">值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2428">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2429">`ldelem.i1` 指令在从零开始的一维 `array` 数组中加载具有索引 `index` （类型 `native int`）的元素的值，并将其放在堆栈顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2429">The `ldelem.i1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="02415-2430">数组是对象，因此由 `O`类型的值表示。</span><span class="sxs-lookup"><span data-stu-id="02415-2430">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="02415-2431">`ldelem.i1` 的返回值为 `int8`。</span><span class="sxs-lookup"><span data-stu-id="02415-2431">The return value for `ldelem.i1` is `int8`.</span></span>  
  
 <span data-ttu-id="02415-2432">请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2432">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="02415-2433">如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2433"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="02415-2434">如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2434"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="02415-2435">如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2435"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="02415-2436">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelem.i1` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2436">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i1` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2437">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2437">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2438">将位于指定数组索引处的 <see langword="int16" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2438">Loads the element with type <see langword="int16" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2439">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2439">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2440">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2440">Format</span></span>|<span data-ttu-id="02415-2441">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2441">Assembly Format</span></span>|<span data-ttu-id="02415-2442">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2442">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2443">92</span><span class="sxs-lookup"><span data-stu-id="02415-2443">92</span></span>|<span data-ttu-id="02415-2444">ldelem.i2</span><span class="sxs-lookup"><span data-stu-id="02415-2444">ldelem.i2</span></span>|<span data-ttu-id="02415-2445">将 `index` 类型 `int16` 的元素作为 `int32`加载到堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2445">Loads the element with type `int16` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="02415-2446">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2446">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2447">对象引用 `array` 被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2447">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2448">将 `index` 的索引值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2448">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-2449">从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的值。</span><span class="sxs-lookup"><span data-stu-id="02415-2449">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="02415-2450">值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2450">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2451">`ldelem.i2` 指令在从零开始的一维 `array` 数组中加载具有索引 `index` （类型 `native int`）的元素的值，并将其放在堆栈顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2451">The `ldelem.i2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="02415-2452">数组是对象，因此由 `O`类型的值表示。</span><span class="sxs-lookup"><span data-stu-id="02415-2452">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="02415-2453">`ldelem.i2` 的返回值为 `int16`。</span><span class="sxs-lookup"><span data-stu-id="02415-2453">The return value for `ldelem.i2` is `int16`.</span></span>  
  
 <span data-ttu-id="02415-2454">请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2454">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="02415-2455">如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2455"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="02415-2456">如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2456"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="02415-2457">如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2457"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="02415-2458">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelem.i2` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2458">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i2` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2459">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2459">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2460">将位于指定数组索引处的 <see langword="int32" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2460">Loads the element with type <see langword="int32" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2461">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2461">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2462">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2462">Format</span></span>|<span data-ttu-id="02415-2463">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2463">Assembly Format</span></span>|<span data-ttu-id="02415-2464">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2464">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2465">94</span><span class="sxs-lookup"><span data-stu-id="02415-2465">94</span></span>|<span data-ttu-id="02415-2466">ldelem.i4</span><span class="sxs-lookup"><span data-stu-id="02415-2466">ldelem.i4</span></span>|<span data-ttu-id="02415-2467">将 `index` 类型 `int32` 的元素作为 `int32`加载到堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2467">Loads the element with type `int32` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="02415-2468">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2468">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2469">对象引用 `array` 被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2469">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2470">将 `index` 的索引值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2470">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-2471">从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的值。</span><span class="sxs-lookup"><span data-stu-id="02415-2471">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="02415-2472">值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2472">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2473">`ldelem.i4` 指令在从零开始的一维 `array` 数组中加载具有索引 `index` （类型 `native int`）的元素的值，并将其放在堆栈顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2473">The `ldelem.i4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="02415-2474">数组是对象，因此由 `O`类型的值表示。</span><span class="sxs-lookup"><span data-stu-id="02415-2474">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="02415-2475">`ldelem.i4` 的返回值为 `int32`。</span><span class="sxs-lookup"><span data-stu-id="02415-2475">The return value for `ldelem.i4` is `int32`.</span></span>  
  
 <span data-ttu-id="02415-2476">请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2476">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="02415-2477">如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2477"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="02415-2478">如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2478"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="02415-2479">如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2479"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="02415-2480">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelem.i4` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i4` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2481">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2481">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2482">将位于指定数组索引处的 <see langword="int64" /> 类型的元素作为 <see langword="int64" /> 加载到计算堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2482">Loads the element with type <see langword="int64" /> at a specified array index onto the top of the evaluation stack as an <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2483">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2484">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2484">Format</span></span>|<span data-ttu-id="02415-2485">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2485">Assembly Format</span></span>|<span data-ttu-id="02415-2486">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2487">96</span><span class="sxs-lookup"><span data-stu-id="02415-2487">96</span></span>|<span data-ttu-id="02415-2488">ldelem.i8</span><span class="sxs-lookup"><span data-stu-id="02415-2488">ldelem.i8</span></span>|<span data-ttu-id="02415-2489">将 `index` 类型 `int64` 的元素作为 `int64`加载到堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2489">Loads the element with type `int64` at `index` onto the top of the stack as an `int64`.</span></span>|  
  
 <span data-ttu-id="02415-2490">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2491">对象引用 `array` 被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2491">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2492">将 `index` 的索引值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2492">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-2493">从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的值。</span><span class="sxs-lookup"><span data-stu-id="02415-2493">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="02415-2494">值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2494">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2495">`ldelem.i8` 指令在从零开始的一维 `array` 数组中加载具有索引 `index` （类型 `native int`）的元素的值，并将其放在堆栈顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2495">The `ldelem.i8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="02415-2496">数组是对象，因此由 `O`类型的值表示。</span><span class="sxs-lookup"><span data-stu-id="02415-2496">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="02415-2497">`ldelem.i8` 的返回值为 `int64`。</span><span class="sxs-lookup"><span data-stu-id="02415-2497">The return value for `ldelem.i8` is `int64`.</span></span>  
  
 <span data-ttu-id="02415-2498">请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2498">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="02415-2499">如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2499"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="02415-2500">如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2500"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="02415-2501">如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2501"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="02415-2502">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelem.i8` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2502">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i8` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2503">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2503">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2504">将位于指定数组索引处的 <see langword="float32" /> 类型的元素作为 <see langword="F" /> 类型（浮点型）加载到计算堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2504">Loads the element with type <see langword="float32" /> at a specified array index onto the top of the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2505">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2505">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2506">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2506">Format</span></span>|<span data-ttu-id="02415-2507">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2507">Assembly Format</span></span>|<span data-ttu-id="02415-2508">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2508">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2509">98</span><span class="sxs-lookup"><span data-stu-id="02415-2509">98</span></span>|<span data-ttu-id="02415-2510">ldelem.r4</span><span class="sxs-lookup"><span data-stu-id="02415-2510">ldelem.r4</span></span>|<span data-ttu-id="02415-2511">将 `index` 类型 `float32` 的元素作为类型 `F`加载到堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2511">Loads the element with type `float32` at `index` onto the top of the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="02415-2512">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2512">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2513">对象引用 `array` 被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2513">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2514">将 `index` 的索引值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2514">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-2515">从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的值。</span><span class="sxs-lookup"><span data-stu-id="02415-2515">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="02415-2516">值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2516">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2517">`ldelem.r4` 指令在从零开始的一维 `array` 数组中加载具有索引 `index` （类型 `native int`）的元素的值，并将其放在堆栈顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2517">The `ldelem.r4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="02415-2518">数组是对象，因此由 `O`类型的值表示。</span><span class="sxs-lookup"><span data-stu-id="02415-2518">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="02415-2519">`ldelem.r4` 的返回值为 `float32`。</span><span class="sxs-lookup"><span data-stu-id="02415-2519">The return value for `ldelem.r4` is `float32`.</span></span>  
  
 <span data-ttu-id="02415-2520">将浮点值加载到计算堆栈上时，会将其转换为类型 `F`。</span><span class="sxs-lookup"><span data-stu-id="02415-2520">Floating-point values are converted to type `F` when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="02415-2521">如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2521"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="02415-2522">如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2522"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="02415-2523">如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2523"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="02415-2524">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelem.r4` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2524">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r4` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2525">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2525">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2526">将位于指定数组索引处的 <see langword="float64" /> 类型的元素作为 <see langword="F" /> 类型（浮点型）加载到计算堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2526">Loads the element with type <see langword="float64" /> at a specified array index onto the top of the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2527">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2527">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2528">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2528">Format</span></span>|<span data-ttu-id="02415-2529">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2529">Assembly Format</span></span>|<span data-ttu-id="02415-2530">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2530">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2531">99</span><span class="sxs-lookup"><span data-stu-id="02415-2531">99</span></span>|<span data-ttu-id="02415-2532">ldelem.r8</span><span class="sxs-lookup"><span data-stu-id="02415-2532">ldelem.r8</span></span>|<span data-ttu-id="02415-2533">将 `index` 类型 `float64` 的元素作为类型 `F`加载到堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2533">Loads the element with type `float64` at `index` onto the top of the stack as type `F`.</span></span>|  
  
 <span data-ttu-id="02415-2534">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2534">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2535">对象引用 `array` 被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2535">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2536">将 `index` 的索引值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2536">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-2537">从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的值。</span><span class="sxs-lookup"><span data-stu-id="02415-2537">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="02415-2538">值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2538">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2539">`ldelem.r8` 指令在从零开始的一维 `array` 数组中加载具有索引 `index` （类型 `native int`）的元素的值，并将其放在堆栈顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2539">The `ldelem.r8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="02415-2540">数组是对象，因此由 `O`类型的值表示。</span><span class="sxs-lookup"><span data-stu-id="02415-2540">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="02415-2541">`ldelem.r8` 的返回值为 `float64`。</span><span class="sxs-lookup"><span data-stu-id="02415-2541">The return value for `ldelem.r8` is `float64`.</span></span>  
  
 <span data-ttu-id="02415-2542">将浮点值加载到计算堆栈上时，会将其转换为类型 `F`。</span><span class="sxs-lookup"><span data-stu-id="02415-2542">Floating-point values are converted to type `F` when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="02415-2543">如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2543"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="02415-2544">如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2544"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="02415-2545">如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2545"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="02415-2546">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelem.r8` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2546">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r8` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2547">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2547">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2548">将位于指定数组索引处的包含对象引用的元素作为 <see langword="O" /> 类型（对象引用）加载到计算堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2548">Loads the element containing an object reference at a specified array index onto the top of the evaluation stack as type <see langword="O" /> (object reference).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2549">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2549">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2550">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2550">Format</span></span>|<span data-ttu-id="02415-2551">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2551">Assembly Format</span></span>|<span data-ttu-id="02415-2552">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2552">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2553">9A</span><span class="sxs-lookup"><span data-stu-id="02415-2553">9A</span></span>|<span data-ttu-id="02415-2554">ldelem.ref</span><span class="sxs-lookup"><span data-stu-id="02415-2554">ldelem.ref</span></span>|<span data-ttu-id="02415-2555">将具有对象引用的元素作为 `O`的类型加载到堆栈顶部 `index`。</span><span class="sxs-lookup"><span data-stu-id="02415-2555">Loads the element with an object reference at `index` onto the top of the stack as type `O`.</span></span>|  
  
 <span data-ttu-id="02415-2556">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2556">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2557">对象引用 `array` 被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2557">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2558">将 `index` 的索引值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2558">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-2559">从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的值。</span><span class="sxs-lookup"><span data-stu-id="02415-2559">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="02415-2560">值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2560">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2561">`ldelem.ref` 指令在从零开始的一维 `array` 数组中加载具有索引 `index` （类型 `native int`）的元素的值，并将其放在堆栈顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2561">The `ldelem.ref` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="02415-2562">数组是对象，因此由 `O`类型的值表示。</span><span class="sxs-lookup"><span data-stu-id="02415-2562">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="02415-2563">`ldelem.ref` 的返回值为类型 `O` （对象引用）。</span><span class="sxs-lookup"><span data-stu-id="02415-2563">The return value for `ldelem.ref` is type `O` (object reference).</span></span>  
  
 <span data-ttu-id="02415-2564">如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2564"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="02415-2565">如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2565"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="02415-2566">如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2566"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="02415-2567">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelem.ref` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2567">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.ref` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2568">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2568">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2569">将位于指定数组索引处的 <see langword="unsigned int8" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2569">Loads the element with type <see langword="unsigned int8" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2570">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2570">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2571">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2571">Format</span></span>|<span data-ttu-id="02415-2572">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2572">Assembly Format</span></span>|<span data-ttu-id="02415-2573">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2573">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2574">91</span><span class="sxs-lookup"><span data-stu-id="02415-2574">91</span></span>|<span data-ttu-id="02415-2575">ldelem.u1</span><span class="sxs-lookup"><span data-stu-id="02415-2575">ldelem.u1</span></span>|<span data-ttu-id="02415-2576">将 `index` 类型 `unsigned int8` 的元素作为 `int32`加载到堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2576">Loads the element with type `unsigned int8` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="02415-2577">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2577">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2578">对象引用 `array` 被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2578">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2579">将 `index` 的索引值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2579">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-2580">从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的值。</span><span class="sxs-lookup"><span data-stu-id="02415-2580">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="02415-2581">值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2581">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2582">`ldelem.u1` 指令在从零开始的一维 `array` 数组中加载具有索引 `index` （类型 `native int`）的元素的值，并将其放在堆栈顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2582">The `ldelem.u1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="02415-2583">数组是对象，因此由 `O`类型的值表示。</span><span class="sxs-lookup"><span data-stu-id="02415-2583">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="02415-2584">`ldelem.u1` 的返回值为 `int8`。</span><span class="sxs-lookup"><span data-stu-id="02415-2584">The return value for `ldelem.u1` is `int8`.</span></span>  
  
 <span data-ttu-id="02415-2585">请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2585">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="02415-2586">如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2586"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="02415-2587">如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2587"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="02415-2588">如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2588"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="02415-2589">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelem.u1` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2589">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u1` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2590">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2590">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2591">将位于指定数组索引处的 <see langword="unsigned int16" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2591">Loads the element with type <see langword="unsigned int16" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2592">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2592">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2593">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2593">Format</span></span>|<span data-ttu-id="02415-2594">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2594">Assembly Format</span></span>|<span data-ttu-id="02415-2595">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2595">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2596">93</span><span class="sxs-lookup"><span data-stu-id="02415-2596">93</span></span>|<span data-ttu-id="02415-2597">ldelem.u2</span><span class="sxs-lookup"><span data-stu-id="02415-2597">ldelem.u2</span></span>|<span data-ttu-id="02415-2598">将索引中类型 `unsigned int16` 的元素作为 `int32`加载到堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2598">Loads the element with type `unsigned int16` at index onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="02415-2599">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2599">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2600">对象引用 `array` 被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2600">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2601">将 `index` 的索引值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2601">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-2602">从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的值。</span><span class="sxs-lookup"><span data-stu-id="02415-2602">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="02415-2603">值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2603">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2604">`ldelem.u2` 指令在从零开始的一维 `array` 数组中加载具有索引 `index` （类型 `native int`）的元素的值，并将其放在堆栈顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2604">The `ldelem.u2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="02415-2605">数组是对象，因此由 `O`类型的值表示。</span><span class="sxs-lookup"><span data-stu-id="02415-2605">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="02415-2606">`ldelem.u2` 的返回值为 `int16`。</span><span class="sxs-lookup"><span data-stu-id="02415-2606">The return value for `ldelem.u2` is `int16`.</span></span>  
  
 <span data-ttu-id="02415-2607">请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2607">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="02415-2608">如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2608"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="02415-2609">如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2609"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="02415-2610">如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2610"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="02415-2611">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelem.u2` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2611">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u2` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2612">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2612">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2613">将位于指定数组索引处的 <see langword="unsigned int32" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2613">Loads the element with type <see langword="unsigned int32" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2614">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2614">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2615">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2615">Format</span></span>|<span data-ttu-id="02415-2616">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2616">Assembly Format</span></span>|<span data-ttu-id="02415-2617">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2617">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2618">95</span><span class="sxs-lookup"><span data-stu-id="02415-2618">95</span></span>|<span data-ttu-id="02415-2619">ldelem.u4</span><span class="sxs-lookup"><span data-stu-id="02415-2619">ldelem.u4</span></span>|<span data-ttu-id="02415-2620">将索引中类型 `unsigned int32` 的元素作为 `int32`加载到堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2620">Loads the element with type `unsigned int32` at index onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="02415-2621">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2621">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2622">对象引用 `array` 被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2622">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2623">将 `index` 的索引值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2623">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-2624">从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的值。</span><span class="sxs-lookup"><span data-stu-id="02415-2624">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="02415-2625">值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2625">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2626">`ldelem.u4` 指令在从零开始的一维 `array` 数组中加载具有索引 `index` （类型 `native int`）的元素的值，并将其放在堆栈顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2626">The `ldelem.u4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="02415-2627">数组是对象，因此由 `O`类型的值表示。</span><span class="sxs-lookup"><span data-stu-id="02415-2627">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="02415-2628">`ldelem.u4` 的返回值为 `int32`。</span><span class="sxs-lookup"><span data-stu-id="02415-2628">The return value for `ldelem.u4` is `int32`.</span></span>  
  
 <span data-ttu-id="02415-2629">请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2629">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="02415-2630">如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2630"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="02415-2631">如果数组不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2631"><xref:System.ArrayTypeMismatchException> is thrown if array does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="02415-2632">如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2632"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="02415-2633">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelem.u4` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2633">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u4` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2634">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2634">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2635">将位于指定数组索引的数组元素的地址作为 <see langword="&amp;" /> 类型（托管指针）加载到计算堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2635">Loads the address of the array element at a specified array index onto the top of the evaluation stack as type <see langword="&amp;" /> (managed pointer).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2636">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2636">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2637">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2637">Format</span></span>|<span data-ttu-id="02415-2638">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2638">Assembly Format</span></span>|<span data-ttu-id="02415-2639">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2639">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2640">8F < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-2640">8F < `T` ></span></span>|<span data-ttu-id="02415-2641">ldelema `class`</span><span class="sxs-lookup"><span data-stu-id="02415-2641">ldelema `class`</span></span>|<span data-ttu-id="02415-2642">将 `index` 上数组元素的地址作为类型 `&` （托管指针）加载到计算堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2642">Loads the address of the array element at `index` onto the top of the evaluation stack as type `&` (managed pointer).</span></span>|  
  
 <span data-ttu-id="02415-2643">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2643">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2644">对象引用 `array` 被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2644">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2645">将 `index` 的索引值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2645">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-2646">从堆栈中弹出 `index` 和 `array`;查找 `array` 中 `index` 位置上存储的地址。</span><span class="sxs-lookup"><span data-stu-id="02415-2646">`index` and `array` are popped from the stack; the address stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="02415-2647">该地址将被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2647">The address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2648">`ldelema` 用于检索对象数组（类型 `class`）中特定索引处的对象的地址。</span><span class="sxs-lookup"><span data-stu-id="02415-2648">The `ldelema` is used to retrieve the address of an object at a particular index in an array of objects (of type `class`).</span></span> <span data-ttu-id="02415-2649">`ldelema` 指令会在从零开始的一维 `array` 数组中的索引 `index` （类型 `native int`）处加载值的地址，并将其放在堆栈顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-2649">The `ldelema` instruction loads the address of the value at index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="02415-2650">数组是对象，因此由 `O`类型的值表示。</span><span class="sxs-lookup"><span data-stu-id="02415-2650">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="02415-2651">该值必须是随指令传递 `class` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-2651">The value must be of type `class` passed with the instruction.</span></span>  
  
 <span data-ttu-id="02415-2652">`ldelema` 的返回值为托管指针（类型 `&`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2652">The return value for `ldelema` is a managed pointer (type `&`).</span></span>  
  
 <span data-ttu-id="02415-2653">请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2653">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="02415-2654">如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2654"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="02415-2655">如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2655"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="02415-2656">如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2656"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="02415-2657">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldelema` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2657">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelema` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2658">ILGenerator （OpCode，Type）</span><span class="sxs-lookup"><span data-stu-id="02415-2658">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2659">查找对象中其引用当前位于计算堆栈的字段的值。</span><span class="sxs-lookup"><span data-stu-id="02415-2659">Finds the value of a field in the object whose reference is currently on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2660">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2660">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2661">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2661">Format</span></span>|<span data-ttu-id="02415-2662">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2662">Assembly Format</span></span>|<span data-ttu-id="02415-2663">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2663">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2664">7B < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-2664">7B < `T` ></span></span>|<span data-ttu-id="02415-2665">ldfld `field`</span><span class="sxs-lookup"><span data-stu-id="02415-2665">ldfld `field`</span></span>|<span data-ttu-id="02415-2666">将指定对象中的字段的值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2666">Pushes the value of a field in a specified object onto the stack.</span></span>|  
  
 <span data-ttu-id="02415-2667">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2667">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2668">对象引用（或指针）被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2668">An object reference (or pointer) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2669">从堆栈中弹出对象引用（或指针）;找到对象中指定字段的值。</span><span class="sxs-lookup"><span data-stu-id="02415-2669">The object reference (or pointer) is popped from the stack; the value of the specified field in the object is found.</span></span>  
  
3.  <span data-ttu-id="02415-2670">存储在字段中的值将被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2670">The value stored in the field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2671">`ldfld` 指令将位于对象中的字段的值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2671">The `ldfld` instruction pushes the value of a field located in an object onto the stack.</span></span> <span data-ttu-id="02415-2672">对象必须位于堆栈上以作为对象引用（类型 `O`）、托管指针（类型 `&`）、非托管指针（类型 `native int`）、暂时性指针（类型 `*`）或值类型的实例。</span><span class="sxs-lookup"><span data-stu-id="02415-2672">The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type.</span></span> <span data-ttu-id="02415-2673">可验证代码中不允许使用非托管指针。</span><span class="sxs-lookup"><span data-stu-id="02415-2673">The use of an unmanaged pointer is not permitted in verifiable code.</span></span> <span data-ttu-id="02415-2674">对象的字段由必须引用字段成员的元数据标记指定。</span><span class="sxs-lookup"><span data-stu-id="02415-2674">The object's field is specified by a metadata token that must refer to a field member.</span></span> <span data-ttu-id="02415-2675">返回类型与字段关联的类型相同。</span><span class="sxs-lookup"><span data-stu-id="02415-2675">The return type is the same as the one associated with the field.</span></span> <span data-ttu-id="02415-2676">字段可以是实例字段（在这种情况下，对象不得为空引用）或静态字段。</span><span class="sxs-lookup"><span data-stu-id="02415-2676">The field may be either an instance field (in which case the object must not be a null reference) or a static field.</span></span>  
  
 <span data-ttu-id="02415-2677">`ldfld` 指令前面可以是 <xref:System.Reflection.Emit.OpCodes.Unaligned> 和/或 <xref:System.Reflection.Emit.OpCodes.Volatile> 前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-2677">The `ldfld` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.</span></span>  
  
 <span data-ttu-id="02415-2678">如果对象为 null，并且该字段不是静态的，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2678"><xref:System.NullReferenceException> is thrown if the object is null and the field is not static.</span></span>  
  
 <span data-ttu-id="02415-2679">如果在元数据中找不到指定的字段，则会引发 <xref:System.MissingFieldException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2679"><xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata.</span></span> <span data-ttu-id="02415-2680">当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是在运行时，通常会检查此情况。</span><span class="sxs-lookup"><span data-stu-id="02415-2680">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="02415-2681">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldfld` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2681">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldfld` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2682">ILGenerator （OpCode，FieldInfo）</span><span class="sxs-lookup"><span data-stu-id="02415-2682">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2683">查找对象中其引用当前位于计算堆栈的字段的地址。</span><span class="sxs-lookup"><span data-stu-id="02415-2683">Finds the address of a field in the object whose reference is currently on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2684">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2684">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2685">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2685">Format</span></span>|<span data-ttu-id="02415-2686">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2686">Assembly Format</span></span>|<span data-ttu-id="02415-2687">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2687">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2688">7C < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-2688">7C < `T` ></span></span>|<span data-ttu-id="02415-2689">ldflda `field`</span><span class="sxs-lookup"><span data-stu-id="02415-2689">ldflda `field`</span></span>|<span data-ttu-id="02415-2690">将指定对象中的 `field` 的地址推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2690">Pushes the address of `field` in a specified object onto the stack.</span></span>|  
  
 <span data-ttu-id="02415-2691">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2691">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2692">对象引用（或指针）被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2692">An object reference (or pointer) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2693">从堆栈中弹出对象引用（或指针）;找到对象中指定字段的地址。</span><span class="sxs-lookup"><span data-stu-id="02415-2693">The object reference (or pointer) is popped from the stack; the address of the specified field in the object is found.</span></span>  
  
3.  <span data-ttu-id="02415-2694">指定字段的地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2694">The address of the specified field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2695">`ldflda` 指令将位于对象中的字段的地址推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2695">The `ldflda` instruction pushes the address of a field located in an object onto the stack.</span></span> <span data-ttu-id="02415-2696">对象必须位于堆栈上以作为对象引用（类型 `O`）、托管指针（类型 `&`）、非托管指针（类型 `native int`）、暂时性指针（类型 `*`）或值类型的实例。</span><span class="sxs-lookup"><span data-stu-id="02415-2696">The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type.</span></span> <span data-ttu-id="02415-2697">可验证代码中不允许使用非托管指针。</span><span class="sxs-lookup"><span data-stu-id="02415-2697">The use of an unmanaged pointer is not permitted in verifiable code.</span></span> <span data-ttu-id="02415-2698">对象的字段由必须引用字段成员的元数据标记指定。</span><span class="sxs-lookup"><span data-stu-id="02415-2698">The object's field is specified by a metadata token that must refer to a field member.</span></span>  
  
 <span data-ttu-id="02415-2699">`ldflda` 返回的值是托管指针（类型 `&`），除非将该对象作为非托管指针推送到堆栈上，在这种情况下，返回地址也是非托管指针（类型 `native int`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2699">The value returned by `ldflda` is a managed pointer (type `&`) unless the object is pushed onto the stack as an unmanaged pointer, in which case the return address is also an unmanaged pointer (type `native int`).</span></span>  
  
 <span data-ttu-id="02415-2700">`ldflda` 指令前面可以是 <xref:System.Reflection.Emit.OpCodes.Unaligned> 和/或 <xref:System.Reflection.Emit.OpCodes.Volatile> 前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-2700">The `ldflda` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.</span></span>  
  
 <span data-ttu-id="02415-2701">如果对象不在从中访问它的应用程序域中，则会引发 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2701"><xref:System.InvalidOperationException> is thrown if the object is not within the application domain from which it is being accessed.</span></span> <span data-ttu-id="02415-2702">不在访问应用程序域中的字段的地址无法加载。</span><span class="sxs-lookup"><span data-stu-id="02415-2702">The address of a field that is not inside the accessing application domain cannot be loaded.</span></span>  
  
 <span data-ttu-id="02415-2703">如果对象为 null，并且该字段不是静态的，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2703"><xref:System.NullReferenceException> is thrown if the object is null and the field is not static.</span></span>  
  
 <span data-ttu-id="02415-2704">如果在元数据中找不到指定的字段，则会引发 <xref:System.MissingFieldException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2704"><xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata.</span></span> <span data-ttu-id="02415-2705">当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是在运行时，通常会检查此情况。</span><span class="sxs-lookup"><span data-stu-id="02415-2705">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="02415-2706">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldflda` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2706">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldflda` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2707">ILGenerator （OpCode，FieldInfo）</span><span class="sxs-lookup"><span data-stu-id="02415-2707">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2708">将指向实现特定方法的本机代码的非托管指针（<see langword="native int" /> 类型）推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2708">Pushes an unmanaged pointer (type <see langword="native int" />) to the native code implementing a specific method onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2709">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2709">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2710">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2710">Format</span></span>|<span data-ttu-id="02415-2711">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2711">Assembly Format</span></span>|<span data-ttu-id="02415-2712">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2712">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2713">FE 06 < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-2713">FE 06 < `T` ></span></span>|<span data-ttu-id="02415-2714">ldftn `method`</span><span class="sxs-lookup"><span data-stu-id="02415-2714">ldftn `method`</span></span>|<span data-ttu-id="02415-2715">将指向 `method` 引用的方法的指针推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2715">Pushes a pointer to a method referenced by `method` on the stack.</span></span>|  
  
 <span data-ttu-id="02415-2716">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2716">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2717">指向特定方法的非托管指针将被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2717">The unmanaged pointer to a specific method is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2718">如果特定方法（`method`）引用托管方法（或从托管代码转换为非托管代码的存根），则可以使用 <xref:System.Reflection.Emit.OpCodes.Calli> 指令进行调用。</span><span class="sxs-lookup"><span data-stu-id="02415-2718">The specific method (`method`) can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</span></span>  
  
 <span data-ttu-id="02415-2719">返回的值指向使用 CLR 调用约定的本机代码。</span><span class="sxs-lookup"><span data-stu-id="02415-2719">The value returned points to native code using the CLR calling convention.</span></span> <span data-ttu-id="02415-2720">此方法指针不应作为回调例程传递到非托管的本机代码。</span><span class="sxs-lookup"><span data-stu-id="02415-2720">This method pointer should not be passed to unmanaged native code as a callback routine.</span></span>  
  
 <span data-ttu-id="02415-2721">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldftn` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2721">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldftn` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2722">ILGenerator （操作码，MethodInfo）</span><span class="sxs-lookup"><span data-stu-id="02415-2722">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2723">将 <see langword="native int" /> 类型的值作为 <see langword="native int" /> 间接加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2723">Loads a value of type <see langword="native int" /> as a <see langword="native int" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2724">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2724">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2725">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2725">Format</span></span>|<span data-ttu-id="02415-2726">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2726">Assembly Format</span></span>|<span data-ttu-id="02415-2727">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2727">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2728">4D</span><span class="sxs-lookup"><span data-stu-id="02415-2728">4D</span></span>|<span data-ttu-id="02415-2729">ldind。 i</span><span class="sxs-lookup"><span data-stu-id="02415-2729">ldind.i</span></span>|<span data-ttu-id="02415-2730">将位于地址 `addr` 的 `native int` 值作为 `native int`加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2730">Loads the `native int` value at address `addr` onto the stack as a `native int`.</span></span>|  
  
 <span data-ttu-id="02415-2731">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2731">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2732">地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2732">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2733">从堆栈中弹出该地址;获取位于地址的值。</span><span class="sxs-lookup"><span data-stu-id="02415-2733">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="02415-2734">提取的值被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2734">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2735">`ldind.i` 指令将指定地址（类型 `native int`、`&`或 \*）的 `native int` 值作为 `native int`间接加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2735">The `ldind.i` instruction indirectly loads a `native int` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a `native int`.</span></span>  
  
 <span data-ttu-id="02415-2736">所有 `ldind` 说明都是指定相应内置值类的 <xref:System.Reflection.Emit.OpCodes.Ldobj> 指令的快捷方式。</span><span class="sxs-lookup"><span data-stu-id="02415-2736">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="02415-2737">请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2737">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="02415-2738">将浮点值加载到计算堆栈上时，会将其转换为 `F` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-2738">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="02415-2739">格式正确的 Microsoft 中间语言（MSIL）确保以与指针类型一致的方式使用 `ldind` 指令。</span><span class="sxs-lookup"><span data-stu-id="02415-2739">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="02415-2740">最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐，否则可能会出现 <xref:System.NullReferenceException> （请参阅针对预防措施的 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀说明）。</span><span class="sxs-lookup"><span data-stu-id="02415-2740">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="02415-2741">返回地址的所有 MSIL 指令的结果（例如 <xref:System.Reflection.Emit.OpCodes.Ldloca> 和 <xref:System.Reflection.Emit.OpCodes.Ldarga>）都安全对齐。</span><span class="sxs-lookup"><span data-stu-id="02415-2741">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="02415-2742">对于大于1个字节的数据类型，字节排序依赖于目标 CPU。</span><span class="sxs-lookup"><span data-stu-id="02415-2742">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="02415-2743">依赖于字节排序的代码可能无法在所有平台上运行。</span><span class="sxs-lookup"><span data-stu-id="02415-2743">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="02415-2744">如果检测到无效地址，则可能引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2744"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="02415-2745">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldind.i` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2745">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2746">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2746">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2747">将 <see langword="int8" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2747">Loads a value of type <see langword="int8" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2748">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2748">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2749">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2749">Format</span></span>|<span data-ttu-id="02415-2750">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2750">Assembly Format</span></span>|<span data-ttu-id="02415-2751">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2751">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2752">46</span><span class="sxs-lookup"><span data-stu-id="02415-2752">46</span></span>|<span data-ttu-id="02415-2753">ldind</span><span class="sxs-lookup"><span data-stu-id="02415-2753">ldind.i1</span></span>|<span data-ttu-id="02415-2754">将位于地址 `addr` 的 `int8` 值作为 `int32`加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2754">Loads the `int8` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="02415-2755">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2755">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2756">地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2756">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2757">从堆栈中弹出该地址;获取位于地址的值。</span><span class="sxs-lookup"><span data-stu-id="02415-2757">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="02415-2758">提取的值被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2758">The fetched value is pushed onto the stack.</span></span> 
  
 <span data-ttu-id="02415-2759">`ldind.i1` 指令将指定地址（类型 `native int`、`&`或 \*）的 `int8` 值作为 `int32`间接加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2759">The `ldind.i1` instruction indirectly loads an `int8` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="02415-2760">所有 `ldind` 说明都是指定相应内置值类的 <xref:System.Reflection.Emit.OpCodes.Ldobj> 指令的快捷方式。</span><span class="sxs-lookup"><span data-stu-id="02415-2760">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="02415-2761">请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2761">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="02415-2762">将浮点值加载到计算堆栈上时，会将其转换为 `F` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-2762">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="02415-2763">格式正确的 Microsoft 中间语言（MSIL）确保以与指针类型一致的方式使用 `ldind` 指令。</span><span class="sxs-lookup"><span data-stu-id="02415-2763">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="02415-2764">最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐，否则可能会出现 <xref:System.NullReferenceException> （请参阅针对预防措施的 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀说明）。</span><span class="sxs-lookup"><span data-stu-id="02415-2764">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="02415-2765">返回地址的所有 MSIL 指令的结果（例如 <xref:System.Reflection.Emit.OpCodes.Ldloca> 和 <xref:System.Reflection.Emit.OpCodes.Ldarga>）都安全对齐。</span><span class="sxs-lookup"><span data-stu-id="02415-2765">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="02415-2766">对于大于1个字节的数据类型，字节排序依赖于目标 CPU。</span><span class="sxs-lookup"><span data-stu-id="02415-2766">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="02415-2767">依赖于字节排序的代码可能无法在所有平台上运行。</span><span class="sxs-lookup"><span data-stu-id="02415-2767">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="02415-2768">如果检测到无效地址，则可能引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2768"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="02415-2769">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldind.i1` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2769">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i1` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2770">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2770">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2771">将 <see langword="int16" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2771">Loads a value of type <see langword="int16" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2772">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2772">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2773">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2773">Format</span></span>|<span data-ttu-id="02415-2774">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2774">Assembly Format</span></span>|<span data-ttu-id="02415-2775">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2775">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2776">48</span><span class="sxs-lookup"><span data-stu-id="02415-2776">48</span></span>|<span data-ttu-id="02415-2777">ldind</span><span class="sxs-lookup"><span data-stu-id="02415-2777">ldind.i2</span></span>|<span data-ttu-id="02415-2778">将位于地址 `addr` 的 `int16` 值作为 `int32`加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2778">Loads the `int16` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="02415-2779">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2779">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2780">地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2780">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2781">从堆栈中弹出该地址;获取位于地址的值。</span><span class="sxs-lookup"><span data-stu-id="02415-2781">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="02415-2782">提取的值被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2782">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2783">`ldind.i2` 指令将指定地址（类型 `native int`、`&`或 \*）的 `int16` 值作为 `int32`间接加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2783">The `ldind.i2` instruction indirectly loads an `int16` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="02415-2784">所有 `ldind` 说明都是指定相应内置值类的 <xref:System.Reflection.Emit.OpCodes.Ldobj> 指令的快捷方式。</span><span class="sxs-lookup"><span data-stu-id="02415-2784">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="02415-2785">请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2785">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="02415-2786">将浮点值加载到计算堆栈上时，会将其转换为 `F` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-2786">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="02415-2787">格式正确的 Microsoft 中间语言（MSIL）确保以与指针类型一致的方式使用 `ldind` 指令。</span><span class="sxs-lookup"><span data-stu-id="02415-2787">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="02415-2788">最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐，否则可能会出现 <xref:System.NullReferenceException> （请参阅针对预防措施的 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀说明）。</span><span class="sxs-lookup"><span data-stu-id="02415-2788">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="02415-2789">返回地址的所有 MSIL 指令的结果（例如 <xref:System.Reflection.Emit.OpCodes.Ldloca> 和 <xref:System.Reflection.Emit.OpCodes.Ldarga>）都安全对齐。</span><span class="sxs-lookup"><span data-stu-id="02415-2789">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="02415-2790">对于大于1个字节的数据类型，字节排序依赖于目标 CPU。</span><span class="sxs-lookup"><span data-stu-id="02415-2790">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="02415-2791">依赖于字节排序的代码可能无法在所有平台上运行。</span><span class="sxs-lookup"><span data-stu-id="02415-2791">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="02415-2792">如果检测到无效地址，则可能引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2792"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="02415-2793">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldind.i2` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2793">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i2` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2794">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2794">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2795">将 <see langword="int32" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2795">Loads a value of type <see langword="int32" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2796">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2796">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2797">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2797">Format</span></span>|<span data-ttu-id="02415-2798">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2798">Assembly Format</span></span>|<span data-ttu-id="02415-2799">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2799">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2800">4A</span><span class="sxs-lookup"><span data-stu-id="02415-2800">4A</span></span>|<span data-ttu-id="02415-2801">ldind. i4</span><span class="sxs-lookup"><span data-stu-id="02415-2801">ldind.i4</span></span>|<span data-ttu-id="02415-2802">将位于地址 `addr` 的 `int32` 值作为 `int32`加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2802">Loads the `int32` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="02415-2803">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2803">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2804">地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2804">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2805">从堆栈中弹出该地址;获取位于地址的值。</span><span class="sxs-lookup"><span data-stu-id="02415-2805">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="02415-2806">提取的值被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2806">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2807">`ldind.i4` 指令将指定地址（类型 `native int`、`&`或 \*）的 `int32` 值作为 `int32`间接加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2807">The `ldind.i4` instruction indirectly loads an `int32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="02415-2808">所有 `ldind` 说明都是指定相应内置值类的 <xref:System.Reflection.Emit.OpCodes.Ldobj> 指令的快捷方式。</span><span class="sxs-lookup"><span data-stu-id="02415-2808">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="02415-2809">请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2809">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="02415-2810">将浮点值加载到计算堆栈上时，会将其转换为 `F` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-2810">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="02415-2811">格式正确的 Microsoft 中间语言（MSIL）确保以与指针类型一致的方式使用 `ldind` 指令。</span><span class="sxs-lookup"><span data-stu-id="02415-2811">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="02415-2812">最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐，否则可能会出现 <xref:System.NullReferenceException> （请参阅针对预防措施的 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀说明）。</span><span class="sxs-lookup"><span data-stu-id="02415-2812">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="02415-2813">返回地址的所有 MSIL 指令的结果（例如 <xref:System.Reflection.Emit.OpCodes.Ldloca> 和 <xref:System.Reflection.Emit.OpCodes.Ldarga>）都安全对齐。</span><span class="sxs-lookup"><span data-stu-id="02415-2813">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="02415-2814">对于大于1个字节的数据类型，字节排序依赖于目标 CPU。</span><span class="sxs-lookup"><span data-stu-id="02415-2814">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="02415-2815">依赖于字节排序的代码可能无法在所有平台上运行。</span><span class="sxs-lookup"><span data-stu-id="02415-2815">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="02415-2816">如果检测到无效地址，则可能引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2816"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="02415-2817">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldind.i4` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2817">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i4` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2818">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2818">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2819">将 <see langword="int64" /> 类型的值作为 <see langword="int64" /> 间接加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2819">Loads a value of type <see langword="int64" /> as an <see langword="int64" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2820">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2820">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2821">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2821">Format</span></span>|<span data-ttu-id="02415-2822">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2822">Assembly Format</span></span>|<span data-ttu-id="02415-2823">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2823">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2824">4C</span><span class="sxs-lookup"><span data-stu-id="02415-2824">4C</span></span>|<span data-ttu-id="02415-2825">ldind. i8</span><span class="sxs-lookup"><span data-stu-id="02415-2825">ldind.i8</span></span>|<span data-ttu-id="02415-2826">将位于地址 `addr` 的 `int64` 值作为 `int64`加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2826">Loads the `int64` value at address `addr` onto the stack as an `int64`.</span></span>|  
  
 <span data-ttu-id="02415-2827">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2827">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2828">地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2828">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2829">从堆栈中弹出该地址;获取位于地址的值。</span><span class="sxs-lookup"><span data-stu-id="02415-2829">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="02415-2830">提取的值被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2830">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2831">`ldind.i8` 指令将指定地址（类型 `native int`、`&`或 \*）的 `int64` 值作为 `int64`间接加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2831">The `ldind.i8` instruction indirectly loads an `int64` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int64`.</span></span>  
  
 <span data-ttu-id="02415-2832">所有 `ldind` 说明都是指定相应内置值类的 <xref:System.Reflection.Emit.OpCodes.Ldobj> 指令的快捷方式。</span><span class="sxs-lookup"><span data-stu-id="02415-2832">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="02415-2833">请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2833">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="02415-2834">将浮点值加载到计算堆栈上时，会将其转换为 `F` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-2834">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="02415-2835">格式正确的 Microsoft 中间语言（MSIL）确保以与指针类型一致的方式使用 `ldind` 指令。</span><span class="sxs-lookup"><span data-stu-id="02415-2835">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="02415-2836">最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐，否则可能会出现 <xref:System.NullReferenceException> （请参阅针对预防措施的 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀说明）。</span><span class="sxs-lookup"><span data-stu-id="02415-2836">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="02415-2837">返回地址的所有 MSIL 指令的结果（例如 <xref:System.Reflection.Emit.OpCodes.Ldloca> 和 <xref:System.Reflection.Emit.OpCodes.Ldarga>）都安全对齐。</span><span class="sxs-lookup"><span data-stu-id="02415-2837">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="02415-2838">对于大于1个字节的数据类型，字节排序依赖于目标 CPU。</span><span class="sxs-lookup"><span data-stu-id="02415-2838">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="02415-2839">依赖于字节排序的代码可能无法在所有平台上运行。</span><span class="sxs-lookup"><span data-stu-id="02415-2839">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="02415-2840">如果检测到无效地址，则可能引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2840"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="02415-2841">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldind.i8` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2841">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i8` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2842">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2842">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2843">将 <see langword="float32" /> 类型的值作为 <see langword="F" /> (float) 类型间接加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2843">Loads a value of type <see langword="float32" /> as a type <see langword="F" /> (float) onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2844">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2844">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2845">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2845">Format</span></span>|<span data-ttu-id="02415-2846">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2846">Assembly Format</span></span>|<span data-ttu-id="02415-2847">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2847">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2848">4E</span><span class="sxs-lookup"><span data-stu-id="02415-2848">4E</span></span>|<span data-ttu-id="02415-2849">ldind. r4</span><span class="sxs-lookup"><span data-stu-id="02415-2849">ldind.r4</span></span>|<span data-ttu-id="02415-2850">将位于地址 `addr` 的 `float32` 值作为类型 `F`加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2850">Loads the `float32` value at address `addr` onto the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="02415-2851">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2851">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2852">地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2852">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2853">从堆栈中弹出该地址;获取位于地址的值。</span><span class="sxs-lookup"><span data-stu-id="02415-2853">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="02415-2854">提取的值被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2854">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2855">`ldind.r4` 指令将指定地址（类型 `native int`、`&`或 \*）的 `float32` 值作为类型 `F`间接加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2855">The `ldind.r4` instruction indirectly loads a `float32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a type `F`.</span></span>  
  
 <span data-ttu-id="02415-2856">所有 `ldind` 说明都是指定相应内置值类的 <xref:System.Reflection.Emit.OpCodes.Ldobj> 指令的快捷方式。</span><span class="sxs-lookup"><span data-stu-id="02415-2856">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="02415-2857">请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2857">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="02415-2858">将浮点值加载到计算堆栈上时，会将其转换为 `F` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-2858">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="02415-2859">格式正确的 Microsoft 中间语言（MSIL）确保以与指针类型一致的方式使用 `ldind` 指令。</span><span class="sxs-lookup"><span data-stu-id="02415-2859">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="02415-2860">最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐，否则可能会出现 <xref:System.NullReferenceException> （请参阅针对预防措施的 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀说明）。</span><span class="sxs-lookup"><span data-stu-id="02415-2860">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="02415-2861">返回地址的所有 MSIL 指令的结果（例如 <xref:System.Reflection.Emit.OpCodes.Ldloca> 和 <xref:System.Reflection.Emit.OpCodes.Ldarga>）都安全对齐。</span><span class="sxs-lookup"><span data-stu-id="02415-2861">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="02415-2862">对于大于1个字节的数据类型，字节排序依赖于目标 CPU。</span><span class="sxs-lookup"><span data-stu-id="02415-2862">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="02415-2863">依赖于字节排序的代码可能无法在所有平台上运行。</span><span class="sxs-lookup"><span data-stu-id="02415-2863">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="02415-2864">如果检测到无效地址，则可能引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2864"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="02415-2865">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldind.r4` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2865">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r4` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2866">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2866">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2867">将 <see langword="float64" /> 类型的值作为 <see langword="F" /> (float) 类型间接加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2867">Loads a value of type <see langword="float64" /> as a type <see langword="F" /> (float) onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2868">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2868">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2869">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2869">Format</span></span>|<span data-ttu-id="02415-2870">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2870">Assembly Format</span></span>|<span data-ttu-id="02415-2871">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2871">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2872">4F</span><span class="sxs-lookup"><span data-stu-id="02415-2872">4F</span></span>|<span data-ttu-id="02415-2873">ldind. r8</span><span class="sxs-lookup"><span data-stu-id="02415-2873">ldind.r8</span></span>|<span data-ttu-id="02415-2874">将位于地址 `addr` 的 `float64` 值作为类型 `F`加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2874">Loads the `float64` value at address `addr` onto the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="02415-2875">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2875">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2876">地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2876">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2877">从堆栈中弹出该地址;获取位于地址的值。</span><span class="sxs-lookup"><span data-stu-id="02415-2877">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="02415-2878">提取的值被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2878">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2879">`ldind.r8` 指令将指定地址（类型 `native int`、`&`或 \*）的 `float64` 值作为 `float64`间接加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2879">The `ldind.r8` instruction indirectly loads a `float64` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a `float64`.</span></span>  
  
 <span data-ttu-id="02415-2880">所有 `ldind` 说明都是指定相应内置值类的 <xref:System.Reflection.Emit.OpCodes.Ldobj> 指令的快捷方式。</span><span class="sxs-lookup"><span data-stu-id="02415-2880">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="02415-2881">请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2881">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="02415-2882">将浮点值加载到计算堆栈上时，会将其转换为 `F` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-2882">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="02415-2883">格式正确的 Microsoft 中间语言（MSIL）确保以与指针类型一致的方式使用 `ldind` 指令。</span><span class="sxs-lookup"><span data-stu-id="02415-2883">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="02415-2884">最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐，否则可能会出现 <xref:System.NullReferenceException> （请参阅针对预防措施的 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀说明）。</span><span class="sxs-lookup"><span data-stu-id="02415-2884">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="02415-2885">返回地址的所有 MSIL 指令的结果（例如 <xref:System.Reflection.Emit.OpCodes.Ldloca> 和 <xref:System.Reflection.Emit.OpCodes.Ldarga>）都安全对齐。</span><span class="sxs-lookup"><span data-stu-id="02415-2885">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="02415-2886">对于大于1个字节的数据类型，字节排序依赖于目标 CPU。</span><span class="sxs-lookup"><span data-stu-id="02415-2886">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="02415-2887">依赖于字节排序的代码可能无法在所有平台上运行。</span><span class="sxs-lookup"><span data-stu-id="02415-2887">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="02415-2888">如果检测到无效地址，则可能引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2888"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="02415-2889">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldind.r8` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2889">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r8` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2890">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2890">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2891">将对象引用作为 <see langword="O" />（对象引用）类型间接加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2891">Loads an object reference as a type <see langword="O" /> (object reference) onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2892">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2892">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2893">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2893">Format</span></span>|<span data-ttu-id="02415-2894">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2894">Assembly Format</span></span>|<span data-ttu-id="02415-2895">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2895">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2896">50</span><span class="sxs-lookup"><span data-stu-id="02415-2896">50</span></span>|<span data-ttu-id="02415-2897">ldind.ref</span><span class="sxs-lookup"><span data-stu-id="02415-2897">ldind.ref</span></span>|<span data-ttu-id="02415-2898">将位于地址 `addr` 的对象引用作为类型加载到堆栈上 `O`</span><span class="sxs-lookup"><span data-stu-id="02415-2898">Loads the object reference at address `addr` onto the stack as a type `O`</span></span>|  
  
 <span data-ttu-id="02415-2899">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2899">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2900">地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2900">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2901">从堆栈中弹出该地址;提取位于地址处的对象引用。</span><span class="sxs-lookup"><span data-stu-id="02415-2901">The address is popped from the stack; the object reference located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="02415-2902">提取的引用将被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2902">The fetched reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2903">`ldind.ref` 指令将对象引用（类型 `native int`、`&`或 \*）的指定地址作为类型 `O`间接加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2903">The `ldind.ref` instruction indirectly loads the object reference the specified address (of type `native int`, `&`, or \*) onto the stack as type `O`.</span></span>  
  
 <span data-ttu-id="02415-2904">所有 `ldind` 说明都是指定相应内置值类的 <xref:System.Reflection.Emit.OpCodes.Ldobj> 指令的快捷方式。</span><span class="sxs-lookup"><span data-stu-id="02415-2904">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="02415-2905">请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2905">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="02415-2906">将浮点值加载到计算堆栈上时，会将其转换为 `F` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-2906">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="02415-2907">格式正确的 Microsoft 中间语言（MSIL）确保以与指针类型一致的方式使用 `ldind` 指令。</span><span class="sxs-lookup"><span data-stu-id="02415-2907">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="02415-2908">最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐，否则可能会出现 <xref:System.NullReferenceException> （请参阅针对预防措施的 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀说明）。</span><span class="sxs-lookup"><span data-stu-id="02415-2908">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="02415-2909">返回地址的所有 MSIL 指令的结果（例如 <xref:System.Reflection.Emit.OpCodes.Ldloca> 和 <xref:System.Reflection.Emit.OpCodes.Ldarga>）都安全对齐。</span><span class="sxs-lookup"><span data-stu-id="02415-2909">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="02415-2910">对于大于1个字节的数据类型，字节排序依赖于目标 CPU。</span><span class="sxs-lookup"><span data-stu-id="02415-2910">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="02415-2911">依赖于字节排序的代码可能无法在所有平台上运行。</span><span class="sxs-lookup"><span data-stu-id="02415-2911">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="02415-2912">如果检测到无效地址，则可能引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2912"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="02415-2913">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldind.ref` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2913">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.ref` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2914">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2914">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2915">将 <see langword="unsigned int8" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2915">Loads a value of type <see langword="unsigned int8" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2916">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2916">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2917">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2917">Format</span></span>|<span data-ttu-id="02415-2918">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2918">Assembly Format</span></span>|<span data-ttu-id="02415-2919">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2919">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2920">47</span><span class="sxs-lookup"><span data-stu-id="02415-2920">47</span></span>|<span data-ttu-id="02415-2921">ldind</span><span class="sxs-lookup"><span data-stu-id="02415-2921">ldind.u1</span></span>|<span data-ttu-id="02415-2922">将位于地址 `addr` 的 `unsigned int8` 值作为 `int32`加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2922">Loads the `unsigned int8` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="02415-2923">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2923">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2924">地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2924">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2925">从堆栈中弹出该地址;获取位于地址的值。</span><span class="sxs-lookup"><span data-stu-id="02415-2925">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="02415-2926">提取的值被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2926">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2927">`ldind.u1` 指令将指定地址（类型`native int`、`&`或 \*）的 `unsigned int8` 值作为 `int32`间接加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2927">The `ldind.u1` instruction indirectly loads an `unsigned int8` value from the specified address (of type`native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="02415-2928">所有 `ldind` 说明都是指定相应内置值类的 <xref:System.Reflection.Emit.OpCodes.Ldobj> 指令的快捷方式。</span><span class="sxs-lookup"><span data-stu-id="02415-2928">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="02415-2929">请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2929">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="02415-2930">将浮点值加载到计算堆栈上时，会将其转换为 `F` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-2930">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="02415-2931">格式正确的 Microsoft 中间语言（MSIL）确保以与指针类型一致的方式使用 `ldind` 指令。</span><span class="sxs-lookup"><span data-stu-id="02415-2931">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="02415-2932">最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐，否则可能会出现 <xref:System.NullReferenceException> （请参阅针对预防措施的 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀说明）。</span><span class="sxs-lookup"><span data-stu-id="02415-2932">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="02415-2933">返回地址的所有 MSIL 指令的结果（例如 <xref:System.Reflection.Emit.OpCodes.Ldloca> 和 <xref:System.Reflection.Emit.OpCodes.Ldarga>）都安全对齐。</span><span class="sxs-lookup"><span data-stu-id="02415-2933">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="02415-2934">对于大于1个字节的数据类型，字节排序依赖于目标 CPU。</span><span class="sxs-lookup"><span data-stu-id="02415-2934">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="02415-2935">依赖于字节排序的代码可能无法在所有平台上运行。</span><span class="sxs-lookup"><span data-stu-id="02415-2935">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="02415-2936">如果检测到无效地址，则可能引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2936"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="02415-2937">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldind.u1` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2937">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u1` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2938">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2938">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2939">将 <see langword="unsigned int16" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2939">Loads a value of type <see langword="unsigned int16" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2940">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2940">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2941">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2941">Format</span></span>|<span data-ttu-id="02415-2942">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2942">Assembly Format</span></span>|<span data-ttu-id="02415-2943">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2943">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2944">49</span><span class="sxs-lookup"><span data-stu-id="02415-2944">49</span></span>|<span data-ttu-id="02415-2945">ldind</span><span class="sxs-lookup"><span data-stu-id="02415-2945">ldind.u2</span></span>|<span data-ttu-id="02415-2946">将位于地址 `addr` 的 `unsigned int16` 值作为 `int32`加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2946">Loads the `unsigned int16` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="02415-2947">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2947">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2948">地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2948">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2949">从堆栈中弹出该地址;获取位于地址的值。</span><span class="sxs-lookup"><span data-stu-id="02415-2949">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="02415-2950">提取的值被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2950">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2951">`ldind.u2` 指令将指定地址（类型 `native int`、`&`或 \*）的 `unsigned int16` 值作为 `int32`间接加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2951">The `ldind.u2` instruction indirectly loads an `unsigned int16` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="02415-2952">所有 `ldind` 说明都是指定相应内置值类的 <xref:System.Reflection.Emit.OpCodes.Ldobj> 指令的快捷方式。</span><span class="sxs-lookup"><span data-stu-id="02415-2952">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="02415-2953">请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2953">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="02415-2954">将浮点值加载到计算堆栈上时，会将其转换为 `F` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-2954">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="02415-2955">格式正确的 Microsoft 中间语言（MSIL）确保以与指针类型一致的方式使用 `ldind` 指令。</span><span class="sxs-lookup"><span data-stu-id="02415-2955">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="02415-2956">最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐，否则可能会出现 <xref:System.NullReferenceException> （请参阅针对预防措施的 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀说明）。</span><span class="sxs-lookup"><span data-stu-id="02415-2956">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="02415-2957">返回地址的所有 MSIL 指令的结果（例如 <xref:System.Reflection.Emit.OpCodes.Ldloca> 和 <xref:System.Reflection.Emit.OpCodes.Ldarga>）都安全对齐。</span><span class="sxs-lookup"><span data-stu-id="02415-2957">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="02415-2958">对于大于1个字节的数据类型，字节排序依赖于目标 CPU。</span><span class="sxs-lookup"><span data-stu-id="02415-2958">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="02415-2959">依赖于字节排序的代码可能无法在所有平台上运行。</span><span class="sxs-lookup"><span data-stu-id="02415-2959">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="02415-2960">如果检测到无效地址，则可能引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2960"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="02415-2961">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldind.u2` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2961">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u2` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2962">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2962">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2963">将 <see langword="unsigned int32" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2963">Loads a value of type <see langword="unsigned int32" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2964">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2964">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2965">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2965">Format</span></span>|<span data-ttu-id="02415-2966">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2966">Assembly Format</span></span>|<span data-ttu-id="02415-2967">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2967">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2968">4B</span><span class="sxs-lookup"><span data-stu-id="02415-2968">4B</span></span>|<span data-ttu-id="02415-2969">ldind. u4</span><span class="sxs-lookup"><span data-stu-id="02415-2969">ldind.u4</span></span>|<span data-ttu-id="02415-2970">将位于地址 `addr` 的 `unsigned int32` 值作为 `int32`加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2970">Loads the `unsigned int32` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="02415-2971">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2971">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2972">地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2972">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2973">从堆栈中弹出该地址;获取位于地址的值。</span><span class="sxs-lookup"><span data-stu-id="02415-2973">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="02415-2974">提取的值被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2974">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2975">`ldind.u4` 指令将指定地址（类型 `native int`、`&`或 \*）的 `unsigned int32` 值作为 `int32`间接加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2975">The `ldind.u4` instruction indirectly loads an `unsigned int32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="02415-2976">所有 `ldind` 说明都是指定相应内置值类的 <xref:System.Reflection.Emit.OpCodes.Ldobj> 指令的快捷方式。</span><span class="sxs-lookup"><span data-stu-id="02415-2976">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="02415-2977">请注意，在将小于4个字节的整数值加载到计算堆栈时，它们将扩展到 `int32` （不 `native int`）。</span><span class="sxs-lookup"><span data-stu-id="02415-2977">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="02415-2978">将浮点值加载到计算堆栈上时，会将其转换为 `F` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-2978">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="02415-2979">格式正确的 Microsoft 中间语言（MSIL）确保以与指针类型一致的方式使用 `ldind` 指令。</span><span class="sxs-lookup"><span data-stu-id="02415-2979">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="02415-2980">最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐，否则可能会出现 <xref:System.NullReferenceException> （请参阅针对预防措施的 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀说明）。</span><span class="sxs-lookup"><span data-stu-id="02415-2980">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="02415-2981">返回地址的所有 MSIL 指令的结果（例如 <xref:System.Reflection.Emit.OpCodes.Ldloca> 和 <xref:System.Reflection.Emit.OpCodes.Ldarga>）都安全对齐。</span><span class="sxs-lookup"><span data-stu-id="02415-2981">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="02415-2982">对于大于1个字节的数据类型，字节排序依赖于目标 CPU。</span><span class="sxs-lookup"><span data-stu-id="02415-2982">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="02415-2983">依赖于字节排序的代码可能无法在所有平台上运行。</span><span class="sxs-lookup"><span data-stu-id="02415-2983">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="02415-2984">如果检测到无效地址，则可能引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-2984"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="02415-2985">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldind.u4` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-2985">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u4` opcode:</span></span>  
  
-   <span data-ttu-id="02415-2986">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-2986">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-2987">将从零开始的、一维数组的元素的数目推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2987">Pushes the number of elements of a zero-based, one-dimensional array onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-2988">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-2988">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-2989">格式</span><span class="sxs-lookup"><span data-stu-id="02415-2989">Format</span></span>|<span data-ttu-id="02415-2990">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-2990">Assembly Format</span></span>|<span data-ttu-id="02415-2991">说明</span><span class="sxs-lookup"><span data-stu-id="02415-2991">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-2992">8E</span><span class="sxs-lookup"><span data-stu-id="02415-2992">8E</span></span>|<span data-ttu-id="02415-2993">ldlen</span><span class="sxs-lookup"><span data-stu-id="02415-2993">ldlen</span></span>|<span data-ttu-id="02415-2994">将数组的长度（类型 `natural unsigned int`）推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2994">Pushes the length (of type `natural unsigned int`) of an array on the stack.</span></span>|  
  
 <span data-ttu-id="02415-2995">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-2995">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-2996">对数组的对象引用被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2996">An object reference to an array is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-2997">从堆栈中弹出数组引用并计算长度。</span><span class="sxs-lookup"><span data-stu-id="02415-2997">The array reference is popped from the stack and the length is computed.</span></span>  
  
3.  <span data-ttu-id="02415-2998">长度被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-2998">The length is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-2999">数组是对象，因此由 `O`类型的值表示。</span><span class="sxs-lookup"><span data-stu-id="02415-2999">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="02415-3000">长度作为 `natural unsigned int`返回。</span><span class="sxs-lookup"><span data-stu-id="02415-3000">The length is returned as a `natural unsigned int`.</span></span>  
  
 <span data-ttu-id="02415-3001">如果数组引用为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3001"><xref:System.NullReferenceException> is thrown if the array reference is a null reference.</span></span>  
  
 <span data-ttu-id="02415-3002">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldlen` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3002">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldlen` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3003">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3003">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3004">将指定索引处的局部变量加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3004">Loads the local variable at a specific index onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3005">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3005">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3006">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3006">Format</span></span>|<span data-ttu-id="02415-3007">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3007">Assembly Format</span></span>|<span data-ttu-id="02415-3008">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3008">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3009">FE 0C < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="02415-3009">FE 0C < `unsigned int16` ></span></span>|<span data-ttu-id="02415-3010">ldloc `index`</span><span class="sxs-lookup"><span data-stu-id="02415-3010">ldloc `index`</span></span>|<span data-ttu-id="02415-3011">将索引 `index` 上的局部变量加载到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3011">Loads the local variable at index `index` onto stack.</span></span>|  
  
 <span data-ttu-id="02415-3012">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3012">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3013">将指定索引处的本地变量值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3013">The local variable value at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3014">`ldloc` 指令将传递的索引处的局部变量数字的内容推送到计算堆栈上，其中本地变量从0开始编号。</span><span class="sxs-lookup"><span data-stu-id="02415-3014">The `ldloc` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</span></span> <span data-ttu-id="02415-3015">仅当方法的 initialize 标志为 true 时，才在输入方法之前，将局部变量初始化为0。</span><span class="sxs-lookup"><span data-stu-id="02415-3015">Local variables are initialized to 0 before entering the method only if the initialize flag on the method is true.</span></span> <span data-ttu-id="02415-3016">可能存在65535（2 ^ 16-1）个本地变量（0-65534）。</span><span class="sxs-lookup"><span data-stu-id="02415-3016">There are 65,535 (2^16-1) local variables possible (0-65,534).</span></span> <span data-ttu-id="02415-3017">索引65535无效，因为可能的实现将使用2字节整数跟踪本地的索引，以及给定方法的局部变量总数。</span><span class="sxs-lookup"><span data-stu-id="02415-3017">Index 65,535 is not valid since likely implementations will use a 2-byte integer to track both a local's index, along with the total number of locals for a given method.</span></span> <span data-ttu-id="02415-3018">如果已将65535的索引设为有效，则需要更宽的整数来跟踪此类方法中的局部变量的数目。</span><span class="sxs-lookup"><span data-stu-id="02415-3018">If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</span></span>  
  
 <span data-ttu-id="02415-3019">`ldloc.0`、`ldloc.1`、`ldloc.2`和 `ldloc.3` 说明提供了用于访问前四个局部变量的有效编码。</span><span class="sxs-lookup"><span data-stu-id="02415-3019">The `ldloc.0`, `ldloc.1`, `ldloc.2`, and `ldloc.3` instructions provide an efficient encoding for accessing the first four local variables.</span></span>  
  
 <span data-ttu-id="02415-3020">值的类型与在方法头中指定的局部变量的类型相同。</span><span class="sxs-lookup"><span data-stu-id="02415-3020">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="02415-3021">请参阅 Partition I. 小于4个字节的局部变量在加载到堆栈上时，将扩展为类型 `int32`。</span><span class="sxs-lookup"><span data-stu-id="02415-3021">See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="02415-3022">浮点值将扩展为其本机大小（类型 `F`）。</span><span class="sxs-lookup"><span data-stu-id="02415-3022">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="02415-3023">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldloc` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3023">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3024">ILGenerator （OpCode，LocalBuilder）</span><span class="sxs-lookup"><span data-stu-id="02415-3024">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="02415-3025">ILGenerator （操作码，short）</span><span class="sxs-lookup"><span data-stu-id="02415-3025">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3026">将索引 0 处的局部变量加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3026">Loads the local variable at index 0 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3027">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3027">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3028">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3028">Format</span></span>|<span data-ttu-id="02415-3029">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3029">Assembly Format</span></span>|<span data-ttu-id="02415-3030">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3030">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3031">06</span><span class="sxs-lookup"><span data-stu-id="02415-3031">06</span></span>|<span data-ttu-id="02415-3032">ldloc</span><span class="sxs-lookup"><span data-stu-id="02415-3032">ldloc.0</span></span>|<span data-ttu-id="02415-3033">将索引 0 处的局部变量加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3033">Loads the local variable at index 0 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="02415-3034">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3034">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3035">将索引0处的局部变量值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3035">The local variable value at the index 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3036">`ldloc.0` 是 <xref:System.Reflection.Emit.OpCodes.Ldloc>的一个特别高效的编码，允许访问索引0处的局部变量。</span><span class="sxs-lookup"><span data-stu-id="02415-3036">`ldloc.0` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 0.</span></span>  
  
 <span data-ttu-id="02415-3037">值的类型与在方法头中指定的局部变量的类型相同。</span><span class="sxs-lookup"><span data-stu-id="02415-3037">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="02415-3038">在将小于4个字节的局部变量加载到堆栈上时，将扩展为 `int32` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-3038">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="02415-3039">浮点值将扩展为其本机大小（类型 `F`）。</span><span class="sxs-lookup"><span data-stu-id="02415-3039">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="02415-3040">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldloc.0` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3040">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.0` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3041">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3041">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3042">将索引 1 处的局部变量加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3042">Loads the local variable at index 1 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3043">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3043">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3044">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3044">Format</span></span>|<span data-ttu-id="02415-3045">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3045">Assembly Format</span></span>|<span data-ttu-id="02415-3046">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3046">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3047">07</span><span class="sxs-lookup"><span data-stu-id="02415-3047">07</span></span>|<span data-ttu-id="02415-3048">ldloc.1</span><span class="sxs-lookup"><span data-stu-id="02415-3048">ldloc.1</span></span>|<span data-ttu-id="02415-3049">将索引 1 处的局部变量加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3049">Loads the local variable at index 1 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="02415-3050">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3050">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3051">位于索引1处的局部变量值被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3051">The local variable value at the index 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3052">`ldloc.1` 是 <xref:System.Reflection.Emit.OpCodes.Ldloc>的一个特别高效的编码，允许访问索引1处的局部变量。</span><span class="sxs-lookup"><span data-stu-id="02415-3052">`ldloc.1` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 1.</span></span>  
  
 <span data-ttu-id="02415-3053">值的类型与在方法头中指定的局部变量的类型相同。</span><span class="sxs-lookup"><span data-stu-id="02415-3053">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="02415-3054">在将小于4个字节的局部变量加载到堆栈上时，将扩展为 `int32` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-3054">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="02415-3055">浮点值将扩展为其本机大小（类型 `F`）。</span><span class="sxs-lookup"><span data-stu-id="02415-3055">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="02415-3056">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldloc.1` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3056">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.1` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3057">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3057">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3058">将索引 2 处的局部变量加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3058">Loads the local variable at index 2 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3059">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3059">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3060">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3060">Format</span></span>|<span data-ttu-id="02415-3061">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3061">Assembly Format</span></span>|<span data-ttu-id="02415-3062">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3062">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3063">08</span><span class="sxs-lookup"><span data-stu-id="02415-3063">08</span></span>|<span data-ttu-id="02415-3064">ldloc.2</span><span class="sxs-lookup"><span data-stu-id="02415-3064">ldloc.2</span></span>|<span data-ttu-id="02415-3065">将索引 2 处的局部变量加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3065">Loads the local variable at index 2 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="02415-3066">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3066">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3067">将索引2处的局部变量值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3067">The local variable value at the index 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3068">`ldloc.2` 是 <xref:System.Reflection.Emit.OpCodes.Ldloc>的一个特别高效的编码，允许访问索引2处的局部变量。</span><span class="sxs-lookup"><span data-stu-id="02415-3068">`ldloc.2` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 2.</span></span>  
  
 <span data-ttu-id="02415-3069">值的类型与在方法头中指定的局部变量的类型相同。</span><span class="sxs-lookup"><span data-stu-id="02415-3069">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="02415-3070">在将小于4个字节的局部变量加载到堆栈上时，将扩展为 `int32` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-3070">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="02415-3071">浮点值将扩展为其本机大小（类型 `F`）。</span><span class="sxs-lookup"><span data-stu-id="02415-3071">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="02415-3072">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldloc.2` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3072">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.2` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3073">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3073">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3074">将索引 3 处的局部变量加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3074">Loads the local variable at index 3 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3075">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3075">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3076">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3076">Format</span></span>|<span data-ttu-id="02415-3077">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3077">Assembly Format</span></span>|<span data-ttu-id="02415-3078">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3078">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3079">09</span><span class="sxs-lookup"><span data-stu-id="02415-3079">09</span></span>|<span data-ttu-id="02415-3080">ldloc.3</span><span class="sxs-lookup"><span data-stu-id="02415-3080">ldloc.3</span></span>|<span data-ttu-id="02415-3081">将索引 3 处的局部变量加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3081">Loads the local variable at index 3 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="02415-3082">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3082">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3083">将索引为3的本地变量值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3083">The local variable value at the index 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3084">`ldloc.3` 是 <xref:System.Reflection.Emit.OpCodes.Ldloc>的一个特别高效的编码，允许访问索引3处的局部变量。</span><span class="sxs-lookup"><span data-stu-id="02415-3084">`ldloc.3` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 3.</span></span>  
  
 <span data-ttu-id="02415-3085">值的类型与在方法头中指定的局部变量的类型相同。</span><span class="sxs-lookup"><span data-stu-id="02415-3085">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="02415-3086">在将小于4个字节的局部变量加载到堆栈上时，将扩展为 `int32` 类型。</span><span class="sxs-lookup"><span data-stu-id="02415-3086">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="02415-3087">浮点值将扩展为其本机大小（类型 `F`）。</span><span class="sxs-lookup"><span data-stu-id="02415-3087">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="02415-3088">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldloc.3` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3088">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.3` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3089">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3089">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3090">将特定索引处的局部变量加载到计算堆栈上（短格式）。</span><span class="sxs-lookup"><span data-stu-id="02415-3090">Loads the local variable at a specific index onto the evaluation stack, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3091">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3091">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3092">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3092">Format</span></span>|<span data-ttu-id="02415-3093">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3093">Assembly Format</span></span>|<span data-ttu-id="02415-3094">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3094">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3095">11 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="02415-3095">11 < `unsigned int8` ></span></span>|<span data-ttu-id="02415-3096">ldloc `index`</span><span class="sxs-lookup"><span data-stu-id="02415-3096">ldloc.s `index`</span></span>|<span data-ttu-id="02415-3097">将索引 `index` 上的局部变量加载到堆栈上（短格式）。</span><span class="sxs-lookup"><span data-stu-id="02415-3097">Loads the local variable at index `index` onto stack, short form.</span></span>|  
  
 <span data-ttu-id="02415-3098">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3098">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3099">将指定索引处的本地变量值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3099">The local variable value at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3100">`ldloc.s` 指令将传递的索引处的局部变量数字的内容推送到计算堆栈上，其中本地变量从0开始编号。</span><span class="sxs-lookup"><span data-stu-id="02415-3100">The `ldloc.s` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</span></span> <span data-ttu-id="02415-3101">如果对方法的 initialize 标志为 true，则在输入方法之前，本地变量将初始化为0。</span><span class="sxs-lookup"><span data-stu-id="02415-3101">Local variables are initialized to 0 before entering the method if the initialize flag on the method is true.</span></span> <span data-ttu-id="02415-3102">可以使用256（2 ^ 8）个本地变量（0-255），这是一种比 `ldloc`更有效的编码。</span><span class="sxs-lookup"><span data-stu-id="02415-3102">There are 256 (2^8) local variables possible (0-255) in the short form, which is a more efficient encoding than `ldloc`.</span></span>  
  
 <span data-ttu-id="02415-3103">值的类型与在方法头中指定的局部变量的类型相同。</span><span class="sxs-lookup"><span data-stu-id="02415-3103">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="02415-3104">请参阅 Partition I. 小于4个字节的局部变量在加载到堆栈上时，将扩展为类型 `int32`。</span><span class="sxs-lookup"><span data-stu-id="02415-3104">See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="02415-3105">浮点值将扩展为其本机大小（类型 `F`）。</span><span class="sxs-lookup"><span data-stu-id="02415-3105">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="02415-3106">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldloc.s` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3106">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc.s` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3107">ILGenerator （OpCode，LocalBuilder）</span><span class="sxs-lookup"><span data-stu-id="02415-3107">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="02415-3108">ILGenerator （OpCode，byte）</span><span class="sxs-lookup"><span data-stu-id="02415-3108">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3109">将位于特定索引处的局部变量的地址加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3109">Loads the address of the local variable at a specific index onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3110">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3110">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3111">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3111">Format</span></span>|<span data-ttu-id="02415-3112">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3112">Assembly Format</span></span>|<span data-ttu-id="02415-3113">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3113">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3114">FE OD < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="02415-3114">FE OD < `unsigned int16` ></span></span>|<span data-ttu-id="02415-3115">ldloca `index`</span><span class="sxs-lookup"><span data-stu-id="02415-3115">ldloca `index`</span></span>|<span data-ttu-id="02415-3116">将 `index` 中的局部变量的地址加载到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3116">Loads the address of the local variable at `index` onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="02415-3117">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3117">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3118">存储在本地变量中指定索引处的地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3118">The address stored in the local variable at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3119">`ldloca` 指令将传递的索引处的局部变量号的地址推送到堆栈上，其中局部变量从0开始编号。</span><span class="sxs-lookup"><span data-stu-id="02415-3119">The `ldloca` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="02415-3120">堆栈中推送的值已正确对齐，以便与 <xref:System.Reflection.Emit.OpCodes.Ldind_I> 和 <xref:System.Reflection.Emit.OpCodes.Stind_I>等说明一起使用。</span><span class="sxs-lookup"><span data-stu-id="02415-3120">The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span></span> <span data-ttu-id="02415-3121">结果为暂时性指针（类型 `*`）。</span><span class="sxs-lookup"><span data-stu-id="02415-3121">The result is a transient pointer (type `*`).</span></span>  
  
 <span data-ttu-id="02415-3122">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldloca` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3122">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3123">ILGenerator （操作码，short）</span><span class="sxs-lookup"><span data-stu-id="02415-3123">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3124">将位于特定索引处的局部变量的地址加载到计算堆栈上（短格式）。</span><span class="sxs-lookup"><span data-stu-id="02415-3124">Loads the address of the local variable at a specific index onto the evaluation stack, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3125">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3125">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3126">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3126">Format</span></span>|<span data-ttu-id="02415-3127">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3127">Assembly Format</span></span>|<span data-ttu-id="02415-3128">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3128">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3129">12 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="02415-3129">12 < `unsigned int8` ></span></span>|<span data-ttu-id="02415-3130">ldloca `index`</span><span class="sxs-lookup"><span data-stu-id="02415-3130">ldloca.s `index`</span></span>|<span data-ttu-id="02415-3131">将 `index` 中的局部变量的地址加载到计算堆栈上（短格式）。</span><span class="sxs-lookup"><span data-stu-id="02415-3131">Loads the address of the local variable at `index` onto the evaluation stack, short form.</span></span>|  
  
 <span data-ttu-id="02415-3132">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3132">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3133">存储在本地变量中指定索引处的地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3133">The address stored in the local variable at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3134">`ldloca.s` 指令将传递的索引处的局部变量号的地址推送到堆栈上，其中局部变量从0开始编号。</span><span class="sxs-lookup"><span data-stu-id="02415-3134">The `ldloca.s` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="02415-3135">堆栈中推送的值已正确对齐，以便与 <xref:System.Reflection.Emit.OpCodes.Ldind_I> 和 <xref:System.Reflection.Emit.OpCodes.Stind_I>等说明一起使用。</span><span class="sxs-lookup"><span data-stu-id="02415-3135">The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span></span> <span data-ttu-id="02415-3136">结果为暂时性指针（类型 `*`）。</span><span class="sxs-lookup"><span data-stu-id="02415-3136">The result is a transient pointer (type `*`).</span></span>  
  
 <span data-ttu-id="02415-3137">`ldloca.s` 指令提供了一个有效的编码，可与局部变量0到255一起使用。</span><span class="sxs-lookup"><span data-stu-id="02415-3137">The `ldloca.s` instruction provides an efficient encoding for use with the local variables 0 through 255.</span></span>  
  
 <span data-ttu-id="02415-3138">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldloca.s` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3138">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca.s` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3139">ILGenerator （OpCode，byte）</span><span class="sxs-lookup"><span data-stu-id="02415-3139">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3140">将空引用（<see langword="O" /> 类型）推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3140">Pushes a null reference (type <see langword="O" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3141">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3141">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3142">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3142">Format</span></span>|<span data-ttu-id="02415-3143">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3143">Assembly Format</span></span>|<span data-ttu-id="02415-3144">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3144">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3145">14</span><span class="sxs-lookup"><span data-stu-id="02415-3145">14</span></span>|<span data-ttu-id="02415-3146">ldnull</span><span class="sxs-lookup"><span data-stu-id="02415-3146">ldnull</span></span>|<span data-ttu-id="02415-3147">在堆栈上推送空引用</span><span class="sxs-lookup"><span data-stu-id="02415-3147">push a null reference onto the stack</span></span>|  
  
 <span data-ttu-id="02415-3148">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3148">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3149">空对象引用被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3149">A null object reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3150">`ldnull` 将堆栈上的空引用（类型 `O`）推送。</span><span class="sxs-lookup"><span data-stu-id="02415-3150">`ldnull` pushes a null reference (type `O`) on the stack.</span></span> <span data-ttu-id="02415-3151">这用于在使用数据填充位置之前或在位置被弃用时初始化位置。</span><span class="sxs-lookup"><span data-stu-id="02415-3151">This is used to initialize locations before they are populated with data, or when they become deprecated.</span></span>  
  
 <span data-ttu-id="02415-3152">`ldnull` 提供了一个与大小无关的空引用。</span><span class="sxs-lookup"><span data-stu-id="02415-3152">`ldnull` provides a null reference that is size-independent.</span></span>  
  
 <span data-ttu-id="02415-3153">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldnull` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3153">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldnull` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3154">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3154">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3155">将地址指向的值类型对象复制到计算堆栈的顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-3155">Copies the value type object pointed to by an address to the top of the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3156">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3156">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3157">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3157">Format</span></span>|<span data-ttu-id="02415-3158">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3158">Assembly Format</span></span>|<span data-ttu-id="02415-3159">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3159">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3160">71 < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-3160">71 < `T` ></span></span>|<span data-ttu-id="02415-3161">ldobj `class`</span><span class="sxs-lookup"><span data-stu-id="02415-3161">ldobj `class`</span></span>|<span data-ttu-id="02415-3162">将值类型 `class` 的实例复制到堆栈中。</span><span class="sxs-lookup"><span data-stu-id="02415-3162">Copy instance of value type `class` to the stack.</span></span>|  
  
 <span data-ttu-id="02415-3163">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3163">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3164">值类型对象的地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3164">The address of a value type object is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3165">从堆栈中弹出该地址，并查找该特定地址处的实例。</span><span class="sxs-lookup"><span data-stu-id="02415-3165">The address is popped from the stack and the instance at that particular address is looked up.</span></span>  
  
3.  <span data-ttu-id="02415-3166">存储在该地址的对象的值被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3166">The value of the object stored at that address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3167">`ldobj` 指令用于作为参数传递值类型。</span><span class="sxs-lookup"><span data-stu-id="02415-3167">The `ldobj` instruction is used to pass a value type as a parameter.</span></span>  
  
 <span data-ttu-id="02415-3168">`ldobj` 指令将 `addrOfValObj` 的值（类型 `&`、`*`或 `native int`）复制到堆栈顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-3168">The `ldobj` instruction copies the value pointed to by `addrOfValObj` (of type `&`, `*`, or `native int`) to the top of the stack.</span></span> <span data-ttu-id="02415-3169">已复制的字节数取决于类的大小（由 `class` 参数指定）。</span><span class="sxs-lookup"><span data-stu-id="02415-3169">The number of bytes copied depends on the size of the class (as specified by the `class` parameter).</span></span> <span data-ttu-id="02415-3170">`class` 参数是表示值类型的元数据标记。</span><span class="sxs-lookup"><span data-stu-id="02415-3170">The `class` parameter is a metadata token representing the value type.</span></span>  
  
 <span data-ttu-id="02415-3171">`ldobj` 指令的操作可以通过紧挨着 <xref:System.Reflection.Emit.OpCodes.Volatile> 或 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀指令来更改。</span><span class="sxs-lookup"><span data-stu-id="02415-3171">The operation of the `ldobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="02415-3172">如果找不到类，则会引发 <xref:System.TypeLoadException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3172"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="02415-3173">当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是运行时，通常会检测到此情况。</span><span class="sxs-lookup"><span data-stu-id="02415-3173">This is typically detected when the Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="02415-3174">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldobj` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3174">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldobj` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3175">ILGenerator （OpCode，Type）</span><span class="sxs-lookup"><span data-stu-id="02415-3175">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3176">将静态字段的值推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3176">Pushes the value of a static field onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3177">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3177">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3178">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3178">Format</span></span>|<span data-ttu-id="02415-3179">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3179">Assembly Format</span></span>|<span data-ttu-id="02415-3180">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3180">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3181">7E < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-3181">7E < `T` ></span></span>|<span data-ttu-id="02415-3182">ldsfld `field`</span><span class="sxs-lookup"><span data-stu-id="02415-3182">ldsfld `field`</span></span>|<span data-ttu-id="02415-3183">将 `field` 的值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3183">Push the value of `field` on the stack.</span></span>|  
  
 <span data-ttu-id="02415-3184">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3184">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3185">将特定字段的值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3185">The value of the specific field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3186">`ldsfld` 指令推送堆栈上的静态（在类的所有实例中共享）字段的值。</span><span class="sxs-lookup"><span data-stu-id="02415-3186">The `ldsfld` instruction pushes the value of a static (shared among all instances of a class) field on the stack.</span></span> <span data-ttu-id="02415-3187">返回类型是与传递的元数据标记 `field`关联的。</span><span class="sxs-lookup"><span data-stu-id="02415-3187">The return type is that associated with the passed metadata token `field`.</span></span>  
  
 <span data-ttu-id="02415-3188">`ldsfld` 指令可以具有 <xref:System.Reflection.Emit.OpCodes.Volatile> 前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-3188">The `ldsfld` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.</span></span>  
  
 <span data-ttu-id="02415-3189">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldsfld` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3189">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsfld` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3190">ILGenerator （OpCode，FieldInfo）</span><span class="sxs-lookup"><span data-stu-id="02415-3190">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3191">将静态字段的地址推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3191">Pushes the address of a static field onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3192">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3192">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3193">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3193">Format</span></span>|<span data-ttu-id="02415-3194">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3194">Assembly Format</span></span>|<span data-ttu-id="02415-3195">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3195">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3196">7F < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-3196">7F < `T` ></span></span>|<span data-ttu-id="02415-3197">ldsflda `field`</span><span class="sxs-lookup"><span data-stu-id="02415-3197">ldsflda `field`</span></span>|<span data-ttu-id="02415-3198">推送堆栈上的 `field` 地址</span><span class="sxs-lookup"><span data-stu-id="02415-3198">Push the address of `field` on the stack</span></span>|  
  
 <span data-ttu-id="02415-3199">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3199">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3200">将特定字段的地址推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3200">The address of a specific field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3201">`ldsflda` 指令将静态（在类的所有实例中共享）字段的地址推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3201">The `ldsflda` instruction pushes the address of a static (shared among all instances of a class) field on the stack.</span></span> <span data-ttu-id="02415-3202">如果元数据标记 `field` 引用其内存被管理的类型，则该地址可以表示为暂时性指针（类型 `*`）。</span><span class="sxs-lookup"><span data-stu-id="02415-3202">The address may be represented as a transient pointer (type `*`) if the metadata token `field` refers to a type whose memory is managed.</span></span> <span data-ttu-id="02415-3203">否则，它对应于非托管指针（类型 `native int`）。</span><span class="sxs-lookup"><span data-stu-id="02415-3203">Otherwise, it corresponds to an unmanaged pointer (type `native int`).</span></span> <span data-ttu-id="02415-3204">请注意，`field` 可能是一个静态全局对象，它具有分配的相对虚拟地址（该字段的偏移量（其包含的 PE 文件将在其中加载到内存中），其中的内存是非托管的。</span><span class="sxs-lookup"><span data-stu-id="02415-3204">Note that `field` may be a static global with an assigned relative virtual address (the offset of the field from the base address at which its containing PE file is loaded into memory) where the memory is unmanaged.</span></span>  
  
 <span data-ttu-id="02415-3205">`ldsflda` 指令可以具有 <xref:System.Reflection.Emit.OpCodes.Volatile> 前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-3205">The `ldsflda` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.</span></span>  
  
 <span data-ttu-id="02415-3206">如果在元数据中找不到字段，则会引发 <xref:System.MissingFieldException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3206"><xref:System.MissingFieldException> is thrown if field is not found in the metadata.</span></span> <span data-ttu-id="02415-3207">当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是运行时，通常会检查此情况。</span><span class="sxs-lookup"><span data-stu-id="02415-3207">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at runtime.</span></span>  
  
 <span data-ttu-id="02415-3208">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldsflda` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3208">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsflda` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3209">ILGenerator （OpCode，FieldInfo）</span><span class="sxs-lookup"><span data-stu-id="02415-3209">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3210">推送对元数据中存储的字符串的新对象引用。</span><span class="sxs-lookup"><span data-stu-id="02415-3210">Pushes a new object reference to a string literal stored in the metadata.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3211">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3211">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3212">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3212">Format</span></span>|<span data-ttu-id="02415-3213">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3213">Assembly Format</span></span>|<span data-ttu-id="02415-3214">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3214">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3215">72 < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-3215">72 < `T` ></span></span>|<span data-ttu-id="02415-3216">ldstr `mdToken`</span><span class="sxs-lookup"><span data-stu-id="02415-3216">ldstr `mdToken`</span></span>|<span data-ttu-id="02415-3217">推送 `mdToken`的元数据字符串标记的字符串对象。</span><span class="sxs-lookup"><span data-stu-id="02415-3217">Pushes a string object for the metadata string token `mdToken`.</span></span>|  
  
 <span data-ttu-id="02415-3218">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3218">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3219">将对字符串的对象引用推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3219">An object reference to a string is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3220">`ldstr` 指令将对象引用（类型 `O`）推送到表示元数据中存储的特定字符串文本的新字符串对象。</span><span class="sxs-lookup"><span data-stu-id="02415-3220">The `ldstr` instruction pushes an object reference (type `O`) to a new string object representing the specific string literal stored in the metadata.</span></span> <span data-ttu-id="02415-3221">`ldstr` 指令分配所需的内存量，并执行任何格式转换，以将字符串文本从文件中使用的格式转换为运行时所需的字符串格式。</span><span class="sxs-lookup"><span data-stu-id="02415-3221">The `ldstr` instruction allocates the requisite amount of memory and performs any format conversion required to convert the string literal from the form used in the file to the string format required at runtime.</span></span>  
  
 <span data-ttu-id="02415-3222">公共语言基础结构（CLI）保证两个 `ldstr` 指令的结果引用两个具有相同字符序列的元数据标记，这将返回完全相同的字符串对象（称为 "字符串暂留" 的过程）。</span><span class="sxs-lookup"><span data-stu-id="02415-3222">The Common Language Infrastructure (CLI) guarantees that the result of two `ldstr` instructions referring to two metadata tokens that have the same sequence of characters return precisely the same string object (a process known as "string interning").</span></span>  
  
 <span data-ttu-id="02415-3223">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldstr` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3223">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldstr` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3224">ILGenerator （OpCode，string）</span><span class="sxs-lookup"><span data-stu-id="02415-3224">ILGenerator.Emit(OpCode, string)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3225">将元数据标记转换为其运行时表示形式，并将其推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3225">Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3226">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3226">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3227">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3227">Format</span></span>|<span data-ttu-id="02415-3228">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3228">Assembly Format</span></span>|<span data-ttu-id="02415-3229">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3229">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3230">D0 < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-3230">D0 < `T` ></span></span>|<span data-ttu-id="02415-3231">ldtoken `token`</span><span class="sxs-lookup"><span data-stu-id="02415-3231">ldtoken `token`</span></span>|<span data-ttu-id="02415-3232">将元数据标记转换为其运行时表示形式。</span><span class="sxs-lookup"><span data-stu-id="02415-3232">Converts a metadata token to its runtime representation.</span></span>|  
  
 <span data-ttu-id="02415-3233">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3233">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3234">传递的标记将转换为 `RuntimeHandle` 并推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3234">The passed token is converted to a `RuntimeHandle` and pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3235">`ldtoken` 指令为指定的元数据标记推送 `RuntimeHandle`。</span><span class="sxs-lookup"><span data-stu-id="02415-3235">The `ldtoken` instruction pushes a `RuntimeHandle` for the specified metadata token.</span></span> <span data-ttu-id="02415-3236">`RuntimeHandle` 可以是 `fieldref/fielddef`、`methodref/methoddef`或 `typeref/typedef`。</span><span class="sxs-lookup"><span data-stu-id="02415-3236">A `RuntimeHandle` can be a `fieldref/fielddef`, a `methodref/methoddef`, or a `typeref/typedef`.</span></span>  
  
 <span data-ttu-id="02415-3237">可以在对系统类库中 `Reflection` 方法的调用中使用推送到堆栈中的值。</span><span class="sxs-lookup"><span data-stu-id="02415-3237">The value pushed on the stack can be used in calls to `Reflection` methods in the system class library.</span></span>  
  
 <span data-ttu-id="02415-3238">有关运行时句柄的信息，请参阅以下类： <xref:System.RuntimeFieldHandle>、<xref:System.RuntimeTypeHandle>和 <xref:System.RuntimeMethodHandle>。</span><span class="sxs-lookup"><span data-stu-id="02415-3238">For information on runtime handles, see the following classes: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, and <xref:System.RuntimeMethodHandle>.</span></span>  
  
 <span data-ttu-id="02415-3239">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldtoken` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3239">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldtoken` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3240">ILGenerator （操作码，MethodInfo）</span><span class="sxs-lookup"><span data-stu-id="02415-3240">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="02415-3241">ILGenerator （OpCode，FieldInfo）</span><span class="sxs-lookup"><span data-stu-id="02415-3241">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
-   <span data-ttu-id="02415-3242">ILGenerator （OpCode，Type）</span><span class="sxs-lookup"><span data-stu-id="02415-3242">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3243">将指向实现与指定对象关联的特定虚方法的本机代码的非托管指针（<see langword="native int" /> 类型）推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3243">Pushes an unmanaged pointer (type <see langword="native int" />) to the native code implementing a particular virtual method associated with a specified object onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3244">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3244">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3245">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3245">Format</span></span>|<span data-ttu-id="02415-3246">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3246">Assembly Format</span></span>|<span data-ttu-id="02415-3247">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3247">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3248">FE 07 < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-3248">FE 07 < `T` ></span></span>|<span data-ttu-id="02415-3249">ldvirtftn `method`</span><span class="sxs-lookup"><span data-stu-id="02415-3249">ldvirtftn `method`</span></span>|<span data-ttu-id="02415-3250">将指针推送到对象的虚拟方法 `method` 堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3250">Pushes the pointer to an object's virtual method `method` on the stack.</span></span>|  
  
 <span data-ttu-id="02415-3251">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3251">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3252">对象引用被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3252">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3253">从堆栈中弹出对象引用，并查找方法（由元数据标记 `method`）指定的入口点地址。</span><span class="sxs-lookup"><span data-stu-id="02415-3253">The object reference is popped from the stack and the address of the entry point to the method (as specified by the metadata token `method`) is looked up.</span></span>  
  
3.  <span data-ttu-id="02415-3254">指向 `method` 的指针被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3254">The pointer to `method` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3255">如果所生成的非托管指针引用托管方法（或从托管代码转换为非托管代码的存根），则可以使用 <xref:System.Reflection.Emit.OpCodes.Calli> 指令，将该指针推送到 `ldvirtftn` 指令推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3255">The resulting unmanaged pointer pushed onto the stack by the `ldvirtftn` instruction can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</span></span>  
  
 <span data-ttu-id="02415-3256">非托管指针使用 CLR 调用约定指向本机代码。</span><span class="sxs-lookup"><span data-stu-id="02415-3256">The unmanaged pointer points to native code using the CLR calling convention.</span></span> <span data-ttu-id="02415-3257">此方法指针不应作为回调例程传递到非托管的本机代码。</span><span class="sxs-lookup"><span data-stu-id="02415-3257">This method pointer should not be passed to unmanaged native code as a callback routine.</span></span>  
  
 <span data-ttu-id="02415-3258">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ldvirtftn` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3258">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldvirtftn` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3259">ILGenerator （操作码，MethodInfo）</span><span class="sxs-lookup"><span data-stu-id="02415-3259">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3260">退出受保护的代码区域，无条件将控制转移到特定目标指令。</span><span class="sxs-lookup"><span data-stu-id="02415-3260">Exits a protected region of code, unconditionally transferring control to a specific target instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3261">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3261">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3262">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3262">Format</span></span>|<span data-ttu-id="02415-3263">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3263">Assembly Format</span></span>|<span data-ttu-id="02415-3264">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3264">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3265">DD < `int32` ></span><span class="sxs-lookup"><span data-stu-id="02415-3265">DD < `int32` ></span></span>|<span data-ttu-id="02415-3266">离开 `target`</span><span class="sxs-lookup"><span data-stu-id="02415-3266">leave `target`</span></span>|<span data-ttu-id="02415-3267">退出受保护的代码区域。</span><span class="sxs-lookup"><span data-stu-id="02415-3267">Exits a protected region of code.</span></span>|  
  
 <span data-ttu-id="02415-3268">没有为此指令指定堆栈转换行为。</span><span class="sxs-lookup"><span data-stu-id="02415-3268">There is no stack transition behavior specified for this instruction.</span></span>  
  
 <span data-ttu-id="02415-3269">`leave` 指令无条件地将控制转移到特定目标指令，表示为从当前指令后面的指令开头开始的4字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-3269">The `leave` instruction unconditionally transfers control to the specific target instruction, represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-3270">`leave` 指令与 `br` 指令类似，但它可用于退出 `try`、`filter`或 `catch` 块，而普通的分支指令只能在此类块中使用。</span><span class="sxs-lookup"><span data-stu-id="02415-3270">The `leave` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</span></span> <span data-ttu-id="02415-3271">`leave` 指令将清空计算堆栈，并确保执行适当的周围 `finally` 块。</span><span class="sxs-lookup"><span data-stu-id="02415-3271">The `leave` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.</span></span>  
  
 <span data-ttu-id="02415-3272">不能使用 `leave` 指令退出 `finally` 块。</span><span class="sxs-lookup"><span data-stu-id="02415-3272">You cannot use a `leave` instruction to exit a `finally` block.</span></span> <span data-ttu-id="02415-3273">为了简化异常处理程序的代码生成，它在 catch 块中有效，可使用 `leave` 指令将控制转移到关联的 `try` 块内的任何指令。</span><span class="sxs-lookup"><span data-stu-id="02415-3273">To ease code generation for exception handlers it is valid from within a catch block to use a `leave` instruction to transfer control to any instruction within the associated `try` block.</span></span>  
  
 <span data-ttu-id="02415-3274">如果指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-3274">If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="02415-3275">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `leave` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3275">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `leave` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3276">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-3276">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3277">退出受保护的代码区域，无条件将控制转移到目标指令（缩写形式）。</span><span class="sxs-lookup"><span data-stu-id="02415-3277">Exits a protected region of code, unconditionally transferring control to a target instruction (short form).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3278">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3278">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3279">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3279">Format</span></span>|<span data-ttu-id="02415-3280">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3280">Assembly Format</span></span>|<span data-ttu-id="02415-3281">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3281">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3282">DE < `int8` ></span><span class="sxs-lookup"><span data-stu-id="02415-3282">DE < `int8` ></span></span>|<span data-ttu-id="02415-3283">离开 `target`</span><span class="sxs-lookup"><span data-stu-id="02415-3283">leave.s `target`</span></span>|<span data-ttu-id="02415-3284">退出受保护的代码区域（缩写形式）。</span><span class="sxs-lookup"><span data-stu-id="02415-3284">Exit a protected region of code, short form.</span></span>|  
  
 <span data-ttu-id="02415-3285">没有为此指令指定堆栈转换行为。</span><span class="sxs-lookup"><span data-stu-id="02415-3285">There is no stack transition behavior specified for this instruction.</span></span>  
  
 <span data-ttu-id="02415-3286">`leave.s` 指令无条件地将控制转移到传递的目标指令，表示为从当前指令后面的指令开头开始的1字节有符号偏移量。</span><span class="sxs-lookup"><span data-stu-id="02415-3286">The `leave.s` instruction unconditionally transfers control to the passed target instruction, represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="02415-3287">`leave.s` 指令与 `br` 指令类似，但它可用于退出 `try`、`filter`或 `catch` 块，而普通的分支指令只能在此类块中使用。</span><span class="sxs-lookup"><span data-stu-id="02415-3287">The `leave.s` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</span></span> <span data-ttu-id="02415-3288">`leave.s` 指令将清空计算堆栈，并确保执行适当的周围 `finally` 块。</span><span class="sxs-lookup"><span data-stu-id="02415-3288">The `leave.s` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.</span></span>  
  
 <span data-ttu-id="02415-3289">不能使用 `leave.s` 指令退出 `finally` 块。</span><span class="sxs-lookup"><span data-stu-id="02415-3289">You cannot use a `leave.s` instruction to exit a `finally` block.</span></span> <span data-ttu-id="02415-3290">为了简化异常处理程序的代码生成，它在 catch 块中有效，可使用 `leave.s` 指令将控制转移到关联的 `try` 块内的任何指令。</span><span class="sxs-lookup"><span data-stu-id="02415-3290">To ease code generation for exception handlers it is valid from within a catch block to use a `leave.s` instruction to transfer control to any instruction within the associated `try` block.</span></span>  
  
 <span data-ttu-id="02415-3291">如果指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-3291">If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="02415-3292">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `leave.s` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3292">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `leave.s` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3293">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-3293">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3294">从本地动态内存池分配特定数目的字节并将第一个分配的字节的地址（瞬态指针，<see langword="*" /> 类型）推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3294">Allocates a certain number of bytes from the local dynamic memory pool and pushes the address (a transient pointer, type <see langword="*" />) of the first allocated byte onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3295">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3295">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3296">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3296">Format</span></span>|<span data-ttu-id="02415-3297">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3297">Assembly Format</span></span>|<span data-ttu-id="02415-3298">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3298">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3299">FE 0F</span><span class="sxs-lookup"><span data-stu-id="02415-3299">FE 0F</span></span>|<span data-ttu-id="02415-3300">localloc</span><span class="sxs-lookup"><span data-stu-id="02415-3300">localloc</span></span>|<span data-ttu-id="02415-3301">从本地堆中分配空间。</span><span class="sxs-lookup"><span data-stu-id="02415-3301">Allocate space from the local heap.</span></span>|  
  
 <span data-ttu-id="02415-3302">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3302">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3303">要分配的字节数将被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3303">The number of bytes to be allocated is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3304">从堆栈中弹出字节数;与该大小相对应的内存量从本地堆中分配。</span><span class="sxs-lookup"><span data-stu-id="02415-3304">The number of bytes is popped from the stack; an amount of memory corresponding to the size is allocated from the local heap.</span></span>  
  
3.  <span data-ttu-id="02415-3305">指向分配的内存的第一个字节的指针被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3305">A pointer to the first byte of the allocated memory is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3306">`localloc` 指令从本地动态内存池分配 `size` （类型 `natural unsigned int`）个字节，并返回第一个分配的字节的地址（瞬态指针，类型 `*`）。</span><span class="sxs-lookup"><span data-stu-id="02415-3306">The `localloc` instruction allocates `size` (type `natural unsigned int`) bytes from the local dynamic memory pool and returns the address (a transient pointer, type `*`) of the first allocated byte.</span></span> <span data-ttu-id="02415-3307">仅当对方法的 initialize 标志 `true`时，返回的内存块才会初始化为0。</span><span class="sxs-lookup"><span data-stu-id="02415-3307">The block of memory returned is initialized to 0 only if the initialize flag on the method is `true`.</span></span> <span data-ttu-id="02415-3308">当当前方法执行 <xref:System.Reflection.Emit.OpCodes.Ret>时，本地内存池可供重复使用。</span><span class="sxs-lookup"><span data-stu-id="02415-3308">When the current method executes a <xref:System.Reflection.Emit.OpCodes.Ret>, the local memory pool is made available for reuse.</span></span>  
  
 <span data-ttu-id="02415-3309">生成的地址是对齐的，以便可以使用 `stind` 指令（如 <xref:System.Reflection.Emit.OpCodes.Stind_I4>）将任何基元数据类型存储在此处，并使用 `ldind` 指令（如 <xref:System.Reflection.Emit.OpCodes.Ldind_I4>）进行加载。</span><span class="sxs-lookup"><span data-stu-id="02415-3309">The resulting address is aligned so that any primitive data type can be stored there using the `stind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Stind_I4>) and loaded using the `ldind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).</span></span>  
  
 <span data-ttu-id="02415-3310">`localloc` 指令不能出现在 `filter`、`catch`、`finally`或 `fault` 块内。</span><span class="sxs-lookup"><span data-stu-id="02415-3310">The `localloc` instruction cannot occur within a `filter`, `catch`, `finally`, or `fault` block.</span></span>  
  
 <span data-ttu-id="02415-3311">如果没有足够的内存来为请求提供服务，则会引发 <xref:System.StackOverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3311"><xref:System.StackOverflowException> is thrown if there is insufficient memory to service the request.</span></span>  
  
 <span data-ttu-id="02415-3312">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `localloc` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3312">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `localloc` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3313">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3313">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3314">将对特定类型实例的类型化引用推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3314">Pushes a typed reference to an instance of a specific type onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3315">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3315">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3316">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3316">Format</span></span>|<span data-ttu-id="02415-3317">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3317">Assembly Format</span></span>|<span data-ttu-id="02415-3318">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3318">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3319">C6 < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-3319">C6 < `T` ></span></span>|<span data-ttu-id="02415-3320">mkrefany `class`</span><span class="sxs-lookup"><span data-stu-id="02415-3320">mkrefany `class`</span></span>|<span data-ttu-id="02415-3321">将类型 `class` 的类型化引用推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3321">Pushes a typed reference of type `class` onto the stack.</span></span>|  
  
 <span data-ttu-id="02415-3322">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3322">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3323">指向片段的数据被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3323">A pointer to piece of data is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3324">将弹出指针并将其转换为类型 `class`的类型化引用。</span><span class="sxs-lookup"><span data-stu-id="02415-3324">The pointer is popped and converted to a typed reference of type `class`.</span></span>  
  
3.  <span data-ttu-id="02415-3325">类型化的引用被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3325">The typed reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3326">`mkrefany` 指令支持动态类型化引用的传递。</span><span class="sxs-lookup"><span data-stu-id="02415-3326">The `mkrefany` instruction supports the passing of dynamically typed references.</span></span> <span data-ttu-id="02415-3327">指针的类型必须为 `&`、`*`或 `native int`，并保存一段数据的有效地址。</span><span class="sxs-lookup"><span data-stu-id="02415-3327">The pointer must be of type `&`, `*`, or `native int`, and hold the valid address of a piece of data.</span></span> <span data-ttu-id="02415-3328">`Class` 是描述指针所引用的数据类型的类标记。</span><span class="sxs-lookup"><span data-stu-id="02415-3328">`Class` is the class token describing the type of the data referenced by the pointer.</span></span> <span data-ttu-id="02415-3329">`Mkrefany` 将类型化引用推送到堆栈上，同时提供指针和类型 `class`的不透明说明符。</span><span class="sxs-lookup"><span data-stu-id="02415-3329">`Mkrefany` pushes a typed reference on the stack, providing an opaque descriptor of the pointer and the type `class`.</span></span>  
  
 <span data-ttu-id="02415-3330">对类型化引用允许的唯一有效操作是将其传递到要求类型化引用作为参数的方法。</span><span class="sxs-lookup"><span data-stu-id="02415-3330">The only valid operation permitted upon a typed reference is to pass it to a method that requires a typed reference as a parameter.</span></span> <span data-ttu-id="02415-3331">然后，调用方可以使用 <xref:System.Reflection.Emit.OpCodes.Refanytype> 和 <xref:System.Reflection.Emit.OpCodes.Refanyval> 指令分别检索类型（类）和地址。</span><span class="sxs-lookup"><span data-stu-id="02415-3331">The callee can then use the <xref:System.Reflection.Emit.OpCodes.Refanytype> and <xref:System.Reflection.Emit.OpCodes.Refanyval> instructions to retrieve the type (class) and the address respectively.</span></span>  
  
 <span data-ttu-id="02415-3332">如果找不到 `class`，则会引发 <xref:System.TypeLoadException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3332"><xref:System.TypeLoadException> is thrown if `class` cannot be found.</span></span> <span data-ttu-id="02415-3333">当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是运行时，通常会检测到此情况。</span><span class="sxs-lookup"><span data-stu-id="02415-3333">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="02415-3334">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `mkrefany` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3334">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mkrefany` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3335">ILGenerator （OpCode，Type）</span><span class="sxs-lookup"><span data-stu-id="02415-3335">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3336">将两个值相乘并将结果推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3336">Multiplies two values and pushes the result on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3337">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3337">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3338">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3338">Format</span></span>|<span data-ttu-id="02415-3339">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3339">Assembly Format</span></span>|<span data-ttu-id="02415-3340">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3340">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3341">5A</span><span class="sxs-lookup"><span data-stu-id="02415-3341">5A</span></span>|<span data-ttu-id="02415-3342">mul</span><span class="sxs-lookup"><span data-stu-id="02415-3342">mul</span></span>|<span data-ttu-id="02415-3343">将两个值相乘。</span><span class="sxs-lookup"><span data-stu-id="02415-3343">Multiplies two values on the stack.</span></span>|  
  
 <span data-ttu-id="02415-3344">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3344">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3345">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3345">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3346">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3346">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-3347">从堆栈中弹出 `value2` 和 `value1`;`value1` 与 `value2`相乘。</span><span class="sxs-lookup"><span data-stu-id="02415-3347">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`.</span></span>  
  
4.  <span data-ttu-id="02415-3348">将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3348">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3349">`mul` 指令将 `value1` 乘以 `value2` 并将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3349">The `mul` instruction multiplies `value1` by `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="02415-3350">整数运算在溢出时无提示截断高位。</span><span class="sxs-lookup"><span data-stu-id="02415-3350">Integer operations silently truncate the upper bits on overflow.</span></span>  
  
 <span data-ttu-id="02415-3351">有关使用溢出处理的特定于整数的乘法运算，请参阅 <xref:System.Reflection.Emit.OpCodes.Mul_Ovf>。</span><span class="sxs-lookup"><span data-stu-id="02415-3351">See <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> for an integer-specific multiply operation with overflow handling.</span></span>  
  
 <span data-ttu-id="02415-3352">对于浮点类型，为 0 \* 无穷 = NaN。</span><span class="sxs-lookup"><span data-stu-id="02415-3352">For floating-point types, 0 \* infinity = NaN.</span></span>  
  
 <span data-ttu-id="02415-3353">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `mul` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3353">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3354">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3354">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3355">将两个整数值相乘，执行溢出检查，并将结果推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3355">Multiplies two integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3356">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3356">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3357">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3357">Format</span></span>|<span data-ttu-id="02415-3358">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3358">Assembly Format</span></span>|<span data-ttu-id="02415-3359">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3359">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3360">D8</span><span class="sxs-lookup"><span data-stu-id="02415-3360">D8</span></span>|<span data-ttu-id="02415-3361">mul.ovf</span><span class="sxs-lookup"><span data-stu-id="02415-3361">mul.ovf</span></span>|<span data-ttu-id="02415-3362">使用溢出检查将堆栈上的两个整数值相乘。</span><span class="sxs-lookup"><span data-stu-id="02415-3362">Multiplies two integer values on the stack with an overflow check.</span></span>|  
  
 <span data-ttu-id="02415-3363">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3363">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3364">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3364">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3365">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3365">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-3366">从堆栈中弹出 `value2` 和 `value1`;`value1` 与 `value2`相乘，并进行溢出检查。</span><span class="sxs-lookup"><span data-stu-id="02415-3366">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.</span></span>  
  
4.  <span data-ttu-id="02415-3367">将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3367">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3368">`mul.ovf` 指令将整数 `value1` 乘以整数 `value2`，并将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3368">The `mul.ovf` instruction multiplies integer `value1` by integer `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="02415-3369">如果结果类型中不能容纳结果，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-3369">An exception is thrown if the result will not fit in the result type.</span></span>  
  
 <span data-ttu-id="02415-3370">如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3370"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-3371">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `mul.ovf` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3371">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3372">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3372">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3373">将两个无符号整数值相乘，执行溢出检查，并将结果推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3373">Multiplies two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3374">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3374">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3375">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3375">Format</span></span>|<span data-ttu-id="02415-3376">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3376">Assembly Format</span></span>|<span data-ttu-id="02415-3377">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3377">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3378">D9</span><span class="sxs-lookup"><span data-stu-id="02415-3378">D9</span></span>|<span data-ttu-id="02415-3379">mul.ovf.un</span><span class="sxs-lookup"><span data-stu-id="02415-3379">mul.ovf.un</span></span>|<span data-ttu-id="02415-3380">将堆栈上的两个无符号值与溢出检查相乘。</span><span class="sxs-lookup"><span data-stu-id="02415-3380">Multiplies two unsigned values on the stack with an overflow check.</span></span>|  
  
 <span data-ttu-id="02415-3381">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3381">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3382">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3382">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3383">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3383">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-3384">从堆栈中弹出 `value2` 和 `value1`;`value1` 与 `value2`相乘，并进行溢出检查。</span><span class="sxs-lookup"><span data-stu-id="02415-3384">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.</span></span>  
  
4.  <span data-ttu-id="02415-3385">将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3385">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3386">`mul.ovf.un` 指令将无符号整数 `value1` 为无 `value2` 符号整数，并将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3386">The `mul.ovf.un` instruction multiplies unsigned integer `value1` by unsigned integer `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="02415-3387">如果结果类型中不能容纳结果，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-3387">An exception is thrown if the result will not fit in the result type.</span></span>  
  
 <span data-ttu-id="02415-3388">如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3388"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-3389">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `mul.ovf.un` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3389">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3390">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3390">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3391">对一个值执行求反并将结果推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3391">Negates a value and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3392">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3392">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3393">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3393">Format</span></span>|<span data-ttu-id="02415-3394">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3394">Assembly Format</span></span>|<span data-ttu-id="02415-3395">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3395">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3396">65</span><span class="sxs-lookup"><span data-stu-id="02415-3396">65</span></span>|<span data-ttu-id="02415-3397">neg</span><span class="sxs-lookup"><span data-stu-id="02415-3397">neg</span></span>|<span data-ttu-id="02415-3398">对当前位于堆栈顶部的值求反。</span><span class="sxs-lookup"><span data-stu-id="02415-3398">Negates the value currently on top of the stack.</span></span>|  
  
 <span data-ttu-id="02415-3399">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3399">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3400">将值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3400">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3401">从堆栈中弹出一个值并对其进行求反。</span><span class="sxs-lookup"><span data-stu-id="02415-3401">A value is popped from the stack and negated.</span></span>  
  
3.  <span data-ttu-id="02415-3402">将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3402">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3403">`neg` 指令对值进行求反并将结果推送到堆栈顶部。</span><span class="sxs-lookup"><span data-stu-id="02415-3403">The `neg` instruction negates value and pushes the result on top of the stack.</span></span> <span data-ttu-id="02415-3404">返回类型与操作数类型相同。</span><span class="sxs-lookup"><span data-stu-id="02415-3404">The return type is the same as the operand type.</span></span>  
  
 <span data-ttu-id="02415-3405">整数值的求反是标准2的补码反运算。</span><span class="sxs-lookup"><span data-stu-id="02415-3405">Negation of integral values is standard two's complement negation.</span></span> <span data-ttu-id="02415-3406">特别是，取消最多负数（不具有正号）将产生最大的负数。</span><span class="sxs-lookup"><span data-stu-id="02415-3406">In particular, negating the most negative number (which does not have a positive counterpart) yields the most negative number.</span></span> <span data-ttu-id="02415-3407">若要检测此溢出，请改用 <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> 指令（即从0中减去）。</span><span class="sxs-lookup"><span data-stu-id="02415-3407">To detect this overflow use the <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> instruction instead (that is, subtract from 0).</span></span>  
  
 <span data-ttu-id="02415-3408">取消浮点数不能溢出，取消 NaN 返回 NaN。</span><span class="sxs-lookup"><span data-stu-id="02415-3408">Negating a floating-point number cannot overflow, and negating NaN returns NaN.</span></span>  
  
 <span data-ttu-id="02415-3409">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `neg` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3409">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `neg` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3410">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3410">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3411">将对新的从零开始的一维数组（其元素属于特定类型）的对象引用推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3411">Pushes an object reference to a new zero-based, one-dimensional array whose elements are of a specific type onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3412">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3412">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3413">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3413">Format</span></span>|<span data-ttu-id="02415-3414">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3414">Assembly Format</span></span>|<span data-ttu-id="02415-3415">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3415">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3416">8 D< `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-3416">8D < `T` ></span></span>|<span data-ttu-id="02415-3417">newarr `etype`</span><span class="sxs-lookup"><span data-stu-id="02415-3417">newarr `etype`</span></span>|<span data-ttu-id="02415-3418">使用 `etype`类型的元素创建一个新数组。</span><span class="sxs-lookup"><span data-stu-id="02415-3418">Creates a new array with elements of type `etype`.</span></span>|  
  
 <span data-ttu-id="02415-3419">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3419">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3420">数组中的元素数被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3420">The number of elements in the array is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3421">从堆栈中弹出元素数并创建数组。</span><span class="sxs-lookup"><span data-stu-id="02415-3421">The number of elements is popped from the stack and the array is created.</span></span>  
  
3.  <span data-ttu-id="02415-3422">对新数组的对象引用被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3422">An object reference to the new array is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3423">`newarr` 指令将对象引用（类型 `O`）推送到新的从零开始的一维数组，该数组的元素的类型为 `etype` （描述该类型的元数据标记）。</span><span class="sxs-lookup"><span data-stu-id="02415-3423">The `newarr` instruction pushes an object reference (type `O`) to a new zero-based, one-dimensional array whose elements are of type `etype` (a metadata token describing the type).</span></span> <span data-ttu-id="02415-3424">新数组中的元素数应指定为 `native int`。</span><span class="sxs-lookup"><span data-stu-id="02415-3424">The number of elements in the new array should be specified as a `native int`.</span></span> <span data-ttu-id="02415-3425">有效的数组索引范围从零到最大元素数减一。</span><span class="sxs-lookup"><span data-stu-id="02415-3425">Valid array indexes range from zero to the maximum number of elements minus one.</span></span>  
  
 <span data-ttu-id="02415-3426">数组元素可以是任何类型，包括值类型。</span><span class="sxs-lookup"><span data-stu-id="02415-3426">The elements of an array can be any type, including value types.</span></span>  
  
 <span data-ttu-id="02415-3427">从零开始的一维数组，使用引用适当值类型（<xref:System.Int32>等）的元数据标记创建。</span><span class="sxs-lookup"><span data-stu-id="02415-3427">Zero-based, one-dimensional arrays of numbers are created using a metadata token referencing the appropriate value type (<xref:System.Int32>, and so on).</span></span> <span data-ttu-id="02415-3428">数组的元素初始化为适当类型的0。</span><span class="sxs-lookup"><span data-stu-id="02415-3428">Elements of the array are initialized to 0 of the appropriate type.</span></span>  
  
 <span data-ttu-id="02415-3429">基于非零的一维数组和多维数组使用 <xref:System.Reflection.Emit.OpCodes.Newobj> 而不是 `newarr`来创建。</span><span class="sxs-lookup"><span data-stu-id="02415-3429">Nonzero-based one-dimensional arrays and multidimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newobj> rather than `newarr`.</span></span> <span data-ttu-id="02415-3430">通常，它们是使用 .NET Framework 中 <xref:System.Array> 类的方法创建的。</span><span class="sxs-lookup"><span data-stu-id="02415-3430">More commonly, they are created using the methods of the <xref:System.Array> class in the .NET Framework.</span></span>  
  
 <span data-ttu-id="02415-3431">如果内存不足，无法满足请求，则会引发 <xref:System.OutOfMemoryException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3431"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="02415-3432">如果 `numElems` 小于0，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3432"><xref:System.OverflowException> is thrown if `numElems` is less than 0.</span></span>  
  
 <span data-ttu-id="02415-3433">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `newarr` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3433">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newarr` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3434">ILGenerator （OpCode，Type）</span><span class="sxs-lookup"><span data-stu-id="02415-3434">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3435">创建一个值类型的新对象或新实例，并将对象引用（<see langword="O" /> 类型）推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3435">Creates a new object or a new instance of a value type, pushing an object reference (type <see langword="O" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3436">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3436">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3437">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3437">Format</span></span>|<span data-ttu-id="02415-3438">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3438">Assembly Format</span></span>|<span data-ttu-id="02415-3439">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3439">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3440">73 < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-3440">73 < `T` ></span></span>|<span data-ttu-id="02415-3441">newobj `ctor`</span><span class="sxs-lookup"><span data-stu-id="02415-3441">newobj `ctor`</span></span>|<span data-ttu-id="02415-3442">分配未初始化的对象或值类型，并 `ctor`调用构造函数方法。</span><span class="sxs-lookup"><span data-stu-id="02415-3442">Allocates an uninitialized object or value type and calls the constructor method `ctor`.</span></span>|  
  
 <span data-ttu-id="02415-3443">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3443">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3444">`arg1` 通过 `argn` 的参数按顺序推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3444">Arguments `arg1` through `argn` are pushed on the stack in sequence.</span></span>  
  
2.  <span data-ttu-id="02415-3445">从堆栈中弹出 `argn` 到 `arg1` 的参数，并将其传递给 `ctor` 以创建对象。</span><span class="sxs-lookup"><span data-stu-id="02415-3445">Arguments `argn` through `arg1` are popped from the stack and passed to `ctor` for object creation.</span></span>  
  
3.  <span data-ttu-id="02415-3446">对新的对象的引用被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3446">A reference to the new object is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3447">`newobj` 指令创建新对象或值类型的新实例。</span><span class="sxs-lookup"><span data-stu-id="02415-3447">The `newobj` instruction creates a new object or a new instance of a value type.</span></span> <span data-ttu-id="02415-3448">`Ctor` 是要调用的构造函数的名称、类和签名的元数据标记（必须标记为构造函数的 `methodref` 或 `methoddef`）。</span><span class="sxs-lookup"><span data-stu-id="02415-3448">`Ctor` is a metadata token (a `methodref` or `methoddef` that must be marked as a constructor) that indicates the name, class and signature of the constructor to call.</span></span>  
  
 <span data-ttu-id="02415-3449">`newobj` 指令分配与 `ctor` 关联的类的新实例，并根据需要将新实例中的所有字段初始化为0（适当的类型）或空引用。</span><span class="sxs-lookup"><span data-stu-id="02415-3449">The `newobj` instruction allocates a new instance of the class associated with `ctor` and initializes all the fields in the new instance to 0 (of the proper type) or null references as appropriate.</span></span> <span data-ttu-id="02415-3450">然后，它将调用具有给定参数的构造 `ctor` 函数和新创建的实例。</span><span class="sxs-lookup"><span data-stu-id="02415-3450">It then calls the constructor `ctor` with the given arguments along with the newly created instance.</span></span> <span data-ttu-id="02415-3451">调用构造函数后，现在将初始化的对象引用（类型 `O`）推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3451">After the constructor has been called, the now initialized object reference (type `O`) is pushed on the stack.</span></span>  
  
 <span data-ttu-id="02415-3452">从构造函数的角度来看，未初始化的对象是参数0，传递给 newobj 的其他参数按照顺序排列。</span><span class="sxs-lookup"><span data-stu-id="02415-3452">From the constructor's point of view, the uninitialized object is argument 0 and the other arguments passed to newobj follow in order.</span></span>  
  
 <span data-ttu-id="02415-3453">所有从零开始的一维数组是使用 <xref:System.Reflection.Emit.OpCodes.Newarr>创建的，而不是 `newobj`的。</span><span class="sxs-lookup"><span data-stu-id="02415-3453">All zero-based, one-dimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newarr>, not `newobj`.</span></span> <span data-ttu-id="02415-3454">另一方面，将使用 `newobj`创建所有其他数组（多个维度，或一维但非从零开始）。</span><span class="sxs-lookup"><span data-stu-id="02415-3454">On the other hand, all other arrays (more than one dimension, or one-dimensional but not zero-based) are created using `newobj`.</span></span>  
  
 <span data-ttu-id="02415-3455">通常不使用 `newobj`创建值类型。</span><span class="sxs-lookup"><span data-stu-id="02415-3455">Value types are not usually created using `newobj`.</span></span> <span data-ttu-id="02415-3456">它们通常作为参数或局部变量分配，使用 `newarr` （适用于从零开始的一维数组）或作为对象的字段。</span><span class="sxs-lookup"><span data-stu-id="02415-3456">They are usually allocated either as arguments or local variables, using `newarr` (for zero-based, one-dimensional arrays), or as fields of objects.</span></span> <span data-ttu-id="02415-3457">分配后，将使用 <xref:System.Reflection.Emit.OpCodes.Initobj>对其进行初始化。</span><span class="sxs-lookup"><span data-stu-id="02415-3457">Once allocated, they are initialized using <xref:System.Reflection.Emit.OpCodes.Initobj>.</span></span> <span data-ttu-id="02415-3458">但是，可以使用 `newobj` 指令在堆栈上创建值类型的新实例，然后可以将该实例作为参数进行传递，并将其存储在本地，等等。</span><span class="sxs-lookup"><span data-stu-id="02415-3458">However, the `newobj` instruction can be used to create a new instance of a value type on the stack, that can then be passed as an argument, stored in a local, and so on.</span></span>  
  
 <span data-ttu-id="02415-3459">如果内存不足，无法满足请求，则会引发 <xref:System.OutOfMemoryException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3459"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="02415-3460">如果找不到具有指定名称、类和签名的构造函数方法 `ctor`，则会引发 <xref:System.MissingMethodException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3460"><xref:System.MissingMethodException> is thrown if a constructor method `ctor` with the indicated name, class and signature could not be found.</span></span> <span data-ttu-id="02415-3461">当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是运行时，通常会检测到此情况。</span><span class="sxs-lookup"><span data-stu-id="02415-3461">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="02415-3462">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `newobj` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3462">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newobj` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3463">ILGenerator （OpCode，ConstructorInfo）</span><span class="sxs-lookup"><span data-stu-id="02415-3463">ILGenerator.Emit(OpCode, ConstructorInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3464">如果修补操作码，则填充空间。</span><span class="sxs-lookup"><span data-stu-id="02415-3464">Fills space if opcodes are patched.</span></span> <span data-ttu-id="02415-3465">尽管可能消耗处理周期，但未执行任何有意义的操作。</span><span class="sxs-lookup"><span data-stu-id="02415-3465">No meaningful operation is performed although a processing cycle can be consumed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3466">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3466">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3467">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3467">Format</span></span>|<span data-ttu-id="02415-3468">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3468">Assembly Format</span></span>|<span data-ttu-id="02415-3469">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3469">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3470">00</span><span class="sxs-lookup"><span data-stu-id="02415-3470">00</span></span>|<span data-ttu-id="02415-3471">nop</span><span class="sxs-lookup"><span data-stu-id="02415-3471">nop</span></span>|<span data-ttu-id="02415-3472">执行不具有行为的操作。</span><span class="sxs-lookup"><span data-stu-id="02415-3472">Performs an operation without behavior.</span></span>|  
  
 <span data-ttu-id="02415-3473">没有为此指令定义堆栈过渡行为。</span><span class="sxs-lookup"><span data-stu-id="02415-3473">There is no stack transitional behavior defined for this instruction.</span></span>  
  
 <span data-ttu-id="02415-3474">`nop` 操作不执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="02415-3474">The `nop` operation does nothing.</span></span> <span data-ttu-id="02415-3475">它用于在对操作码进行修补时填充空间。</span><span class="sxs-lookup"><span data-stu-id="02415-3475">It is intended to fill in space if opcodes are patched.</span></span>  
  
 <span data-ttu-id="02415-3476">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `nop` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3476">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `nop` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3477">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3477">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3478">计算堆栈顶部整数值的按位求补并将结果作为相同的类型推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3478">Computes the bitwise complement of the integer value on top of the stack and pushes the result onto the evaluation stack as the same type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3479">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3479">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3480">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3480">Format</span></span>|<span data-ttu-id="02415-3481">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3481">Assembly Format</span></span>|<span data-ttu-id="02415-3482">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3482">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3483">66</span><span class="sxs-lookup"><span data-stu-id="02415-3483">66</span></span>|<span data-ttu-id="02415-3484">not</span><span class="sxs-lookup"><span data-stu-id="02415-3484">not</span></span>|<span data-ttu-id="02415-3485">计算值的按位求补。</span><span class="sxs-lookup"><span data-stu-id="02415-3485">Computes the bitwise complement of a value.</span></span>|  
  
 <span data-ttu-id="02415-3486">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3486">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3487">将 `value` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3487">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3488">从堆栈中弹出 `value`，并计算按位求补。</span><span class="sxs-lookup"><span data-stu-id="02415-3488">`value` is popped from the stack and its bitwise complement computed.</span></span>  
  
3.  <span data-ttu-id="02415-3489">将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3489">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3490">`not` 指令计算整数值的按位求补并将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3490">The `not` instruction computes the bitwise complement of an integer value and pushes the result onto the stack.</span></span> <span data-ttu-id="02415-3491">返回类型与操作数类型相同。</span><span class="sxs-lookup"><span data-stu-id="02415-3491">The return type is the same as the operand type.</span></span>  
  
 <span data-ttu-id="02415-3492">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `not` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3492">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `not` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3493">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3493">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3494">计算位于堆栈顶部的两个整数值的按位求补并将结果推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3494">Compute the bitwise complement of the two integer values on top of the stack and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3495">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3495">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3496">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3496">Format</span></span>|<span data-ttu-id="02415-3497">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3497">Assembly Format</span></span>|<span data-ttu-id="02415-3498">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3498">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3499">60</span><span class="sxs-lookup"><span data-stu-id="02415-3499">60</span></span>|<span data-ttu-id="02415-3500">or</span><span class="sxs-lookup"><span data-stu-id="02415-3500">or</span></span>|<span data-ttu-id="02415-3501">计算两个整数值的按位 "或"，返回整数。</span><span class="sxs-lookup"><span data-stu-id="02415-3501">Computes the bitwise OR of two integer values, returns an integer.</span></span>|  
  
 <span data-ttu-id="02415-3502">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3502">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3503">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3503">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3504">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3504">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-3505">`value2` 和 `value1` 从堆栈中弹出，并按位或计算。</span><span class="sxs-lookup"><span data-stu-id="02415-3505">`value2` and `value1` are popped from the stack and their bitwise OR computed.</span></span>  
  
4.  <span data-ttu-id="02415-3506">将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3506">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3507">`or` 指令计算堆栈顶部的两个值的按位 "或"，并将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3507">The `or` instruction computes the bitwise OR of two values atop the stack, pushing the result onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3508">`Or` 是特定于整数的操作。</span><span class="sxs-lookup"><span data-stu-id="02415-3508">`Or` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="02415-3509">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `or` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3509">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `or` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3510">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3510">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3511">移除当前位于计算堆栈顶部的值。</span><span class="sxs-lookup"><span data-stu-id="02415-3511">Removes the value currently on top of the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3512">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3512">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3513">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3513">Format</span></span>|<span data-ttu-id="02415-3514">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3514">Assembly Format</span></span>|<span data-ttu-id="02415-3515">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3515">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3516">26</span><span class="sxs-lookup"><span data-stu-id="02415-3516">26</span></span>|<span data-ttu-id="02415-3517">pop</span><span class="sxs-lookup"><span data-stu-id="02415-3517">pop</span></span>|<span data-ttu-id="02415-3518">从堆栈中弹出顶部值。</span><span class="sxs-lookup"><span data-stu-id="02415-3518">Pops the top value from the stack.</span></span>|  
  
 <span data-ttu-id="02415-3519">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3519">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3520">顶部值从堆栈中弹出。</span><span class="sxs-lookup"><span data-stu-id="02415-3520">The top value is popped from the stack.</span></span>  
  
 <span data-ttu-id="02415-3521">`pop` 指令从堆栈中移除顶部元素。</span><span class="sxs-lookup"><span data-stu-id="02415-3521">The `pop` instruction removes the top element from the stack.</span></span>  
  
 <span data-ttu-id="02415-3522">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `pop` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3522">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `pop` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3523">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3523">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3524">此指令为保留指令。</span><span class="sxs-lookup"><span data-stu-id="02415-3524">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3525">此指令为保留指令。</span><span class="sxs-lookup"><span data-stu-id="02415-3525">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3526">此指令为保留指令。</span><span class="sxs-lookup"><span data-stu-id="02415-3526">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3527">此指令为保留指令。</span><span class="sxs-lookup"><span data-stu-id="02415-3527">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3528">此指令为保留指令。</span><span class="sxs-lookup"><span data-stu-id="02415-3528">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3529">此指令为保留指令。</span><span class="sxs-lookup"><span data-stu-id="02415-3529">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3530">此指令为保留指令。</span><span class="sxs-lookup"><span data-stu-id="02415-3530">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3531">此指令为保留指令。</span><span class="sxs-lookup"><span data-stu-id="02415-3531">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3532">指定后面的数组地址操作在运行时不执行类型检查，并且返回可变性受限的托管指针。</span><span class="sxs-lookup"><span data-stu-id="02415-3532">Specifies that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer whose mutability is restricted.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3533">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3533">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3534">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3534">Format</span></span>|<span data-ttu-id="02415-3535">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3535">Assembly Format</span></span>|<span data-ttu-id="02415-3536">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3536">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3537">FE 1E</span><span class="sxs-lookup"><span data-stu-id="02415-3537">FE 1E</span></span>|<span data-ttu-id="02415-3538">只读.</span><span class="sxs-lookup"><span data-stu-id="02415-3538">readonly.</span></span>|<span data-ttu-id="02415-3539">指定后续数组地址操作在运行时不执行类型检查，并且它返回具有受限可变性的托管指针。</span><span class="sxs-lookup"><span data-stu-id="02415-3539">Specify that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer with restricted mutability.</span></span>|  
  
 <span data-ttu-id="02415-3540">此前缀只能出现在 `ldelema` 指令之前，并调用数组的特殊 `Address` 方法。</span><span class="sxs-lookup"><span data-stu-id="02415-3540">This prefix can only appear immediately preceding the `ldelema` instruction and calls to the special `Address` method on arrays.</span></span> <span data-ttu-id="02415-3541">其对后续操作的影响是双重的：</span><span class="sxs-lookup"><span data-stu-id="02415-3541">Its effect on the subsequent operation is twofold:</span></span>  
  
1.  <span data-ttu-id="02415-3542">在运行时，不执行任何类型检查操作。</span><span class="sxs-lookup"><span data-stu-id="02415-3542">At run time, no type check operation is performed.</span></span> <span data-ttu-id="02415-3543">请注意，在引用类型数组上使用时，通常会对 `ldelema` 进行隐式类型检查，并 `stelem` 说明。</span><span class="sxs-lookup"><span data-stu-id="02415-3543">Note that there is normally an implicit type check for the `ldelema` and `stelem` instructions when used on reference type arrays.</span></span> <span data-ttu-id="02415-3544">对于值类，从来不会进行运行时类型检查，因此在这种情况下 `readonly` 是无操作的。</span><span class="sxs-lookup"><span data-stu-id="02415-3544">There is never a run-time type check for value classes, so `readonly` is a no-op in that case.</span></span>  
  
2.  <span data-ttu-id="02415-3545">验证程序将操作地址操作的结果视为具有受限可变性的托管指针。</span><span class="sxs-lookup"><span data-stu-id="02415-3545">The verifier treats the result of the address-of operation as a managed pointer with restricted mutability.</span></span>  
  
 <span data-ttu-id="02415-3546">指针被称为具有受限的可变性，因为定义类型控制值是否可转变。</span><span class="sxs-lookup"><span data-stu-id="02415-3546">The pointer is said to have restricted mutability because the defining type controls whether the value can be mutated.</span></span> <span data-ttu-id="02415-3547">对于公开无公共字段或更新就地值的方法的值类，该指针为只读（因此为前缀的名称）。</span><span class="sxs-lookup"><span data-stu-id="02415-3547">For value classes that expose no public fields or methods that update the value in place, the pointer is read-only (hence the name of the prefix).</span></span> <span data-ttu-id="02415-3548">特别是，表示基元类型的类（例如，System.object）不公开赋值函数，因此它们是只读的。</span><span class="sxs-lookup"><span data-stu-id="02415-3548">In particular, the classes representing primitive types (for example, System.Int32) do not expose mutators and thus are read-only.</span></span>  
  
 <span data-ttu-id="02415-3549">以这种方式限制的托管指针只能通过以下方式使用：</span><span class="sxs-lookup"><span data-stu-id="02415-3549">A managed pointer restricted in this fashion can be used only in the following ways:</span></span>  
  
-   <span data-ttu-id="02415-3550">作为 `ldfld`的 `object` 参数，`ldflda`、`stfld`、`call`或`constrained callvirt` 说明。</span><span class="sxs-lookup"><span data-stu-id="02415-3550">As the `object` parameter for the `ldfld`, `ldflda`, `stfld`, `call`, or`constrained callvirt` instructions.</span></span>  
  
-   <span data-ttu-id="02415-3551">作为 `ldobj` 指令的 `pointer` 参数或 `ldind` 说明之一。</span><span class="sxs-lookup"><span data-stu-id="02415-3551">As the `pointer` parameter to the `ldobj` instruction or to one of the `ldind` instructions.</span></span>  
  
-   <span data-ttu-id="02415-3552">作为 `cpobj` 指令的 `source` 参数。</span><span class="sxs-lookup"><span data-stu-id="02415-3552">As the `source` parameter to the `cpobj` instruction.</span></span>  
  
 <span data-ttu-id="02415-3553">不允许所有其他操作，包括 `stobj`、`initobj`或 `mkrefany` 操作，或者任何 `stind` 说明。</span><span class="sxs-lookup"><span data-stu-id="02415-3553">All other operations disallowed, including the `stobj`, `initobj`, or `mkrefany` operations, or any of the `stind` instructions.</span></span>  
  
 <span data-ttu-id="02415-3554">`readonly` 前缀的目的是为了避免在从泛型代码中的数组获取元素时进行类型检查。</span><span class="sxs-lookup"><span data-stu-id="02415-3554">The purpose of the `readonly` prefix is to avoid a type check when fetching an element from an array in generic code.</span></span> <span data-ttu-id="02415-3555">例如，表达式 `arr[i].m()`，其中数组 `arr` 的元素类型是一个泛型类型，该类型被约束为具有带方法 `m`的接口，可能会编译为以下 MSIL。</span><span class="sxs-lookup"><span data-stu-id="02415-3555">For example, the expression `arr[i].m()`, where the element type of the array `arr` is a generic type that has been constrained to have an interface with method `m`, might compile to the following MSIL.</span></span>  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 <span data-ttu-id="02415-3556">如果没有 `readonly` 前缀，则 `ldelema` 指令会在！0是引用类型的情况下执行类型检查。</span><span class="sxs-lookup"><span data-stu-id="02415-3556">Without the `readonly` prefix, the `ldelema` instruction would perform a type check in the case where !0 was a reference type.</span></span> <span data-ttu-id="02415-3557">这种类型的检查不仅低效，而且它在语义上不正确。</span><span class="sxs-lookup"><span data-stu-id="02415-3557">Not only is this type check inefficient, but it is semantically incorrect.</span></span> <span data-ttu-id="02415-3558">`ldelema` 的类型检查是完全匹配，这太强。</span><span class="sxs-lookup"><span data-stu-id="02415-3558">The type check for `ldelema` is an exact match, which is too strong.</span></span> <span data-ttu-id="02415-3559">如果数组持有类型为！0的子类，则上述代码将无法通过类型检查。</span><span class="sxs-lookup"><span data-stu-id="02415-3559">If the array held subclasses of type !0, the code above would fail the type check.</span></span>  
  
 <span data-ttu-id="02415-3560">提取数组元素的地址，而不是元素本身，以获得适用于值类型和引用类型的 `arr[i]` 的句柄，因此可将其传递给 `constrained callvirt` 指令。</span><span class="sxs-lookup"><span data-stu-id="02415-3560">The address of the array element is fetched, instead of the element itself, in order to have a handle for `arr[i]` that works for both value types and reference types, and thus can be passed to the `constrained callvirt` instruction.</span></span>  
  
 <span data-ttu-id="02415-3561">通常，如果数组持有引用类型的元素，则跳过运行时检查是不安全的。</span><span class="sxs-lookup"><span data-stu-id="02415-3561">In general it would be unsafe to skip the run-time check if the array held elements of a reference type.</span></span> <span data-ttu-id="02415-3562">为安全起见，需要确保不通过此指针对数组进行任何修改。</span><span class="sxs-lookup"><span data-stu-id="02415-3562">To be safe, it is necessary to ensure that no modifications to the array are made through this pointer.</span></span> <span data-ttu-id="02415-3563">验证程序规则确保这一点。</span><span class="sxs-lookup"><span data-stu-id="02415-3563">The verifier rules ensure this.</span></span> <span data-ttu-id="02415-3564">受限制的托管指针可以作为实例方法调用的对象进行传递，因此对于值类型而言，并不严格地说是只读的，但对于值类型，不存在任何类型安全问题。</span><span class="sxs-lookup"><span data-stu-id="02415-3564">The restricted managed pointer can be passed as the object of instance method calls, so it is not strictly speaking read-only for value types, but there is no type safety problem for value types.</span></span>  
  
 <span data-ttu-id="02415-3565">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `readonly` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3565">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `readonly` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3566">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3566">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3567">检索嵌入在类型化引用内的类型标记。</span><span class="sxs-lookup"><span data-stu-id="02415-3567">Retrieves the type token embedded in a typed reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3568">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3568">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3569">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3569">Format</span></span>|<span data-ttu-id="02415-3570">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3570">Assembly Format</span></span>|<span data-ttu-id="02415-3571">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3571">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3572">FE 1D</span><span class="sxs-lookup"><span data-stu-id="02415-3572">FE 1D</span></span>|<span data-ttu-id="02415-3573">refanytype</span><span class="sxs-lookup"><span data-stu-id="02415-3573">refanytype</span></span>|<span data-ttu-id="02415-3574">推送在类型化引用中存储的类型标记。</span><span class="sxs-lookup"><span data-stu-id="02415-3574">Pushes the type token stored in a typed reference.</span></span>|  
  
 <span data-ttu-id="02415-3575">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3575">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3576">值类型引用被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3576">A value type reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3577">类型化引用从堆栈中弹出，并检索其相应的类型标记。</span><span class="sxs-lookup"><span data-stu-id="02415-3577">The typed reference is popped from the stack and its corresponding type token retrieved.</span></span>  
  
3.  <span data-ttu-id="02415-3578">类型标记被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3578">The type token is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3579">类型化引用包含对象实例的类型标记和地址。</span><span class="sxs-lookup"><span data-stu-id="02415-3579">A typed reference contains a type token and an address to an object instance.</span></span>  
  
 <span data-ttu-id="02415-3580">`refanytype` 指令检索嵌入在类型化引用中的类型标记。</span><span class="sxs-lookup"><span data-stu-id="02415-3580">The `refanytype` instruction retrieves the type token embedded in the typed reference.</span></span> <span data-ttu-id="02415-3581">有关创建类型化引用的信息，请参阅 <xref:System.Reflection.Emit.OpCodes.Mkrefany> 说明。</span><span class="sxs-lookup"><span data-stu-id="02415-3581">See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for information on creating typed references.</span></span>  
  
 <span data-ttu-id="02415-3582">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `refanytype` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3582">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanytype` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3583">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3583">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3584">检索嵌入在类型化引用内的地址（<see langword="&amp;" /> 类型）。</span><span class="sxs-lookup"><span data-stu-id="02415-3584">Retrieves the address (type <see langword="&amp;" />) embedded in a typed reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3585">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3585">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3586">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3586">Format</span></span>|<span data-ttu-id="02415-3587">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3587">Assembly Format</span></span>|<span data-ttu-id="02415-3588">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3588">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3589">C2 < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-3589">C2 < `T` ></span></span>|<span data-ttu-id="02415-3590">refanyval `type`</span><span class="sxs-lookup"><span data-stu-id="02415-3590">refanyval `type`</span></span>|<span data-ttu-id="02415-3591">推送在类型化引用中存储的地址。</span><span class="sxs-lookup"><span data-stu-id="02415-3591">Pushes the address stored in a typed reference.</span></span>|  
  
 <span data-ttu-id="02415-3592">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3592">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3593">值类型引用被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3593">A value type reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3594">从堆栈中弹出类型化引用和检索到相应的地址。</span><span class="sxs-lookup"><span data-stu-id="02415-3594">The typed reference is popped from the stack and the corresponding address retrieved.</span></span>  
  
3.  <span data-ttu-id="02415-3595">该地址将被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3595">The address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3596">类型化引用包含对象实例的类型标记和地址。</span><span class="sxs-lookup"><span data-stu-id="02415-3596">A typed reference contains a type token and an address to an object instance.</span></span>  
  
 <span data-ttu-id="02415-3597">`refanyval` 指令检索嵌入在类型化引用中的地址。</span><span class="sxs-lookup"><span data-stu-id="02415-3597">The `refanyval` instruction retrieves the address embedded in the a typed reference.</span></span> <span data-ttu-id="02415-3598">在堆栈上提供的类型化引用中嵌入的类型必须与 `type` （元数据标记，`typedef` 或 `typeref`）指定的类型匹配。</span><span class="sxs-lookup"><span data-stu-id="02415-3598">The type embedded in the typed reference supplied on the stack must match the type specified by `type` (a metadata token, either a `typedef` or a `typeref`).</span></span> <span data-ttu-id="02415-3599">请参阅 <xref:System.Reflection.Emit.OpCodes.Mkrefany> 说明了解相关内容。</span><span class="sxs-lookup"><span data-stu-id="02415-3599">See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for related content.</span></span>  
  
 <span data-ttu-id="02415-3600">如果 `type` 与类型引用中存储的类型不完全相同（在这种情况下，则会引发 <xref:System.InvalidCastException>，`type` 是提供给构造所说的类型化引用的 <xref:System.Reflection.Emit.OpCodes.Mkrefany> 指令的类。）</span><span class="sxs-lookup"><span data-stu-id="02415-3600"><xref:System.InvalidCastException> is thrown if `type` is not identical to the type stored in the type reference (in this case, `type` is the class supplied to the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction that constructed said typed reference).</span></span>  
  
 <span data-ttu-id="02415-3601">如果找不到 `type`，则会引发 <xref:System.TypeLoadException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3601"><xref:System.TypeLoadException> is thrown if `type` cannot be found.</span></span>  
  
 <span data-ttu-id="02415-3602">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `refanyval` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3602">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanyval` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3603">ILGenerator （OpCode，Type）</span><span class="sxs-lookup"><span data-stu-id="02415-3603">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3604">将两个值相除并将余数推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3604">Divides two values and pushes the remainder onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3605">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3605">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3606">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3606">Format</span></span>|<span data-ttu-id="02415-3607">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3607">Assembly Format</span></span>|<span data-ttu-id="02415-3608">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3608">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3609">5D</span><span class="sxs-lookup"><span data-stu-id="02415-3609">5D</span></span>|<span data-ttu-id="02415-3610">rem</span><span class="sxs-lookup"><span data-stu-id="02415-3610">rem</span></span>|<span data-ttu-id="02415-3611">将除以 `value2` `value1` 的剩余部分推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3611">Pushes the remainder of dividing `value1` by `value2` onto the stack.</span></span>|  
  
  
 <span data-ttu-id="02415-3612">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3612">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3613">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3613">A `value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3614">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3614">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-3615">`value2` 和 `value1` 从堆栈中弹出，`value1` `div` `value2` 计算所得的余数。</span><span class="sxs-lookup"><span data-stu-id="02415-3615">`value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.</span></span>  
  
4.  <span data-ttu-id="02415-3616">将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3616">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3617">`result` = `value1` `rem` `value2` 满足以下条件：</span><span class="sxs-lookup"><span data-stu-id="02415-3617">`result` = `value1` `rem` `value2` satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="02415-3618">`result` = `value1` - `value2` `×` （`value1` `div` `value2`）和：</span><span class="sxs-lookup"><span data-stu-id="02415-3618">`result` = `value1` - `value2` `×` (`value1` `div` `value2`), and:</span></span>  
  
 <span data-ttu-id="02415-3619">0 = &#124; `result` &#124; < &#124; `value2` &#124;、符号（`result`） = sign （`value1`），其中 `div` 是向零截断的除法指令。</span><span class="sxs-lookup"><span data-stu-id="02415-3619">0 = &#124; `result` &#124; < &#124; `value2` &#124;, sign(`result`) = sign(`value1`), where `div` is the division instruction that truncates towards zero.</span></span>  
  
 <span data-ttu-id="02415-3620">如果 `value2` 为零或 `value1` 为无穷大，则结果为 NaN。</span><span class="sxs-lookup"><span data-stu-id="02415-3620">If `value2` is zero or `value1` is infinity the result is NaN.</span></span> <span data-ttu-id="02415-3621">如果 `value2` 无穷，则结果为 `value1` （`-infinity`为求反）。</span><span class="sxs-lookup"><span data-stu-id="02415-3621">If `value2` is infinity, the result is `value1` (negated for `-infinity`).</span></span>  
  
 <span data-ttu-id="02415-3622">如果 `value2` 为零，则整型运算引发 <xref:System.DivideByZeroException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3622">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="02415-3623">请注意，在基于 Intel 的平台上，计算（minint `rem`）时将引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3623">Note that on the Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint `rem` -1).</span></span>  
  
 <span data-ttu-id="02415-3624">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `rem` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3624">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3625">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3625">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3626">将两个无符号值相除并将余数推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3626">Divides two unsigned values and pushes the remainder onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3627">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3627">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3628">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3628">Format</span></span>|<span data-ttu-id="02415-3629">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3629">Assembly Format</span></span>|<span data-ttu-id="02415-3630">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3630">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3631">5E</span><span class="sxs-lookup"><span data-stu-id="02415-3631">5E</span></span>|<span data-ttu-id="02415-3632">rem.un</span><span class="sxs-lookup"><span data-stu-id="02415-3632">rem.un</span></span>|<span data-ttu-id="02415-3633">将未签名 `value1` `value2` 的余数推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3633">Pushes the remainder of dividing unsigned `value1` by unsigned `value2` onto the stack.</span></span>|  
  
 <span data-ttu-id="02415-3634">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3634">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3635">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3635">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3636">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3636">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-3637">`value2` 和 `value1` 从堆栈中弹出，`value1` `div` `value2` 计算所得的余数。</span><span class="sxs-lookup"><span data-stu-id="02415-3637">`value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.</span></span>  
  
4.  <span data-ttu-id="02415-3638">将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3638">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3639">`result` = `value1` `rem.un` `value2` 满足以下条件：</span><span class="sxs-lookup"><span data-stu-id="02415-3639">`result` = `value1` `rem.un` `value2` satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="02415-3640">`result` = `value1` - `value2` x （`value1` `div.un` `value2`）和：</span><span class="sxs-lookup"><span data-stu-id="02415-3640">`result` = `value1` - `value2` x(`value1` `div.un` `value2`), and:</span></span>  
  
 <span data-ttu-id="02415-3641">0 = `result` < `value2`，其中 `div.un` 是无符号除法指令。</span><span class="sxs-lookup"><span data-stu-id="02415-3641">0 = `result` < `value2`, where `div.un` is the unsigned division instruction.</span></span>  
  
 <span data-ttu-id="02415-3642">`rem.un` 指令计算 `result` 并将其推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3642">The `rem.un` instruction computes `result` and pushes it on the stack.</span></span> <span data-ttu-id="02415-3643">`Rem.un` 将其参数视为无符号整数，而 <xref:System.Reflection.Emit.OpCodes.Rem> 将其视为有符号整数。</span><span class="sxs-lookup"><span data-stu-id="02415-3643">`Rem.un` treats its arguments as unsigned integers, while <xref:System.Reflection.Emit.OpCodes.Rem> treats them as signed integers.</span></span>  
  
 <span data-ttu-id="02415-3644">不为浮点数指定 `Rem.un`。</span><span class="sxs-lookup"><span data-stu-id="02415-3644">`Rem.un` is unspecified for floating-point numbers.</span></span>  
  
 <span data-ttu-id="02415-3645">如果 `value2` 为零，则整型运算引发 <xref:System.DivideByZeroException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3645">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="02415-3646">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `rem.un` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3646">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem.un` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3647">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3647">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3648">从当前方法返回，并将返回值（如果存在）从被调用方的计算堆栈推送到调用方的计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3648">Returns from the current method, pushing a return value (if present) from the callee's evaluation stack onto the caller's evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3649">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3649">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3650">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3650">Format</span></span>|<span data-ttu-id="02415-3651">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3651">Assembly Format</span></span>|<span data-ttu-id="02415-3652">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3652">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3653">2A</span><span class="sxs-lookup"><span data-stu-id="02415-3653">2A</span></span>|<span data-ttu-id="02415-3654">ret</span><span class="sxs-lookup"><span data-stu-id="02415-3654">ret</span></span>|<span data-ttu-id="02415-3655">从方法返回，可能返回值。</span><span class="sxs-lookup"><span data-stu-id="02415-3655">Returns from method, possibly returning a value.</span></span>|  
  
 <span data-ttu-id="02415-3656">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3656">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3657">从被调用方的计算堆栈中弹出返回值。</span><span class="sxs-lookup"><span data-stu-id="02415-3657">The return value is popped from the callee evaluation stack.</span></span>  
  
2.  <span data-ttu-id="02415-3658">在步骤1中获取的返回值被推送到调用方计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3658">The return value obtained in step 1 is pushed onto the caller evaluation stack.</span></span>  
  
 <span data-ttu-id="02415-3659">如果返回值不在被调用方的计算堆栈上，则不返回任何值（对于被调用方或调用方方法，不返回任何堆栈转换行为）。</span><span class="sxs-lookup"><span data-stu-id="02415-3659">If the return value is not present on the callee evaluation stack, no value is returned (no stack transition behaviors for either the callee or caller method).</span></span>  
  
 <span data-ttu-id="02415-3660">当前方法的返回值的类型（如果有）确定要从堆栈顶部获取的值的类型，并将其复制到调用当前方法的方法的堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3660">The type of the return value, if any, of the current method determines the type of value to be fetched from the top of the stack and copied onto the stack of the method that called the current method.</span></span> <span data-ttu-id="02415-3661">当前方法的计算堆栈必须为空，但要返回的值除外。</span><span class="sxs-lookup"><span data-stu-id="02415-3661">The evaluation stack for the current method must be empty except for the value to be returned.</span></span>  
  
 <span data-ttu-id="02415-3662">`ret` 指令不能用于将控制转移出`try`、`filter`、`catch`或 `finally` 块。</span><span class="sxs-lookup"><span data-stu-id="02415-3662">The `ret` instruction cannot be used to transfer control out of a`try`, `filter`, `catch`, or `finally` block.</span></span> <span data-ttu-id="02415-3663">在 `try` 或 `catch`中，将 <xref:System.Reflection.Emit.OpCodes.Leave> 指令与所有封闭异常块之外的 `ret` 指令的目标一起使用。</span><span class="sxs-lookup"><span data-stu-id="02415-3663">From within a `try` or `catch`, use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction with a destination of a `ret` instruction that is outside all enclosing exception blocks.</span></span> <span data-ttu-id="02415-3664">由于 `filter` 和 `finally` 块在逻辑上是异常处理的一部分，而不是其代码的嵌入方法，因此正确生成的 Microsoft 中间语言（MSIL）指令不会从 `filter` 或 `finally`中执行方法返回。</span><span class="sxs-lookup"><span data-stu-id="02415-3664">Because the `filter` and `finally` blocks are logically part of exception handling and not the method in which their code is embedded, correctly generated Microsoft Intermediate Language (MSIL) instructions do not perform a method return from within a `filter` or `finally`.</span></span>  
  
 <span data-ttu-id="02415-3665">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `ret` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3665">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ret` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3666">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3666">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3667">再次引发当前异常。</span><span class="sxs-lookup"><span data-stu-id="02415-3667">Rethrows the current exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3668">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3668">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3669">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3669">Format</span></span>|<span data-ttu-id="02415-3670">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3670">Assembly Format</span></span>|<span data-ttu-id="02415-3671">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3671">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3672">FE 1A</span><span class="sxs-lookup"><span data-stu-id="02415-3672">FE 1A</span></span>|<span data-ttu-id="02415-3673">重新引发</span><span class="sxs-lookup"><span data-stu-id="02415-3673">rethrow</span></span>|<span data-ttu-id="02415-3674">重新引发当前异常</span><span class="sxs-lookup"><span data-stu-id="02415-3674">Rethrows the current exception</span></span>|  
  
 <span data-ttu-id="02415-3675">没有为此指令定义堆栈转换行为。</span><span class="sxs-lookup"><span data-stu-id="02415-3675">No stack transition behavior is defined for this instruction.</span></span>  
  
 <span data-ttu-id="02415-3676">仅允许在 `catch` 处理程序的主体内使用 `rethrow` 指令。</span><span class="sxs-lookup"><span data-stu-id="02415-3676">The `rethrow` instruction is only permitted within the body of a `catch` handler.</span></span> <span data-ttu-id="02415-3677">它将引发与此处理程序捕获的异常。</span><span class="sxs-lookup"><span data-stu-id="02415-3677">It throws the same exception that was caught by this handler.</span></span>  
  
 <span data-ttu-id="02415-3678">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `rethrow` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3678">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rethrow` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3679">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3679">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3680">将整数值左移（用零填充）指定的位数，并将结果推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3680">Shifts an integer value to the left (in zeroes) by a specified number of bits, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3681">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3681">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3682">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3682">Format</span></span>|<span data-ttu-id="02415-3683">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3683">Assembly Format</span></span>|<span data-ttu-id="02415-3684">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3684">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3685">62</span><span class="sxs-lookup"><span data-stu-id="02415-3685">62</span></span>|<span data-ttu-id="02415-3686">shl</span><span class="sxs-lookup"><span data-stu-id="02415-3686">shl</span></span>|<span data-ttu-id="02415-3687">向左移动一个整数（以零为变化）。</span><span class="sxs-lookup"><span data-stu-id="02415-3687">Shifts an integer to the left (shifting in zeros).</span></span>|  
  
 <span data-ttu-id="02415-3688">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3688">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3689">将值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3689">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3690">要移动的位数将被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3690">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-3691">要移动的位数以及从堆栈中弹出的值的数目;该值将向左移动指定的位数。</span><span class="sxs-lookup"><span data-stu-id="02415-3691">The number of bits to be shifted and the value are popped from the stack; the value is shifted left by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="02415-3692">将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3692">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3693">`shl` 指令将值（类型 `int32`、`int64` 或 `native int`）向左移动指定的位数。</span><span class="sxs-lookup"><span data-stu-id="02415-3693">The `shl` instruction shifts the value (type `int32`, `int64` or `native int`) left by the specified number of bits.</span></span> <span data-ttu-id="02415-3694">位数是 `int32` 或 `native int`类型的值。</span><span class="sxs-lookup"><span data-stu-id="02415-3694">The number of bits is a value of type `int32` or `native int`.</span></span> <span data-ttu-id="02415-3695">如果要移位的位数大于或等于所提供值的宽度（以位为单位），则返回值为未指定。</span><span class="sxs-lookup"><span data-stu-id="02415-3695">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="02415-3696">`Shl` 将在每次移位的最小位置插入零位。</span><span class="sxs-lookup"><span data-stu-id="02415-3696">`Shl` inserts a zero bit in the lowest position on each shift.</span></span>  
  
 <span data-ttu-id="02415-3697">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `shl` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3697">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shl` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3698">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3698">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3699">将整数值右移（保留符号）指定的位数，并将结果推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3699">Shifts an integer value (in sign) to the right by a specified number of bits, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3700">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3700">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3701">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3701">Format</span></span>|<span data-ttu-id="02415-3702">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3702">Assembly Format</span></span>|<span data-ttu-id="02415-3703">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3703">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3704">63</span><span class="sxs-lookup"><span data-stu-id="02415-3704">63</span></span>|<span data-ttu-id="02415-3705">shr</span><span class="sxs-lookup"><span data-stu-id="02415-3705">shr</span></span>|<span data-ttu-id="02415-3706">向右移动一个整数（移位）。</span><span class="sxs-lookup"><span data-stu-id="02415-3706">Shifts an integer to the right (shifting in sign).</span></span>|  
  
 <span data-ttu-id="02415-3707">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3707">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3708">将值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3708">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3709">要移动的位数将被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3709">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-3710">要移动的位数以及从堆栈中弹出的值的数目;值向右移动指定的位数。</span><span class="sxs-lookup"><span data-stu-id="02415-3710">The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="02415-3711">将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3711">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3712">`shr.un` 指令将值（键入 `int32`、`int64` 或 `native int`）向右移动指定的位数。</span><span class="sxs-lookup"><span data-stu-id="02415-3712">The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits.</span></span> <span data-ttu-id="02415-3713">位数是 `int32` 或 `native int`类型的值。</span><span class="sxs-lookup"><span data-stu-id="02415-3713">The number of bits is a value of type `int32` or `native int`.</span></span> <span data-ttu-id="02415-3714">如果要移位的位数大于或等于所提供值的宽度（以位为单位），则返回值为未指定。</span><span class="sxs-lookup"><span data-stu-id="02415-3714">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="02415-3715">`Shr` 复制每个班次的高阶位，同时保留 `result`中原始值的符号。</span><span class="sxs-lookup"><span data-stu-id="02415-3715">`Shr` replicates the high order bit on each shift, preserving the sign of the original value in the `result`.</span></span>  
  
 <span data-ttu-id="02415-3716">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `shr` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3716">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3717">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3717">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3718">将无符号整数值右移（用零填充）指定的位数，并将结果推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3718">Shifts an unsigned integer value (in zeroes) to the right by a specified number of bits, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3719">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3719">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3720">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3720">Format</span></span>|<span data-ttu-id="02415-3721">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3721">Assembly Format</span></span>|<span data-ttu-id="02415-3722">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3722">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3723">64</span><span class="sxs-lookup"><span data-stu-id="02415-3723">64</span></span>|<span data-ttu-id="02415-3724">shr</span><span class="sxs-lookup"><span data-stu-id="02415-3724">shr.un</span></span>|<span data-ttu-id="02415-3725">向右移动一个整数（以零为变化）。</span><span class="sxs-lookup"><span data-stu-id="02415-3725">Shifts an integer to the right (shifting in zeroes).</span></span>|  
  
 <span data-ttu-id="02415-3726">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3726">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3727">将值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3727">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3728">要移动的位数将被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3728">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-3729">要移动的位数以及从堆栈中弹出的值的数目;值向右移动指定的位数。</span><span class="sxs-lookup"><span data-stu-id="02415-3729">The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="02415-3730">将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3730">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3731">`shr.un` 指令将值（键入 `int32`、`int64` 或 `native int`）向右移动指定的位数。</span><span class="sxs-lookup"><span data-stu-id="02415-3731">The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits.</span></span> <span data-ttu-id="02415-3732">位数是 `int32`、`int64` 或 `native int`类型的值。</span><span class="sxs-lookup"><span data-stu-id="02415-3732">The number of bits is a value of type `int32`, `int64` or `native int`.</span></span> <span data-ttu-id="02415-3733">如果要移位的位数大于或等于所提供值的宽度（以位为单位），则返回值为未指定。</span><span class="sxs-lookup"><span data-stu-id="02415-3733">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="02415-3734">`Shr.un` 在每个移位上的最高位置插入零位。</span><span class="sxs-lookup"><span data-stu-id="02415-3734">`Shr.un` inserts a zero bit in the highest position on each shift.</span></span>  
  
 <span data-ttu-id="02415-3735">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `shr.un` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3735">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr.un` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3736">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3736">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3737">将提供的值类型的大小（以字节为单位）推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3737">Pushes the size, in bytes, of a supplied value type onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3738">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3738">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3739">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3739">Format</span></span>|<span data-ttu-id="02415-3740">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3740">Assembly Format</span></span>|<span data-ttu-id="02415-3741">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3741">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3742">FE 1C < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-3742">FE 1C < `T` ></span></span>|<span data-ttu-id="02415-3743">sizeof `valType`</span><span class="sxs-lookup"><span data-stu-id="02415-3743">sizeof `valType`</span></span>|<span data-ttu-id="02415-3744">将值类型的大小（以字节为单位）作为 `unsigned int32`推送。</span><span class="sxs-lookup"><span data-stu-id="02415-3744">Push the size, in bytes, of a value type as an `unsigned int32`.</span></span>|  
  
 <span data-ttu-id="02415-3745">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3745">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3746">将提供的值类型（`valType`）的大小（以字节为单位）推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3746">The size (in bytes) of the supplied value type (`valType`) is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3747">`valType` 必须是指定值类型、引用类型或泛型类型参数的元数据标记（`typeref` 或 `typedef`）。</span><span class="sxs-lookup"><span data-stu-id="02415-3747">`valType` must be a metadata token (a `typeref` or `typedef`) that specifies a value type, reference type, or generic type parameter.</span></span>  
  
 <span data-ttu-id="02415-3748">对于引用类型，返回的大小为相应类型的引用值的大小（32位系统上为4个字节），而不是存储在引用值引用的对象中的数据的大小。</span><span class="sxs-lookup"><span data-stu-id="02415-3748">For a reference type, the size returned is the size of a reference value of the corresponding type (4 bytes on 32-bit systems), not the size of the data stored in objects referred to by the reference value.</span></span> <span data-ttu-id="02415-3749">泛型类型参数只能在定义它的类型或方法的主体中使用。</span><span class="sxs-lookup"><span data-stu-id="02415-3749">A generic type parameter can be used only in the body of the type or method that defines it.</span></span> <span data-ttu-id="02415-3750">当对该类型或方法进行实例化时，泛型类型参数被替换为值类型或引用类型。</span><span class="sxs-lookup"><span data-stu-id="02415-3750">When that type or method is instantiated, the generic type parameter is replaced by a value type or reference type.</span></span>  
  
 <span data-ttu-id="02415-3751">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `sizeof` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3751">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sizeof` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3752">ILGenerator （OpCode，Type）</span><span class="sxs-lookup"><span data-stu-id="02415-3752">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3753">将位于计算堆栈顶部的值存储到位于指定索引的自变量槽中。</span><span class="sxs-lookup"><span data-stu-id="02415-3753">Stores the value on top of the evaluation stack in the argument slot at a specified index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3754">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3754">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3755">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3755">Format</span></span>|<span data-ttu-id="02415-3756">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3756">Assembly Format</span></span>|<span data-ttu-id="02415-3757">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3757">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3758">FE 0B < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="02415-3758">FE 0B < `unsigned int16` ></span></span>|<span data-ttu-id="02415-3759">starg `num`</span><span class="sxs-lookup"><span data-stu-id="02415-3759">starg `num`</span></span>|<span data-ttu-id="02415-3760">从堆栈中弹出顶部值并将其存储在参数槽中 `num`。</span><span class="sxs-lookup"><span data-stu-id="02415-3760">Pops the top value from the stack and stores it in argument slot `num`.</span></span>|  
  
 <span data-ttu-id="02415-3761">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3761">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3762">将弹出当前位于堆栈顶部的值并将其放入参数槽位 `num`。</span><span class="sxs-lookup"><span data-stu-id="02415-3762">The value currently on top of the stack is popped and placed in argument slot `num`.</span></span>  
  
 <span data-ttu-id="02415-3763">`starg` 指令从堆栈中弹出一个值，并将其放在参数槽中 `num`。</span><span class="sxs-lookup"><span data-stu-id="02415-3763">The `starg` instruction pops a value from the stack and places it in argument slot `num`.</span></span> <span data-ttu-id="02415-3764">值的类型必须与当前方法的签名中指定的参数的类型匹配。</span><span class="sxs-lookup"><span data-stu-id="02415-3764">The type of the value must match the type of the argument, as specified in the current method's signature.</span></span>  
  
 <span data-ttu-id="02415-3765">对于采用变量参数列表的过程，`starg` 指令只能用于初始固定参数，而不能用于签名的变量部分。</span><span class="sxs-lookup"><span data-stu-id="02415-3765">For procedures that take a variable argument list, the `starg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="02415-3766">如果将存储区的参数保留为小于4个字节的整数值，则会在从堆栈移到参数时截断值。</span><span class="sxs-lookup"><span data-stu-id="02415-3766">Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</span></span> <span data-ttu-id="02415-3767">浮点值从其本机大小（类型 `F`）舍入到与参数关联的大小。</span><span class="sxs-lookup"><span data-stu-id="02415-3767">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="02415-3768">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `starg` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3768">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `starg` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3769">ILGenerator （操作码，short）</span><span class="sxs-lookup"><span data-stu-id="02415-3769">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3770">将位于计算堆栈顶部的值存储在自变量槽中的指定索引处（短格式）。</span><span class="sxs-lookup"><span data-stu-id="02415-3770">Stores the value on top of the evaluation stack in the argument slot at a specified index, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3771">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3771">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3772">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3772">Format</span></span>|<span data-ttu-id="02415-3773">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3773">Assembly Format</span></span>|<span data-ttu-id="02415-3774">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3774">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3775">10 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="02415-3775">10 < `unsigned int8` ></span></span>|<span data-ttu-id="02415-3776">starg `num`</span><span class="sxs-lookup"><span data-stu-id="02415-3776">starg.s `num`</span></span>|<span data-ttu-id="02415-3777">从堆栈中弹出顶部值并将其存储在参数槽中 `num`缩写形式。</span><span class="sxs-lookup"><span data-stu-id="02415-3777">Pops the top value from the stack and stores it in argument slot `num`, short form.</span></span>|  
  
 <span data-ttu-id="02415-3778">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3778">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3779">将弹出当前位于堆栈顶部的值并将其放入参数槽位 `num`。</span><span class="sxs-lookup"><span data-stu-id="02415-3779">The value currently on top of the stack is popped and placed in argument slot `num`.</span></span>  
  
 <span data-ttu-id="02415-3780">`starg.s` 指令从堆栈中弹出一个值，并将其放在参数槽中 `num`。</span><span class="sxs-lookup"><span data-stu-id="02415-3780">The `starg.s` instruction pops a value from the stack and places it in argument slot `num`.</span></span> <span data-ttu-id="02415-3781">值的类型必须与当前方法的签名中指定的参数的类型匹配。</span><span class="sxs-lookup"><span data-stu-id="02415-3781">The type of the value must match the type of the argument, as specified in the current method's signature.</span></span>  
  
 <span data-ttu-id="02415-3782">`starg.s` 指令提供了一个有效的编码以便与前256个参数一起使用。</span><span class="sxs-lookup"><span data-stu-id="02415-3782">The `starg.s` instruction provides an efficient encoding for use with the first 256 arguments.</span></span>  
  
 <span data-ttu-id="02415-3783">对于采用变量参数列表的过程，`starg.s` 指令只能用于初始固定参数，而不能用于签名的变量部分。</span><span class="sxs-lookup"><span data-stu-id="02415-3783">For procedures that take a variable argument list, the `starg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="02415-3784">如果将存储区的参数保留为小于4个字节的整数值，则会在从堆栈移到参数时截断值。</span><span class="sxs-lookup"><span data-stu-id="02415-3784">Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</span></span> <span data-ttu-id="02415-3785">浮点值从其本机大小（类型 `F`）舍入到与参数关联的大小。</span><span class="sxs-lookup"><span data-stu-id="02415-3785">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="02415-3786">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `starg.s` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3786">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `starg.s` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3787">ILGenerator （OpCode，byte）</span><span class="sxs-lookup"><span data-stu-id="02415-3787">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3788">用计算堆栈中的值替换给定索引处的数组元素，其类型在指令中指定。</span><span class="sxs-lookup"><span data-stu-id="02415-3788">Replaces the array element at a given index with the value on the evaluation stack, whose type is specified in the instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3789">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3789">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3790">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3790">Format</span></span>|<span data-ttu-id="02415-3791">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3791">Assembly Format</span></span>|<span data-ttu-id="02415-3792">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3792">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3793">A4 < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-3793">A4 < `T` ></span></span>|<span data-ttu-id="02415-3794">stelem `typeTok`</span><span class="sxs-lookup"><span data-stu-id="02415-3794">stelem `typeTok`</span></span>|<span data-ttu-id="02415-3795">将所提供索引处的数组元素替换为堆栈上的类型 `typeTok` 的值。</span><span class="sxs-lookup"><span data-stu-id="02415-3795">Replaces the array element at the supplied index with a value of type `typeTok` on the stack.</span></span>|  
  
 <span data-ttu-id="02415-3796">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3796">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3797">对数组 `array`的对象引用被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3797">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3798">将索引值 `index`到 `array` 中的元素推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3798">An index value, `index`, to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-3799">指令中指定的类型的值被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3799">A value of the type specified in the instruction is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="02415-3800">从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。</span><span class="sxs-lookup"><span data-stu-id="02415-3800">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="02415-3801">`stelem` 指令用值替换一维 `array` 数组中提供的从零开始的索引处的元素的值。</span><span class="sxs-lookup"><span data-stu-id="02415-3801">The `stelem` instruction replaces the value of the element at the supplied zero-based index in the one-dimensional array `array` with the value.</span></span> <span data-ttu-id="02415-3802">值具有指令中的标记所指定的类型 `typeTok`。</span><span class="sxs-lookup"><span data-stu-id="02415-3802">The value has the type specified by the token `typeTok` in the instruction.</span></span>  
  
 <span data-ttu-id="02415-3803">数组是对象，因此由 `O`类型的值表示。</span><span class="sxs-lookup"><span data-stu-id="02415-3803">Arrays are objects, and hence represented by a value of type `O`.</span></span> <span data-ttu-id="02415-3804">索引的类型 `native int`。</span><span class="sxs-lookup"><span data-stu-id="02415-3804">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="02415-3805">如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3805"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="02415-3806">如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3806"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="02415-3807">如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3807"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="02415-3808">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stelem` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3808">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3809">ILGenerator （OpCode，Type）</span><span class="sxs-lookup"><span data-stu-id="02415-3809">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3810">用计算堆栈上的 <see langword="native int" /> 值替换给定索引处的数组元素。</span><span class="sxs-lookup"><span data-stu-id="02415-3810">Replaces the array element at a given index with the <see langword="native int" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3811">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3811">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3812">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3812">Format</span></span>|<span data-ttu-id="02415-3813">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3813">Assembly Format</span></span>|<span data-ttu-id="02415-3814">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3814">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3815">9B</span><span class="sxs-lookup"><span data-stu-id="02415-3815">9B</span></span>|<span data-ttu-id="02415-3816">stelem。 i</span><span class="sxs-lookup"><span data-stu-id="02415-3816">stelem.i</span></span>|<span data-ttu-id="02415-3817">将所提供索引处的数组元素替换为堆栈上的 `native int` 值。</span><span class="sxs-lookup"><span data-stu-id="02415-3817">Replaces an array element at the supplied index with the `native int` value on the stack.</span></span>|  
  
 <span data-ttu-id="02415-3818">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3818">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3819">对数组 `array`的对象引用被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3819">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3820">将 `array` 中的元素的有效索引推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3820">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-3821">将值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3821">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="02415-3822">从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。</span><span class="sxs-lookup"><span data-stu-id="02415-3822">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="02415-3823">`stelem.i` 指令替换一维数组中 `index` 元素的值 `array`，并将 `native int` 值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3823">The `stelem.i` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `native int` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3824">数组是对象，因此由 `O`类型的值表示。</span><span class="sxs-lookup"><span data-stu-id="02415-3824">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="02415-3825">索引的类型 `native int`。</span><span class="sxs-lookup"><span data-stu-id="02415-3825">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="02415-3826">如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3826"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="02415-3827">如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3827"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="02415-3828">如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3828"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="02415-3829">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stelem.i` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3829">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3830">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3830">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3831">用计算堆栈上的 <see langword="int8" /> 值替换给定索引处的数组元素。</span><span class="sxs-lookup"><span data-stu-id="02415-3831">Replaces the array element at a given index with the <see langword="int8" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3832">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3832">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3833">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3833">Format</span></span>|<span data-ttu-id="02415-3834">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3834">Assembly Format</span></span>|<span data-ttu-id="02415-3835">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3835">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3836">9C</span><span class="sxs-lookup"><span data-stu-id="02415-3836">9C</span></span>|<span data-ttu-id="02415-3837">stelem.i1</span><span class="sxs-lookup"><span data-stu-id="02415-3837">stelem.i1</span></span>|<span data-ttu-id="02415-3838">将所提供索引处的数组元素替换为堆栈上的 `int8` 值。</span><span class="sxs-lookup"><span data-stu-id="02415-3838">Replaces an array element at the supplied index with the `int8` value on the stack.</span></span>|  
  
 <span data-ttu-id="02415-3839">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3839">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3840">对数组 `array`的对象引用被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3840">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3841">将 `array` 中的元素的有效索引推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3841">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-3842">将值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3842">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="02415-3843">从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。</span><span class="sxs-lookup"><span data-stu-id="02415-3843">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="02415-3844">`stelem.i1` 指令替换一维数组中 `index` 元素的值 `array`，并将 `int8` 值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3844">The `stelem.i1` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int8` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3845">数组是对象，因此由 `O`类型的值表示。</span><span class="sxs-lookup"><span data-stu-id="02415-3845">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="02415-3846">索引的类型 `native int`。</span><span class="sxs-lookup"><span data-stu-id="02415-3846">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="02415-3847">如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3847"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="02415-3848">如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3848"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="02415-3849">如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3849"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="02415-3850">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stelem.i1` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3850">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i1` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3851">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3851">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3852">用计算堆栈上的 <see langword="int16" /> 值替换给定索引处的数组元素。</span><span class="sxs-lookup"><span data-stu-id="02415-3852">Replaces the array element at a given index with the <see langword="int16" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3853">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3853">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3854">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3854">Format</span></span>|<span data-ttu-id="02415-3855">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3855">Assembly Format</span></span>|<span data-ttu-id="02415-3856">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3856">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3857">9D</span><span class="sxs-lookup"><span data-stu-id="02415-3857">9D</span></span>|<span data-ttu-id="02415-3858">stelem.i2</span><span class="sxs-lookup"><span data-stu-id="02415-3858">stelem.i2</span></span>|<span data-ttu-id="02415-3859">将所提供索引处的数组元素替换为堆栈上的 `int16` 值。</span><span class="sxs-lookup"><span data-stu-id="02415-3859">Replaces an array element at the supplied index with the `int16` value on the stack.</span></span>|  
  
 <span data-ttu-id="02415-3860">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3860">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3861">对数组 `array`的对象引用被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3861">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3862">将 `array` 中的元素的有效索引推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3862">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-3863">将值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3863">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="02415-3864">从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。</span><span class="sxs-lookup"><span data-stu-id="02415-3864">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="02415-3865">`stelem.i2` 指令替换一维数组中 `index` 元素的值 `array`，并将 `int16` 值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3865">The `stelem.i2` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int16` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3866">数组是对象，因此由 `O`类型的值表示。</span><span class="sxs-lookup"><span data-stu-id="02415-3866">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="02415-3867">索引的类型 `native int`。</span><span class="sxs-lookup"><span data-stu-id="02415-3867">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="02415-3868">如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3868"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="02415-3869">如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3869"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="02415-3870">如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3870"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="02415-3871">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stelem.i2` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3871">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i2` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3872">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3872">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3873">用计算堆栈上的 <see langword="int32" /> 值替换给定索引处的数组元素。</span><span class="sxs-lookup"><span data-stu-id="02415-3873">Replaces the array element at a given index with the <see langword="int32" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3874">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3874">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3875">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3875">Format</span></span>|<span data-ttu-id="02415-3876">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3876">Assembly Format</span></span>|<span data-ttu-id="02415-3877">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3877">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3878">9E</span><span class="sxs-lookup"><span data-stu-id="02415-3878">9E</span></span>|<span data-ttu-id="02415-3879">stelem.i4</span><span class="sxs-lookup"><span data-stu-id="02415-3879">stelem.i4</span></span>|<span data-ttu-id="02415-3880">将所提供索引处的数组元素替换为堆栈上的 `int32` 值。</span><span class="sxs-lookup"><span data-stu-id="02415-3880">Replaces an array element at the supplied index with the `int32` value on the stack.</span></span>|  
  
 <span data-ttu-id="02415-3881">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3881">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3882">对数组 `array`的对象引用被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3882">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3883">将 `array` 中的元素的有效索引推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3883">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-3884">将值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3884">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="02415-3885">从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。</span><span class="sxs-lookup"><span data-stu-id="02415-3885">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="02415-3886">`stelem.i4` 指令替换一维数组中 `index` 元素的值 `array`，并将 `int32` 值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3886">The `stelem.i4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int32` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3887">数组是对象，因此由 `O`类型的值表示。</span><span class="sxs-lookup"><span data-stu-id="02415-3887">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="02415-3888">索引的类型 `native int`。</span><span class="sxs-lookup"><span data-stu-id="02415-3888">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="02415-3889">如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3889"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="02415-3890">如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3890"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="02415-3891">如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3891"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="02415-3892">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stelem.i4` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3892">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i4` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3893">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3893">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3894">用计算堆栈上的 <see langword="int64" /> 值替换给定索引处的数组元素。</span><span class="sxs-lookup"><span data-stu-id="02415-3894">Replaces the array element at a given index with the <see langword="int64" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3895">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3895">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3896">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3896">Format</span></span>|<span data-ttu-id="02415-3897">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3897">Assembly Format</span></span>|<span data-ttu-id="02415-3898">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3898">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3899">9F</span><span class="sxs-lookup"><span data-stu-id="02415-3899">9F</span></span>|<span data-ttu-id="02415-3900">stelem.i8</span><span class="sxs-lookup"><span data-stu-id="02415-3900">stelem.i8</span></span>|<span data-ttu-id="02415-3901">将所提供索引处的数组元素替换为堆栈上的 `int64` 值。</span><span class="sxs-lookup"><span data-stu-id="02415-3901">Replaces an array element at the supplied index with the `int64` value on the stack.</span></span>|  
  
 <span data-ttu-id="02415-3902">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3902">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3903">对数组 `array`的对象引用被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3903">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3904">将 `array` 中的元素的有效索引推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3904">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-3905">将值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3905">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="02415-3906">从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。</span><span class="sxs-lookup"><span data-stu-id="02415-3906">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="02415-3907">`stelem.i8` 指令替换一维数组中 `index` 元素的值 `array`，并将 `int64` 值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3907">The `stelem.i8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int64` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3908">数组是对象，因此由 `O`类型的值表示。</span><span class="sxs-lookup"><span data-stu-id="02415-3908">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="02415-3909">索引的类型 `native int`。</span><span class="sxs-lookup"><span data-stu-id="02415-3909">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="02415-3910">如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3910"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="02415-3911">如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3911"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="02415-3912">如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3912"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="02415-3913">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stelem.i8` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3913">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i8` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3914">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3914">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3915">用计算堆栈上的 <see langword="float32" /> 值替换给定索引处的数组元素。</span><span class="sxs-lookup"><span data-stu-id="02415-3915">Replaces the array element at a given index with the <see langword="float32" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3916">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3916">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3917">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3917">Format</span></span>|<span data-ttu-id="02415-3918">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3918">Assembly Format</span></span>|<span data-ttu-id="02415-3919">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3919">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3920">A0</span><span class="sxs-lookup"><span data-stu-id="02415-3920">A0</span></span>|<span data-ttu-id="02415-3921">stelem.r4</span><span class="sxs-lookup"><span data-stu-id="02415-3921">stelem.r4</span></span>|<span data-ttu-id="02415-3922">将所提供索引处的数组元素替换为堆栈上的 `float32` 值。</span><span class="sxs-lookup"><span data-stu-id="02415-3922">Replaces an array element at the supplied index with the `float32` value on the stack.</span></span>|  
  
 <span data-ttu-id="02415-3923">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3923">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3924">对数组 `array`的对象引用被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3924">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3925">将 `array` 中的元素的有效索引推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3925">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-3926">将值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3926">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="02415-3927">从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。</span><span class="sxs-lookup"><span data-stu-id="02415-3927">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="02415-3928">`stelem.r4` 指令替换一维数组中 `index` 元素的值 `array`，并将 `float32` 值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3928">The `stelem.r4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float32` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3929">数组是对象，因此由 `O`类型的值表示。</span><span class="sxs-lookup"><span data-stu-id="02415-3929">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="02415-3930">索引的类型 `native int`。</span><span class="sxs-lookup"><span data-stu-id="02415-3930">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="02415-3931">如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3931"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="02415-3932">如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3932"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="02415-3933">如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3933"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="02415-3934">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stelem.r4` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3934">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r4` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3935">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3935">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3936">用计算堆栈上的 <see langword="float64" /> 值替换给定索引处的数组元素。</span><span class="sxs-lookup"><span data-stu-id="02415-3936">Replaces the array element at a given index with the <see langword="float64" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3937">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3937">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3938">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3938">Format</span></span>|<span data-ttu-id="02415-3939">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3939">Assembly Format</span></span>|<span data-ttu-id="02415-3940">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3940">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3941">A1</span><span class="sxs-lookup"><span data-stu-id="02415-3941">A1</span></span>|<span data-ttu-id="02415-3942">stelem.r8</span><span class="sxs-lookup"><span data-stu-id="02415-3942">stelem.r8</span></span>|<span data-ttu-id="02415-3943">将所提供索引处的数组元素替换为堆栈上的 `float64` 值。</span><span class="sxs-lookup"><span data-stu-id="02415-3943">Replaces an array element at the supplied index with the `float64` value on the stack.</span></span>|  
  
 <span data-ttu-id="02415-3944">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3944">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3945">对数组 `array`的对象引用被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3945">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3946">将 `array` 中的元素的有效索引推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3946">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-3947">将值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3947">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="02415-3948">从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。</span><span class="sxs-lookup"><span data-stu-id="02415-3948">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="02415-3949">`stelem.r8` 指令替换一维数组中 `index` 元素的值 `array`，并将 `float64` 值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3949">The `stelem.r8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float64` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3950">数组是对象，因此由 `O`类型的值表示。</span><span class="sxs-lookup"><span data-stu-id="02415-3950">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="02415-3951">索引的类型 `native int`。</span><span class="sxs-lookup"><span data-stu-id="02415-3951">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="02415-3952">如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3952"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="02415-3953">如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3953"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="02415-3954">如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3954"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="02415-3955">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stelem.r8` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3955">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r8` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3956">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3956">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3957">用计算堆栈上的对象 ref 值（<see langword="O" /> 类型）替换给定索引处的数组元素。</span><span class="sxs-lookup"><span data-stu-id="02415-3957">Replaces the array element at a given index with the object ref value (type <see langword="O" />) on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3958">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3958">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3959">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3959">Format</span></span>|<span data-ttu-id="02415-3960">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3960">Assembly Format</span></span>|<span data-ttu-id="02415-3961">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3961">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3962">A2</span><span class="sxs-lookup"><span data-stu-id="02415-3962">A2</span></span>|<span data-ttu-id="02415-3963">stelem.ref</span><span class="sxs-lookup"><span data-stu-id="02415-3963">stelem.ref</span></span>|<span data-ttu-id="02415-3964">将所提供索引处的数组元素替换为堆栈上的 `ref` 值（类型 `O`）。</span><span class="sxs-lookup"><span data-stu-id="02415-3964">Replaces an array element at the supplied index with the `ref` value (type `O`) on the stack.</span></span>|  
  
 <span data-ttu-id="02415-3965">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3965">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3966">对数组 `array`的对象引用被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3966">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3967">将 `array` 中的元素的有效索引推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3967">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-3968">将值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3968">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="02415-3969">从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。</span><span class="sxs-lookup"><span data-stu-id="02415-3969">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="02415-3970">`stelem.ref` 指令替换一维数组中所提供索引处的元素的值 `array` 并将 `ref` （类型 `O`）值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3970">The `stelem.ref` instruction replaces the value of the element at the supplied index in the one-dimensional array `array` with the `ref` (type `O`) value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-3971">数组是对象，因此由 `O`类型的值表示。</span><span class="sxs-lookup"><span data-stu-id="02415-3971">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="02415-3972">索引的类型 `native int`。</span><span class="sxs-lookup"><span data-stu-id="02415-3972">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="02415-3973">请注意，在为数组元素赋值之前，`stelem.ref` 会将提供的值隐式转换为 `array` 的元素类型。</span><span class="sxs-lookup"><span data-stu-id="02415-3973">Note that `stelem.ref` implicitly casts the supplied value to the element type of `array` before assigning the value to the array element.</span></span> <span data-ttu-id="02415-3974">此强制转换可能会失败，即使对于已验证的代码也是如此。</span><span class="sxs-lookup"><span data-stu-id="02415-3974">This cast can fail, even for verified code.</span></span> <span data-ttu-id="02415-3975">因此 `stelem.ref` 指令可能会引发 <xref:System.InvalidCastException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3975">Thus the `stelem.ref` instruction can throw <xref:System.InvalidCastException>.</span></span> <span data-ttu-id="02415-3976">对于不是从零开始的一维数组和多维数组，<xref:System.Array> 类提供 <xref:System.Array.SetValue%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="02415-3976">For one-dimensional arrays that aren't zero-based and for multidimensional arrays, the <xref:System.Array> class provides a <xref:System.Array.SetValue%2A> method.</span></span>  
  
 <span data-ttu-id="02415-3977">如果 `array` 为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3977"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="02415-3978">如果 `index` 为负数或大于 `array`的界限，则会引发 <xref:System.IndexOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3978"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="02415-3979">如果 `array` 不包含所需类型的元素，则会引发 <xref:System.ArrayTypeMismatchException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3979"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="02415-3980">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stelem.ref` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-3980">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.ref` opcode:</span></span>  
  
-   <span data-ttu-id="02415-3981">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-3981">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-3982">用新值替换在对象引用或指针的字段中存储的值。</span><span class="sxs-lookup"><span data-stu-id="02415-3982">Replaces the value stored in the field of an object reference or pointer with a new value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-3983">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-3983">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-3984">格式</span><span class="sxs-lookup"><span data-stu-id="02415-3984">Format</span></span>|<span data-ttu-id="02415-3985">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-3985">Assembly Format</span></span>|<span data-ttu-id="02415-3986">说明</span><span class="sxs-lookup"><span data-stu-id="02415-3986">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-3987">7D < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-3987">7D < `T` ></span></span>|<span data-ttu-id="02415-3988">stfld `field`</span><span class="sxs-lookup"><span data-stu-id="02415-3988">stfld `field`</span></span>|<span data-ttu-id="02415-3989">将对象 `field` 的值替换为新值。</span><span class="sxs-lookup"><span data-stu-id="02415-3989">Replaces the value of `field` of the object with a new value.</span></span>|  
  
 <span data-ttu-id="02415-3990">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-3990">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-3991">对象引用或指针被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3991">An object reference or pointer is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-3992">将值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-3992">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-3993">从堆栈中弹出值和对象引用/指针;对象中 `field` 的值将替换为提供的值。</span><span class="sxs-lookup"><span data-stu-id="02415-3993">The value and the object reference/pointer are popped from the stack; the value of `field` in the object is replaced with the supplied value.</span></span>  
  
 <span data-ttu-id="02415-3994">`stfld` 指令替换对象（类型 `O`）的字段的值，或通过具有给定值的指针（类型 `native int`、`&`或 `*`）替换。</span><span class="sxs-lookup"><span data-stu-id="02415-3994">The `stfld` instruction replaces the value of a field of an object (type `O`) or via a pointer (type `native int`, `&`, or `*`) with a given value.</span></span> <span data-ttu-id="02415-3995">`Field` 是引用字段成员引用的元数据标记。</span><span class="sxs-lookup"><span data-stu-id="02415-3995">`Field` is a metadata token that refers to a field member reference.</span></span> <span data-ttu-id="02415-3996">`stfld` 指令可以具有 <xref:System.Reflection.Emit.OpCodes.Unaligned> 和 <xref:System.Reflection.Emit.OpCodes.Volatile>的一个或两个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-3996">The `stfld` instruction can have a prefix of either or both of <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile>.</span></span>  
  
 <span data-ttu-id="02415-3997">如果对象引用或指针为空引用，并且该字段不是静态的，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3997"><xref:System.NullReferenceException> is thrown if the object reference or pointer is a null reference and the field isn't static.</span></span>  
  
 <span data-ttu-id="02415-3998">如果在元数据中找不到 `field`，则会引发 <xref:System.MissingFieldException>。</span><span class="sxs-lookup"><span data-stu-id="02415-3998"><xref:System.MissingFieldException> is thrown if `field` is not found in the metadata.</span></span> <span data-ttu-id="02415-3999">当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是运行时，通常会检查此情况。</span><span class="sxs-lookup"><span data-stu-id="02415-3999">This is typically checked when the Microsoft Intermediate Language (MSIL) instruction is converted to native code, not at runtime.</span></span>  
  
 <span data-ttu-id="02415-4000">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stfld` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4000">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stfld` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4001">ILGenerator （OpCode，FieldInfo）</span><span class="sxs-lookup"><span data-stu-id="02415-4001">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4002">在所提供的地址存储 <see langword="native int" /> 类型的值。</span><span class="sxs-lookup"><span data-stu-id="02415-4002">Stores a value of type <see langword="native int" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4003">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4003">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4004">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4004">Format</span></span>|<span data-ttu-id="02415-4005">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4005">Assembly Format</span></span>|<span data-ttu-id="02415-4006">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4006">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4007">DF</span><span class="sxs-lookup"><span data-stu-id="02415-4007">DF</span></span>|<span data-ttu-id="02415-4008">stind。 i</span><span class="sxs-lookup"><span data-stu-id="02415-4008">stind.i</span></span>|<span data-ttu-id="02415-4009">将 `native int` 值存储在给定地址。</span><span class="sxs-lookup"><span data-stu-id="02415-4009">Stores a `native int` value at a given address.</span></span>|  
  
 <span data-ttu-id="02415-4010">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4010">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4011">地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4011">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-4012">将值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4012">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-4013">从堆栈中弹出值和地址;值存储在地址上。</span><span class="sxs-lookup"><span data-stu-id="02415-4013">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="02415-4014">`stind.i` 指令将 `native int` 值存储在所提供的地址（类型 `native int`、`*`或 `&`）上。</span><span class="sxs-lookup"><span data-stu-id="02415-4014">The `stind.i` instruction stores a `native int` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="02415-4015">类型安全操作要求 `stind.i` 指令的使用方式与指针的类型一致。</span><span class="sxs-lookup"><span data-stu-id="02415-4015">Type safe operation requires that the `stind.i` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="02415-4016">`stind.i` 指令的操作可以通过紧挨着 <xref:System.Reflection.Emit.OpCodes.Volatile> 或 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀指令来更改。</span><span class="sxs-lookup"><span data-stu-id="02415-4016">The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="02415-4017">如果对于指令后缀隐含的参数类型，`addr` 不是自然对齐的，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-4017"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="02415-4018">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stind.i` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4018">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4019">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-4019">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4020">在所提供的地址存储 <see langword="int8" /> 类型的值。</span><span class="sxs-lookup"><span data-stu-id="02415-4020">Stores a value of type <see langword="int8" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4021">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4021">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4022">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4022">Format</span></span>|<span data-ttu-id="02415-4023">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4023">Assembly Format</span></span>|<span data-ttu-id="02415-4024">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4024">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4025">52</span><span class="sxs-lookup"><span data-stu-id="02415-4025">52</span></span>|<span data-ttu-id="02415-4026">stind</span><span class="sxs-lookup"><span data-stu-id="02415-4026">stind.i1</span></span>|<span data-ttu-id="02415-4027">将 `int8` 值存储在给定地址。</span><span class="sxs-lookup"><span data-stu-id="02415-4027">Stores an `int8` value at a given address.</span></span>|  
  
 <span data-ttu-id="02415-4028">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4028">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4029">地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4029">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-4030">将值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4030">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-4031">从堆栈中弹出值和地址;值存储在地址上。</span><span class="sxs-lookup"><span data-stu-id="02415-4031">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="02415-4032">`stind.i1` 指令将 `int8` 值存储在所提供的地址（类型 `native int`、`*`或 `&`）上。</span><span class="sxs-lookup"><span data-stu-id="02415-4032">The `stind.i1` instruction stores an `int8` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="02415-4033">类型安全操作要求 `stind.i1` 指令的使用方式与指针的类型一致。</span><span class="sxs-lookup"><span data-stu-id="02415-4033">Type safe operation requires that the `stind.i1` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="02415-4034">`stind.i1` 指令的操作可以通过紧挨着 <xref:System.Reflection.Emit.OpCodes.Volatile> 或 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀指令来更改。</span><span class="sxs-lookup"><span data-stu-id="02415-4034">The operation of the `stind.i1` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="02415-4035">如果对于指令后缀隐含的参数类型，`addr` 不是自然对齐的，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-4035"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="02415-4036">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stind.i1` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4036">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i1` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4037">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-4037">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4038">在所提供的地址存储 <see langword="int16" /> 类型的值。</span><span class="sxs-lookup"><span data-stu-id="02415-4038">Stores a value of type <see langword="int16" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4039">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4039">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4040">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4040">Format</span></span>|<span data-ttu-id="02415-4041">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4041">Assembly Format</span></span>|<span data-ttu-id="02415-4042">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4042">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4043">53</span><span class="sxs-lookup"><span data-stu-id="02415-4043">53</span></span>|<span data-ttu-id="02415-4044">stind</span><span class="sxs-lookup"><span data-stu-id="02415-4044">stind.i2</span></span>|<span data-ttu-id="02415-4045">将 `int16` 值存储在给定地址。</span><span class="sxs-lookup"><span data-stu-id="02415-4045">Stores an `int16` value at a given address.</span></span>|  
  
 <span data-ttu-id="02415-4046">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4046">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4047">地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4047">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-4048">将值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4048">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-4049">从堆栈中弹出值和地址;值存储在地址上。</span><span class="sxs-lookup"><span data-stu-id="02415-4049">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="02415-4050">`stind.i2` 指令将 `int16` 值存储在所提供的地址（类型 `native int`、`*`或 `&`）上。</span><span class="sxs-lookup"><span data-stu-id="02415-4050">The `stind.i2` instruction stores an `int16` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="02415-4051">类型安全操作要求 `stind.2i` 指令的使用方式与指针的类型一致。</span><span class="sxs-lookup"><span data-stu-id="02415-4051">Type safe operation requires that the `stind.2i` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="02415-4052">`stind.i2` 指令的操作可以通过紧挨着 <xref:System.Reflection.Emit.OpCodes.Volatile> 或 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀指令来更改。</span><span class="sxs-lookup"><span data-stu-id="02415-4052">The operation of the `stind.i2` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="02415-4053">如果对于指令后缀隐含的参数类型，`addr` 不是自然对齐的，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-4053"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="02415-4054">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stind.i2` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4054">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i2` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4055">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-4055">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4056">在所提供的地址存储 <see langword="int32" /> 类型的值。</span><span class="sxs-lookup"><span data-stu-id="02415-4056">Stores a value of type <see langword="int32" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4057">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4057">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4058">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4058">Format</span></span>|<span data-ttu-id="02415-4059">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4059">Assembly Format</span></span>|<span data-ttu-id="02415-4060">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4060">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4061">54</span><span class="sxs-lookup"><span data-stu-id="02415-4061">54</span></span>|<span data-ttu-id="02415-4062">stind. i4</span><span class="sxs-lookup"><span data-stu-id="02415-4062">stind.i4</span></span>|<span data-ttu-id="02415-4063">将 `int32` 值存储在给定地址。</span><span class="sxs-lookup"><span data-stu-id="02415-4063">Stores an `int32` value at a given address.</span></span>|  
  
 <span data-ttu-id="02415-4064">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4064">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4065">地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4065">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-4066">将值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4066">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-4067">从堆栈中弹出值和地址;值存储在地址上。</span><span class="sxs-lookup"><span data-stu-id="02415-4067">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="02415-4068">`stind.i4` 指令将 `int32` 值存储在所提供的地址（类型 `native int`、`*`或 `&`）上。</span><span class="sxs-lookup"><span data-stu-id="02415-4068">The `stind.i4` instruction stores an `int32` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="02415-4069">类型安全操作要求 `stind.i4` 指令的使用方式与指针的类型一致。</span><span class="sxs-lookup"><span data-stu-id="02415-4069">Type safe operation requires that the `stind.i4` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="02415-4070">`stind.i4` 指令的操作可以通过紧挨着 <xref:System.Reflection.Emit.OpCodes.Volatile> 或 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀指令来更改。</span><span class="sxs-lookup"><span data-stu-id="02415-4070">The operation of the `stind.i4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="02415-4071">如果对于指令后缀隐含的参数类型，`addr` 不是自然对齐的，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-4071"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="02415-4072">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stind.i4` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4072">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i4` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4073">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-4073">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4074">在所提供的地址存储 <see langword="int64" /> 类型的值。</span><span class="sxs-lookup"><span data-stu-id="02415-4074">Stores a value of type <see langword="int64" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4075">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4075">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4076">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4076">Format</span></span>|<span data-ttu-id="02415-4077">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4077">Assembly Format</span></span>|<span data-ttu-id="02415-4078">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4078">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4079">55</span><span class="sxs-lookup"><span data-stu-id="02415-4079">55</span></span>|<span data-ttu-id="02415-4080">stind. i8</span><span class="sxs-lookup"><span data-stu-id="02415-4080">stind.i8</span></span>|<span data-ttu-id="02415-4081">将 `int64` 值存储在给定地址。</span><span class="sxs-lookup"><span data-stu-id="02415-4081">Stores an `int64` value at a given address.</span></span>|  
  
 <span data-ttu-id="02415-4082">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4082">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4083">地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4083">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-4084">将值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4084">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-4085">从堆栈中弹出值和地址;值存储在地址上。</span><span class="sxs-lookup"><span data-stu-id="02415-4085">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="02415-4086">`stind.i8` 指令将 `int64` 值存储在所提供的地址（类型 `native int`、`*`或 `&`）上。</span><span class="sxs-lookup"><span data-stu-id="02415-4086">The `stind.i8` instruction stores an `int64` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="02415-4087">类型安全操作要求 `stind.i8` 指令的使用方式与指针的类型一致。</span><span class="sxs-lookup"><span data-stu-id="02415-4087">Type safe operation requires that the `stind.i8` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="02415-4088">`stind.i` 指令的操作可以通过紧挨着 <xref:System.Reflection.Emit.OpCodes.Volatile> 或 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀指令来更改。</span><span class="sxs-lookup"><span data-stu-id="02415-4088">The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="02415-4089">如果对于指令后缀隐含的参数类型，`addr` 不是自然对齐的，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-4089"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="02415-4090">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stind.i8` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4090">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i8` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4091">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-4091">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4092">在所提供的地址存储 <see langword="float32" /> 类型的值。</span><span class="sxs-lookup"><span data-stu-id="02415-4092">Stores a value of type <see langword="float32" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4093">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4093">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4094">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4094">Format</span></span>|<span data-ttu-id="02415-4095">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4095">Assembly Format</span></span>|<span data-ttu-id="02415-4096">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4096">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4097">56</span><span class="sxs-lookup"><span data-stu-id="02415-4097">56</span></span>|<span data-ttu-id="02415-4098">stind.r4</span><span class="sxs-lookup"><span data-stu-id="02415-4098">stind.r4</span></span>|<span data-ttu-id="02415-4099">将 `float32` 值存储在给定地址。</span><span class="sxs-lookup"><span data-stu-id="02415-4099">Stores a `float32` value at a given address.</span></span>|  
  
 <span data-ttu-id="02415-4100">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4100">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4101">地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4101">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-4102">将值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4102">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-4103">从堆栈中弹出值和地址;值存储在地址上。</span><span class="sxs-lookup"><span data-stu-id="02415-4103">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="02415-4104">`stind.r4` 指令将 `float32` 值存储在所提供的地址（类型 `native int`、`*`或 `&`）上。</span><span class="sxs-lookup"><span data-stu-id="02415-4104">The `stind.r4` instruction stores a `float32` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="02415-4105">类型安全操作要求 `stind.r4` 指令的使用方式与指针的类型一致。</span><span class="sxs-lookup"><span data-stu-id="02415-4105">Type safe operation requires that the `stind.r4` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="02415-4106">`stind.r4` 指令的操作可以通过紧挨着 <xref:System.Reflection.Emit.OpCodes.Volatile> 或 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀指令来更改。</span><span class="sxs-lookup"><span data-stu-id="02415-4106">The operation of the `stind.r4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="02415-4107">如果对于指令后缀隐含的参数类型，`addr` 不是自然对齐的，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-4107"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="02415-4108">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stind.r4` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4108">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r4` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4109">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-4109">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4110">在所提供的地址存储 <see langword="float64" /> 类型的值。</span><span class="sxs-lookup"><span data-stu-id="02415-4110">Stores a value of type <see langword="float64" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4111">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4111">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4112">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4112">Format</span></span>|<span data-ttu-id="02415-4113">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4113">Assembly Format</span></span>|<span data-ttu-id="02415-4114">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4114">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4115">57</span><span class="sxs-lookup"><span data-stu-id="02415-4115">57</span></span>|<span data-ttu-id="02415-4116">stind. r8</span><span class="sxs-lookup"><span data-stu-id="02415-4116">stind.r8</span></span>|<span data-ttu-id="02415-4117">将 `float64` 值存储在给定地址。</span><span class="sxs-lookup"><span data-stu-id="02415-4117">Stores a `float64` value at a given address.</span></span>|  
  
 <span data-ttu-id="02415-4118">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4118">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4119">地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4119">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-4120">将值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4120">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-4121">从堆栈中弹出值和地址;值存储在地址上。</span><span class="sxs-lookup"><span data-stu-id="02415-4121">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="02415-4122">`stind.r8` 指令将 `float64` 值存储在所提供的地址（类型 `native int`、`*`或 `&`）上。</span><span class="sxs-lookup"><span data-stu-id="02415-4122">The `stind.r8` instruction stores a `float64` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="02415-4123">类型安全操作要求 `stind.r8` 指令的使用方式与指针的类型一致。</span><span class="sxs-lookup"><span data-stu-id="02415-4123">Type safe operation requires that the `stind.r8` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="02415-4124">`stind.r8` 指令的操作可以通过紧挨着 <xref:System.Reflection.Emit.OpCodes.Volatile> 或 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀指令来更改。</span><span class="sxs-lookup"><span data-stu-id="02415-4124">The operation of the `stind.r8` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="02415-4125">如果对于指令后缀隐含的参数类型，`addr` 不是自然对齐的，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-4125"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="02415-4126">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stind.r8` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4126">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r8` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4127">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-4127">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4128">存储所提供地址处的对象引用值。</span><span class="sxs-lookup"><span data-stu-id="02415-4128">Stores a object reference value at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4129">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4129">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4130">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4130">Format</span></span>|<span data-ttu-id="02415-4131">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4131">Assembly Format</span></span>|<span data-ttu-id="02415-4132">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4132">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4133">51</span><span class="sxs-lookup"><span data-stu-id="02415-4133">51</span></span>|<span data-ttu-id="02415-4134">stind.ref</span><span class="sxs-lookup"><span data-stu-id="02415-4134">stind.ref</span></span>|<span data-ttu-id="02415-4135">将对象引用（类型 `O`）值存储在给定地址。</span><span class="sxs-lookup"><span data-stu-id="02415-4135">Stores an object reference (type `O`) value at a given address.</span></span>|  
  
 <span data-ttu-id="02415-4136">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4136">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4137">地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4137">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-4138">将值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4138">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-4139">从堆栈中弹出值和地址;值存储在地址上。</span><span class="sxs-lookup"><span data-stu-id="02415-4139">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="02415-4140">`stind.ref` 指令将对象引用值存储在所提供的地址（类型 `native int`、`*`或 `&`）上。</span><span class="sxs-lookup"><span data-stu-id="02415-4140">The `stind.ref` instruction stores an object reference value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="02415-4141">类型安全操作要求 `stind.ref` 指令的使用方式与指针的类型一致。</span><span class="sxs-lookup"><span data-stu-id="02415-4141">Type safe operation requires that the `stind.ref` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="02415-4142">`stind.ref` 指令的操作可以通过紧挨着 <xref:System.Reflection.Emit.OpCodes.Volatile> 或 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀指令来更改。</span><span class="sxs-lookup"><span data-stu-id="02415-4142">The operation of the `stind.ref` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="02415-4143">如果对于指令后缀隐含的参数类型，`addr` 不是自然对齐的，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-4143"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="02415-4144">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stind.ref` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4144">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.ref` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4145">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-4145">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4146">从计算堆栈的顶部弹出当前值并将其存储到指定索引处的局部变量列表中。</span><span class="sxs-lookup"><span data-stu-id="02415-4146">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4147">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4147">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4148">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4148">Format</span></span>|<span data-ttu-id="02415-4149">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4149">Assembly Format</span></span>|<span data-ttu-id="02415-4150">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4150">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4151">FE 0E < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="02415-4151">FE 0E < `unsigned int16` ></span></span>|<span data-ttu-id="02415-4152">stloc `index`</span><span class="sxs-lookup"><span data-stu-id="02415-4152">stloc `index`</span></span>|<span data-ttu-id="02415-4153">从堆栈中弹出一个值并将其存储在本地变量 `index`中。</span><span class="sxs-lookup"><span data-stu-id="02415-4153">Pops a value from the stack and stores it in local variable `index`.</span></span>|  
  
 <span data-ttu-id="02415-4154">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4154">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4155">将从堆栈中弹出一个值并将其放入本地变量 `index`中。</span><span class="sxs-lookup"><span data-stu-id="02415-4155">A value is popped off of the stack and placed in local variable `index`.</span></span>  
  
 <span data-ttu-id="02415-4156">`stloc` 指令从计算堆栈中弹出顶部值，并将其移到局部变量号 `index`，其中局部变量从0开始编号。</span><span class="sxs-lookup"><span data-stu-id="02415-4156">The `stloc` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="02415-4157">值的类型必须与当前方法本地签名中指定的局部变量的类型匹配。</span><span class="sxs-lookup"><span data-stu-id="02415-4157">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="02415-4158">如果存储在保持小于4个字节的整数值的局部变量中，长时间将在从堆栈移到局部变量时截断值。</span><span class="sxs-lookup"><span data-stu-id="02415-4158">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="02415-4159">浮点值从其本机大小（类型 `F`）舍入到与参数关联的大小。</span><span class="sxs-lookup"><span data-stu-id="02415-4159">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="02415-4160">更正 Microsoft 中间语言（MSIL）指令需要 `index` 是有效的本地索引。</span><span class="sxs-lookup"><span data-stu-id="02415-4160">Correct Microsoft Intermediate Language (MSIL) instructions require that `index` be a valid local index.</span></span> <span data-ttu-id="02415-4161">对于 `stloc` 指令，`index` 必须在0到65534的范围内（具体而言，65535是无效的）。</span><span class="sxs-lookup"><span data-stu-id="02415-4161">For the `stloc` instruction, `index` must lie in the range 0 to 65534 inclusive (specifically, 65535 is not valid).</span></span> <span data-ttu-id="02415-4162">排除65535的原因是实际的：可能的实现将使用2字节整数跟踪本地的索引，以及给定方法的局部变量总数。</span><span class="sxs-lookup"><span data-stu-id="02415-4162">The reason for excluding 65535 is pragmatic: likely implementations will use a 2-byte integer to track both a local's index, as well as the total number of locals for a given method.</span></span> <span data-ttu-id="02415-4163">如果已将65535的索引设为有效，则需要更宽的整数来跟踪此类方法中的局部变量的数目。</span><span class="sxs-lookup"><span data-stu-id="02415-4163">If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</span></span>  
  
 <span data-ttu-id="02415-4164">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stloc` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4164">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4165">ILGenerator （OpCode，LocalBuilder）</span><span class="sxs-lookup"><span data-stu-id="02415-4165">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="02415-4166">ILGenerator （操作码，short）</span><span class="sxs-lookup"><span data-stu-id="02415-4166">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4167">从计算堆栈的顶部弹出当前值并将其存储到索引 0 处的局部变量列表中。</span><span class="sxs-lookup"><span data-stu-id="02415-4167">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 0.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4168">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4168">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4169">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4169">Format</span></span>|<span data-ttu-id="02415-4170">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4170">Assembly Format</span></span>|<span data-ttu-id="02415-4171">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4171">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4172">0A</span><span class="sxs-lookup"><span data-stu-id="02415-4172">0A</span></span>|<span data-ttu-id="02415-4173">stloc.0</span><span class="sxs-lookup"><span data-stu-id="02415-4173">stloc.0</span></span>|<span data-ttu-id="02415-4174">将值从堆栈中弹出到局部变量0中。</span><span class="sxs-lookup"><span data-stu-id="02415-4174">Pops a value from the stack into local variable 0.</span></span>|  
  
 <span data-ttu-id="02415-4175">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4175">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4176">从堆栈中弹出一个值，并将其放入索引为0的局部变量。</span><span class="sxs-lookup"><span data-stu-id="02415-4176">A value is popped off of the stack and placed in the local variable indexed by 0.</span></span>  
  
 <span data-ttu-id="02415-4177">`stloc.0` 指令从计算堆栈中弹出顶部值，并将其移动到索引为0的局部变量中。</span><span class="sxs-lookup"><span data-stu-id="02415-4177">The `stloc.0` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 0.</span></span> <span data-ttu-id="02415-4178">值的类型必须与当前方法本地签名中指定的局部变量的类型匹配。</span><span class="sxs-lookup"><span data-stu-id="02415-4178">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="02415-4179">`stloc.0` 是一种非常有效的编码，用于在局部变量0中存储值。</span><span class="sxs-lookup"><span data-stu-id="02415-4179">`stloc.0` is an especially efficient encoding for storing values in local variable 0.</span></span>  
  
 <span data-ttu-id="02415-4180">如果存储在保持小于4个字节的整数值的局部变量中，长时间将在从堆栈移到局部变量时截断值。</span><span class="sxs-lookup"><span data-stu-id="02415-4180">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="02415-4181">浮点值从其本机大小（类型 `F`）舍入到与参数关联的大小。</span><span class="sxs-lookup"><span data-stu-id="02415-4181">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="02415-4182">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stloc.0` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4182">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.0` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4183">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-4183">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4184">从计算堆栈的顶部弹出当前值并将其存储到索引 1 处的局部变量列表中。</span><span class="sxs-lookup"><span data-stu-id="02415-4184">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 1.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4185">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4185">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4186">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4186">Format</span></span>|<span data-ttu-id="02415-4187">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4187">Assembly Format</span></span>|<span data-ttu-id="02415-4188">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4188">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4189">0B</span><span class="sxs-lookup"><span data-stu-id="02415-4189">0B</span></span>|<span data-ttu-id="02415-4190">stloc.1</span><span class="sxs-lookup"><span data-stu-id="02415-4190">stloc.1</span></span>|<span data-ttu-id="02415-4191">将值从堆栈中弹出到局部变量1中。</span><span class="sxs-lookup"><span data-stu-id="02415-4191">Pops a value from the stack into local variable 1.</span></span>|  
  
 <span data-ttu-id="02415-4192">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4192">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4193">从堆栈中弹出一个值，并将其放入索引为1的局部变量。</span><span class="sxs-lookup"><span data-stu-id="02415-4193">A value is popped off of the stack and placed in the local variable indexed by 1.</span></span>  
  
 <span data-ttu-id="02415-4194">`stloc.1` 指令从计算堆栈中弹出顶部值，并将其移动到索引为1的本地变量中。</span><span class="sxs-lookup"><span data-stu-id="02415-4194">The `stloc.1` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 1.</span></span> <span data-ttu-id="02415-4195">值的类型必须与当前方法本地签名中指定的局部变量的类型匹配。</span><span class="sxs-lookup"><span data-stu-id="02415-4195">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="02415-4196">`stloc.1` 是一种非常有效的编码方式，用于将值存储在本地变量1中。</span><span class="sxs-lookup"><span data-stu-id="02415-4196">`stloc.1` is an especially efficient encoding for storing values in local variable 1.</span></span>  
  
 <span data-ttu-id="02415-4197">如果存储在保持小于4个字节的整数值的局部变量中，长时间将在从堆栈移到局部变量时截断值。</span><span class="sxs-lookup"><span data-stu-id="02415-4197">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="02415-4198">浮点值从其本机大小（类型 `F`）舍入到与参数关联的大小。</span><span class="sxs-lookup"><span data-stu-id="02415-4198">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="02415-4199">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stloc.1` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4199">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.1` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4200">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-4200">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4201">从计算堆栈的顶部弹出当前值并将其存储到索引 2 处的局部变量列表中。</span><span class="sxs-lookup"><span data-stu-id="02415-4201">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 2.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4202">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4202">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4203">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4203">Format</span></span>|<span data-ttu-id="02415-4204">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4204">Assembly Format</span></span>|<span data-ttu-id="02415-4205">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4205">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4206">0C</span><span class="sxs-lookup"><span data-stu-id="02415-4206">0C</span></span>|<span data-ttu-id="02415-4207">stloc.2</span><span class="sxs-lookup"><span data-stu-id="02415-4207">stloc.2</span></span>|<span data-ttu-id="02415-4208">将值从堆栈中弹出到局部变量2中</span><span class="sxs-lookup"><span data-stu-id="02415-4208">Pops a value from the stack into local variable 2</span></span>|  
  
 <span data-ttu-id="02415-4209">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4209">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4210">从堆栈中弹出一个值，并将其放入索引为2的局部变量中。</span><span class="sxs-lookup"><span data-stu-id="02415-4210">A value is popped off of the stack and placed in the local variable indexed by 2.</span></span>  
  
 <span data-ttu-id="02415-4211">`stloc.2` 指令从计算堆栈中弹出顶部值，并将其移动到索引为2的局部变量中。</span><span class="sxs-lookup"><span data-stu-id="02415-4211">The `stloc.2` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 2.</span></span> <span data-ttu-id="02415-4212">值的类型必须与当前方法本地签名中指定的局部变量的类型匹配。</span><span class="sxs-lookup"><span data-stu-id="02415-4212">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="02415-4213">`stloc.2` 是一种非常有效的编码，用于在局部变量2中存储值。</span><span class="sxs-lookup"><span data-stu-id="02415-4213">`stloc.2` is an especially efficient encoding for storing values in local variable 2.</span></span>  
  
 <span data-ttu-id="02415-4214">如果存储在保持小于4个字节的整数值的局部变量中，长时间将在从堆栈移到局部变量时截断值。</span><span class="sxs-lookup"><span data-stu-id="02415-4214">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="02415-4215">浮点值从其本机大小（类型 `F`）舍入到与参数关联的大小。</span><span class="sxs-lookup"><span data-stu-id="02415-4215">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="02415-4216">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stloc.2` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4216">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.2` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4217">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-4217">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4218">从计算堆栈的顶部弹出当前值并将其存储到索引 3 处的局部变量列表中。</span><span class="sxs-lookup"><span data-stu-id="02415-4218">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 3.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4219">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4219">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4220">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4220">Format</span></span>|<span data-ttu-id="02415-4221">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4221">Assembly Format</span></span>|<span data-ttu-id="02415-4222">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4222">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4223">0D</span><span class="sxs-lookup"><span data-stu-id="02415-4223">0D</span></span>|<span data-ttu-id="02415-4224">stloc.3</span><span class="sxs-lookup"><span data-stu-id="02415-4224">stloc.3</span></span>|<span data-ttu-id="02415-4225">从堆栈中弹出一个值到局部变量3</span><span class="sxs-lookup"><span data-stu-id="02415-4225">Pops a value from the stack into local variable 3</span></span>|  
  
 <span data-ttu-id="02415-4226">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4226">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4227">从堆栈中弹出一个值，并将其放入索引为3的局部变量。</span><span class="sxs-lookup"><span data-stu-id="02415-4227">A value is popped off of the stack and placed in the local variable indexed by 3.</span></span>  
  
 <span data-ttu-id="02415-4228">`stloc.3` 指令从计算堆栈中弹出顶部值，并将其移动到索引为3的本地变量中。</span><span class="sxs-lookup"><span data-stu-id="02415-4228">The `stloc.3` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 3.</span></span> <span data-ttu-id="02415-4229">值的类型必须与当前方法本地签名中指定的局部变量的类型匹配。</span><span class="sxs-lookup"><span data-stu-id="02415-4229">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="02415-4230">`stloc.3` 是一种非常有效的编码，用于在局部变量3中存储值。</span><span class="sxs-lookup"><span data-stu-id="02415-4230">`stloc.3` is an especially efficient encoding for storing values in local variable 3.</span></span>  
  
 <span data-ttu-id="02415-4231">如果存储在保持小于4个字节的整数值的局部变量中，长时间将在从堆栈移到局部变量时截断值。</span><span class="sxs-lookup"><span data-stu-id="02415-4231">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="02415-4232">浮点值从其本机大小（类型 `F`）舍入到与参数关联的大小。</span><span class="sxs-lookup"><span data-stu-id="02415-4232">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="02415-4233">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stloc.3` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4233">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.3` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4234">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-4234">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4235">从计算堆栈的顶部弹出当前值并将其存储在局部变量列表中的 <paramref name="index" /> 处（短格式）。</span><span class="sxs-lookup"><span data-stu-id="02415-4235">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at <paramref name="index" /> (short form).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4236">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4236">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4237">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4237">Format</span></span>|<span data-ttu-id="02415-4238">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4238">Assembly Format</span></span>|<span data-ttu-id="02415-4239">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4239">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4240">13 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="02415-4240">13 < `unsigned int8` ></span></span>|<span data-ttu-id="02415-4241">stloc `index`</span><span class="sxs-lookup"><span data-stu-id="02415-4241">stloc.s `index`</span></span>|<span data-ttu-id="02415-4242">从堆栈中弹出一个值并将其存储在本地变量 `index`中，即缩写形式。</span><span class="sxs-lookup"><span data-stu-id="02415-4242">Pops a value from the stack and stores it in local variable `index`, short form.</span></span>|  
  
 <span data-ttu-id="02415-4243">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4243">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4244">将从堆栈中弹出一个值并将其放入本地变量 `index`中。</span><span class="sxs-lookup"><span data-stu-id="02415-4244">A value is popped off of the stack and placed in local variable `index`.</span></span>  
  
 <span data-ttu-id="02415-4245">`stloc.s` 指令从计算堆栈中弹出顶部值，并将其移到局部变量号 `index`，其中局部变量从0开始编号。</span><span class="sxs-lookup"><span data-stu-id="02415-4245">The `stloc.s` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="02415-4246">值的类型必须与当前方法本地签名中指定的局部变量的类型匹配。</span><span class="sxs-lookup"><span data-stu-id="02415-4246">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="02415-4247">`stloc.s` 指令为局部变量0到255提供有效编码。</span><span class="sxs-lookup"><span data-stu-id="02415-4247">The `stloc.s` instruction provides an efficient encoding for local variables 0 through 255.</span></span>  
  
 <span data-ttu-id="02415-4248">如果存储在保持小于4个字节的整数值的局部变量中，长时间将在从堆栈移到局部变量时截断值。</span><span class="sxs-lookup"><span data-stu-id="02415-4248">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="02415-4249">浮点值从其本机大小（类型 `F`）舍入到与参数关联的大小。</span><span class="sxs-lookup"><span data-stu-id="02415-4249">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="02415-4250">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stloc.s` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4250">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc.s` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4251">ILGenerator （OpCode，LocalBuilder）</span><span class="sxs-lookup"><span data-stu-id="02415-4251">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="02415-4252">ILGenerator （OpCode，byte）</span><span class="sxs-lookup"><span data-stu-id="02415-4252">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4253">将指定类型的值从计算堆栈复制到所提供的内存地址中。</span><span class="sxs-lookup"><span data-stu-id="02415-4253">Copies a value of a specified type from the evaluation stack into a supplied memory address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4254">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4254">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4255">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4255">Format</span></span>|<span data-ttu-id="02415-4256">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4256">Assembly Format</span></span>|<span data-ttu-id="02415-4257">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4257">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4258">81 < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-4258">81 < `T` ></span></span>|<span data-ttu-id="02415-4259">stobj `class`</span><span class="sxs-lookup"><span data-stu-id="02415-4259">stobj `class`</span></span>|<span data-ttu-id="02415-4260">将类型 `class` 的值存储在内存中。</span><span class="sxs-lookup"><span data-stu-id="02415-4260">Stores a value of type `class` from the stack into memory.</span></span>|  
  
 <span data-ttu-id="02415-4261">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4261">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4262">地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4262">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-4263">类型 `class` 的值类型对象被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4263">A value type object of type `class` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-4264">从堆栈中弹出对象和地址;值类型对象存储在地址上。</span><span class="sxs-lookup"><span data-stu-id="02415-4264">The object and the address are popped from the stack; the value type object is stored at the address.</span></span>  
  
 <span data-ttu-id="02415-4265">`stobj` 指令将值类型对象复制到地址指定的地址（`native int`、`*`或 `&`类型的指针）。</span><span class="sxs-lookup"><span data-stu-id="02415-4265">The `stobj` instruction copies the value type object into the address specified by the address (a pointer of type `native int`, `*`, or `&`).</span></span> <span data-ttu-id="02415-4266">已复制的字节数取决于 `class`（表示值类型的元数据标记）所表示的类的大小。</span><span class="sxs-lookup"><span data-stu-id="02415-4266">The number of bytes copied depends on the size of the class represented by `class`, a metadata token representing a value type.</span></span>  
  
 <span data-ttu-id="02415-4267">`stobj` 指令的操作可以通过紧挨着 <xref:System.Reflection.Emit.OpCodes.Volatile> 或 <xref:System.Reflection.Emit.OpCodes.Unaligned> 前缀指令来更改。</span><span class="sxs-lookup"><span data-stu-id="02415-4267">The operation of the `stobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="02415-4268">如果找不到类，则会引发 <xref:System.TypeLoadException>。</span><span class="sxs-lookup"><span data-stu-id="02415-4268"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="02415-4269">当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是运行时，通常会检测到此情况。</span><span class="sxs-lookup"><span data-stu-id="02415-4269">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</span></span>  
  
 <span data-ttu-id="02415-4270">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stobj` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4270">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stobj` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4271">ILGenerator （OpCode，Type）</span><span class="sxs-lookup"><span data-stu-id="02415-4271">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4272">用来自计算堆栈的值替换静态字段的值。</span><span class="sxs-lookup"><span data-stu-id="02415-4272">Replaces the value of a static field with a value from the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4273">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4273">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4274">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4274">Format</span></span>|<span data-ttu-id="02415-4275">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4275">Assembly Format</span></span>|<span data-ttu-id="02415-4276">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4276">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4277">80 < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-4277">80 < `T` ></span></span>|<span data-ttu-id="02415-4278">stsfld `field`</span><span class="sxs-lookup"><span data-stu-id="02415-4278">stsfld `field`</span></span>|<span data-ttu-id="02415-4279">将 `field` 中的值替换为提供的值。</span><span class="sxs-lookup"><span data-stu-id="02415-4279">Replaces the value in `field` with a supplied value.</span></span>|  
  
 <span data-ttu-id="02415-4280">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4280">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4281">将值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4281">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-4282">从堆栈中弹出一个值并将其存储在 `field`中。</span><span class="sxs-lookup"><span data-stu-id="02415-4282">A value is popped from the stack and stored in `field`.</span></span>  
  
 <span data-ttu-id="02415-4283">`stsfld` 指令用来自堆栈的值替换静态字段的值。</span><span class="sxs-lookup"><span data-stu-id="02415-4283">The `stsfld` instruction replaces the value of a static field with a value from the stack.</span></span> <span data-ttu-id="02415-4284">`field` 是必须引用静态字段成员的元数据标记。</span><span class="sxs-lookup"><span data-stu-id="02415-4284">`field` is a metadata token that must refer to a static field member.</span></span>  
  
 <span data-ttu-id="02415-4285">`stsfld` 指令可能以 <xref:System.Reflection.Emit.OpCodes.Volatile>为前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-4285">The `stsfld` instruction may be prefixed by <xref:System.Reflection.Emit.OpCodes.Volatile>.</span></span>  
  
 <span data-ttu-id="02415-4286">如果在元数据中找不到字段，则会引发 <xref:System.MissingFieldException>。</span><span class="sxs-lookup"><span data-stu-id="02415-4286"><xref:System.MissingFieldException> is thrown if field is not found in the metadata.</span></span> <span data-ttu-id="02415-4287">当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是在运行时，通常会检查此情况。</span><span class="sxs-lookup"><span data-stu-id="02415-4287">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="02415-4288">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `stsfld` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4288">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stsfld` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4289">ILGenerator （OpCode，FieldInfo）</span><span class="sxs-lookup"><span data-stu-id="02415-4289">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4290">从其他值中减去一个值并将结果推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4290">Subtracts one value from another and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4291">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4291">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4292">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4292">Format</span></span>|<span data-ttu-id="02415-4293">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4293">Assembly Format</span></span>|<span data-ttu-id="02415-4294">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4294">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4295">59</span><span class="sxs-lookup"><span data-stu-id="02415-4295">59</span></span>|<span data-ttu-id="02415-4296">sub</span><span class="sxs-lookup"><span data-stu-id="02415-4296">sub</span></span>|<span data-ttu-id="02415-4297">从一个值中减去另一个值，返回新的数值。</span><span class="sxs-lookup"><span data-stu-id="02415-4297">Subtracts one value from another, returning a new numeric value.</span></span>|  
  
 <span data-ttu-id="02415-4298">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4298">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4299">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4299">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-4300">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4300">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-4301">从堆栈中弹出 `value2` 和 `value1`;从 `value1`中减去 `value2`。</span><span class="sxs-lookup"><span data-stu-id="02415-4301">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1`.</span></span>  
  
4.  <span data-ttu-id="02415-4302">将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4302">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-4303">未检测到用于整数运算的溢出（有关正确的溢出处理，请参阅 <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>）。</span><span class="sxs-lookup"><span data-stu-id="02415-4303">Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).</span></span>  
  
 <span data-ttu-id="02415-4304">整数减法环绕，而不是尽量充满。</span><span class="sxs-lookup"><span data-stu-id="02415-4304">Integer subtraction wraps, rather than saturates.</span></span> <span data-ttu-id="02415-4305">例如：假设8位整数，其中 `value1` 设置为0，并且 `value2` 设置为1，则 "已包装" 结果将为255。</span><span class="sxs-lookup"><span data-stu-id="02415-4305">For example: assuming 8-bit integers, where `value1` is set to 0 and `value2` is set to 1, the "wrapped" result will be 255.</span></span>  
  
 <span data-ttu-id="02415-4306">浮点溢出返回 `+inf` （`PositiveInfinity`）或 `-inf` （`NegativeInfinity`）。</span><span class="sxs-lookup"><span data-stu-id="02415-4306">Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).</span></span>  
  
 <span data-ttu-id="02415-4307">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `sub` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4307">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4308">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-4308">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4309">从另一值中减去一个整数值，执行溢出检查，并且将结果推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4309">Subtracts one integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4310">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4310">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4311">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4311">Format</span></span>|<span data-ttu-id="02415-4312">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4312">Assembly Format</span></span>|<span data-ttu-id="02415-4313">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4313">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4314">DA</span><span class="sxs-lookup"><span data-stu-id="02415-4314">DA</span></span>|<span data-ttu-id="02415-4315">sub.ovf</span><span class="sxs-lookup"><span data-stu-id="02415-4315">sub.ovf</span></span>|<span data-ttu-id="02415-4316">使用溢出检查从一个整数值中减去另一个整数值。</span><span class="sxs-lookup"><span data-stu-id="02415-4316">Subtracts one integer value from another with an overflow check.</span></span>|  
  
 <span data-ttu-id="02415-4317">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4317">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4318">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4318">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-4319">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4319">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-4320">从堆栈中弹出 `value2` 和 `value1`;将从 `value1` 中减去 `value2`，并检查是否有溢出。</span><span class="sxs-lookup"><span data-stu-id="02415-4320">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="02415-4321">将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4321">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-4322">如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-4322"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-4323">此操作在有符号整数上执行;对于浮点值，请使用 <xref:System.Reflection.Emit.OpCodes.Sub>。</span><span class="sxs-lookup"><span data-stu-id="02415-4323">This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.</span></span>  
  
 <span data-ttu-id="02415-4324">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `sub.ovf` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4324">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4325">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-4325">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4326">从另一值中减去一个无符号整数值，执行溢出检查，并且将结果推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4326">Subtracts one unsigned integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4327">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4327">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4328">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4328">Format</span></span>|<span data-ttu-id="02415-4329">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4329">Assembly Format</span></span>|<span data-ttu-id="02415-4330">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4330">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4331">DB</span><span class="sxs-lookup"><span data-stu-id="02415-4331">DB</span></span>|<span data-ttu-id="02415-4332">sub.ovf.un</span><span class="sxs-lookup"><span data-stu-id="02415-4332">sub.ovf.un</span></span>|<span data-ttu-id="02415-4333">使用溢出检查从一个无符号整数值减去另一个无符号整数值。</span><span class="sxs-lookup"><span data-stu-id="02415-4333">Subtracts one unsigned integer value from another with an overflow check.</span></span>|  
  
 <span data-ttu-id="02415-4334">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4334">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4335">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4335">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-4336">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4336">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-4337">从堆栈中弹出 `value2` 和 `value1`;将从 `value1` 中减去 `value2`，并检查是否有溢出。</span><span class="sxs-lookup"><span data-stu-id="02415-4337">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="02415-4338">将结果推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4338">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-4339">如果结果类型中不能表示结果，则会引发 <xref:System.OverflowException>。</span><span class="sxs-lookup"><span data-stu-id="02415-4339"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="02415-4340">此操作在有符号整数上执行;对于浮点值，请使用 <xref:System.Reflection.Emit.OpCodes.Sub>。</span><span class="sxs-lookup"><span data-stu-id="02415-4340">This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.</span></span>  
  
 <span data-ttu-id="02415-4341">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `sub.ovf.un` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4341">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4342">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-4342">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4343">实现跳转表。</span><span class="sxs-lookup"><span data-stu-id="02415-4343">Implements a jump table.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4344">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4344">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4345">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4345">Format</span></span>|<span data-ttu-id="02415-4346">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4346">Assembly Format</span></span>|<span data-ttu-id="02415-4347">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4347">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4348">45 < `unsigned int32` > < `int32` > .。。< `int32` ></span><span class="sxs-lookup"><span data-stu-id="02415-4348">45 < `unsigned int32` > < `int32` >... < `int32` ></span></span>|<span data-ttu-id="02415-4349">switch （`N`、`t1`、`t2`... `tN`）</span><span class="sxs-lookup"><span data-stu-id="02415-4349">switch (`N`, `t1`, `t2`... `tN`)</span></span>|<span data-ttu-id="02415-4350">跳转到 `N` 值之一。</span><span class="sxs-lookup"><span data-stu-id="02415-4350">Jumps to one of `N` values.</span></span>|  
  
 <span data-ttu-id="02415-4351">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4351">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4352">将值推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4352">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-4353">该值将从堆栈中弹出，并按照值索引的偏移量将执行转移到指令，其中值小于 `N`。</span><span class="sxs-lookup"><span data-stu-id="02415-4353">The value is popped off the stack and execution is transferred to the instruction at the offset indexed by the value, where the value is less than `N`.</span></span>  
  
 <span data-ttu-id="02415-4354">`switch` 指令实现跳转表。</span><span class="sxs-lookup"><span data-stu-id="02415-4354">The `switch` instruction implements a jump table.</span></span> <span data-ttu-id="02415-4355">指令的格式是表示目标 `N`数量的 `unsigned int32`，后跟指定跳转目标 `N` int32 值。</span><span class="sxs-lookup"><span data-stu-id="02415-4355">The format of the instruction is an `unsigned int32` representing the number of targets `N`, followed by `N` int32 values specifying jump targets.</span></span> <span data-ttu-id="02415-4356">这些目标在此 `switch` 指令后面的指令开头表示为偏移量（正或负）。</span><span class="sxs-lookup"><span data-stu-id="02415-4356">These targets are represented as offsets (positive or negative) from the beginning of the instruction following this `switch` instruction.</span></span>  
  
 <span data-ttu-id="02415-4357">`switch` 指令从堆栈中弹出一个值，并将其作为无符号整数进行比较，以 `N`。</span><span class="sxs-lookup"><span data-stu-id="02415-4357">The `switch` instruction pops a value off the stack and compares it, as an unsigned integer, to `N`.</span></span> <span data-ttu-id="02415-4358">如果 value 小于 `N`，则将执行转移到按值索引的目标，其中目标从0开始编号（例如，值0采用第一个目标，值为1，则使用第二个目标，依此类推）。</span><span class="sxs-lookup"><span data-stu-id="02415-4358">If value is less than `N`, execution is transferred to the target indexed by value, where targets are numbered from 0 (for example, a value of 0 takes the first target, a value of 1 takes the second target, and so on).</span></span> <span data-ttu-id="02415-4359">如果该值大于或等于 `N`，则继续执行下一条指令（贯穿）。</span><span class="sxs-lookup"><span data-stu-id="02415-4359">If the value is greater than or equal to `N`, execution continues at the next instruction (fall through).</span></span>  
  
 <span data-ttu-id="02415-4360">如果目标指令具有一个或多个前缀代码，则只能将控制转移到其中的第一个前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-4360">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="02415-4361">此指令不能执行控制传入和传出 `try`、`catch`、`filter`和 `finally` 块的控制。</span><span class="sxs-lookup"><span data-stu-id="02415-4361">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span> <span data-ttu-id="02415-4362">（此类传输受到严格限制，因此必须改用 leave 指令）。</span><span class="sxs-lookup"><span data-stu-id="02415-4362">(Such transfers are severely restricted and must use the leave instruction instead).</span></span>  
  
 <span data-ttu-id="02415-4363">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `switch` 操作码。</span><span class="sxs-lookup"><span data-stu-id="02415-4363">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `switch` opcode.</span></span> <span data-ttu-id="02415-4364">`Label[]` 参数是表示32位偏移量的标签数组。</span><span class="sxs-lookup"><span data-stu-id="02415-4364">The `Label[]` argument is an array of Labels representing 32-bit offsets.</span></span>  
  
-   <span data-ttu-id="02415-4365">ILGenerator.Emit(OpCode, Label[])</span><span class="sxs-lookup"><span data-stu-id="02415-4365">ILGenerator.Emit(OpCode, Label[])</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02415-4366">下面的代码示例演示如何使用 `Switch` 操作码来使用 <xref:System.Reflection.Emit.Label>的数组生成跳转表。</span><span class="sxs-lookup"><span data-stu-id="02415-4366">The following code sample illustrates the use of the `Switch` opcode to generate a jump table using an array of <xref:System.Reflection.Emit.Label>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4367">执行后缀的方法调用指令，以便在执行实际调用指令前移除当前方法的堆栈帧。</span><span class="sxs-lookup"><span data-stu-id="02415-4367">Performs a postfixed method call instruction such that the current method's stack frame is removed before the actual call instruction is executed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4368">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4368">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4369">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4369">Format</span></span>|<span data-ttu-id="02415-4370">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4370">Assembly Format</span></span>|<span data-ttu-id="02415-4371">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4371">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4372">FE 14</span><span class="sxs-lookup"><span data-stu-id="02415-4372">FE 14</span></span>|<span data-ttu-id="02415-4373">侧.</span><span class="sxs-lookup"><span data-stu-id="02415-4373">tail.</span></span>|<span data-ttu-id="02415-4374">后续调用终止当前方法</span><span class="sxs-lookup"><span data-stu-id="02415-4374">Subsequent call terminates current methods</span></span>|  
  
 <span data-ttu-id="02415-4375">没有为此指令定义堆栈转换行为。</span><span class="sxs-lookup"><span data-stu-id="02415-4375">There is no stack transition behavior defined for this instruction.</span></span>  
  
 <span data-ttu-id="02415-4376">`tail` 前缀指令必须紧跟 <xref:System.Reflection.Emit.OpCodes.Call>、<xref:System.Reflection.Emit.OpCodes.Calli>或 <xref:System.Reflection.Emit.OpCodes.Callvirt> 指令之前。</span><span class="sxs-lookup"><span data-stu-id="02415-4376">The `tail` prefix instruction must immediately precede a <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, or <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction.</span></span> <span data-ttu-id="02415-4377">它指示在执行调用指令之前应移除当前方法的堆栈帧。</span><span class="sxs-lookup"><span data-stu-id="02415-4377">It indicates that the current method's stack frame should be removed before the call instruction is executed.</span></span> <span data-ttu-id="02415-4378">它还意味着从以下调用返回的值也是当前方法返回的值，因此可以将调用转换为交叉方法跳转。</span><span class="sxs-lookup"><span data-stu-id="02415-4378">It also implies that the value returned from the following call is also the value returned by the current method, and the call can therefore be converted into a cross-method jump.</span></span>  
  
 <span data-ttu-id="02415-4379">堆栈必须为空，但通过以下调用传输的参数除外。</span><span class="sxs-lookup"><span data-stu-id="02415-4379">The stack must be empty except for the arguments being transferred by the following call.</span></span> <span data-ttu-id="02415-4380">调用指令后面的指令必须是 ret。因此，唯一有效的代码序列是 `tail. call` （或 `calli` 或 `callvirt`）。</span><span class="sxs-lookup"><span data-stu-id="02415-4380">The instruction following the call instruction must be a ret. Thus the only valid code sequence is `tail. call` (or `calli` or `callvirt`).</span></span> <span data-ttu-id="02415-4381">更正 Microsoft 中间语言（MSIL）指令不能分支到 `call` 指令，但是它们可能会分支到后续的 <xref:System.Reflection.Emit.OpCodes.Ret>。</span><span class="sxs-lookup"><span data-stu-id="02415-4381">Correct Microsoft Intermediate Language (MSIL) instructions must not branch to the `call` instruction, but they may branch to the subsequent <xref:System.Reflection.Emit.OpCodes.Ret>.</span></span>  
  
 <span data-ttu-id="02415-4382">如果控件从不受信任的代码传输到受信任的代码，则无法放弃当前帧，因为这会危及代码标识安全性。</span><span class="sxs-lookup"><span data-stu-id="02415-4382">The current frame cannot be discarded when control is transferred from untrusted code to trusted code, since this would jeopardize code identity security.</span></span> <span data-ttu-id="02415-4383">因此 .NET Framework 安全检查可能会导致 `tail` 被忽略，而保留标准 <xref:System.Reflection.Emit.OpCodes.Call> 指令。</span><span class="sxs-lookup"><span data-stu-id="02415-4383">The .NET Framework security checks can therefore cause the `tail` to be ignored, leaving a standard <xref:System.Reflection.Emit.OpCodes.Call> instruction.</span></span> <span data-ttu-id="02415-4384">同样，若要允许在调用返回后退出已同步的区域，则在用于退出标记为已同步的方法时，将忽略 `tail` 前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-4384">Similarly, in order to allow the exit of a synchronized region to occur after the call returns, the `tail` prefix is ignored when used to exit a method that is marked synchronized.</span></span>  
  
 <span data-ttu-id="02415-4385">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `tail` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4385">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `tail` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4386">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-4386">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst"><span data-ttu-id="02415-4387">操作码对象的实例。</span><span class="sxs-lookup"><span data-stu-id="02415-4387">An instance of an Opcode object.</span></span></param>
        <summary><span data-ttu-id="02415-4388">如果提供的操作码采用单字节自变量则返回真或假。</span><span class="sxs-lookup"><span data-stu-id="02415-4388">Returns true or false if the supplied opcode takes a single byte argument.</span></span></summary>
        <returns><span data-ttu-id="02415-4389"><see langword="true" /> 或 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="02415-4389"><see langword="true" /> or <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4390">此方法可用于查找要在优化代码中使用的 MSIL 操作码为 "短格式"。</span><span class="sxs-lookup"><span data-stu-id="02415-4390">This method can be used to find which MSIL opcodes are "short form", for use in optimized code.</span></span>  
  
 <span data-ttu-id="02415-4391">如果 <xref:System.Reflection.Emit.OpCode> 实例在以下情况下使用单个字节参数，`TakesSingleByteArgument` 将返回 `true`：</span><span class="sxs-lookup"><span data-stu-id="02415-4391">`TakesSingleByteArgument` returns `true` if the <xref:System.Reflection.Emit.OpCode> instance takes a single byte argument in the following cases:</span></span>  
  
-   <span data-ttu-id="02415-4392">操作码对字节大小的地址（例如 <xref:System.Reflection.Emit.OpCodes.Br_S> 和 <xref:System.Reflection.Emit.OpCodes.Bgt_S>）执行分支指令。</span><span class="sxs-lookup"><span data-stu-id="02415-4392">The opcode performs a branch instruction to a byte-sized address (for example, <xref:System.Reflection.Emit.OpCodes.Br_S> and <xref:System.Reflection.Emit.OpCodes.Bgt_S>).</span></span>  
  
-   <span data-ttu-id="02415-4393">操作码将一个字节值推送到堆栈上（例如 <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>）。</span><span class="sxs-lookup"><span data-stu-id="02415-4393">The opcode pushes a byte value onto the stack (for example, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).</span></span>  
  
-   <span data-ttu-id="02415-4394">操作码通过大小为字节大小的 "缩写" （例如 <xref:System.Reflection.Emit.OpCodes.Ldloc_S> 和 <xref:System.Reflection.Emit.OpCodes.Stloc_S>）来引用变量或参数。</span><span class="sxs-lookup"><span data-stu-id="02415-4394">The opcode references a variable or argument via the byte-sized "short form" (for example, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> and <xref:System.Reflection.Emit.OpCodes.Stloc_S>).</span></span>  
  
 <span data-ttu-id="02415-4395">否则，它将返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="02415-4395">Otherwise, it returns `false`.</span></span>  
  
 <span data-ttu-id="02415-4396">下面的示例演示了如何使用 `TakesSingleByteArgument`，方法是反射到 `OpCodes` 类并进行测试，以查看每个 `OpCode` 字段是否采用单字节参数。</span><span class="sxs-lookup"><span data-stu-id="02415-4396">The example below demonstrates the use of `TakesSingleByteArgument` by reflecting on to the `OpCodes` class and testing to see whether each `OpCode` field takes a single-byte argument.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4397">引发当前位于计算堆栈上的异常对象。</span><span class="sxs-lookup"><span data-stu-id="02415-4397">Throws the exception object currently on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4398">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4398">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4399">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4399">Format</span></span>|<span data-ttu-id="02415-4400">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4400">Assembly Format</span></span>|<span data-ttu-id="02415-4401">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4401">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4402">7A</span><span class="sxs-lookup"><span data-stu-id="02415-4402">7A</span></span>|<span data-ttu-id="02415-4403">throw</span><span class="sxs-lookup"><span data-stu-id="02415-4403">throw</span></span>|<span data-ttu-id="02415-4404">引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-4404">Throws an exception.</span></span>|  
  
 <span data-ttu-id="02415-4405">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4405">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4406">将对象引用（对异常）推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4406">An object reference (to an exception) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-4407">从堆栈中弹出对象引用并引发异常。</span><span class="sxs-lookup"><span data-stu-id="02415-4407">The object reference is popped from the stack and the exception thrown.</span></span>  
  
 <span data-ttu-id="02415-4408">`throw` 指令引发当前堆栈上的异常对象（类型 `O`）。</span><span class="sxs-lookup"><span data-stu-id="02415-4408">The `throw` instruction throws the exception object (type `O`) currently on the stack.</span></span>  
  
 <span data-ttu-id="02415-4409">如果对象引用为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-4409"><xref:System.NullReferenceException> is thrown if the object reference is a null reference.</span></span>  
  
 <span data-ttu-id="02415-4410">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `throw` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4410">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `throw` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4411">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-4411">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4412">指示当前位于计算堆栈上的地址可能没有与紧接的 <see langword="ldind" />、<see langword="stind" />、<see langword="ldfld" />、<see langword="stfld" />、<see langword="ldobj" />、<see langword="stobj" />、<see langword="initblk" /> 或 <see langword="cpblk" /> 指令的自然大小对齐。</span><span class="sxs-lookup"><span data-stu-id="02415-4412">Indicates that an address currently atop the evaluation stack might not be aligned to the natural size of the immediately following <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" />, or <see langword="cpblk" /> instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4413">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4413">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4414">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4414">Format</span></span>|<span data-ttu-id="02415-4415">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4415">Assembly Format</span></span>|<span data-ttu-id="02415-4416">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4416">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4417">FE 12 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="02415-4417">FE 12 < `unsigned int8` ></span></span>|<span data-ttu-id="02415-4418">未对齐.</span><span class="sxs-lookup"><span data-stu-id="02415-4418">unaligned.</span></span> `alignment`|<span data-ttu-id="02415-4419">指示后面的指针指令可能是不对齐的。</span><span class="sxs-lookup"><span data-stu-id="02415-4419">Indicates that the subsequent pointer instruction may be unaligned.</span></span>|  
  
 <span data-ttu-id="02415-4420">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4420">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4421">地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4421">An address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-4422">`Unaligned` 指定堆栈上的地址（非托管指针、`native int`）可能不会与紧随其后 `ldind`、`stind`、`ldfld`、`stfld`、`ldobj`、`stobj`、`initblk`或 `cpblk` 指令的自然大小对齐。</span><span class="sxs-lookup"><span data-stu-id="02415-4422">`Unaligned` specifies that the address (an unmanaged pointer, `native int`) on the stack might not be aligned to the natural size of the immediately following `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="02415-4423">也就是说，对于 <xref:System.Reflection.Emit.OpCodes.Ldind_I4> 说明地址的对齐方式可能不是4字节边界。</span><span class="sxs-lookup"><span data-stu-id="02415-4423">That is, for a <xref:System.Reflection.Emit.OpCodes.Ldind_I4> instruction the alignment of the address may not be to a 4-byte boundary.</span></span> <span data-ttu-id="02415-4424">对于 `initblk` 和 `cpblk` 默认对齐方式取决于体系结构依赖（32位 Cpu 上的4个字节，64位 Cpu 上的8个字节）。</span><span class="sxs-lookup"><span data-stu-id="02415-4424">For `initblk` and `cpblk` the default alignment is architecture dependent (4-byte on 32-bit CPUs, 8-byte on 64-bit CPUs).</span></span> <span data-ttu-id="02415-4425">如果在编译时不知道对齐方式为8字节，则不会将其输出限制为32位 word 的代码生成器必须使用 `unaligned`。</span><span class="sxs-lookup"><span data-stu-id="02415-4425">Code generators that do not restrict their output to a 32-bit word size must use `unaligned` if the alignment is not known at compile time to be 8-byte.</span></span>  
  
 <span data-ttu-id="02415-4426">"对齐" 的值必须是1、2或4，这意味着生成的代码应分别假定地址是字节、双字节或4字节对齐。</span><span class="sxs-lookup"><span data-stu-id="02415-4426">The value of alignment must be 1, 2, or 4 and means that the generated code should assume that the address is byte, double-byte, or quad-byte aligned, respectively.</span></span> <span data-ttu-id="02415-4427">请注意，临时指针（类型 `*`）始终对齐。</span><span class="sxs-lookup"><span data-stu-id="02415-4427">Note that transient pointers (type `*`) are always aligned.</span></span>  
  
 <span data-ttu-id="02415-4428">尽管 `cpblk` 指令的对齐在逻辑上需要两个数字（一个用于源，另一个用于目标），但如果只指定了较小的数字，则对性能没有明显影响。</span><span class="sxs-lookup"><span data-stu-id="02415-4428">While the alignment for a `cpblk` instruction would logically require two numbers (one for the source and one for the destination), there is no noticeable impact on performance if only the lower number is specified.</span></span>  
  
 <span data-ttu-id="02415-4429">可以按任意顺序组合 `unaligned` 和 `volatile` 前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-4429">The `unaligned` and `volatile` prefixes can be combined in either order.</span></span> <span data-ttu-id="02415-4430">它们必须紧跟在 `ldind`、`stind`、`ldfld`、`stfld`、`ldobj`、`stobj`、`initblk`或 `cpblk` 指令之前。</span><span class="sxs-lookup"><span data-stu-id="02415-4430">They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="02415-4431">对于 <xref:System.Reflection.Emit.OpCodes.Ldsfld> 和 <xref:System.Reflection.Emit.OpCodes.Stsfld> 说明，只允许使用 <xref:System.Reflection.Emit.OpCodes.Volatile> 前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-4431">Only the <xref:System.Reflection.Emit.OpCodes.Volatile> prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.</span></span>  
  
 <span data-ttu-id="02415-4432">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `unaligned` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4432">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `unaligned` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4433">ILGenerator （操作码、标签）</span><span class="sxs-lookup"><span data-stu-id="02415-4433">ILGenerator.Emit(OpCode, Label)</span></span>  
  
-   <span data-ttu-id="02415-4434">ILGenerator （Opcode，Byte）</span><span class="sxs-lookup"><span data-stu-id="02415-4434">ILGenerator.Emit(Opcode, Byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4435">将值类型的已装箱的表示形式转换为其未装箱的形式。</span><span class="sxs-lookup"><span data-stu-id="02415-4435">Converts the boxed representation of a value type to its unboxed form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4436">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4436">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4437">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4437">Format</span></span>|<span data-ttu-id="02415-4438">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4438">Assembly Format</span></span>|<span data-ttu-id="02415-4439">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4439">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4440">79 < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-4440">79 < `T` ></span></span>|<span data-ttu-id="02415-4441">取消装箱 `valType`</span><span class="sxs-lookup"><span data-stu-id="02415-4441">unbox `valType`</span></span>|<span data-ttu-id="02415-4442">从 `obj`（其装箱表示形式）中提取值类型数据。</span><span class="sxs-lookup"><span data-stu-id="02415-4442">Extracts the value type data from `obj`, its boxed representation.</span></span>|  
  
 <span data-ttu-id="02415-4443">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4443">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4444">对象引用被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4444">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-4445">从堆栈中弹出对象引用，并取消装箱到值类型指针。</span><span class="sxs-lookup"><span data-stu-id="02415-4445">The object reference is popped from the stack and unboxed to a value type pointer.</span></span>  
  
3.  <span data-ttu-id="02415-4446">值类型指针被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4446">The value type pointer is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-4447">值类型在公共语言基础结构（CLI）中具有两种不同的表示形式：</span><span class="sxs-lookup"><span data-stu-id="02415-4447">A value type has two separate representations within the Common Language Infrastructure (CLI):</span></span>  
  
-   <span data-ttu-id="02415-4448">当值类型嵌入到另一个对象中时使用的 "原始" 窗体。</span><span class="sxs-lookup"><span data-stu-id="02415-4448">A 'raw' form used when a value type is embedded within another object.</span></span>  
  
-   <span data-ttu-id="02415-4449">"装箱" 窗体，其中值类型中的数据被包装（装箱）到对象中，因此它可以作为独立实体存在。</span><span class="sxs-lookup"><span data-stu-id="02415-4449">A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</span></span>  
  
 <span data-ttu-id="02415-4450">`unbox` 指令将对象引用（类型 `O`）、值类型的装箱表示形式转换为值类型指针（托管指针、类型 `&`）、其未装箱形式。</span><span class="sxs-lookup"><span data-stu-id="02415-4450">The `unbox` instruction converts the object reference (type `O`), the boxed representation of a value type, to a value type pointer (a managed pointer, type `&`), its unboxed form.</span></span> <span data-ttu-id="02415-4451">提供的值类型（`valType`）是一个元数据标记，用于指示装箱对象中包含的值类型类型。</span><span class="sxs-lookup"><span data-stu-id="02415-4451">The supplied value type (`valType`) is a metadata token indicating the type of value type contained within the boxed object.</span></span>  
  
 <span data-ttu-id="02415-4452">与 <xref:System.Reflection.Emit.OpCodes.Box>（这是复制值类型以在对象中使用所必需的），不需要 `unbox` 从对象复制值类型。</span><span class="sxs-lookup"><span data-stu-id="02415-4452">Unlike <xref:System.Reflection.Emit.OpCodes.Box>, which is required to make a copy of a value type for use in the object, `unbox` is not required to copy the value type from the object.</span></span> <span data-ttu-id="02415-4453">通常，它只是计算装箱对象内已存在的值类型的地址。</span><span class="sxs-lookup"><span data-stu-id="02415-4453">Typically it simply computes the address of the value type that is already present inside of the boxed object.</span></span>  
  
 <span data-ttu-id="02415-4454">如果对象未装箱为 `valType`，则会引发 <xref:System.InvalidCastException>。</span><span class="sxs-lookup"><span data-stu-id="02415-4454"><xref:System.InvalidCastException> is thrown if the object is not boxed as `valType`.</span></span>  
  
 <span data-ttu-id="02415-4455">如果对象引用为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-4455"><xref:System.NullReferenceException> is thrown if the object reference is a null reference.</span></span>  
  
 <span data-ttu-id="02415-4456">如果找不到值类型 `valType`，则会引发 <xref:System.TypeLoadException>。</span><span class="sxs-lookup"><span data-stu-id="02415-4456"><xref:System.TypeLoadException> is thrown if the value type `valType` cannot be found.</span></span> <span data-ttu-id="02415-4457">当 Microsoft 中间语言（MSIL）指令转换为本机代码而不是运行时，通常会检测到此情况。</span><span class="sxs-lookup"><span data-stu-id="02415-4457">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="02415-4458">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `unbox` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4458">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4459">ILGenerator （OpCode，Type）</span><span class="sxs-lookup"><span data-stu-id="02415-4459">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4460">将指令中指定类型的已装箱的表示形式转换成未装箱形式。</span><span class="sxs-lookup"><span data-stu-id="02415-4460">Converts the boxed representation of a type specified in the instruction to its unboxed form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4461">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4461">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4462">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4462">Format</span></span>|<span data-ttu-id="02415-4463">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4463">Assembly Format</span></span>|<span data-ttu-id="02415-4464">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4464">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4465">A5 < `T` ></span><span class="sxs-lookup"><span data-stu-id="02415-4465">A5 < `T` ></span></span>|<span data-ttu-id="02415-4466">取消装箱。任意 `typeTok`</span><span class="sxs-lookup"><span data-stu-id="02415-4466">unbox.any `typeTok`</span></span>|<span data-ttu-id="02415-4467">从 `obj`（其装箱表示形式）中提取数据。</span><span class="sxs-lookup"><span data-stu-id="02415-4467">Extract the data from `obj`, its boxed representation.</span></span>|  
  
 <span data-ttu-id="02415-4468">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4468">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4469">对象引用 `obj` 被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4469">An object reference `obj` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-4470">从堆栈中弹出对象引用，并取消装箱到指令中指定的类型。</span><span class="sxs-lookup"><span data-stu-id="02415-4470">The object reference is popped from the stack and unboxed to the type specified in the instruction.</span></span>  
  
3.  <span data-ttu-id="02415-4471">生成的对象引用或值类型被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4471">The resulting object reference or value type is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-4472">当应用于值类型的装箱形式时，`unbox.any` 指令提取 `obj` 内包含的值（类型 `O`），因此等效于 `unbox` 后跟 `ldobj`。</span><span class="sxs-lookup"><span data-stu-id="02415-4472">When applied to the boxed form of a value type, the `unbox.any` instruction extracts the value contained within `obj` (of type `O`), and is therefore equivalent to `unbox` followed by `ldobj`.</span></span>  
  
 <span data-ttu-id="02415-4473">当应用于引用类型时，`unbox.any` 指令与 `castclass` `typeTok`具有相同的效果。</span><span class="sxs-lookup"><span data-stu-id="02415-4473">When applied to a reference type, the `unbox.any` instruction has the same effect as `castclass` `typeTok`.</span></span>  
  
 <span data-ttu-id="02415-4474">如果操作数 `typeTok` 是泛型类型参数，则运行时行为取决于为该泛型类型参数指定的类型。</span><span class="sxs-lookup"><span data-stu-id="02415-4474">If the operand `typeTok` is a generic type parameter, then the runtime behavior is determined by the type that is specified for that generic type parameter.</span></span>  
  
 <span data-ttu-id="02415-4475">如果 `obj` 不是装箱类型，则会引发 <xref:System.InvalidCastException>。</span><span class="sxs-lookup"><span data-stu-id="02415-4475"><xref:System.InvalidCastException> is thrown if `obj` is not a boxed type.</span></span>  
  
 <span data-ttu-id="02415-4476">如果 `obj` 为空引用，则会引发 <xref:System.NullReferenceException>。</span><span class="sxs-lookup"><span data-stu-id="02415-4476"><xref:System.NullReferenceException> is thrown if `obj` is a null reference.</span></span>  
  
 <span data-ttu-id="02415-4477">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `unbox.any` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4477">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox.any` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4478">ILGenerator （OpCode，Type）</span><span class="sxs-lookup"><span data-stu-id="02415-4478">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4479">指定当前位于计算堆栈顶部的地址可以是易失的，并且读取该位置的结果不能被缓存，或者对该地址的多个存储区不能被取消。</span><span class="sxs-lookup"><span data-stu-id="02415-4479">Specifies that an address currently atop the evaluation stack might be volatile, and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4480">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4480">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4481">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4481">Format</span></span>|<span data-ttu-id="02415-4482">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4482">Assembly Format</span></span>|<span data-ttu-id="02415-4483">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4483">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4484">FE 13</span><span class="sxs-lookup"><span data-stu-id="02415-4484">FE 13</span></span>|<span data-ttu-id="02415-4485">失效.</span><span class="sxs-lookup"><span data-stu-id="02415-4485">volatile.</span></span>|<span data-ttu-id="02415-4486">指示后续指针引用是可变的。</span><span class="sxs-lookup"><span data-stu-id="02415-4486">Indicates that the subsequent pointer reference is volatile.</span></span>|  
  
 <span data-ttu-id="02415-4487">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4487">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4488">地址被推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4488">An address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-4489">`volatile`</span><span class="sxs-lookup"><span data-stu-id="02415-4489">`volatile`.</span></span> <span data-ttu-id="02415-4490">指定该地址是一个可变地址（即，可以从外部引用到当前执行线程），并且无法缓存读取该位置的结果，或者无法禁止显示此位置的多个存储。</span><span class="sxs-lookup"><span data-stu-id="02415-4490">specifies that the address is a volatile address (that is, it can be referenced externally to the current thread of execution) and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</span></span> <span data-ttu-id="02415-4491">将访问标记为 `volatile` 仅影响单一访问权限;必须单独标记对同一位置的其他访问。</span><span class="sxs-lookup"><span data-stu-id="02415-4491">Marking an access as `volatile` affects only that single access; other accesses to the same location must be marked separately.</span></span> <span data-ttu-id="02415-4492">不需要以原子方式执行对可变位置的访问。</span><span class="sxs-lookup"><span data-stu-id="02415-4492">Access to volatile locations need not be performed atomically.</span></span>  
  
 <span data-ttu-id="02415-4493">可以按任意顺序组合 <xref:System.Reflection.Emit.OpCodes.Unaligned> 和 `volatile` 前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-4493">The <xref:System.Reflection.Emit.OpCodes.Unaligned> and `volatile` prefixes can be combined in either order.</span></span> <span data-ttu-id="02415-4494">它们必须紧跟在 `ldind`、`stind`、`ldfld`、`stfld`、`ldobj`、`stobj`、`initblk`或 `cpblk` 指令之前。</span><span class="sxs-lookup"><span data-stu-id="02415-4494">They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="02415-4495">对于 <xref:System.Reflection.Emit.OpCodes.Ldsfld> 和 <xref:System.Reflection.Emit.OpCodes.Stsfld> 说明，只允许使用 `volatile` 前缀。</span><span class="sxs-lookup"><span data-stu-id="02415-4495">Only the `volatile` prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.</span></span>  
  
 <span data-ttu-id="02415-4496">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `volatile` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4496">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `volatile` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4497">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-4497">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="02415-4498">计算位于计算堆栈顶部的两个值的按位异或，并且将结果推送到计算堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4498">Computes the bitwise XOR of the top two values on the evaluation stack, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02415-4499">下表列出了指令的十六进制和 Microsoft 中间语言（MSIL）程序集格式以及简短的参考摘要：</span><span class="sxs-lookup"><span data-stu-id="02415-4499">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="02415-4500">格式</span><span class="sxs-lookup"><span data-stu-id="02415-4500">Format</span></span>|<span data-ttu-id="02415-4501">程序集格式</span><span class="sxs-lookup"><span data-stu-id="02415-4501">Assembly Format</span></span>|<span data-ttu-id="02415-4502">说明</span><span class="sxs-lookup"><span data-stu-id="02415-4502">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="02415-4503">61</span><span class="sxs-lookup"><span data-stu-id="02415-4503">61</span></span>|<span data-ttu-id="02415-4504">xor</span><span class="sxs-lookup"><span data-stu-id="02415-4504">xor</span></span>|<span data-ttu-id="02415-4505">计算两个整数值的按位 XOR 并返回整数。</span><span class="sxs-lookup"><span data-stu-id="02415-4505">Computes the bitwise XOR of two integer values and returns an integer.</span></span>|  
  
 <span data-ttu-id="02415-4506">堆栈转换行为顺序如下：</span><span class="sxs-lookup"><span data-stu-id="02415-4506">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="02415-4507">将 `value1` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4507">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="02415-4508">将 `value2` 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4508">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="02415-4509">`value2` 和 `value1` 从堆栈中弹出，并计算按位 XOR。</span><span class="sxs-lookup"><span data-stu-id="02415-4509">`value2` and `value1` are popped from the stack and their bitwise XOR computed.</span></span>  
  
4.  <span data-ttu-id="02415-4510">将 `value2` 和 `value1` 的按位 XOR 推送到堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4510">The bitwise XOR of `value2` and `value1` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="02415-4511">`xor` 指令计算堆栈顶部两个值的按位 XOR，并将结果保留在堆栈上。</span><span class="sxs-lookup"><span data-stu-id="02415-4511">The `xor` instruction computes the bitwise XOR of the top two values on the stack and leaves the result on the stack.</span></span>  
  
 <span data-ttu-id="02415-4512">`Xor` 是特定于整数的操作。</span><span class="sxs-lookup"><span data-stu-id="02415-4512">`Xor` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="02415-4513">以下 <xref:System.Reflection.Emit.ILGenerator.Emit%2A> 方法重载可以使用 `xor` 操作码：</span><span class="sxs-lookup"><span data-stu-id="02415-4513">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `xor` opcode:</span></span>  
  
-   <span data-ttu-id="02415-4514">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="02415-4514">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
