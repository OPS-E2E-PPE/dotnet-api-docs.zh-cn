<Type Name="FileStream" FullName="System.IO.FileStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="66e0c9b3599a6238db4a1e0068c136bad0f6e2ae" /><Meta Name="ms.sourcegitcommit" Value="8b09499854b5b7b909802126edc1f1fca0054c10" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="02/01/2020" /><Meta Name="ms.locfileid" Value="76946354" /></Metadata><TypeSignature Language="C#" Value="public class FileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileStream" />
  <TypeSignature Language="VB.NET" Value="Public Class FileStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type FileStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="a47c0-101">为文件提供 <see cref="T:System.IO.Stream" />，既支持同步读写操作，也支持异步读写操作。</span><span class="sxs-lookup"><span data-stu-id="a47c0-101">Provides a <see cref="T:System.IO.Stream" /> for a file, supporting both synchronous and asynchronous read and write operations.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-102">使用 <xref:System.IO.FileStream> 类可对文件系统中的文件进行读取、写入、打开和关闭，还可以操作其他与文件相关的操作系统句柄，包括管道、标准输入和标准输出。</span><span class="sxs-lookup"><span data-stu-id="a47c0-102">Use the <xref:System.IO.FileStream> class to read from, write to, open, and close files on a file system, and to manipulate other file-related operating system handles, including pipes, standard input, and standard output.</span></span> <span data-ttu-id="a47c0-103">您可以使用 <xref:System.IO.FileStream.Read%2A>、<xref:System.IO.FileStream.Write%2A>、<xref:System.IO.Stream.CopyTo%2A>和 <xref:System.IO.FileStream.Flush%2A> 方法来执行同步操作，或使用 <xref:System.IO.FileStream.ReadAsync%2A>、<xref:System.IO.FileStream.WriteAsync%2A>、<xref:System.IO.Stream.CopyToAsync%2A>和 <xref:System.IO.FileStream.FlushAsync%2A> 方法执行异步操作。</span><span class="sxs-lookup"><span data-stu-id="a47c0-103">You can use the <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.Stream.CopyTo%2A>, and <xref:System.IO.FileStream.Flush%2A> methods to perform synchronous operations, or the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.FileStream.FlushAsync%2A> methods to perform asynchronous operations.</span></span> <span data-ttu-id="a47c0-104">使用异步方法来执行占用大量资源的文件操作，而不会阻止主线程。</span><span class="sxs-lookup"><span data-stu-id="a47c0-104">Use the asynchronous methods to perform resource-intensive file operations without blocking the main thread.</span></span> <span data-ttu-id="a47c0-105">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="a47c0-105">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="a47c0-106"><xref:System.IO.FileStream> 缓冲输入和输出以提高性能。</span><span class="sxs-lookup"><span data-stu-id="a47c0-106"><xref:System.IO.FileStream> buffers input and output for better performance.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a47c0-107">此类型实现 <xref:System.IDisposable> 接口。</span><span class="sxs-lookup"><span data-stu-id="a47c0-107">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="a47c0-108">在使用完类型后，您应直接或间接释放类型。</span><span class="sxs-lookup"><span data-stu-id="a47c0-108">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="a47c0-109">若要直接释放类型，请在 <xref:System.IDisposable.Dispose%2A>`try`/ 块中调用其 `catch` 方法。</span><span class="sxs-lookup"><span data-stu-id="a47c0-109">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="a47c0-110">若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。</span><span class="sxs-lookup"><span data-stu-id="a47c0-110">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="a47c0-111">有关详细信息，请参阅 <xref:System.IDisposable> 接口主题中的“使用实现 IDisposable 的对象”一节。</span><span class="sxs-lookup"><span data-stu-id="a47c0-111">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="a47c0-112"><xref:System.IO.FileStream.IsAsync%2A> 属性检测文件句柄是否已异步打开。</span><span class="sxs-lookup"><span data-stu-id="a47c0-112">The <xref:System.IO.FileStream.IsAsync%2A> property detects whether the file handle was opened asynchronously.</span></span> <span data-ttu-id="a47c0-113">使用具有 `isAsync`、`useAsync`或 `options` 参数的构造函数创建 <xref:System.IO.FileStream> 类的实例时，可以指定此值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-113">You specify this value when you create an instance of the <xref:System.IO.FileStream> class using a constructor that has an `isAsync`, `useAsync`, or `options` parameter.</span></span> <span data-ttu-id="a47c0-114">如果 `true`属性，则流将使用重叠的 i/o 以异步方式执行文件操作。</span><span class="sxs-lookup"><span data-stu-id="a47c0-114">When the property is `true`, the stream utilizes overlapped I/O to perform file operations asynchronously.</span></span> <span data-ttu-id="a47c0-115">不过，不必 `true` <xref:System.IO.FileStream.IsAsync%2A> 属性来调用 <xref:System.IO.FileStream.ReadAsync%2A>、<xref:System.IO.FileStream.WriteAsync%2A>或 <xref:System.IO.Stream.CopyToAsync%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="a47c0-115">However, the <xref:System.IO.FileStream.IsAsync%2A> property does not have to be `true` to call the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, or <xref:System.IO.Stream.CopyToAsync%2A> method.</span></span> <span data-ttu-id="a47c0-116">当 `false` <xref:System.IO.FileStream.IsAsync%2A> 属性并且调用异步读写操作时，UI 线程仍不会被阻止，但实际的 i/o 操作将以同步方式执行。</span><span class="sxs-lookup"><span data-stu-id="a47c0-116">When the <xref:System.IO.FileStream.IsAsync%2A> property is `false` and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.</span></span>  
  
 <span data-ttu-id="a47c0-117"><xref:System.IO.FileStream.Seek%2A> 方法支持对文件进行随机访问。</span><span class="sxs-lookup"><span data-stu-id="a47c0-117">The <xref:System.IO.FileStream.Seek%2A> method supports random access to files.</span></span> <span data-ttu-id="a47c0-118"><xref:System.IO.FileStream.Seek%2A> 允许将读/写位置移动到文件中的任何位置。</span><span class="sxs-lookup"><span data-stu-id="a47c0-118"><xref:System.IO.FileStream.Seek%2A> allows the read/write position to be moved to any position within the file.</span></span> <span data-ttu-id="a47c0-119">这是通过字节偏移量引用点参数实现的。</span><span class="sxs-lookup"><span data-stu-id="a47c0-119">This is done with byte offset reference point parameters.</span></span> <span data-ttu-id="a47c0-120">字节偏移量是相对于查找引用点的，它可以是基础文件的开头、当前位置或末尾，由 <xref:System.IO.SeekOrigin> 枚举的三个成员表示。</span><span class="sxs-lookup"><span data-stu-id="a47c0-120">The byte offset is relative to the seek reference point, which can be the beginning, the current position, or the end of the underlying file, as represented by the three members of the <xref:System.IO.SeekOrigin> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a47c0-121">磁盘文件始终支持随机访问。</span><span class="sxs-lookup"><span data-stu-id="a47c0-121">Disk files always support random access.</span></span> <span data-ttu-id="a47c0-122">构造时，<xref:System.IO.FileStream.CanSeek%2A> 属性值设置为 `true` 或 `false` 具体取决于基础文件类型。如果基础文件类型是 FILE_TYPE_DISK （如 winbase.h 中所定义），则 <xref:System.IO.FileStream.CanSeek%2A> 属性值 `true`。</span><span class="sxs-lookup"><span data-stu-id="a47c0-122">At the time of construction, the <xref:System.IO.FileStream.CanSeek%2A> property value is set to `true` or `false` depending on the underlying file type.If the underlying file type is FILE_TYPE_DISK, as defined in winbase.h, the <xref:System.IO.FileStream.CanSeek%2A> property value is `true`.</span></span> <span data-ttu-id="a47c0-123">否则，将 `false`<xref:System.IO.FileStream.CanSeek%2A> 属性值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-123">Otherwise, the <xref:System.IO.FileStream.CanSeek%2A> property value is `false`.</span></span>  
  
 <span data-ttu-id="a47c0-124">如果进程以锁定的部分文件终止或关闭具有未完成锁定的文件，则该行为是不确定的。</span><span class="sxs-lookup"><span data-stu-id="a47c0-124">If a process terminates with part of a file locked or closes a file that has outstanding locks, the behavior is undefined.</span></span>  
  
 <span data-ttu-id="a47c0-125">有关目录操作和其他文件操作，请参阅 <xref:System.IO.File>、<xref:System.IO.Directory>和 <xref:System.IO.Path> 类。</span><span class="sxs-lookup"><span data-stu-id="a47c0-125">For directory operations and other file operations, see the <xref:System.IO.File>, <xref:System.IO.Directory>, and <xref:System.IO.Path> classes.</span></span> <span data-ttu-id="a47c0-126"><xref:System.IO.File> 类是一个实用工具类，该类具有用于基于文件路径创建 <xref:System.IO.FileStream> 对象的静态方法。</span><span class="sxs-lookup"><span data-stu-id="a47c0-126">The <xref:System.IO.File> class is a utility class that has static methods primarily for the creation of <xref:System.IO.FileStream> objects based on file paths.</span></span> <span data-ttu-id="a47c0-127"><xref:System.IO.MemoryStream> 类从字节数组创建流，与 <xref:System.IO.FileStream> 类类似。</span><span class="sxs-lookup"><span data-stu-id="a47c0-127">The <xref:System.IO.MemoryStream> class creates a stream from a byte array and is similar to the <xref:System.IO.FileStream> class.</span></span>  
  
 <span data-ttu-id="a47c0-128">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-128">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
## <a name="detection-of-stream-position-changes"></a><span data-ttu-id="a47c0-129">检测流位置更改</span><span class="sxs-lookup"><span data-stu-id="a47c0-129">Detection of Stream Position Changes</span></span>  
 <span data-ttu-id="a47c0-130">当 <xref:System.IO.FileStream> 对象在其句柄上没有独占保留时，另一个线程可以同时访问文件句柄，并更改与文件句柄关联的操作系统文件指针的位置。</span><span class="sxs-lookup"><span data-stu-id="a47c0-130">When a <xref:System.IO.FileStream> object does not have an exclusive hold on its handle, another thread could access the file handle concurrently and change the position of the operating system's file pointer that is associated with the file handle.</span></span> <span data-ttu-id="a47c0-131">在这种情况下，<xref:System.IO.FileStream> 对象中缓存的位置和缓冲区中的缓存数据可能会泄露。</span><span class="sxs-lookup"><span data-stu-id="a47c0-131">In this case, the cached position in the <xref:System.IO.FileStream> object and the cached data in the buffer could be compromised.</span></span> <span data-ttu-id="a47c0-132"><xref:System.IO.FileStream> 对象定期对访问缓存的缓冲区的方法执行检查，以确保操作系统的句柄位置与 <xref:System.IO.FileStream> 对象使用的缓存位置相同。</span><span class="sxs-lookup"><span data-stu-id="a47c0-132">The <xref:System.IO.FileStream> object routinely performs checks on methods that access the cached buffer to ensure that the operating system's handle position is the same as the cached position used by the <xref:System.IO.FileStream> object.</span></span>  
  
 <span data-ttu-id="a47c0-133">如果在对 <xref:System.IO.FileStream.Read%2A> 方法的调用中检测到句柄位置发生意外更改，则 .NET Framework 会丢弃缓冲区的内容，并再次从文件读取流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-133">If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Read%2A> method, the .NET Framework discards the contents of the buffer and reads the stream from the file again.</span></span> <span data-ttu-id="a47c0-134">这可能会影响性能，具体取决于文件的大小和可能影响文件流位置的任何其他进程。</span><span class="sxs-lookup"><span data-stu-id="a47c0-134">This can affect performance, depending on the size of the file and any other processes that could affect the position of the file stream.</span></span>  
  
 <span data-ttu-id="a47c0-135">如果在对 <xref:System.IO.FileStream.Write%2A> 方法的调用中检测到句柄位置发生意外更改，则会丢弃缓冲区的内容并引发 <xref:System.IO.IOException> 异常。</span><span class="sxs-lookup"><span data-stu-id="a47c0-135">If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Write%2A> method, the contents of the buffer are discarded and an <xref:System.IO.IOException> exception is thrown.</span></span>  
  
 <span data-ttu-id="a47c0-136">当访问 <xref:System.IO.FileStream.SafeFileHandle%2A> 属性以公开句柄或将 <xref:System.IO.FileStream> 对象提供在其构造函数中的 <xref:System.IO.FileStream.SafeFileHandle%2A> 属性时，<xref:System.IO.FileStream> 对象将不会在其句柄上独占保留。</span><span class="sxs-lookup"><span data-stu-id="a47c0-136">A <xref:System.IO.FileStream> object will not have an exclusive hold on its handle when either the <xref:System.IO.FileStream.SafeFileHandle%2A> property is accessed to expose the handle or the <xref:System.IO.FileStream> object is given the <xref:System.IO.FileStream.SafeFileHandle%2A> property in its constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a47c0-137">下面的示例演示了某些 <xref:System.IO.FileStream> 构造函数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-137">The following example demonstrates some of the <xref:System.IO.FileStream> constructors.</span></span>  
  
 [!code-cpp[fstream class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream Class/CPP/fstream class.cpp#1)]
 [!code-csharp[fstream class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream Class/CS/fstream class.cs#1)]
 [!code-vb[fstream class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream Class/VB/fstream class.vb#1)]  
  
 <span data-ttu-id="a47c0-138">下面的示例演示如何以异步方式写入文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-138">The following example shows how to write to a file asynchronously.</span></span> <span data-ttu-id="a47c0-139">此代码在具有名为 U s 的 TextBlock 的 WPF 应用中运行，并将按钮挂钩到名为 Button_Click 的 Click 事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="a47c0-139">This code runs in a WPF app that has a TextBlock named UserInput and a button hooked up to a Click event handler that is named Button_Click.</span></span> <span data-ttu-id="a47c0-140">文件路径需要更改为计算机上存在的文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-140">The file path needs to be changed to a file that exists on the computer.</span></span>  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.FileAccess" />
    <altmember cref="T:System.IO.FileMode" />
    <altmember cref="T:System.IO.FileShare" />
    <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-141">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-141">File and Stream I/O</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-142">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-142">How to: Read Text from a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-143">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-143">How to: Write Text to a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md"><span data-ttu-id="a47c0-144">如何：对新建的数据文件进行读取和写入</span><span class="sxs-lookup"><span data-stu-id="a47c0-144">How to: Read and Write to a Newly Created Data File</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a47c0-145">初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a47c0-145">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="a47c0-146">当前 <see langword="FileStream" /> 对象将封装的文件的文件句柄。</span><span class="sxs-lookup"><span data-stu-id="a47c0-146">A file handle for the file that the current <see langword="FileStream" /> object will encapsulate.</span></span></param>
        <param name="access"><span data-ttu-id="a47c0-147">枚举值的按位组合，它用于设置 <see cref="P:System.IO.FileStream.CanRead" /> 对象的 <see cref="P:System.IO.FileStream.CanWrite" /> 和 <see langword="FileStream" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="a47c0-147">A bitwise combination of the enumeration values that sets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span></span></param>
        <summary><span data-ttu-id="a47c0-148">使用指定的读/写权限为指定的文件句柄初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a47c0-148">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-149">调用 <xref:System.IO.Stream.Close%2A> 时，还将关闭句柄，并减少文件的句柄计数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-149">When <xref:System.IO.Stream.Close%2A> is called, the handle is also closed and the file's handle count is decremented.</span></span>  
  
 <span data-ttu-id="a47c0-150">`FileStream` 假设它对句柄具有独占控制。</span><span class="sxs-lookup"><span data-stu-id="a47c0-150">`FileStream` assumes that it has exclusive control over the handle.</span></span> <span data-ttu-id="a47c0-151">读取、写入或查找 `FileStream` 同时包含句柄可能会导致数据损坏。</span><span class="sxs-lookup"><span data-stu-id="a47c0-151">Reading, writing, or seeking while a `FileStream` is also holding a handle could result in data corruption.</span></span> <span data-ttu-id="a47c0-152">为实现数据安全，请在使用句柄之前调用 <xref:System.IO.FileStream.Flush%2A>，并在使用完句柄之后避免调用除 `Close` 以外的任何方法。</span><span class="sxs-lookup"><span data-stu-id="a47c0-152">For data safety, call <xref:System.IO.FileStream.Flush%2A> before using the handle, and avoid calling any methods other than `Close` after you are done using the handle.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a47c0-153">使用特定的区域性设置编译一组字符并使用不同的区域性设置检索这些相同的字符时，这些字符可能不是可解释，并且可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="a47c0-153">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="a47c0-154">`FileShare.Read` 是不带 `FileShare` 参数 <xref:System.IO.FileStream> 构造函数的默认值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-154">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
 <span data-ttu-id="a47c0-155">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-155">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a47c0-156"><paramref name="access" /> 不是 <see cref="T:System.IO.FileAccess" /> 的字段。</span><span class="sxs-lookup"><span data-stu-id="a47c0-156"><paramref name="access" /> is not a field of <see cref="T:System.IO.FileAccess" />.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="a47c0-157">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-157">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-158">出现 I/O 错误，例如磁盘错误。</span><span class="sxs-lookup"><span data-stu-id="a47c0-158">An I/O error, such as a disk error, occurred.</span></span>  
  
 <span data-ttu-id="a47c0-159">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-159">-or-</span></span>  
  
 <span data-ttu-id="a47c0-160">已关闭流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-160">The stream has been closed.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a47c0-161">对于指定的文件句柄，操作系统不允许所请求的 <paramref name="access" />。例如当 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，并将文件句柄设置为只读访问时会出现此情况。</span><span class="sxs-lookup"><span data-stu-id="a47c0-161">The <paramref name="access" /> requested is not permitted by the operating system for the specified file handle, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file handle is set for read-only access.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="a47c0-162">用于读取、写入和追加到文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-162">for reading, writing, and appending to files.</span></span> <span data-ttu-id="a47c0-163">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-163">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-164">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-164">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-165">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-165">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-166">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-166">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="a47c0-167">当前 <see langword="FileStream" /> 对象将封装的文件的文件句柄。</span><span class="sxs-lookup"><span data-stu-id="a47c0-167">A file handle for the file that the current <see langword="FileStream" /> object will encapsulate.</span></span></param>
        <param name="access"><span data-ttu-id="a47c0-168">枚举值的按位组合，它用于设置 <see cref="P:System.IO.FileStream.CanRead" /> 对象的 <see cref="P:System.IO.FileStream.CanWrite" /> 和 <see langword="FileStream" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="a47c0-168">A bitwise combination of the enumeration values that sets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span></span></param>
        <summary><span data-ttu-id="a47c0-169">使用指定的读/写权限为指定的文件句柄初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a47c0-169">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-170">调用 <xref:System.IO.Stream.Close%2A> 时，还将关闭句柄，并减少文件的句柄计数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-170">When <xref:System.IO.Stream.Close%2A> is called, the handle is also closed and the file's handle count is decremented.</span></span>  
  
 <span data-ttu-id="a47c0-171">`FileStream` 假设它对句柄具有独占控制。</span><span class="sxs-lookup"><span data-stu-id="a47c0-171">`FileStream` assumes that it has exclusive control over the handle.</span></span> <span data-ttu-id="a47c0-172">读取、写入或查找 `FileStream` 同时包含句柄可能会导致数据损坏。</span><span class="sxs-lookup"><span data-stu-id="a47c0-172">Reading, writing, or seeking while a `FileStream` is also holding a handle could result in data corruption.</span></span> <span data-ttu-id="a47c0-173">为实现数据安全，请在使用句柄之前调用 <xref:System.IO.FileStream.Flush%2A>，并在使用完句柄之后避免调用除 `Close` 以外的任何方法。</span><span class="sxs-lookup"><span data-stu-id="a47c0-173">For data safety, call <xref:System.IO.FileStream.Flush%2A> before using the handle, and avoid calling any methods other than `Close` after you are done using the handle.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a47c0-174">使用特定的区域性设置编译一组字符并使用不同的区域性设置检索这些相同的字符时，这些字符可能不是可解释，并且可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="a47c0-174">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="a47c0-175">`FileShare.Read` 是不带 `FileShare` 参数 <xref:System.IO.FileStream> 构造函数的默认值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-175">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
 <span data-ttu-id="a47c0-176">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-176">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a47c0-177"><paramref name="access" /> 不是 <see cref="T:System.IO.FileAccess" /> 的字段。</span><span class="sxs-lookup"><span data-stu-id="a47c0-177"><paramref name="access" /> is not a field of <see cref="T:System.IO.FileAccess" />.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="a47c0-178">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-178">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-179">出现 I/O 错误，例如磁盘错误。</span><span class="sxs-lookup"><span data-stu-id="a47c0-179">An I/O error, such as a disk error, occurred.</span></span>  
  
 <span data-ttu-id="a47c0-180">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-180">-or-</span></span>  
  
 <span data-ttu-id="a47c0-181">已关闭流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-181">The stream has been closed.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a47c0-182">对于指定的文件句柄，操作系统不允许所请求的 <paramref name="access" />。例如当 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，并将文件句柄设置为只读访问时会出现此情况。</span><span class="sxs-lookup"><span data-stu-id="a47c0-182">The <paramref name="access" /> requested is not permitted by the operating system for the specified file handle, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file handle is set for read-only access.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="a47c0-183">用于读取、写入和追加到文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-183">for reading, writing, and appending to files.</span></span> <span data-ttu-id="a47c0-184">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-184">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-185">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-185">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-186">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-186">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-187">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-187">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="a47c0-188">当前 <see langword="FileStream" /> 对象将封装的文件的相对路径或绝对路径。</span><span class="sxs-lookup"><span data-stu-id="a47c0-188">A relative or absolute path for the file that the current <see langword="FileStream" /> object will encapsulate.</span></span></param>
        <param name="mode"><span data-ttu-id="a47c0-189">用于确定文件的打开或创建方式的枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="a47c0-189">One of the enumeration values that determines how to open or create the file.</span></span></param>
        <summary><span data-ttu-id="a47c0-190">使用指定的路径和创建模式初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a47c0-190">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path and creation mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-191">.NET Framework 不支持通过作为设备名称的路径（如 "\\\\.\PHYSICALDRIVE0"）直接访问物理磁盘。</span><span class="sxs-lookup"><span data-stu-id="a47c0-191">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="a47c0-192">`path` 参数可以是文件名，包括通用命名约定（UNC）共享上的文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-192">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
 <span data-ttu-id="a47c0-193">为构造函数提供对文件的读/写访问权限，并且该构造函数已打开共享读取权限（也就是说，此或其他进程打开文件以进行写入的请求将失败，直至 `FileStream` 对象关闭，但读取尝试将成功）。</span><span class="sxs-lookup"><span data-stu-id="a47c0-193">The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed).</span></span>  
  
 <span data-ttu-id="a47c0-194">不能使用此构造函数打开只读文件;相反，必须使用接受值设置为 `FileAccess.Read`的 `FileAccess` 参数的构造函数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-194">You cannot use this constructor to open read-only files; instead, you must use a constructor that accepts a `FileAccess` parameter with the value set to `FileAccess.Read`.</span></span>  
  
 <span data-ttu-id="a47c0-195">缓冲区大小设置为默认大小（4096字节）（4 KB）。</span><span class="sxs-lookup"><span data-stu-id="a47c0-195">The buffer size is set to the default size of 4096 bytes (4 KB).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a47c0-196">`path` 不需要是存储在磁盘上的文件;它可以是支持通过流进行访问的系统的任何部分。</span><span class="sxs-lookup"><span data-stu-id="a47c0-196">`path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</span></span> <span data-ttu-id="a47c0-197">例如，根据系统，此类可以访问物理设备。</span><span class="sxs-lookup"><span data-stu-id="a47c0-197">For example, depending on the system, this class can access a physical device.</span></span>  
  
 <span data-ttu-id="a47c0-198">对于封装文件的所有 <xref:System.IO.FileStream> 对象 `true` <xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-198"><xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files.</span></span> <span data-ttu-id="a47c0-199">如果 `path` 指示不支持查找的设备，则将 `false`生成的 <xref:System.IO.FileStream> 上的 <xref:System.IO.FileStream.CanSeek%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="a47c0-199">If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`.</span></span> <span data-ttu-id="a47c0-200">有关附加信息，请参见 <xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-200">For additional information, see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
 <span data-ttu-id="a47c0-201">`FileShare.Read` 是不带 `FileShare` 参数 <xref:System.IO.FileStream> 构造函数的默认值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-201">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
 <span data-ttu-id="a47c0-202">对于没有 <xref:System.IO.FileAccess> 参数的构造函数，如果 `mode` 参数设置为 <xref:System.IO.FileMode.Append>，则 <xref:System.IO.FileAccess.Write> 是默认访问。</span><span class="sxs-lookup"><span data-stu-id="a47c0-202">For constructors without a <xref:System.IO.FileAccess> parameter, if the `mode` parameter is set to <xref:System.IO.FileMode.Append>, <xref:System.IO.FileAccess.Write> is the default access.</span></span> <span data-ttu-id="a47c0-203">否则，访问将设置为 <xref:System.IO.FileAccess.ReadWrite>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-203">Otherwise, the access is set to <xref:System.IO.FileAccess.ReadWrite>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a47c0-204">使用特定的区域性设置编译一组字符并使用不同的区域性设置检索这些相同的字符时，这些字符可能不是可解释，并且可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="a47c0-204">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="a47c0-205">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-205">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a47c0-206">下面的代码示例演示了如何按字节将数据写入文件，然后验证是否已正确写入数据。</span><span class="sxs-lookup"><span data-stu-id="a47c0-206">The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.</span></span>  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a47c0-207"><paramref name="path" /> 是一个空字符串 ("")，仅包含空格，或者包含一个或多个无效字符。</span><span class="sxs-lookup"><span data-stu-id="a47c0-207"><paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters.</span></span>  
  
<span data-ttu-id="a47c0-208">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-208">-or-</span></span> 
 <span data-ttu-id="a47c0-209"><paramref name="path" /> 指非文件设备，如 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</span><span class="sxs-lookup"><span data-stu-id="a47c0-209"><paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a47c0-210"><paramref name="path" /> 指非文件设备，如非 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</span><span class="sxs-lookup"><span data-stu-id="a47c0-210"><paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a47c0-211"><paramref name="path" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-211"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="a47c0-212">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-212">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a47c0-213">找不到该文件。例如，当 <paramref name="mode" /> 是 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，并且 <paramref name="path" /> 指定的文件不存在时会出现这种情况。</span><span class="sxs-lookup"><span data-stu-id="a47c0-213">The file cannot be found, such as when <paramref name="mode" /> is <see langword="FileMode.Truncate" /> or <see langword="FileMode.Open" />, and the file specified by <paramref name="path" /> does not exist.</span></span> <span data-ttu-id="a47c0-214">该文件必须以这些模式存在。</span><span class="sxs-lookup"><span data-stu-id="a47c0-214">The file must already exist in these modes.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a47c0-215"><paramref name="path" /> 指定只读文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-215"><paramref name="path" /> specifies a file that is read-only.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-216">I/O 错误，例如在 <see langword="FileMode.CreateNew" /> 指定的文件已存在时指定 <paramref name="path" />，会发生此错误。</span><span class="sxs-lookup"><span data-stu-id="a47c0-216">An I/O error, such as specifying <see langword="FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists, occurred.</span></span>  
  
<span data-ttu-id="a47c0-217">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-217">-or-</span></span> 
<span data-ttu-id="a47c0-218">已关闭流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-218">The stream has been closed.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="a47c0-219">指定的路径无效，例如位于未映射的驱动器上。</span><span class="sxs-lookup"><span data-stu-id="a47c0-219">The specified path is invalid, such as being on an unmapped drive.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="a47c0-220">指定的路径和/或文件名超过了系统定义的最大长度。</span><span class="sxs-lookup"><span data-stu-id="a47c0-220">The specified path, file name, or both exceed the system-defined maximum length.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a47c0-221"><paramref name="mode" /> 包含无效值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-221"><paramref name="mode" /> contains an invalid value.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="a47c0-222">用于读取、写入和追加到文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-222">for reading, writing, and appending to files.</span></span> <span data-ttu-id="a47c0-223">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-223">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span></span></permission>
        <altmember cref="F:System.IO.Path.InvalidPathChars" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-224">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-224">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-225">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-225">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-226">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-226">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="a47c0-227">当前 <see langword="FileStream" /> 对象将封装的文件的文件句柄。</span><span class="sxs-lookup"><span data-stu-id="a47c0-227">A file handle for the file that the current <see langword="FileStream" /> object will encapsulate.</span></span></param>
        <param name="access"><span data-ttu-id="a47c0-228">一个 <see cref="T:System.IO.FileAccess" /> 常数，它设置 <see cref="P:System.IO.FileStream.CanRead" /> 对象的 <see cref="P:System.IO.FileStream.CanWrite" /> 和 <see langword="FileStream" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="a47c0-228">A <see cref="T:System.IO.FileAccess" /> constant that sets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="a47c0-229">一个大于零的正 <see cref="T:System.Int32" /> 值，表示缓冲区大小。</span><span class="sxs-lookup"><span data-stu-id="a47c0-229">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span></span> <span data-ttu-id="a47c0-230">默认缓冲区大小为 4096。</span><span class="sxs-lookup"><span data-stu-id="a47c0-230">The default buffer size is 4096.</span></span></param>
        <summary><span data-ttu-id="a47c0-231">使用指定的读/写权限和缓冲区大小为指定的文件句柄初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a47c0-231">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission, and buffer size.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-232">`FileStream` 假设它对句柄具有独占控制。</span><span class="sxs-lookup"><span data-stu-id="a47c0-232">`FileStream` assumes that it has exclusive control over the handle.</span></span> <span data-ttu-id="a47c0-233">读取、写入或查找 `FileStream` 同时包含句柄可能会导致数据损坏。</span><span class="sxs-lookup"><span data-stu-id="a47c0-233">Reading, writing, or seeking while a `FileStream` is also holding a handle could result in data corruption.</span></span> <span data-ttu-id="a47c0-234">为实现数据安全，请在使用句柄之前调用 <xref:System.IO.FileStream.Flush%2A>，并在使用完句柄之后避免调用除 `Close` 以外的任何方法。</span><span class="sxs-lookup"><span data-stu-id="a47c0-234">For data safety, call <xref:System.IO.FileStream.Flush%2A> before using the handle, and avoid calling any methods other than `Close` after you are done using the handle.</span></span> <span data-ttu-id="a47c0-235">或者，在调用此 `FileStream` 构造函数之前，读取和写入句柄。</span><span class="sxs-lookup"><span data-stu-id="a47c0-235">Alternately, read and write to the handle before calling this `FileStream` constructor.</span></span>  
  
 <span data-ttu-id="a47c0-236">`FileShare.Read` 是不带 `FileShare` 参数 <xref:System.IO.FileStream> 构造函数的默认值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-236">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a47c0-237">使用特定的区域性设置编译一组字符并使用不同的区域性设置检索这些相同的字符时，这些字符可能不是可解释，并且可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="a47c0-237">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="a47c0-238">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-238">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a47c0-239"><paramref name="handle" /> 参数是无效的句柄。</span><span class="sxs-lookup"><span data-stu-id="a47c0-239">The <paramref name="handle" /> parameter is an invalid handle.</span></span>  
  
<span data-ttu-id="a47c0-240">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-240">-or-</span></span> 
<span data-ttu-id="a47c0-241"><paramref name="handle" /> 参数是同步句柄，但被异步使用。</span><span class="sxs-lookup"><span data-stu-id="a47c0-241">The <paramref name="handle" /> parameter is a synchronous handle and it was used asynchronously.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a47c0-242"><paramref name="bufferSize" /> 参数为负。</span><span class="sxs-lookup"><span data-stu-id="a47c0-242">The <paramref name="bufferSize" /> parameter is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-243">出现 I/O 错误，例如磁盘错误。</span><span class="sxs-lookup"><span data-stu-id="a47c0-243">An I/O error, such as a disk error, occurred.</span></span>  
  
 <span data-ttu-id="a47c0-244">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-244">-or-</span></span>  
  
 <span data-ttu-id="a47c0-245">已关闭流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-245">The stream has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="a47c0-246">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-246">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a47c0-247">对于指定的文件句柄，操作系统不允许所请求的 <paramref name="access" />。例如当 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，并将文件句柄设置为只读访问时会出现此情况。</span><span class="sxs-lookup"><span data-stu-id="a47c0-247">The <paramref name="access" /> requested is not permitted by the operating system for the specified file handle, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file handle is set for read-only access.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="a47c0-248">用于读取、写入和追加到文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-248">for reading, writing, and appending to files.</span></span> <span data-ttu-id="a47c0-249">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-249">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="a47c0-250">用于调用非托管代码的权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-250">for permission to call unmanaged code.</span></span> <span data-ttu-id="a47c0-251">关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="a47c0-251">Associated enumerations: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-252">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-252">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-253">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-253">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-254">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-254">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="ownsHandle" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="a47c0-255">当前 <see langword="FileStream" /> 对象将封装的文件的文件句柄。</span><span class="sxs-lookup"><span data-stu-id="a47c0-255">A file handle for the file that the current <see langword="FileStream" /> object will encapsulate.</span></span></param>
        <param name="access"><span data-ttu-id="a47c0-256">枚举值的按位组合，它用于设置 <see cref="P:System.IO.FileStream.CanRead" /> 对象的 <see cref="P:System.IO.FileStream.CanWrite" /> 和 <see langword="FileStream" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="a47c0-256">A bitwise combination of the enumeration values that sets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span></span></param>
        <param name="ownsHandle"><span data-ttu-id="a47c0-257">如果文件句柄将由此 <see langword="true" /> 实例所有，则为 <see langword="FileStream" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-257"><see langword="true" /> if the file handle will be owned by this <see langword="FileStream" /> instance; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="a47c0-258">使用指定的读/写权限和 <see cref="T:System.IO.FileStream" /> 实例所属权为指定的文件句柄初始化 <see langword="FileStream" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a47c0-258">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission and <see langword="FileStream" /> instance ownership.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-259">为 `FileStream` 对象提供了对文件的指定访问权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-259">The `FileStream` object is given the specified access to the file.</span></span> <span data-ttu-id="a47c0-260">句柄的所有权将为指定的。</span><span class="sxs-lookup"><span data-stu-id="a47c0-260">The ownership of the handle will be as specified.</span></span> <span data-ttu-id="a47c0-261">如果此进程拥有该句柄，则调用 <xref:System.IO.Stream.Close%2A> 方法还将关闭该句柄，并且文件的句柄计数将减少。</span><span class="sxs-lookup"><span data-stu-id="a47c0-261">If this process owns the handle, a call to the <xref:System.IO.Stream.Close%2A> method will also close the handle and the file's handle count is decremented.</span></span> <span data-ttu-id="a47c0-262">为 `FileStream` 对象指定了默认缓冲区大小4096字节。</span><span class="sxs-lookup"><span data-stu-id="a47c0-262">The `FileStream` object is given the default buffer size of 4096 bytes.</span></span>  
  
 <span data-ttu-id="a47c0-263">`FileStream` 假设它对句柄具有独占控制。</span><span class="sxs-lookup"><span data-stu-id="a47c0-263">`FileStream` assumes that it has exclusive control over the handle.</span></span> <span data-ttu-id="a47c0-264">读取、写入或查找 `FileStream` 同时包含句柄可能会导致数据损坏。</span><span class="sxs-lookup"><span data-stu-id="a47c0-264">Reading, writing, or seeking while a `FileStream` is also holding a handle could result in data corruption.</span></span> <span data-ttu-id="a47c0-265">为实现数据安全，请在使用句柄之前调用 <xref:System.IO.FileStream.Flush%2A>，并避免在使用完句柄之后 `Close` 调用其他方法。</span><span class="sxs-lookup"><span data-stu-id="a47c0-265">For data safety, call <xref:System.IO.FileStream.Flush%2A> before using the handle, and avoid calling methods other than `Close` after you are done using the handle.</span></span>  
  
 <span data-ttu-id="a47c0-266">`FileShare.Read` 是不带 `FileShare` 参数 <xref:System.IO.FileStream> 构造函数的默认值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-266">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a47c0-267">使用特定的区域性设置编译一组字符并使用不同的区域性设置检索这些相同的字符时，这些字符可能不是可解释，并且可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="a47c0-267">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="a47c0-268">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-268">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a47c0-269"><paramref name="access" /> 不是 <see cref="T:System.IO.FileAccess" /> 的字段。</span><span class="sxs-lookup"><span data-stu-id="a47c0-269"><paramref name="access" /> is not a field of <see cref="T:System.IO.FileAccess" />.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="a47c0-270">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-270">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-271">出现 I/O 错误，例如磁盘错误。</span><span class="sxs-lookup"><span data-stu-id="a47c0-271">An I/O error, such as a disk error, occurred.</span></span>  
  
 <span data-ttu-id="a47c0-272">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-272">-or-</span></span>  
  
 <span data-ttu-id="a47c0-273">已关闭流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-273">The stream has been closed.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a47c0-274">对于指定的文件句柄，操作系统不允许所请求的 <paramref name="access" />。例如当 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，并将文件句柄设置为只读访问时会出现此情况。</span><span class="sxs-lookup"><span data-stu-id="a47c0-274">The <paramref name="access" /> requested is not permitted by the operating system for the specified file handle, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file handle is set for read-only access.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="a47c0-275">用于读取、写入和追加到文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-275">for reading, writing, and appending to files.</span></span> <span data-ttu-id="a47c0-276">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-276">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-277">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-277">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-278">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-278">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-279">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-279">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="a47c0-280">当前 <see langword="FileStream" /> 对象将封装的文件的相对路径或绝对路径。</span><span class="sxs-lookup"><span data-stu-id="a47c0-280">A relative or absolute path for the file that the current <see langword="FileStream" /> object will encapsulate.</span></span></param>
        <param name="mode"><span data-ttu-id="a47c0-281">用于确定文件的打开或创建方式的枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="a47c0-281">One of the enumeration values that determines how to open or create the file.</span></span></param>
        <param name="access"><span data-ttu-id="a47c0-282">枚举值的按位组合，这些枚举值确定 <see langword="FileStream" /> 对象访问文件的方式。</span><span class="sxs-lookup"><span data-stu-id="a47c0-282">A bitwise combination of the enumeration values that determines how the file can be accessed by the <see langword="FileStream" /> object.</span></span> <span data-ttu-id="a47c0-283">该常数还可以确定由 <see cref="P:System.IO.FileStream.CanRead" /> 对象的 <see cref="P:System.IO.FileStream.CanWrite" /> 和 <see langword="FileStream" /> 属性返回的值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-283">This also determines the values returned by the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span></span> <span data-ttu-id="a47c0-284">如果 <see cref="P:System.IO.FileStream.CanSeek" /> 指定磁盘文件，则 <see langword="true" /> 为 <paramref name="path" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-284"><see cref="P:System.IO.FileStream.CanSeek" /> is <see langword="true" /> if <paramref name="path" /> specifies a disk file.</span></span></param>
        <summary><span data-ttu-id="a47c0-285">使用指定的路径、创建模式和读/写权限初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a47c0-285">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, and read/write permission.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-286">.NET Framework 不支持通过作为设备名称的路径（如 "\\\\.\PHYSICALDRIVE0"）直接访问物理磁盘。</span><span class="sxs-lookup"><span data-stu-id="a47c0-286">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="a47c0-287">`path` 参数可以是文件名，包括通用命名约定（UNC）共享上的文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-287">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
 <span data-ttu-id="a47c0-288">为构造函数提供对文件的读/写访问权限，并且该构造函数已打开共享读取权限（也就是说，此或其他进程打开文件以进行写入的请求将失败，直至 `FileStream` 对象关闭，但读取尝试将成功）。</span><span class="sxs-lookup"><span data-stu-id="a47c0-288">The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed).</span></span> <span data-ttu-id="a47c0-289">缓冲区大小设置为默认大小（4096字节）（4 KB）。</span><span class="sxs-lookup"><span data-stu-id="a47c0-289">The buffer size is set to the default size of 4096 bytes (4 KB).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a47c0-290">`path` 不需要是存储在磁盘上的文件;它可以是支持通过流进行访问的系统的任何部分。</span><span class="sxs-lookup"><span data-stu-id="a47c0-290">`path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</span></span> <span data-ttu-id="a47c0-291">例如，根据系统，此类可以访问物理设备。</span><span class="sxs-lookup"><span data-stu-id="a47c0-291">For example, depending on the system, this class can access a physical device.</span></span>  
  
 <span data-ttu-id="a47c0-292">对于封装文件的所有 <xref:System.IO.FileStream> 对象 `true` <xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-292"><xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files.</span></span> <span data-ttu-id="a47c0-293">如果 `path` 指示不支持查找的设备，则将 `false`生成的 <xref:System.IO.FileStream> 上的 <xref:System.IO.FileStream.CanSeek%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="a47c0-293">If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`.</span></span> <span data-ttu-id="a47c0-294">有关附加信息，请参见 <xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-294">For additional information, see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
 <span data-ttu-id="a47c0-295">`FileShare.Read` 是不带 `FileShare` 参数 <xref:System.IO.FileStream> 构造函数的默认值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-295">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a47c0-296">使用特定的区域性设置编译一组字符并使用不同的区域性设置检索这些相同的字符时，这些字符可能不是可解释，并且可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="a47c0-296">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="a47c0-297">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-297">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a47c0-298"><paramref name="path" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-298"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a47c0-299"><paramref name="path" /> 是一个空字符串 ("")，仅包含空格，或者包含一个或多个无效字符。</span><span class="sxs-lookup"><span data-stu-id="a47c0-299"><paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters.</span></span>  
  
<span data-ttu-id="a47c0-300">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-300">-or-</span></span> 
 <span data-ttu-id="a47c0-301"><paramref name="path" /> 指非文件设备，如 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</span><span class="sxs-lookup"><span data-stu-id="a47c0-301"><paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a47c0-302"><paramref name="path" /> 指非文件设备，如非 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</span><span class="sxs-lookup"><span data-stu-id="a47c0-302"><paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a47c0-303">找不到该文件。例如，当 <paramref name="mode" /> 是 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，并且 <paramref name="path" /> 指定的文件不存在时会出现这种情况。</span><span class="sxs-lookup"><span data-stu-id="a47c0-303">The file cannot be found, such as when <paramref name="mode" /> is <see langword="FileMode.Truncate" /> or <see langword="FileMode.Open" />, and the file specified by <paramref name="path" /> does not exist.</span></span> <span data-ttu-id="a47c0-304">该文件必须以这些模式存在。</span><span class="sxs-lookup"><span data-stu-id="a47c0-304">The file must already exist in these modes.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-305">I/O 错误，例如在 <see langword="FileMode.CreateNew" /> 指定的文件已存在时指定 <paramref name="path" />，会发生此错误。</span><span class="sxs-lookup"><span data-stu-id="a47c0-305">An I/O error, such as specifying <see langword="FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists, occurred.</span></span>  
  
<span data-ttu-id="a47c0-306">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-306">-or-</span></span> 
<span data-ttu-id="a47c0-307">已关闭流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-307">The stream has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="a47c0-308">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-308">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="a47c0-309">指定的路径无效，例如位于未映射的驱动器上。</span><span class="sxs-lookup"><span data-stu-id="a47c0-309">The specified path is invalid, such as being on an unmapped drive.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a47c0-310">对于指定的 <paramref name="access" />，操作系统不允许所请求的 <paramref name="path" />。例如当 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，并将文件或目录设置为只读访问时会出现此情况。</span><span class="sxs-lookup"><span data-stu-id="a47c0-310">The <paramref name="access" /> requested is not permitted by the operating system for the specified <paramref name="path" />, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file or directory is set for read-only access.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="a47c0-311">指定的路径和/或文件名超过了系统定义的最大长度。</span><span class="sxs-lookup"><span data-stu-id="a47c0-311">The specified path, file name, or both exceed the system-defined maximum length.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a47c0-312"><paramref name="mode" /> 包含无效值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-312"><paramref name="mode" /> contains an invalid value.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="a47c0-313">用于读取、写入和追加到文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-313">for reading, writing, and appending to files.</span></span> <span data-ttu-id="a47c0-314">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-314">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-315">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-315">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-316">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-316">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-317">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-317">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="isAsync" Type="System.Boolean" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="a47c0-318">此 <see langword="FileStream" /> 对象将封装的文件的文件句柄。</span><span class="sxs-lookup"><span data-stu-id="a47c0-318">A file handle for the file that this <see langword="FileStream" /> object will encapsulate.</span></span></param>
        <param name="access"><span data-ttu-id="a47c0-319">枚举值的按位组合，它用于设置 <see cref="P:System.IO.FileStream.CanRead" /> 对象的 <see cref="P:System.IO.FileStream.CanWrite" /> 和 <see langword="FileStream" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="a47c0-319">A bitwise combination of the enumeration values that sets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="a47c0-320">一个大于零的正 <see cref="T:System.Int32" /> 值，表示缓冲区大小。</span><span class="sxs-lookup"><span data-stu-id="a47c0-320">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span></span> <span data-ttu-id="a47c0-321">默认缓冲区大小为 4096。</span><span class="sxs-lookup"><span data-stu-id="a47c0-321">The default buffer size is 4096.</span></span></param>
        <param name="isAsync"><span data-ttu-id="a47c0-322">如果异步打开句柄（即以重叠的 I/O 模式），则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-322"><see langword="true" /> if the handle was opened asynchronously (that is, in overlapped I/O mode); otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="a47c0-323">使用指定的读/写权限、缓冲区大小和同步或异步状态为指定的文件句柄初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a47c0-323">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission, buffer size, and synchronous or asynchronous state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-324">将 `isAsync` 参数设置为 `true` 以异步打开文件句柄。</span><span class="sxs-lookup"><span data-stu-id="a47c0-324">You set the `isAsync` parameter to `true` to open the file handle asynchronously.</span></span> <span data-ttu-id="a47c0-325">当参数 `true`时，流将使用重叠的 i/o 以异步方式执行文件操作。</span><span class="sxs-lookup"><span data-stu-id="a47c0-325">When the parameter is `true`, the stream utilizes overlapped I/O to perform file operations asynchronously.</span></span> <span data-ttu-id="a47c0-326">但是，无需 `true` 参数即可调用 <xref:System.IO.FileStream.ReadAsync%2A>、<xref:System.IO.FileStream.WriteAsync%2A>或 <xref:System.IO.Stream.CopyToAsync%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="a47c0-326">However, the parameter does not have to be `true` to call the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, or <xref:System.IO.Stream.CopyToAsync%2A> method.</span></span> <span data-ttu-id="a47c0-327">当 `false` `isAsync` 参数并且调用异步读写操作时，UI 线程仍不会被阻止，但实际的 i/o 操作将以同步方式执行。</span><span class="sxs-lookup"><span data-stu-id="a47c0-327">When the `isAsync` parameter is `false` and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.</span></span>  
  
 <span data-ttu-id="a47c0-328">`FileStream` 假设它对句柄具有独占控制。</span><span class="sxs-lookup"><span data-stu-id="a47c0-328">`FileStream` assumes that it has exclusive control over the handle.</span></span> <span data-ttu-id="a47c0-329">读取、写入或查找 `FileStream` 同时包含句柄可能会导致数据损坏。</span><span class="sxs-lookup"><span data-stu-id="a47c0-329">Reading, writing, or seeking while a `FileStream` is also holding a handle could result in data corruption.</span></span> <span data-ttu-id="a47c0-330">为实现数据安全，请在使用句柄之前调用 <xref:System.IO.FileStream.Flush%2A>，并在使用完句柄之后避免调用除 `Close` 以外的任何方法。</span><span class="sxs-lookup"><span data-stu-id="a47c0-330">For data safety, call <xref:System.IO.FileStream.Flush%2A> before using the handle, and avoid calling any methods other than `Close` after you are done using the handle.</span></span> <span data-ttu-id="a47c0-331">或者，在调用此 `FileStream` 构造函数之前，读取和写入句柄。</span><span class="sxs-lookup"><span data-stu-id="a47c0-331">Alternately, read and write to the handle before calling this `FileStream` constructor.</span></span>  
  
 <span data-ttu-id="a47c0-332">`FileShare.Read` 是不带 `FileShare` 参数 <xref:System.IO.FileStream> 构造函数的默认值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-332">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a47c0-333">使用特定的区域性设置编译一组字符并使用不同的区域性设置检索这些相同的字符时，这些字符可能不是可解释，并且可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="a47c0-333">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="a47c0-334">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-334">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a47c0-335"><paramref name="handle" /> 参数是无效的句柄。</span><span class="sxs-lookup"><span data-stu-id="a47c0-335">The <paramref name="handle" /> parameter is an invalid handle.</span></span>  
  
<span data-ttu-id="a47c0-336">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-336">-or-</span></span> 
<span data-ttu-id="a47c0-337"><paramref name="handle" /> 参数是同步句柄，但被异步使用。</span><span class="sxs-lookup"><span data-stu-id="a47c0-337">The <paramref name="handle" /> parameter is a synchronous handle and it was used asynchronously.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a47c0-338"><paramref name="bufferSize" /> 参数为负。</span><span class="sxs-lookup"><span data-stu-id="a47c0-338">The <paramref name="bufferSize" /> parameter is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-339">出现 I/O 错误，例如磁盘错误。</span><span class="sxs-lookup"><span data-stu-id="a47c0-339">An I/O error, such as a disk error, occurred.</span></span>  
  
 <span data-ttu-id="a47c0-340">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-340">-or-</span></span>  
  
 <span data-ttu-id="a47c0-341">已关闭流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-341">The stream has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="a47c0-342">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-342">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a47c0-343">对于指定的文件句柄，操作系统不允许所请求的 <paramref name="access" />。例如当 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，并将文件句柄设置为只读访问时会出现此情况。</span><span class="sxs-lookup"><span data-stu-id="a47c0-343">The <paramref name="access" /> requested is not permitted by the operating system for the specified file handle, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file handle is set for read-only access.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="a47c0-344">用于读取、写入和追加到文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-344">for reading, writing, and appending to files.</span></span> <span data-ttu-id="a47c0-345">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-345">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="a47c0-346">用于调用非托管代码的权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-346">for permission to call unmanaged code.</span></span> <span data-ttu-id="a47c0-347">关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="a47c0-347">Associated enumerations: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-348">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-348">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-349">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-349">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-350">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-350">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="ownsHandle" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="a47c0-351">此 <see langword="FileStream" /> 对象将封装的文件的文件句柄。</span><span class="sxs-lookup"><span data-stu-id="a47c0-351">A file handle for the file that this <see langword="FileStream" /> object will encapsulate.</span></span></param>
        <param name="access"><span data-ttu-id="a47c0-352">枚举值的按位组合，它用于设置 <see cref="P:System.IO.FileStream.CanRead" /> 对象的 <see cref="P:System.IO.FileStream.CanWrite" /> 和 <see langword="FileStream" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="a47c0-352">A bitwise combination of the enumeration values that sets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span></span></param>
        <param name="ownsHandle"><span data-ttu-id="a47c0-353">如果文件句柄将由此 <see langword="true" /> 实例所有，则为 <see langword="FileStream" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-353"><see langword="true" /> if the file handle will be owned by this <see langword="FileStream" /> instance; otherwise, <see langword="false" />.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="a47c0-354">一个大于零的正 <see cref="T:System.Int32" /> 值，表示缓冲区大小。</span><span class="sxs-lookup"><span data-stu-id="a47c0-354">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span></span> <span data-ttu-id="a47c0-355">默认缓冲区大小为 4096。</span><span class="sxs-lookup"><span data-stu-id="a47c0-355">The default buffer size is 4096.</span></span></param>
        <summary><span data-ttu-id="a47c0-356">使用指定的读/写权限、<see cref="T:System.IO.FileStream" /> 实例所属权和缓冲区大小为指定的文件句柄初始化 <see langword="FileStream" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a47c0-356">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission, <see langword="FileStream" /> instance ownership, and buffer size.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-357">为 `FileStream` 对象提供了对文件的指定访问权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-357">The `FileStream` object is given the specified access to the file.</span></span> <span data-ttu-id="a47c0-358">句柄的所有权将为指定的。</span><span class="sxs-lookup"><span data-stu-id="a47c0-358">The ownership of the handle will be as specified.</span></span> <span data-ttu-id="a47c0-359">如果此 `FileStream` 拥有该句柄，则调用 <xref:System.IO.Stream.Close%2A> 方法也将关闭句柄。</span><span class="sxs-lookup"><span data-stu-id="a47c0-359">If this `FileStream` owns the handle, a call to the <xref:System.IO.Stream.Close%2A> method will also close the handle.</span></span> <span data-ttu-id="a47c0-360">特别是，文件的句柄计数递减。</span><span class="sxs-lookup"><span data-stu-id="a47c0-360">In particular, the file's handle count is decremented.</span></span> <span data-ttu-id="a47c0-361">为 `FileStream` 对象提供指定的缓冲区大小。</span><span class="sxs-lookup"><span data-stu-id="a47c0-361">The `FileStream` object is given the specified buffer size.</span></span>  
  
 <span data-ttu-id="a47c0-362">`FileStream` 假设它对句柄具有独占控制。</span><span class="sxs-lookup"><span data-stu-id="a47c0-362">`FileStream` assumes that it has exclusive control over the handle.</span></span> <span data-ttu-id="a47c0-363">读取、写入或查找 `FileStream` 同时包含句柄可能会导致数据损坏。</span><span class="sxs-lookup"><span data-stu-id="a47c0-363">Reading, writing, or seeking while a `FileStream` is also holding a handle could result in data corruption.</span></span> <span data-ttu-id="a47c0-364">为实现数据安全，请在使用句柄之前调用 <xref:System.IO.FileStream.Flush%2A>，并在使用完句柄之后避免调用除 `Close` 以外的任何方法。</span><span class="sxs-lookup"><span data-stu-id="a47c0-364">For data safety, call <xref:System.IO.FileStream.Flush%2A> before using the handle, and avoid calling any methods other than `Close` after you are done using the handle.</span></span> <span data-ttu-id="a47c0-365">或者，在调用此 `FileStream` 构造函数之前，读取和写入句柄。</span><span class="sxs-lookup"><span data-stu-id="a47c0-365">Alternately, read and write to the handle before calling this `FileStream` constructor.</span></span>  
  
 <span data-ttu-id="a47c0-366">`FileShare.Read` 是不带 `FileShare` 参数 <xref:System.IO.FileStream> 构造函数的默认值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-366">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a47c0-367">使用特定的区域性设置编译一组字符并使用不同的区域性设置检索这些相同的字符时，这些字符可能不是可解释，并且可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="a47c0-367">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="a47c0-368">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-368">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a47c0-369"><paramref name="bufferSize" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-369"><paramref name="bufferSize" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-370">出现 I/O 错误，例如磁盘错误。</span><span class="sxs-lookup"><span data-stu-id="a47c0-370">An I/O error, such as a disk error, occurred.</span></span>  
  
 <span data-ttu-id="a47c0-371">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-371">-or-</span></span>  
  
 <span data-ttu-id="a47c0-372">已关闭流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-372">The stream has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="a47c0-373">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-373">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a47c0-374">对于指定的文件句柄，操作系统不允许所请求的 <paramref name="access" />。例如当 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，并将文件句柄设置为只读访问时会出现此情况。</span><span class="sxs-lookup"><span data-stu-id="a47c0-374">The <paramref name="access" /> requested is not permitted by the operating system for the specified file handle, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file handle is set for read-only access.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="a47c0-375">用于读取、写入和追加到文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-375">for reading, writing, and appending to files.</span></span> <span data-ttu-id="a47c0-376">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-376">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-377">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-377">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-378">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-378">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-379">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-379">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="a47c0-380">当前 <see langword="FileStream" /> 对象将封装的文件的相对路径或绝对路径。</span><span class="sxs-lookup"><span data-stu-id="a47c0-380">A relative or absolute path for the file that the current <see langword="FileStream" /> object will encapsulate.</span></span></param>
        <param name="mode"><span data-ttu-id="a47c0-381">用于确定文件的打开或创建方式的枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="a47c0-381">One of the enumeration values that determines how to open or create the file.</span></span></param>
        <param name="access"><span data-ttu-id="a47c0-382">枚举值的按位组合，这些枚举值确定 <see langword="FileStream" /> 对象访问文件的方式。</span><span class="sxs-lookup"><span data-stu-id="a47c0-382">A bitwise combination of the enumeration values that determines how the file can be accessed by the <see langword="FileStream" /> object.</span></span> <span data-ttu-id="a47c0-383">该常数还可以确定由 <see cref="P:System.IO.FileStream.CanRead" /> 对象的 <see cref="P:System.IO.FileStream.CanWrite" /> 和 <see langword="FileStream" /> 属性返回的值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-383">This also determines the values returned by the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span></span> <span data-ttu-id="a47c0-384">如果 <see cref="P:System.IO.FileStream.CanSeek" /> 指定磁盘文件，则 <see langword="true" /> 为 <paramref name="path" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-384"><see cref="P:System.IO.FileStream.CanSeek" /> is <see langword="true" /> if <paramref name="path" /> specifies a disk file.</span></span></param>
        <param name="share"><span data-ttu-id="a47c0-385">枚举值的按位组合，这些枚举值确定进程共享文件的方式。</span><span class="sxs-lookup"><span data-stu-id="a47c0-385">A bitwise combination of the enumeration values that determines how the file will be shared by processes.</span></span></param>
        <summary><span data-ttu-id="a47c0-386">使用指定的路径、创建模式、读/写权限和共享权限创建 <see cref="T:System.IO.FileStream" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a47c0-386">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, read/write permission, and sharing permission.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-387">.NET Framework 不支持通过作为设备名称的路径（如 "\\\\.\PHYSICALDRIVE0"）直接访问物理磁盘。</span><span class="sxs-lookup"><span data-stu-id="a47c0-387">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="a47c0-388">`path` 参数可以是文件名，包括通用命名约定（UNC）共享上的文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-388">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
 <span data-ttu-id="a47c0-389">为构造函数提供对文件的读/写访问权限，并且该构造函数已打开共享读取权限（也就是说，此或其他进程打开文件以进行写入的请求将失败，直至 `FileStream` 对象关闭，但读取尝试将成功）。</span><span class="sxs-lookup"><span data-stu-id="a47c0-389">The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed).</span></span> <span data-ttu-id="a47c0-390">缓冲区大小设置为默认大小（4096字节）（4 KB）。</span><span class="sxs-lookup"><span data-stu-id="a47c0-390">The buffer size is set to the default size of 4096 bytes (4 KB).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a47c0-391">`path` 不需要是存储在磁盘上的文件;它可以是支持通过流进行访问的系统的任何部分。</span><span class="sxs-lookup"><span data-stu-id="a47c0-391">`path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</span></span> <span data-ttu-id="a47c0-392">例如，根据系统，此类可以访问物理设备。</span><span class="sxs-lookup"><span data-stu-id="a47c0-392">For example, depending on the system, this class can access a physical device.</span></span>  
  
 <span data-ttu-id="a47c0-393">对于封装文件的所有 <xref:System.IO.FileStream> 对象 `true` <xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-393"><xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files.</span></span> <span data-ttu-id="a47c0-394">如果 `path` 指示不支持查找的设备，则将 `false`生成的 <xref:System.IO.FileStream> 上的 <xref:System.IO.FileStream.CanSeek%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="a47c0-394">If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`.</span></span> <span data-ttu-id="a47c0-395">有关附加信息，请参见 <xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-395">For additional information, see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a47c0-396">使用特定的区域性设置编译一组字符并使用不同的区域性设置检索这些相同的字符时，这些字符可能不是可解释，并且可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="a47c0-396">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="a47c0-397">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-397">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a47c0-398">此代码示例是为 <xref:System.IO.FileStream.Lock%2A> 方法提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="a47c0-398">This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.</span></span>  
  
 [!code-cpp[System.IO.FileStream3#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#2)]
 [!code-csharp[System.IO.FileStream3#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#2)]
 [!code-vb[System.IO.FileStream3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a47c0-399"><paramref name="path" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-399"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a47c0-400"><paramref name="path" /> 是一个空字符串 ("")，仅包含空格，或者包含一个或多个无效字符。</span><span class="sxs-lookup"><span data-stu-id="a47c0-400"><paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters.</span></span>  
  
<span data-ttu-id="a47c0-401">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-401">-or-</span></span> 
 <span data-ttu-id="a47c0-402"><paramref name="path" /> 指非文件设备，如 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</span><span class="sxs-lookup"><span data-stu-id="a47c0-402"><paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a47c0-403"><paramref name="path" /> 指非文件设备，如非 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</span><span class="sxs-lookup"><span data-stu-id="a47c0-403"><paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a47c0-404">找不到该文件。例如，当 <paramref name="mode" /> 是 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，并且 <paramref name="path" /> 指定的文件不存在时会出现这种情况。</span><span class="sxs-lookup"><span data-stu-id="a47c0-404">The file cannot be found, such as when <paramref name="mode" /> is <see langword="FileMode.Truncate" /> or <see langword="FileMode.Open" />, and the file specified by <paramref name="path" /> does not exist.</span></span> <span data-ttu-id="a47c0-405">该文件必须以这些模式存在。</span><span class="sxs-lookup"><span data-stu-id="a47c0-405">The file must already exist in these modes.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-406">I/O 错误，例如在 <see langword="FileMode.CreateNew" /> 指定的文件已存在时指定 <paramref name="path" />，会发生此错误。</span><span class="sxs-lookup"><span data-stu-id="a47c0-406">An I/O error, such as specifying <see langword="FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists, occurred.</span></span>  
  
<span data-ttu-id="a47c0-407">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-407">-or-</span></span> 
<span data-ttu-id="a47c0-408">系统正在运行 Windows 98 或 Windows 98 Second Edition，并将 <paramref name="share" /> 设置为 <see langword="FileShare.Delete" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-408">The system is running Windows 98 or Windows 98 Second Edition and <paramref name="share" /> is set to <see langword="FileShare.Delete" />.</span></span>  
  
<span data-ttu-id="a47c0-409">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-409">-or-</span></span> 
<span data-ttu-id="a47c0-410">已关闭流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-410">The stream has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="a47c0-411">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-411">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="a47c0-412">指定的路径无效，例如位于未映射的驱动器上。</span><span class="sxs-lookup"><span data-stu-id="a47c0-412">The specified path is invalid, such as being on an unmapped drive.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a47c0-413">对于指定的 <paramref name="access" />，操作系统不允许所请求的 <paramref name="path" />。例如当 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，并将文件或目录设置为只读访问时会出现此情况。</span><span class="sxs-lookup"><span data-stu-id="a47c0-413">The <paramref name="access" /> requested is not permitted by the operating system for the specified <paramref name="path" />, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file or directory is set for read-only access.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="a47c0-414">指定的路径和/或文件名超过了系统定义的最大长度。</span><span class="sxs-lookup"><span data-stu-id="a47c0-414">The specified path, file name, or both exceed the system-defined maximum length.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a47c0-415"><paramref name="mode" /> 包含无效值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-415"><paramref name="mode" /> contains an invalid value.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="a47c0-416">用于读取、写入和追加到文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-416">for reading, writing, and appending to files.</span></span> <span data-ttu-id="a47c0-417">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-417">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-418">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-418">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-419">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-419">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-420">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-420">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="ownsHandle" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="isAsync" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="a47c0-421">此 <see langword="FileStream" /> 对象将封装的文件的文件句柄。</span><span class="sxs-lookup"><span data-stu-id="a47c0-421">A file handle for the file that this <see langword="FileStream" /> object will encapsulate.</span></span></param>
        <param name="access"><span data-ttu-id="a47c0-422">枚举值的按位组合，它用于设置 <see cref="P:System.IO.FileStream.CanRead" /> 对象的 <see cref="P:System.IO.FileStream.CanWrite" /> 和 <see langword="FileStream" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="a47c0-422">A bitwise combination of the enumeration values that sets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span></span></param>
        <param name="ownsHandle"><span data-ttu-id="a47c0-423">如果文件句柄将由此 <see langword="true" /> 实例所有，则为 <see langword="FileStream" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-423"><see langword="true" /> if the file handle will be owned by this <see langword="FileStream" /> instance; otherwise, <see langword="false" />.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="a47c0-424">一个大于零的正 <see cref="T:System.Int32" /> 值，表示缓冲区大小。</span><span class="sxs-lookup"><span data-stu-id="a47c0-424">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span></span> <span data-ttu-id="a47c0-425">默认缓冲区大小为 4096。</span><span class="sxs-lookup"><span data-stu-id="a47c0-425">The default buffer size is 4096.</span></span></param>
        <param name="isAsync"><span data-ttu-id="a47c0-426">如果异步打开句柄（即以重叠的 I/O 模式），则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-426"><see langword="true" /> if the handle was opened asynchronously (that is, in overlapped I/O mode); otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="a47c0-427">使用指定的读/写权限、<see cref="T:System.IO.FileStream" /> 实例所属权、缓冲区大小和同步或异步状态为指定的文件句柄初始化 <see langword="FileStream" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a47c0-427">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission, <see langword="FileStream" /> instance ownership, buffer size, and synchronous or asynchronous state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-428">为 `FileStream` 对象提供了对文件的指定访问权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-428">The `FileStream` object is given the specified access to the file.</span></span> <span data-ttu-id="a47c0-429">句柄的所有权将为指定的。</span><span class="sxs-lookup"><span data-stu-id="a47c0-429">The ownership of the handle will be as specified.</span></span> <span data-ttu-id="a47c0-430">如果此 `FileStream` 拥有该句柄，则调用 <xref:System.IO.Stream.Close%2A> 方法也将关闭句柄。</span><span class="sxs-lookup"><span data-stu-id="a47c0-430">If this `FileStream` owns the handle, a call to the <xref:System.IO.Stream.Close%2A> method will also close the handle.</span></span> <span data-ttu-id="a47c0-431">特别是，文件的句柄计数递减。</span><span class="sxs-lookup"><span data-stu-id="a47c0-431">In particular, the file's handle count is decremented.</span></span> <span data-ttu-id="a47c0-432">为 `FileStream` 对象提供指定的缓冲区大小。</span><span class="sxs-lookup"><span data-stu-id="a47c0-432">The `FileStream` object is given the specified buffer size.</span></span>  
  
 <span data-ttu-id="a47c0-433">`FileStream` 假设它对句柄具有独占控制。</span><span class="sxs-lookup"><span data-stu-id="a47c0-433">`FileStream` assumes that it has exclusive control over the handle.</span></span> <span data-ttu-id="a47c0-434">读取、写入或查找 `FileStream` 同时包含句柄可能会导致数据损坏。</span><span class="sxs-lookup"><span data-stu-id="a47c0-434">Reading, writing, or seeking while a `FileStream` is also holding a handle could result in data corruption.</span></span> <span data-ttu-id="a47c0-435">为实现数据安全，请在使用句柄之前调用 <xref:System.IO.FileStream.Flush%2A>，并在使用完句柄之后避免调用除 `Close` 以外的任何方法。</span><span class="sxs-lookup"><span data-stu-id="a47c0-435">For data safety, call <xref:System.IO.FileStream.Flush%2A> before using the handle, and avoid calling any methods other than `Close` after you are done using the handle.</span></span> <span data-ttu-id="a47c0-436">或者，在调用此 `FileStream` 构造函数之前，读取和写入句柄。</span><span class="sxs-lookup"><span data-stu-id="a47c0-436">Alternately, read and write to the handle before calling this `FileStream` constructor.</span></span>  
  
 <span data-ttu-id="a47c0-437">`FileShare.Read` 是不带 `FileShare` 参数 <xref:System.IO.FileStream> 构造函数的默认值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-437">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a47c0-438">使用特定的区域性设置编译一组字符并使用不同的区域性设置检索这些相同的字符时，这些字符可能不是可解释，并且可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="a47c0-438">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="a47c0-439">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-439">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a47c0-440"><paramref name="access" /> 小于 <see langword="FileAccess.Read" /> 或大于 <see langword="FileAccess.ReadWrite" />，或者 <paramref name="bufferSize" /> 小于等于 0。</span><span class="sxs-lookup"><span data-stu-id="a47c0-440"><paramref name="access" /> is less than <see langword="FileAccess.Read" /> or greater than <see langword="FileAccess.ReadWrite" /> or <paramref name="bufferSize" /> is less than or equal to 0.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a47c0-441">该句柄无效。</span><span class="sxs-lookup"><span data-stu-id="a47c0-441">The handle is invalid.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-442">出现 I/O 错误，例如磁盘错误。</span><span class="sxs-lookup"><span data-stu-id="a47c0-442">An I/O error, such as a disk error, occurred.</span></span>  
  
 <span data-ttu-id="a47c0-443">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-443">-or-</span></span>  
  
 <span data-ttu-id="a47c0-444">已关闭流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-444">The stream has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="a47c0-445">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-445">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a47c0-446">对于指定的文件句柄，操作系统不允许所请求的 <paramref name="access" />。例如当 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，并将文件句柄设置为只读访问时会出现此情况。</span><span class="sxs-lookup"><span data-stu-id="a47c0-446">The <paramref name="access" /> requested is not permitted by the operating system for the specified file handle, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file handle is set for read-only access.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="a47c0-447">用于访问非托管代码。</span><span class="sxs-lookup"><span data-stu-id="a47c0-447">for access to unmanaged code.</span></span> <span data-ttu-id="a47c0-448">关联的枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-448">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-449">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-449">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-450">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-450">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-451">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-451">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="a47c0-452">当前 <see langword="FileStream" /> 对象将封装的文件的相对路径或绝对路径。</span><span class="sxs-lookup"><span data-stu-id="a47c0-452">A relative or absolute path for the file that the current <see langword="FileStream" /> object will encapsulate.</span></span></param>
        <param name="mode"><span data-ttu-id="a47c0-453">用于确定文件的打开或创建方式的枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="a47c0-453">One of the enumeration values that determines how to open or create the file.</span></span></param>
        <param name="access"><span data-ttu-id="a47c0-454">枚举值的按位组合，这些枚举值确定 <see langword="FileStream" /> 对象访问文件的方式。</span><span class="sxs-lookup"><span data-stu-id="a47c0-454">A bitwise combination of the enumeration values that determines how the file can be accessed by the <see langword="FileStream" /> object.</span></span> <span data-ttu-id="a47c0-455">该常数还可以确定由 <see cref="P:System.IO.FileStream.CanRead" /> 对象的 <see cref="P:System.IO.FileStream.CanWrite" /> 和 <see langword="FileStream" /> 属性返回的值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-455">This also determines the values returned by the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span></span> <span data-ttu-id="a47c0-456">如果 <see cref="P:System.IO.FileStream.CanSeek" /> 指定磁盘文件，则 <see langword="true" /> 为 <paramref name="path" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-456"><see cref="P:System.IO.FileStream.CanSeek" /> is <see langword="true" /> if <paramref name="path" /> specifies a disk file.</span></span></param>
        <param name="share"><span data-ttu-id="a47c0-457">枚举值的按位组合，这些枚举值确定进程共享文件的方式。</span><span class="sxs-lookup"><span data-stu-id="a47c0-457">A bitwise combination of the enumeration values that determines how the file will be shared by processes.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="a47c0-458">一个大于零的正 <see cref="T:System.Int32" /> 值，表示缓冲区大小。</span><span class="sxs-lookup"><span data-stu-id="a47c0-458">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span></span> <span data-ttu-id="a47c0-459">默认缓冲区大小为 4096。</span><span class="sxs-lookup"><span data-stu-id="a47c0-459">The default buffer size is 4096.</span></span></param>
        <summary><span data-ttu-id="a47c0-460">用指定的路径、创建模式、读/写及共享权限和缓冲区大小初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a47c0-460">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, read/write and sharing permission, and buffer size.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-461">.NET Framework 不支持通过作为设备名称的路径（如 "\\\\.\PHYSICALDRIVE0"）直接访问物理磁盘。</span><span class="sxs-lookup"><span data-stu-id="a47c0-461">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="a47c0-462">`path` 参数可以是文件名，包括通用命名约定（UNC）共享上的文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-462">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a47c0-463">`path` 不需要是存储在磁盘上的文件;它可以是支持通过流进行访问的系统的任何部分。</span><span class="sxs-lookup"><span data-stu-id="a47c0-463">`path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</span></span> <span data-ttu-id="a47c0-464">例如，根据系统，此类可以访问物理设备。</span><span class="sxs-lookup"><span data-stu-id="a47c0-464">For example, depending on the system, this class can access a physical device.</span></span>  
  
 <span data-ttu-id="a47c0-465">对于封装文件的所有 <xref:System.IO.FileStream> 对象 `true` <xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-465"><xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files.</span></span> <span data-ttu-id="a47c0-466">如果 `path` 指示不支持查找的设备，则将 `false`生成的 <xref:System.IO.FileStream> 上的 <xref:System.IO.FileStream.CanSeek%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="a47c0-466">If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`.</span></span> <span data-ttu-id="a47c0-467">有关附加信息，请参见 <xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-467">For additional information, see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a47c0-468">使用特定的区域性设置编译一组字符并使用不同的区域性设置检索这些相同的字符时，这些字符可能不是可解释，并且可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="a47c0-468">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="a47c0-469">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-469">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a47c0-470"><paramref name="path" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-470"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a47c0-471"><paramref name="path" /> 是一个空字符串 ("")，仅包含空格，或者包含一个或多个无效字符。</span><span class="sxs-lookup"><span data-stu-id="a47c0-471"><paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters.</span></span>  
  
<span data-ttu-id="a47c0-472">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-472">-or-</span></span> 
 <span data-ttu-id="a47c0-473"><paramref name="path" /> 指非文件设备，如 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</span><span class="sxs-lookup"><span data-stu-id="a47c0-473"><paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a47c0-474"><paramref name="path" /> 指非文件设备，如非 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</span><span class="sxs-lookup"><span data-stu-id="a47c0-474"><paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a47c0-475"><paramref name="bufferSize" /> 为负数或零。</span><span class="sxs-lookup"><span data-stu-id="a47c0-475"><paramref name="bufferSize" /> is negative or zero.</span></span>  
  
<span data-ttu-id="a47c0-476">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-476">-or-</span></span> 
 <span data-ttu-id="a47c0-477"><paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 包含无效的值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-477"><paramref name="mode" />, <paramref name="access" />, or <paramref name="share" /> contain an invalid value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a47c0-478">找不到该文件。例如，当 <paramref name="mode" /> 是 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，并且 <paramref name="path" /> 指定的文件不存在时会出现这种情况。</span><span class="sxs-lookup"><span data-stu-id="a47c0-478">The file cannot be found, such as when <paramref name="mode" /> is <see langword="FileMode.Truncate" /> or <see langword="FileMode.Open" />, and the file specified by <paramref name="path" /> does not exist.</span></span> <span data-ttu-id="a47c0-479">该文件必须以这些模式存在。</span><span class="sxs-lookup"><span data-stu-id="a47c0-479">The file must already exist in these modes.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-480">I/O 错误，例如在 <see langword="FileMode.CreateNew" /> 指定的文件已存在时指定 <paramref name="path" />，会发生此错误。</span><span class="sxs-lookup"><span data-stu-id="a47c0-480">An I/O error, such as specifying <see langword="FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists, occurred.</span></span>  
  
<span data-ttu-id="a47c0-481">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-481">-or-</span></span> 
<span data-ttu-id="a47c0-482">系统正在运行 Windows 98 或 Windows 98 Second Edition，并将 <paramref name="share" /> 设置为 <see langword="FileShare.Delete" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-482">The system is running Windows 98 or Windows 98 Second Edition and <paramref name="share" /> is set to <see langword="FileShare.Delete" />.</span></span>  
  
<span data-ttu-id="a47c0-483">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-483">-or-</span></span> 
<span data-ttu-id="a47c0-484">已关闭流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-484">The stream has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="a47c0-485">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-485">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="a47c0-486">指定的路径无效，例如位于未映射的驱动器上。</span><span class="sxs-lookup"><span data-stu-id="a47c0-486">The specified path is invalid, such as being on an unmapped drive.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a47c0-487">对于指定的 <paramref name="access" />，操作系统不允许所请求的 <paramref name="path" />。例如当 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，并将文件或目录设置为只读访问时会出现此情况。</span><span class="sxs-lookup"><span data-stu-id="a47c0-487">The <paramref name="access" /> requested is not permitted by the operating system for the specified <paramref name="path" />, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file or directory is set for read-only access.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="a47c0-488">指定的路径和/或文件名超过了系统定义的最大长度。</span><span class="sxs-lookup"><span data-stu-id="a47c0-488">The specified path, file name, or both exceed the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="a47c0-489">用于读取、写入和追加到文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-489">for reading, writing, and appending to files.</span></span> <span data-ttu-id="a47c0-490">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-490">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-491">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-491">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-492">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-492">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-493">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-493">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, useAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, useAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="a47c0-494">当前 <see langword="FileStream" /> 对象将封装的文件的相对路径或绝对路径。</span><span class="sxs-lookup"><span data-stu-id="a47c0-494">A relative or absolute path for the file that the current <see langword="FileStream" /> object will encapsulate.</span></span></param>
        <param name="mode"><span data-ttu-id="a47c0-495">用于确定文件的打开或创建方式的枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="a47c0-495">One of the enumeration values that determines how to open or create the file.</span></span></param>
        <param name="access"><span data-ttu-id="a47c0-496">枚举值的按位组合，这些枚举值确定 <see langword="FileStream" /> 对象访问文件的方式。</span><span class="sxs-lookup"><span data-stu-id="a47c0-496">A bitwise combination of the enumeration values that determines how the file can be accessed by the <see langword="FileStream" /> object.</span></span> <span data-ttu-id="a47c0-497">该常数还可以确定由 <see cref="P:System.IO.FileStream.CanRead" /> 对象的 <see cref="P:System.IO.FileStream.CanWrite" /> 和 <see langword="FileStream" /> 属性返回的值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-497">This also determines the values returned by the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span></span> <span data-ttu-id="a47c0-498">如果 <see cref="P:System.IO.FileStream.CanSeek" /> 指定磁盘文件，则 <see langword="true" /> 为 <paramref name="path" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-498"><see cref="P:System.IO.FileStream.CanSeek" /> is <see langword="true" /> if <paramref name="path" /> specifies a disk file.</span></span></param>
        <param name="share"><span data-ttu-id="a47c0-499">枚举值的按位组合，这些枚举值确定进程共享文件的方式。</span><span class="sxs-lookup"><span data-stu-id="a47c0-499">A bitwise combination of the enumeration values that determines how the file will be shared by processes.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="a47c0-500">一个大于零的正 <see cref="T:System.Int32" /> 值，表示缓冲区大小。</span><span class="sxs-lookup"><span data-stu-id="a47c0-500">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span></span> <span data-ttu-id="a47c0-501">默认缓冲区大小为 4096。</span><span class="sxs-lookup"><span data-stu-id="a47c0-501">The default buffer size is 4096.</span></span></param>
        <param name="useAsync"><span data-ttu-id="a47c0-502">指定使用异步 I/O 还是同步 I/O。</span><span class="sxs-lookup"><span data-stu-id="a47c0-502">Specifies whether to use asynchronous I/O or synchronous I/O.</span></span> <span data-ttu-id="a47c0-503">但是，请注意，基础操作系统可能不支持异步 I/O，因此在指定 <see langword="true" /> 后，根据所用平台，句柄可能同步打开。</span><span class="sxs-lookup"><span data-stu-id="a47c0-503">However, note that the underlying operating system might not support asynchronous I/O, so when specifying <see langword="true" />, the handle might be opened synchronously depending on the platform.</span></span> <span data-ttu-id="a47c0-504">当异步打开时，<see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 和 <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 方法在执行大量读或写时效果更好，但对于少量的读/写，这些方法速度可能要慢得多。</span><span class="sxs-lookup"><span data-stu-id="a47c0-504">When opened asynchronously, the <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> and <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> methods perform better on large reads or writes, but they might be much slower for small reads or writes.</span></span> <span data-ttu-id="a47c0-505">如果应用程序打算利用异步 I/O，将 <paramref name="useAsync" /> 参数设置为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-505">If the application is designed to take advantage of asynchronous I/O, set the <paramref name="useAsync" /> parameter to <see langword="true" />.</span></span> <span data-ttu-id="a47c0-506">正确使用异步 I/O 可以使应用程序的速度加快 10 倍，但是如果在没有为异步 I/O 重新设计应用程序的情况下使用异步 I/O，则可能使性能降低 10 倍。</span><span class="sxs-lookup"><span data-stu-id="a47c0-506">Using asynchronous I/O correctly can speed up applications by as much as a factor of 10, but using it without redesigning the application for asynchronous I/O can decrease performance by as much as a factor of 10.</span></span></param>
        <summary><span data-ttu-id="a47c0-507">使用指定的路径、创建模式、读/写和共享权限、缓冲区大小和同步或异步状态初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a47c0-507">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, read/write and sharing permission, buffer size, and synchronous or asynchronous state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-508">.NET Framework 不支持通过作为设备名称的路径（如 "\\\\.\PHYSICALDRIVE0"）直接访问物理磁盘。</span><span class="sxs-lookup"><span data-stu-id="a47c0-508">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="a47c0-509">`path` 参数可以是文件名，包括通用命名约定（UNC）共享上的文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-509">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a47c0-510">`path` 不需要是存储在磁盘上的文件;它可以是支持通过流进行访问的系统的任何部分。</span><span class="sxs-lookup"><span data-stu-id="a47c0-510">`path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</span></span> <span data-ttu-id="a47c0-511">例如，根据系统，此类可以访问物理设备。</span><span class="sxs-lookup"><span data-stu-id="a47c0-511">For example, depending on the system, this class can access a physical device.</span></span>  
  
 <span data-ttu-id="a47c0-512">对于封装文件的所有 <xref:System.IO.FileStream> 对象 `true` <xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-512"><xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files.</span></span> <span data-ttu-id="a47c0-513">如果 `path` 指示不支持查找的设备，则将 `false`生成的 <xref:System.IO.FileStream> 上的 <xref:System.IO.FileStream.CanSeek%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="a47c0-513">If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`.</span></span> <span data-ttu-id="a47c0-514">有关附加信息，请参见 <xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-514">For additional information, see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a47c0-515">使用特定的区域性设置编译一组字符并使用不同的区域性设置检索这些相同的字符时，这些字符可能不是可解释，并且可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="a47c0-515">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="a47c0-516">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-516">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a47c0-517">下面的代码示例演示如何以异步方式将数据写入文件，然后验证是否已正确写入数据。</span><span class="sxs-lookup"><span data-stu-id="a47c0-517">The following code example shows how to asynchronously write data to a file and then verify that the data was written correctly.</span></span> <span data-ttu-id="a47c0-518">将创建一个 `State` 对象，以从主线程向 `EndReadCallback` 和 `EndWriteCallback` 方法传递信息。</span><span class="sxs-lookup"><span data-stu-id="a47c0-518">A `State` object is created to pass information from the main thread to the `EndReadCallback` and `EndWriteCallback` methods.</span></span>  
  
 [!code-cpp[System.IO.FileStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a47c0-519"><paramref name="path" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-519"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a47c0-520"><paramref name="path" /> 是一个空字符串 ("")，仅包含空格，或者包含一个或多个无效字符。</span><span class="sxs-lookup"><span data-stu-id="a47c0-520"><paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters.</span></span>  
  
<span data-ttu-id="a47c0-521">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-521">-or-</span></span> 
 <span data-ttu-id="a47c0-522"><paramref name="path" /> 指非文件设备，如 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</span><span class="sxs-lookup"><span data-stu-id="a47c0-522"><paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a47c0-523"><paramref name="path" /> 指非文件设备，如非 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</span><span class="sxs-lookup"><span data-stu-id="a47c0-523"><paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a47c0-524"><paramref name="bufferSize" /> 为负数或零。</span><span class="sxs-lookup"><span data-stu-id="a47c0-524"><paramref name="bufferSize" /> is negative or zero.</span></span>  
  
<span data-ttu-id="a47c0-525">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-525">-or-</span></span> 
 <span data-ttu-id="a47c0-526"><paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 包含无效的值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-526"><paramref name="mode" />, <paramref name="access" />, or <paramref name="share" /> contain an invalid value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a47c0-527">找不到该文件。例如，当 <paramref name="mode" /> 是 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，并且 <paramref name="path" /> 指定的文件不存在时会出现这种情况。</span><span class="sxs-lookup"><span data-stu-id="a47c0-527">The file cannot be found, such as when <paramref name="mode" /> is <see langword="FileMode.Truncate" /> or <see langword="FileMode.Open" />, and the file specified by <paramref name="path" /> does not exist.</span></span> <span data-ttu-id="a47c0-528">该文件必须以这些模式存在。</span><span class="sxs-lookup"><span data-stu-id="a47c0-528">The file must already exist in these modes.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-529">I/O 错误，例如在 <see langword="FileMode.CreateNew" /> 指定的文件已存在时指定 <paramref name="path" />，会发生此错误。</span><span class="sxs-lookup"><span data-stu-id="a47c0-529">An I/O error, such as specifying <see langword="FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists, occurred.</span></span>  
  
<span data-ttu-id="a47c0-530">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-530">-or-</span></span> 
<span data-ttu-id="a47c0-531">系统正在运行 Windows 98 或 Windows 98 Second Edition，并将 <paramref name="share" /> 设置为 <see langword="FileShare.Delete" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-531">The system is running Windows 98 or Windows 98 Second Edition and <paramref name="share" /> is set to <see langword="FileShare.Delete" />.</span></span>  
  
<span data-ttu-id="a47c0-532">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-532">-or-</span></span> 
<span data-ttu-id="a47c0-533">已关闭流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-533">The stream has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="a47c0-534">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-534">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="a47c0-535">指定的路径无效，例如位于未映射的驱动器上。</span><span class="sxs-lookup"><span data-stu-id="a47c0-535">The specified path is invalid, such as being on an unmapped drive.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a47c0-536">对于指定的 <paramref name="access" />，操作系统不允许所请求的 <paramref name="path" />。例如当 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，并将文件或目录设置为只读访问时会出现此情况。</span><span class="sxs-lookup"><span data-stu-id="a47c0-536">The <paramref name="access" /> requested is not permitted by the operating system for the specified <paramref name="path" />, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file or directory is set for read-only access.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="a47c0-537">指定的路径和/或文件名超过了系统定义的最大长度。</span><span class="sxs-lookup"><span data-stu-id="a47c0-537">The specified path, file name, or both exceed the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="a47c0-538">用于读取、写入和追加到文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-538">for reading, writing, and appending to files.</span></span> <span data-ttu-id="a47c0-539">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-539">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span></span></permission>
        <altmember cref="T:System.IO.File" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-540">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-540">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-541">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-541">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-542">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-542">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.IO.FileMode" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="share" Type="System.IO.FileShare" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.FileOptions" Index="5" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="a47c0-543">当前 <see langword="FileStream" /> 对象将封装的文件的相对路径或绝对路径。</span><span class="sxs-lookup"><span data-stu-id="a47c0-543">A relative or absolute path for the file that the current <see langword="FileStream" /> object will encapsulate.</span></span></param>
        <param name="mode"><span data-ttu-id="a47c0-544">用于确定文件的打开或创建方式的枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="a47c0-544">One of the enumeration values that determines how to open or create the file.</span></span></param>
        <param name="access"><span data-ttu-id="a47c0-545">枚举值的按位组合，这些枚举值确定 <see langword="FileStream" /> 对象访问文件的方式。</span><span class="sxs-lookup"><span data-stu-id="a47c0-545">A bitwise combination of the enumeration values that determines how the file can be accessed by the <see langword="FileStream" /> object.</span></span> <span data-ttu-id="a47c0-546">该常数还可以确定由 <see cref="P:System.IO.FileStream.CanRead" /> 对象的 <see cref="P:System.IO.FileStream.CanWrite" /> 和 <see langword="FileStream" /> 属性返回的值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-546">This also determines the values returned by the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span></span> <span data-ttu-id="a47c0-547">如果 <see cref="P:System.IO.FileStream.CanSeek" /> 指定磁盘文件，则 <see langword="true" /> 为 <paramref name="path" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-547"><see cref="P:System.IO.FileStream.CanSeek" /> is <see langword="true" /> if <paramref name="path" /> specifies a disk file.</span></span></param>
        <param name="share"><span data-ttu-id="a47c0-548">枚举值的按位组合，这些枚举值确定进程共享文件的方式。</span><span class="sxs-lookup"><span data-stu-id="a47c0-548">A bitwise combination of the enumeration values that determines how the file will be shared by processes.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="a47c0-549">一个大于零的正 <see cref="T:System.Int32" /> 值，表示缓冲区大小。</span><span class="sxs-lookup"><span data-stu-id="a47c0-549">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span></span> <span data-ttu-id="a47c0-550">默认缓冲区大小为 4096。</span><span class="sxs-lookup"><span data-stu-id="a47c0-550">The default buffer size is 4096.</span></span></param>
        <param name="options"><span data-ttu-id="a47c0-551">枚举值的按位组合，它用于指定其他文件选项。</span><span class="sxs-lookup"><span data-stu-id="a47c0-551">A bitwise combination of the enumeration values that specifies additional file options.</span></span></param>
        <summary><span data-ttu-id="a47c0-552">使用指定的路径、创建模式、读/写和共享权限、其他 FileStreams 可以具有的对此文件的访问权限、缓冲区大小和附加文件选项初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a47c0-552">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, read/write and sharing permission, the access other FileStreams can have to the same file, the buffer size, and additional file options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-553">.NET Framework 不支持通过作为设备名称的路径（如 "\\\\.\PHYSICALDRIVE0"）直接访问物理磁盘。</span><span class="sxs-lookup"><span data-stu-id="a47c0-553">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="a47c0-554">`fileOptions` 参数用于提供对创建 <xref:System.IO.FileStream> 对象时可利用的更高级操作的访问权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-554">The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.</span></span>  
  
 <span data-ttu-id="a47c0-555">`path` 参数可以是文件名，包括通用命名约定（UNC）共享上的文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-555">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a47c0-556">`path` 不需要是存储在磁盘上的文件;它可以是支持通过流进行访问的系统的任何部分。</span><span class="sxs-lookup"><span data-stu-id="a47c0-556">`path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</span></span> <span data-ttu-id="a47c0-557">例如，根据系统，此类可以访问物理设备。</span><span class="sxs-lookup"><span data-stu-id="a47c0-557">For example, depending on the system, this class can access a physical device.</span></span>  
  
 <span data-ttu-id="a47c0-558">对于封装文件的所有 <xref:System.IO.FileStream> 对象 `true` <xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-558"><xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files.</span></span> <span data-ttu-id="a47c0-559">如果 `path` 指示不支持查找的设备，则将 `false`生成的 <xref:System.IO.FileStream> 上的 <xref:System.IO.FileStream.CanSeek%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="a47c0-559">If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`.</span></span> <span data-ttu-id="a47c0-560">有关附加信息，请参见 <xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-560">For additional information, see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a47c0-561">使用特定的区域性设置编译一组字符并使用不同的区域性设置检索这些相同的字符时，这些字符可能不是可解释，并且可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="a47c0-561">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="a47c0-562">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-562">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a47c0-563">下面的示例将数据写入文件，然后使用 <xref:System.IO.FileStream> 对象读取数据。</span><span class="sxs-lookup"><span data-stu-id="a47c0-563">The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.</span></span>  
  
 [!code-cpp[IO.FileStream.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor1/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor1/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor1/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a47c0-564"><paramref name="path" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-564"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a47c0-565"><paramref name="path" /> 是一个空字符串 ("")，仅包含空格，或者包含一个或多个无效字符。</span><span class="sxs-lookup"><span data-stu-id="a47c0-565"><paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters.</span></span>  
  
<span data-ttu-id="a47c0-566">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-566">-or-</span></span> 
 <span data-ttu-id="a47c0-567"><paramref name="path" /> 指非文件设备，如 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</span><span class="sxs-lookup"><span data-stu-id="a47c0-567"><paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a47c0-568"><paramref name="path" /> 指非文件设备，如非 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</span><span class="sxs-lookup"><span data-stu-id="a47c0-568"><paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a47c0-569"><paramref name="bufferSize" /> 为负数或零。</span><span class="sxs-lookup"><span data-stu-id="a47c0-569"><paramref name="bufferSize" /> is negative or zero.</span></span>  
  
<span data-ttu-id="a47c0-570">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-570">-or-</span></span> 
 <span data-ttu-id="a47c0-571"><paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 包含无效的值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-571"><paramref name="mode" />, <paramref name="access" />, or <paramref name="share" /> contain an invalid value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a47c0-572">找不到该文件。例如，当 <paramref name="mode" /> 是 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，并且 <paramref name="path" /> 指定的文件不存在时会出现这种情况。</span><span class="sxs-lookup"><span data-stu-id="a47c0-572">The file cannot be found, such as when <paramref name="mode" /> is <see langword="FileMode.Truncate" /> or <see langword="FileMode.Open" />, and the file specified by <paramref name="path" /> does not exist.</span></span> <span data-ttu-id="a47c0-573">该文件必须以这些模式存在。</span><span class="sxs-lookup"><span data-stu-id="a47c0-573">The file must already exist in these modes.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-574">I/O 错误，例如在 <see langword="FileMode.CreateNew" /> 指定的文件已存在时指定 <paramref name="path" />，会发生此错误。</span><span class="sxs-lookup"><span data-stu-id="a47c0-574">An I/O error, such as specifying <see langword="FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists, occurred.</span></span>  
  
<span data-ttu-id="a47c0-575">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-575">-or-</span></span> 
<span data-ttu-id="a47c0-576">已关闭流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-576">The stream has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="a47c0-577">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-577">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="a47c0-578">指定的路径无效，例如位于未映射的驱动器上。</span><span class="sxs-lookup"><span data-stu-id="a47c0-578">The specified path is invalid, such as being on an unmapped drive.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a47c0-579">对于指定的 <paramref name="access" />，操作系统不允许所请求的 <paramref name="path" />。例如当 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，并将文件或目录设置为只读访问时会出现此情况。</span><span class="sxs-lookup"><span data-stu-id="a47c0-579">The <paramref name="access" /> requested is not permitted by the operating system for the specified <paramref name="path" />, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file or directory is set for read-only access.</span></span>  
  
<span data-ttu-id="a47c0-580">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-580">-or-</span></span> 
 <span data-ttu-id="a47c0-581"><see cref="F:System.IO.FileOptions.Encrypted" /> 指定用于 <paramref name="options" />，但在当前平台上不支持文件加密。</span><span class="sxs-lookup"><span data-stu-id="a47c0-581"><see cref="F:System.IO.FileOptions.Encrypted" /> is specified for <paramref name="options" />, but file encryption is not supported on the current platform.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="a47c0-582">指定的路径和/或文件名超过了系统定义的最大长度。</span><span class="sxs-lookup"><span data-stu-id="a47c0-582">The specified path, file name, or both exceed the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="a47c0-583">用于读取、写入和追加到文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-583">for reading, writing, and appending to files.</span></span> <span data-ttu-id="a47c0-584">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-584">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-585">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-585">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-586">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-586">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-587">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-587">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, rights As FileSystemRights, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.IO.FileMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="share" Type="System.IO.FileShare" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.FileOptions" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="a47c0-588">当前 <see cref="T:System.IO.FileStream" /> 对象将封装的文件的相对路径或绝对路径。</span><span class="sxs-lookup"><span data-stu-id="a47c0-588">A relative or absolute path for the file that the current <see cref="T:System.IO.FileStream" /> object will encapsulate.</span></span></param>
        <param name="mode"><span data-ttu-id="a47c0-589">用于确定文件的打开或创建方式的枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="a47c0-589">One of the enumeration values that determines how to open or create the file.</span></span></param>
        <param name="rights"><span data-ttu-id="a47c0-590">枚举值的按位组合，它用于确定在为文件创建访问和审核规则时要使用的访问权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-590">A bitwise combination of the enumeration values that determines the access rights to use when creating access and audit rules for the file.</span></span></param>
        <param name="share"><span data-ttu-id="a47c0-591">枚举值的按位组合，这些枚举值确定进程共享文件的方式。</span><span class="sxs-lookup"><span data-stu-id="a47c0-591">A bitwise combination of the enumeration values that determines how the file will be shared by processes.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="a47c0-592">一个大于零的正 <see cref="T:System.Int32" /> 值，表示缓冲区大小。</span><span class="sxs-lookup"><span data-stu-id="a47c0-592">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span></span> <span data-ttu-id="a47c0-593">默认缓冲区大小为 4096。</span><span class="sxs-lookup"><span data-stu-id="a47c0-593">The default buffer size is 4096.</span></span></param>
        <param name="options"><span data-ttu-id="a47c0-594">枚举值的按位组合，它用于指定其他文件选项。</span><span class="sxs-lookup"><span data-stu-id="a47c0-594">A bitwise combination of the enumeration values that specifies additional file options.</span></span></param>
        <summary><span data-ttu-id="a47c0-595">使用指定的路径、创建模式、访问权限和共享权限、缓冲区大小和附加文件选项初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a47c0-595">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, access rights and sharing permission, the buffer size, and additional file options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-596">.NET Framework 不支持通过作为设备名称的路径（如 "\\\\.\PHYSICALDRIVE0"）直接访问物理磁盘。</span><span class="sxs-lookup"><span data-stu-id="a47c0-596">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="a47c0-597">使用此 <xref:System.IO.FileStream.%23ctor%2A> 构造函数在文件创建时应用访问权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-597">Use this <xref:System.IO.FileStream.%23ctor%2A> constructor to apply access rights at the point of creation of a file.</span></span> <span data-ttu-id="a47c0-598">若要访问或修改现有文件的权限，请考虑使用 <xref:System.IO.File.GetAccessControl%2A> 和 <xref:System.IO.File.SetAccessControl%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="a47c0-598">To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.</span></span>  
  
 <span data-ttu-id="a47c0-599">`fileOptions` 参数用于提供对创建 <xref:System.IO.FileStream> 对象时可利用的更高级操作的访问权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-599">The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.</span></span>  
  
 <span data-ttu-id="a47c0-600">`path` 参数可以是文件名，包括通用命名约定（UNC）共享上的文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-600">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a47c0-601">`path` 不需要是存储在磁盘上的文件;它可以是支持通过流进行访问的系统的任何部分。</span><span class="sxs-lookup"><span data-stu-id="a47c0-601">`path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</span></span> <span data-ttu-id="a47c0-602">例如，根据系统，此类可以访问物理设备。</span><span class="sxs-lookup"><span data-stu-id="a47c0-602">For example, depending on the system, this class can access a physical device.</span></span>  
  
 <span data-ttu-id="a47c0-603">对于封装文件的所有 <xref:System.IO.FileStream> 对象 `true` <xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-603"><xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files.</span></span> <span data-ttu-id="a47c0-604">如果 `path` 指示不支持查找的设备，则将 `false`生成的 <xref:System.IO.FileStream> 上的 <xref:System.IO.FileStream.CanSeek%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="a47c0-604">If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`.</span></span> <span data-ttu-id="a47c0-605">有关附加信息，请参见 <xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-605">For additional information, see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a47c0-606">使用特定的区域性设置编译一组字符并使用不同的区域性设置检索这些相同的字符时，这些字符可能不是可解释，并且可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="a47c0-606">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="a47c0-607">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-607">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a47c0-608"><paramref name="path" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-608"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a47c0-609"><paramref name="path" /> 是一个空字符串 ("")，仅包含空格，或者包含一个或多个无效字符。</span><span class="sxs-lookup"><span data-stu-id="a47c0-609"><paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters.</span></span>  
  
<span data-ttu-id="a47c0-610">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-610">-or-</span></span> 
 <span data-ttu-id="a47c0-611"><paramref name="path" /> 指非文件设备，如 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</span><span class="sxs-lookup"><span data-stu-id="a47c0-611"><paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a47c0-612"><paramref name="path" /> 指非文件设备，如非 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</span><span class="sxs-lookup"><span data-stu-id="a47c0-612"><paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a47c0-613"><paramref name="bufferSize" /> 为负数或零。</span><span class="sxs-lookup"><span data-stu-id="a47c0-613"><paramref name="bufferSize" /> is negative or zero.</span></span>  
  
<span data-ttu-id="a47c0-614">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-614">-or-</span></span> 
 <span data-ttu-id="a47c0-615"><paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 包含无效的值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-615"><paramref name="mode" />, <paramref name="access" />, or <paramref name="share" /> contain an invalid value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a47c0-616">找不到该文件。例如，当 <paramref name="mode" /> 是 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，并且 <paramref name="path" /> 指定的文件不存在时会出现这种情况。</span><span class="sxs-lookup"><span data-stu-id="a47c0-616">The file cannot be found, such as when <paramref name="mode" /> is <see langword="FileMode.Truncate" /> or <see langword="FileMode.Open" />, and the file specified by <paramref name="path" /> does not exist.</span></span> <span data-ttu-id="a47c0-617">该文件必须以这些模式存在。</span><span class="sxs-lookup"><span data-stu-id="a47c0-617">The file must already exist in these modes.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="a47c0-618">当前操作系统不是 Windows NT 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="a47c0-618">The current operating system is not Windows NT or later.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-619">I/O 错误，例如在 <see langword="FileMode.CreateNew" /> 指定的文件已存在时指定 <paramref name="path" />，会发生此错误。</span><span class="sxs-lookup"><span data-stu-id="a47c0-619">An I/O error, such as specifying <see langword="FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists, occurred.</span></span>  
  
<span data-ttu-id="a47c0-620">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-620">-or-</span></span> 
<span data-ttu-id="a47c0-621">已关闭流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-621">The stream has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="a47c0-622">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-622">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="a47c0-623">指定的路径无效，例如位于未映射的驱动器上。</span><span class="sxs-lookup"><span data-stu-id="a47c0-623">The specified path is invalid, such as being on an unmapped drive.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a47c0-624">对于指定的 <paramref name="access" />，操作系统不允许所请求的 <paramref name="path" />。例如当 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，并将文件或目录设置为只读访问时会出现此情况。</span><span class="sxs-lookup"><span data-stu-id="a47c0-624">The <paramref name="access" /> requested is not permitted by the operating system for the specified <paramref name="path" />, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file or directory is set for read-only access.</span></span>  
  
<span data-ttu-id="a47c0-625">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-625">-or-</span></span> 
 <span data-ttu-id="a47c0-626"><see cref="F:System.IO.FileOptions.Encrypted" /> 指定用于 <paramref name="options" />，但在当前平台上不支持文件加密。</span><span class="sxs-lookup"><span data-stu-id="a47c0-626"><see cref="F:System.IO.FileOptions.Encrypted" /> is specified for <paramref name="options" />, but file encryption is not supported on the current platform.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="a47c0-627">指定的 <paramref name="path" />、文件名或这两者都超过了系统定义的最大长度。</span><span class="sxs-lookup"><span data-stu-id="a47c0-627">The specified <paramref name="path" />, file name, or both exceed the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="a47c0-628">用于读取、写入和追加到文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-628">for reading, writing, and appending to files.</span></span> <span data-ttu-id="a47c0-629">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-629">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-630">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-630">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-631">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-631">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-632">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-632">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions * System.Security.AccessControl.FileSecurity -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.IO.FileMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="share" Type="System.IO.FileShare" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.FileOptions" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" Index="6" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="a47c0-633">当前 <see cref="T:System.IO.FileStream" /> 对象将封装的文件的相对路径或绝对路径。</span><span class="sxs-lookup"><span data-stu-id="a47c0-633">A relative or absolute path for the file that the current <see cref="T:System.IO.FileStream" /> object will encapsulate.</span></span></param>
        <param name="mode"><span data-ttu-id="a47c0-634">用于确定文件的打开或创建方式的枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="a47c0-634">One of the enumeration values that determines how to open or create the file.</span></span></param>
        <param name="rights"><span data-ttu-id="a47c0-635">枚举值的按位组合，它用于确定在为文件创建访问和审核规则时要使用的访问权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-635">A bitwise combination of the enumeration values that determines the access rights to use when creating access and audit rules for the file.</span></span></param>
        <param name="share"><span data-ttu-id="a47c0-636">枚举值的按位组合，这些枚举值确定进程共享文件的方式。</span><span class="sxs-lookup"><span data-stu-id="a47c0-636">A bitwise combination of the enumeration values that determines how the file will be shared by processes.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="a47c0-637">一个大于零的正 <see cref="T:System.Int32" /> 值，表示缓冲区大小。</span><span class="sxs-lookup"><span data-stu-id="a47c0-637">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span></span> <span data-ttu-id="a47c0-638">默认缓冲区大小为 4096。</span><span class="sxs-lookup"><span data-stu-id="a47c0-638">The default buffer size is 4096.</span></span></param>
        <param name="options"><span data-ttu-id="a47c0-639">枚举值的按位组合，它用于指定其他文件选项。</span><span class="sxs-lookup"><span data-stu-id="a47c0-639">A bitwise combination of the enumeration values that specifies additional file options.</span></span></param>
        <param name="fileSecurity"><span data-ttu-id="a47c0-640">一个对象，用于确定文件的访问控制和审核安全性。</span><span class="sxs-lookup"><span data-stu-id="a47c0-640">An object that determines the access control and audit security for the file.</span></span></param>
        <summary><span data-ttu-id="a47c0-641">使用指定的路径、创建模式、访问权限和共享权限、缓冲区大小、附加文件选项、访问控制和审核安全初始化 <see cref="T:System.IO.FileStream" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a47c0-641">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, access rights and sharing permission, the buffer size, additional file options, access control and audit security.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-642">.NET Framework 不支持通过作为设备名称的路径（如 "\\\\.\PHYSICALDRIVE0"）直接访问物理磁盘。</span><span class="sxs-lookup"><span data-stu-id="a47c0-642">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="a47c0-643">使用此 <xref:System.IO.FileStream.%23ctor%2A> 构造函数在文件创建时应用访问权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-643">Use this <xref:System.IO.FileStream.%23ctor%2A> constructor to apply access rights at the point of creation of a file.</span></span> <span data-ttu-id="a47c0-644">若要访问或修改现有文件的权限，请考虑使用 <xref:System.IO.File.GetAccessControl%2A> 和 <xref:System.IO.File.SetAccessControl%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="a47c0-644">To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.</span></span>  
  
 <span data-ttu-id="a47c0-645">`fileOptions` 参数用于提供对创建 <xref:System.IO.FileStream> 对象时可利用的更高级操作的访问权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-645">The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.</span></span>  
  
 <span data-ttu-id="a47c0-646">`path` 参数可以是文件名，包括通用命名约定（UNC）共享上的文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-646">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a47c0-647">`path` 不需要是存储在磁盘上的文件;它可以是支持通过流进行访问的系统的任何部分。</span><span class="sxs-lookup"><span data-stu-id="a47c0-647">`path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</span></span> <span data-ttu-id="a47c0-648">例如，根据系统，此类可以访问物理设备。</span><span class="sxs-lookup"><span data-stu-id="a47c0-648">For example, depending on the system, this class can access a physical device.</span></span>  
  
 <span data-ttu-id="a47c0-649">对于封装文件的所有 <xref:System.IO.FileStream> 对象 `true` <xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-649"><xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files.</span></span> <span data-ttu-id="a47c0-650">如果 `path` 指示不支持查找的设备，则将 `false`生成的 <xref:System.IO.FileStream> 上的 <xref:System.IO.FileStream.CanSeek%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="a47c0-650">If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`.</span></span> <span data-ttu-id="a47c0-651">有关附加信息，请参见 <xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-651">For additional information, see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a47c0-652">使用特定的区域性设置编译一组字符并使用不同的区域性设置检索这些相同的字符时，这些字符可能不是可解释，并且可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="a47c0-652">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="a47c0-653">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-653">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a47c0-654">下面的示例将数据写入文件，然后使用 <xref:System.IO.FileStream> 对象读取数据。</span><span class="sxs-lookup"><span data-stu-id="a47c0-654">The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.</span></span>  
  
 [!code-cpp[IO.FileStream.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor2/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor2/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor2/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a47c0-655"><paramref name="path" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-655"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a47c0-656"><paramref name="path" /> 是一个空字符串 ("")，仅包含空格，或者包含一个或多个无效字符。</span><span class="sxs-lookup"><span data-stu-id="a47c0-656"><paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters.</span></span>  
  
<span data-ttu-id="a47c0-657">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-657">-or-</span></span> 
 <span data-ttu-id="a47c0-658"><paramref name="path" /> 指非文件设备，如 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</span><span class="sxs-lookup"><span data-stu-id="a47c0-658"><paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a47c0-659"><paramref name="path" /> 指非文件设备，如非 NTFS 环境中的“con:”、“com1:”、“lpt1:”等。</span><span class="sxs-lookup"><span data-stu-id="a47c0-659"><paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a47c0-660"><paramref name="bufferSize" /> 为负数或零。</span><span class="sxs-lookup"><span data-stu-id="a47c0-660"><paramref name="bufferSize" /> is negative or zero.</span></span>  
  
<span data-ttu-id="a47c0-661">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-661">-or-</span></span> 
 <span data-ttu-id="a47c0-662"><paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 包含无效的值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-662"><paramref name="mode" />, <paramref name="access" />, or <paramref name="share" /> contain an invalid value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a47c0-663">找不到该文件。例如，当 <paramref name="mode" /> 是 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，并且 <paramref name="path" /> 指定的文件不存在时会出现这种情况。</span><span class="sxs-lookup"><span data-stu-id="a47c0-663">The file cannot be found, such as when <paramref name="mode" /> is <see langword="FileMode.Truncate" /> or <see langword="FileMode.Open" />, and the file specified by <paramref name="path" /> does not exist.</span></span> <span data-ttu-id="a47c0-664">该文件必须以这些模式存在。</span><span class="sxs-lookup"><span data-stu-id="a47c0-664">The file must already exist in these modes.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-665">I/O 错误，例如在 <see langword="FileMode.CreateNew" /> 指定的文件已存在时指定 <paramref name="path" />，会发生此错误。</span><span class="sxs-lookup"><span data-stu-id="a47c0-665">An I/O error, such as specifying <see langword="FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists, occurred.</span></span>  
  
<span data-ttu-id="a47c0-666">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-666">-or-</span></span> 
<span data-ttu-id="a47c0-667">已关闭流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-667">The stream has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="a47c0-668">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-668">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="a47c0-669">指定的路径无效，例如位于未映射的驱动器上。</span><span class="sxs-lookup"><span data-stu-id="a47c0-669">The specified path is invalid, such as being on an unmapped drive.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a47c0-670">对于指定的 <paramref name="access" />，操作系统不允许所请求的 <paramref name="path" />。例如当 <paramref name="access" /> 是 <see langword="Write" /> 或 <see langword="ReadWrite" />，并将文件或目录设置为只读访问时会出现此情况。</span><span class="sxs-lookup"><span data-stu-id="a47c0-670">The <paramref name="access" /> requested is not permitted by the operating system for the specified <paramref name="path" />, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file or directory is set for read-only access.</span></span>  
  
<span data-ttu-id="a47c0-671">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-671">-or-</span></span> 
 <span data-ttu-id="a47c0-672"><see cref="F:System.IO.FileOptions.Encrypted" /> 指定用于 <paramref name="options" />，但在当前平台上不支持文件加密。</span><span class="sxs-lookup"><span data-stu-id="a47c0-672"><see cref="F:System.IO.FileOptions.Encrypted" /> is specified for <paramref name="options" />, but file encryption is not supported on the current platform.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="a47c0-673">指定的 <paramref name="path" />、文件名或这两者都超过了系统定义的最大长度。</span><span class="sxs-lookup"><span data-stu-id="a47c0-673">The specified <paramref name="path" />, file name, or both exceed the system-defined maximum length.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="a47c0-674">当前操作系统不是 Windows NT 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="a47c0-674">The current operating system is not Windows NT or later.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="a47c0-675">用于读取、写入和追加到文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-675">for reading, writing, and appending to files.</span></span> <span data-ttu-id="a47c0-676">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-676">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-677">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-677">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-678">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-678">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-679">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-679">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginRead (buffer, offset, count, callback, state)" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (array As Byte(), offset As Integer, numBytes As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginRead (array, offset, numBytes, callback, state)" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (array As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginRead (array, offset, numBytes, userCallback, stateObject)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-2.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-2.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="a47c0-680">将数据读入的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="a47c0-680">The buffer to read data into.</span></span></param>
        <param name="buffer"><span data-ttu-id="a47c0-681">将数据读入的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="a47c0-681">The buffer to read data into.</span></span></param>
        <param name="offset"><span data-ttu-id="a47c0-682"><paramref name="array" /> 中的字节偏移量，从此处开始读取。</span><span class="sxs-lookup"><span data-stu-id="a47c0-682">The byte offset in <paramref name="array" /> at which to begin reading.</span></span></param>
        <param name="numBytes"><span data-ttu-id="a47c0-683">最多读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-683">The maximum number of bytes to read.</span></span></param>
        <param name="count"><span data-ttu-id="a47c0-684">最多读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-684">The maximum number of bytes to read.</span></span></param>
        <param name="callback"><span data-ttu-id="a47c0-685">异步读操作完成后调用的方法。</span><span class="sxs-lookup"><span data-stu-id="a47c0-685">The method to be called when the asynchronous read operation is completed.</span></span></param>
        <param name="userCallback"><span data-ttu-id="a47c0-686">异步读操作完成后调用的方法。</span><span class="sxs-lookup"><span data-stu-id="a47c0-686">The method to be called when the asynchronous read operation is completed.</span></span></param>
        <param name="state"><span data-ttu-id="a47c0-687">一个用户提供的对象，它将该特定的异步读取请求与其他请求区别开来。</span><span class="sxs-lookup"><span data-stu-id="a47c0-687">A user-provided object that distinguishes this particular asynchronous read request from other requests.</span></span></param>
        <param name="stateObject"><span data-ttu-id="a47c0-688">一个用户提供的对象，它将该特定的异步读取请求与其他请求区别开来。</span><span class="sxs-lookup"><span data-stu-id="a47c0-688">A user-provided object that distinguishes this particular asynchronous read request from other requests.</span></span></param>
        <summary><span data-ttu-id="a47c0-689">开始异步读操作。</span><span class="sxs-lookup"><span data-stu-id="a47c0-689">Begins an asynchronous read operation.</span></span> <span data-ttu-id="a47c0-690">请考虑改用 <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-690">Consider using <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.</span></span></summary>
        <returns><span data-ttu-id="a47c0-691">引用异步读取的对象。</span><span class="sxs-lookup"><span data-stu-id="a47c0-691">An object that references the asynchronous read.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a47c0-692">数组长度减去 <paramref name="offset" /> 小于 <paramref name="numBytes" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-692">The array length minus <paramref name="offset" /> is less than <paramref name="numBytes" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a47c0-693"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-693"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a47c0-694"><paramref name="offset" /> 或 <paramref name="numBytes" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-694"><paramref name="offset" /> or <paramref name="numBytes" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-695">尝试在文件的末尾后进行异步读取。</span><span class="sxs-lookup"><span data-stu-id="a47c0-695">An asynchronous read was attempted past the end of the file.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginWrite (buffer, offset, count, callback, state)" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (array As Byte(), offset As Integer, numBytes As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginWrite (array, offset, numBytes, callback, state)" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (array As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginWrite (array, offset, numBytes, userCallback, stateObject)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-2.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-2.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="a47c0-696">包含要写入当前流的数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="a47c0-696">The buffer containing data to write to the current stream.</span></span></param>
        <param name="buffer"><span data-ttu-id="a47c0-697">包含要写入当前流的数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="a47c0-697">The buffer containing data to write to the current stream.</span></span></param>
        <param name="offset"><span data-ttu-id="a47c0-698"><paramref name="array" /> 中的从零开始的字节偏移量，从此处开始将字节复制到当前流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-698">The zero-based byte offset in <paramref name="array" /> at which to begin copying bytes to the current stream.</span></span></param>
        <param name="numBytes"><span data-ttu-id="a47c0-699">最多写入的字节数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-699">The maximum number of bytes to write.</span></span></param>
        <param name="count"><span data-ttu-id="a47c0-700">最多写入的字节数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-700">The maximum number of bytes to write.</span></span></param>
        <param name="callback"><span data-ttu-id="a47c0-701">异步写操作完成后调用的方法。</span><span class="sxs-lookup"><span data-stu-id="a47c0-701">The method to be called when the asynchronous write operation is completed.</span></span></param>
        <param name="userCallback"><span data-ttu-id="a47c0-702">异步写操作完成后调用的方法。</span><span class="sxs-lookup"><span data-stu-id="a47c0-702">The method to be called when the asynchronous write operation is completed.</span></span></param>
        <param name="state"><span data-ttu-id="a47c0-703">一个用户提供的对象，它将该特定的异步写入请求与其他请求区别开来。</span><span class="sxs-lookup"><span data-stu-id="a47c0-703">A user-provided object that distinguishes this particular asynchronous write request from other requests.</span></span></param>
        <param name="stateObject"><span data-ttu-id="a47c0-704">一个用户提供的对象，它将该特定的异步写入请求与其他请求区别开来。</span><span class="sxs-lookup"><span data-stu-id="a47c0-704">A user-provided object that distinguishes this particular asynchronous write request from other requests.</span></span></param>
        <summary><span data-ttu-id="a47c0-705">开始异步写操作。</span><span class="sxs-lookup"><span data-stu-id="a47c0-705">Begins an asynchronous write operation.</span></span> <span data-ttu-id="a47c0-706">请考虑改用 <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-706">Consider using <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.</span></span></summary>
        <returns><span data-ttu-id="a47c0-707">引用异步写入的对象。</span><span class="sxs-lookup"><span data-stu-id="a47c0-707">An object that references the asynchronous write.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a47c0-708"><paramref name="array" /> 长度减去 <paramref name="offset" /> 小于 <paramref name="numBytes" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-708"><paramref name="array" /> length minus <paramref name="offset" /> is less than <paramref name="numBytes" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a47c0-709"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-709"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a47c0-710"><paramref name="offset" /> 或 <paramref name="numBytes" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-710"><paramref name="offset" /> or <paramref name="numBytes" /> is negative.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a47c0-711">流不支持写入。</span><span class="sxs-lookup"><span data-stu-id="a47c0-711">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a47c0-712">流已关闭。</span><span class="sxs-lookup"><span data-stu-id="a47c0-712">The stream is closed.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-713">出现 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="a47c0-713">An I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.FileStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a47c0-714">获取一个值，该值指示当前流是否支持读取。</span><span class="sxs-lookup"><span data-stu-id="a47c0-714">Gets a value that indicates whether the current stream supports reading.</span></span></summary>
        <value><span data-ttu-id="a47c0-715">如果流支持读取，则为 <see langword="true" />；如果流已关闭或是通过只写访问方式打开的，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-715"><see langword="true" /> if the stream supports reading; <see langword="false" /> if the stream is closed or was opened with write-only access.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-716">如果从 <xref:System.IO.Stream> 派生的类不支持读取，则对 <xref:System.IO.FileStream.Read%2A>、<xref:System.IO.FileStream.ReadByte%2A>和 <xref:System.IO.FileStream.BeginRead%2A> 方法的调用将引发 <xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-716">If a class derived from <xref:System.IO.Stream> does not support reading, calls to the <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.ReadByte%2A>, and <xref:System.IO.FileStream.BeginRead%2A> methods throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="a47c0-717">如果流已关闭，此属性将返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="a47c0-717">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a47c0-718">下面的示例演示了 `CanRead` 属性的用法。</span><span class="sxs-lookup"><span data-stu-id="a47c0-718">The following example demonstrates a use of the `CanRead` property.</span></span> <span data-ttu-id="a47c0-719">此代码的输出为 "Myfile.txt 不可写。"</span><span class="sxs-lookup"><span data-stu-id="a47c0-719">The output of this code is "MyFile.txt is not writable."</span></span> <span data-ttu-id="a47c0-720">若要获取输出消息 "Myfile.txt 可以写入并读取"，请将 `FileAccess` 参数更改为 `FileStream` 构造函数中 `ReadWrite`。</span><span class="sxs-lookup"><span data-stu-id="a47c0-720">To get the output message "MyFile.txt can be both written to and read from.", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.</span></span>  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-721">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-721">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-722">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-722">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-723">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-723">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.FileStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a47c0-724">获取一个值，该值指示当前流是否支持查找。</span><span class="sxs-lookup"><span data-stu-id="a47c0-724">Gets a value that indicates whether the current stream supports seeking.</span></span></summary>
        <value><span data-ttu-id="a47c0-725">如果流支持查找，则为 <see langword="true" />；如果流已关闭或者如果 <see langword="false" /> 是从操作系统句柄（如管道或到控制台的输出）构造的，则为 <see langword="FileStream" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-725"><see langword="true" /> if the stream supports seeking; <see langword="false" /> if the stream is closed or if the <see langword="FileStream" /> was constructed from an operating-system handle such as a pipe or output to the console.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-726">如果从 <xref:System.IO.Stream> 派生的类不支持查找，则调用 <xref:System.IO.FileStream.Length%2A>、<xref:System.IO.FileStream.SetLength%2A>、<xref:System.IO.FileStream.Position%2A>和 <xref:System.IO.FileStream.Seek%2A> 引发 <xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-726">If a class derived from <xref:System.IO.Stream> does not support seeking, calls to <xref:System.IO.FileStream.Length%2A>, <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Position%2A>, and <xref:System.IO.FileStream.Seek%2A> throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="a47c0-727">如果流已关闭，此属性将返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="a47c0-727">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a47c0-728">下面的示例使用 `CanSeek` 属性检查流是否支持查找。</span><span class="sxs-lookup"><span data-stu-id="a47c0-728">The following example uses the `CanSeek` property to check whether a stream supports seeking.</span></span>  
  
 [!code-cpp[fstream canseek#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanSeek/CPP/fstream canseek.cpp#1)]
 [!code-csharp[fstream canseek#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanSeek/CS/fstream canseek.cs#1)]
 [!code-vb[fstream canseek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanSeek/VB/fstream canseek.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-729">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-729">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-730">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-730">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-731">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-731">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.FileStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a47c0-732">获取一个值，该值指示当前流是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="a47c0-732">Gets a value that indicates whether the current stream supports writing.</span></span></summary>
        <value><span data-ttu-id="a47c0-733">如果流支持写入，则为 <see langword="true" />；如果流已关闭或是通过只读访问方式打开的，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-733"><see langword="true" /> if the stream supports writing; <see langword="false" /> if the stream is closed or was opened with read-only access.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-734">如果从 <xref:System.IO.Stream> 派生的类不支持写入，则对 <xref:System.IO.FileStream.SetLength%2A>、<xref:System.IO.FileStream.Write%2A>、<xref:System.IO.FileStream.BeginWrite%2A>或 <xref:System.IO.FileStream.WriteByte%2A> 的调用将引发 <xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-734">If a class derived from <xref:System.IO.Stream> does not support writing, a call to <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.FileStream.BeginWrite%2A>, or <xref:System.IO.FileStream.WriteByte%2A> throws a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="a47c0-735">如果流已关闭，此属性将返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="a47c0-735">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a47c0-736">下面的示例使用 `CanWrite` 属性检查流是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="a47c0-736">The following example uses the `CanWrite` property to check whether a stream supports writing.</span></span>  
  
 [!code-cpp[fstream canwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanWrite/CPP/fstream canwrite.cpp#1)]
 [!code-csharp[fstream canwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanWrite/CS/fstream canwrite.cs#1)]
 [!code-vb[fstream canwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanWrite/VB/fstream canwrite.vb#1)]  
  
 <span data-ttu-id="a47c0-737">下面是一个使用 `CanWrite` 属性的示例。</span><span class="sxs-lookup"><span data-stu-id="a47c0-737">The following is an example using the `CanWrite` property.</span></span> <span data-ttu-id="a47c0-738">此代码的输出为 "Myfile.txt 是可写的。"</span><span class="sxs-lookup"><span data-stu-id="a47c0-738">The output of this code is "MyFile.txt is writable."</span></span> <span data-ttu-id="a47c0-739">若要获取输出消息 "Myfile.txt 可以写入并读取"，请将 `FileAccess` 参数更改为 `FileStream` 构造函数中 `ReadWrite`。</span><span class="sxs-lookup"><span data-stu-id="a47c0-739">To get the output message "MyFile.txt can be both written to and read from.", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.</span></span>  
  
 [!code-cpp[Classic FileStream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-740">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-740">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-741">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-741">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-742">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-742">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="fileStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a47c0-743">关闭当前流并释放与之关联的所有资源（如套接字和文件句柄）。</span><span class="sxs-lookup"><span data-stu-id="a47c0-743">Closes the current stream and releases any resources (such as sockets and file handles) associated with the current stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a47c0-744">有关此方法的详细信息，请参阅 <xref:System.IO.Stream.Close?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-744">See <xref:System.IO.Stream.Close?displayProperty=nameWithType> for more information about this method.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.CopyToAsync (destination, bufferSize, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a47c0-745">向其中复制当前文件流的内容的流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-745">The stream to which the contents of the current file stream will be copied.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="a47c0-746">缓冲区的大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="a47c0-746">The size, in bytes, of the buffer.</span></span> <span data-ttu-id="a47c0-747">此值必须大于零。</span><span class="sxs-lookup"><span data-stu-id="a47c0-747">This value must be greater than zero.</span></span> <span data-ttu-id="a47c0-748">默认大小为 81920。</span><span class="sxs-lookup"><span data-stu-id="a47c0-748">The default size is 81920.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="a47c0-749">要监视取消请求的标记。</span><span class="sxs-lookup"><span data-stu-id="a47c0-749">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="a47c0-750">默认值是 <see cref="P:System.Threading.CancellationToken.None" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-750">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="a47c0-751">使用指定的缓冲区大小和取消令牌，从当前文件流中异步读取字节并将其写入到另一个流中。</span><span class="sxs-lookup"><span data-stu-id="a47c0-751">Asynchronously reads the bytes from the current file stream and writes them to another stream, using a specified buffer size and cancellation token.</span></span></summary>
        <returns><span data-ttu-id="a47c0-752">表示异步复制操作的任务。</span><span class="sxs-lookup"><span data-stu-id="a47c0-752">A task that represents the asynchronous copy operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a47c0-753">利用 `CopyToAsync` 方法，你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="a47c0-753">The `CopyToAsync` method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="a47c0-754">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="a47c0-754">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="a47c0-755">异步方法与 Visual Basic 和C#中的 `async` 和 `await` 关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="a47c0-755">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="a47c0-756">如果在操作完成前取消该操作，则返回的任务将包含 <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithType> 属性的 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-756">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithType> property.</span></span>

<span data-ttu-id="a47c0-757">复制从当前文件流中的当前位置开始。</span><span class="sxs-lookup"><span data-stu-id="a47c0-757">Copying begins at the current position in the current file stream.</span></span>

<span data-ttu-id="a47c0-758">有关在两个流之间进行复制的示例，请参阅 <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> 重载。</span><span class="sxs-lookup"><span data-stu-id="a47c0-758">For an example of copying between two streams, see the <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> overload.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileStream.Dispose disposing" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="fileStream.Dispose disposing" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="a47c0-759">如果为 <see langword="true" />，则托管及非托管资源都释放；如果为 <see langword="false" />，则仅释放非托管资源。</span><span class="sxs-lookup"><span data-stu-id="a47c0-759"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="a47c0-760">释放 <see cref="T:System.IO.FileStream" /> 使用的非托管资源并选择性地释放托管资源。</span><span class="sxs-lookup"><span data-stu-id="a47c0-760">Releases the unmanaged resources used by the <see cref="T:System.IO.FileStream" /> and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-761">此方法由 public <xref:System.ComponentModel.Component.Dispose%2A> 方法和 <xref:System.Object.Finalize%2A> 方法调用。</span><span class="sxs-lookup"><span data-stu-id="a47c0-761">This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="a47c0-762"><xref:System.ComponentModel.Component.Dispose%2A> 调用受保护的 <xref:System.IO.FileStream.Dispose%2A> 方法，并将 `disposing` 参数设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="a47c0-762"><xref:System.ComponentModel.Component.Dispose%2A> invokes the protected <xref:System.IO.FileStream.Dispose%2A> method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="a47c0-763"><xref:System.Object.Finalize%2A> 调用 `disposing` 设置为 `false`的 <xref:System.IO.FileStream.Dispose%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-763"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.FileStream.Dispose%2A> with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="a47c0-764">当 `disposing` 参数为 `true` 时，此方法释放该 <xref:System.IO.FileStream> 引用的、由任何托管对象持有的全部资源。</span><span class="sxs-lookup"><span data-stu-id="a47c0-764">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.IO.FileStream> references.</span></span> <span data-ttu-id="a47c0-765">此方法将调用每个被引用对象的 <xref:System.ComponentModel.Component.Dispose%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="a47c0-765">This method invokes the <xref:System.ComponentModel.Component.Dispose%2A> method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="a47c0-766">
            <see cref="M:System.ComponentModel.Component.Dispose" /> 可以由其他对象多次调用。</span><span class="sxs-lookup"><span data-stu-id="a47c0-766">
            <see cref="M:System.ComponentModel.Component.Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="a47c0-767"><see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /> 重写时，请注意不要引用先前在调用 <see cref="M:System.ComponentModel.Component.Dispose" />之前已释放的对象。</span><span class="sxs-lookup"><span data-stu-id="a47c0-767">When overriding <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /> be careful not to reference objects that have been previously disposed of in an earlier call to <see cref="M:System.ComponentModel.Component.Dispose" />.</span></span> <span data-ttu-id="a47c0-768">有关如何实现 <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />的详细信息，请参阅[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-768">For more information about how to implement <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
<span data-ttu-id="a47c0-769">有关 <see cref="M:System.ComponentModel.Component.Dispose" /> 和 <see cref="M:System.Object.Finalize" />的详细信息，请参阅[清理非托管资源](~/docs/standard/garbage-collection/unmanaged.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-769">For more information about <see cref="M:System.ComponentModel.Component.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span></para></block>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-770">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-770">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-771">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-771">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-772">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-772">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DisposeAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask DisposeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask DisposeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.DisposeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DisposeAsync () As ValueTask" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::ValueTask DisposeAsync();" />
      <MemberSignature Language="F#" Value="override this.DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask" Usage="fileStream.DisposeAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a47c0-773">异步释放 <see cref="T:System.IO.FileStream" /> 使用的非托管资源。</span><span class="sxs-lookup"><span data-stu-id="a47c0-773">Asynchronously releases the unmanaged resources used by the <see cref="T:System.IO.FileStream" />.</span></span></summary>
        <returns><span data-ttu-id="a47c0-774">一个表示异步释放操作的任务。</span><span class="sxs-lookup"><span data-stu-id="a47c0-774">A task that represents the asynchronous dispose operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="a47c0-775">利用 `DisposeAsync` 方法，您可以在不阻塞主线程的情况下执行占用大量资源的释放操作。</span><span class="sxs-lookup"><span data-stu-id="a47c0-775">The `DisposeAsync` method lets you perform a resource-intensive dispose operation without blocking the main thread.</span></span> <span data-ttu-id="a47c0-776">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="a47c0-776">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="a47c0-777">异步方法与 Visual Basic 和C#中的 `async` 和 `await` 关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="a47c0-777">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="a47c0-778">此方法通过将任何更改写入后备存储并关闭流以释放资源来释放流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-778">This method disposes the stream by writing any changes to the backing store and closing the stream to release resources.</span></span>

<span data-ttu-id="a47c0-779">调用 `DisposeAsync` 允许出于其他目的重新分配 <xref:System.IO.FileStream> 所使用的资源。</span><span class="sxs-lookup"><span data-stu-id="a47c0-779">Calling `DisposeAsync` allows the resources used by the <xref:System.IO.FileStream> to be reallocated for other purposes.</span></span> <span data-ttu-id="a47c0-780">有关详细信息，请参阅[清理非托管资源](~/docs/standard/garbage-collection/unmanaged.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-780">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="fileStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="a47c0-781">对所等待的挂起异步请求的引用。</span><span class="sxs-lookup"><span data-stu-id="a47c0-781">The reference to the pending asynchronous request to wait for.</span></span></param>
        <summary><span data-ttu-id="a47c0-782">等待挂起的异步读操作完成。</span><span class="sxs-lookup"><span data-stu-id="a47c0-782">Waits for the pending asynchronous read operation to complete.</span></span> <span data-ttu-id="a47c0-783">（请考虑改用 <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />。）</span><span class="sxs-lookup"><span data-stu-id="a47c0-783">(Consider using <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span></span></summary>
        <returns><span data-ttu-id="a47c0-784">从流中读取的字节数，介于 0 和所请求的字节数之间。</span><span class="sxs-lookup"><span data-stu-id="a47c0-784">The number of bytes read from the stream, between 0 and the number of bytes you requested.</span></span> <span data-ttu-id="a47c0-785">流仅在流结尾返回 0，否则在至少有 1 个字节可用之前应一直进行阻止。</span><span class="sxs-lookup"><span data-stu-id="a47c0-785">Streams only return 0 at the end of the stream, otherwise, they should block until at least 1 byte is available.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-786">在 .NET Framework 4 及更早版本中，必须使用 <xref:System.IO.FileStream.BeginRead%2A> 和 <xref:System.IO.FileStream.EndRead%2A> 等方法来实现异步文件操作。</span><span class="sxs-lookup"><span data-stu-id="a47c0-786">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.FileStream.BeginRead%2A> and <xref:System.IO.FileStream.EndRead%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="a47c0-787">这些方法在 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 仍可用以支持旧版代码;但是，新的异步方法（如 <xref:System.IO.FileStream.ReadAsync%2A>、<xref:System.IO.FileStream.WriteAsync%2A>、<xref:System.IO.Stream.CopyToAsync%2A>和 <xref:System.IO.FileStream.FlushAsync%2A>）可帮助你更轻松地实现异步文件操作。</span><span class="sxs-lookup"><span data-stu-id="a47c0-787">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.FileStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="a47c0-788">对于每次调用 <xref:System.IO.FileStream.BeginRead%2A>，都必须调用 <xref:System.IO.FileStream.EndRead%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-788"><xref:System.IO.FileStream.EndRead%2A> must be called exactly for every call to <xref:System.IO.FileStream.BeginRead%2A>.</span></span> <span data-ttu-id="a47c0-789">在开始另一次读取之前未能结束读取进程可能会导致意外行为，如死锁。</span><span class="sxs-lookup"><span data-stu-id="a47c0-789">Failing to end a read process before beginning another read can cause undesirable behavior such as deadlock.</span></span>  
  
 <span data-ttu-id="a47c0-790">此方法重写 <xref:System.IO.Stream.EndRead%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-790">This method overrides <xref:System.IO.Stream.EndRead%2A>.</span></span>  
  
 <span data-ttu-id="a47c0-791">可以从 <xref:System.IO.FileStream.BeginRead%2A>对每个 <xref:System.IAsyncResult> 调用 <xref:System.IO.FileStream.EndRead%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-791"><xref:System.IO.FileStream.EndRead%2A> can be called on every <xref:System.IAsyncResult> from <xref:System.IO.FileStream.BeginRead%2A>.</span></span> <span data-ttu-id="a47c0-792">调用 <xref:System.IO.FileStream.EndRead%2A> 说明从流中读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-792">Calling <xref:System.IO.FileStream.EndRead%2A> tells you how many bytes were read from the stream.</span></span> <span data-ttu-id="a47c0-793">在 i/o 操作完成之前，将阻止 <xref:System.IO.FileStream.EndRead%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-793"><xref:System.IO.FileStream.EndRead%2A> will block until the I/O operation has completed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a47c0-794">此代码示例是为 <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> 构造函数提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="a47c0-794">This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.</span></span>  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a47c0-795"><paramref name="asyncResult" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-795"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a47c0-796">此 <see cref="T:System.IAsyncResult" /> 对象不是通过对该类调用 <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 来创建的。</span><span class="sxs-lookup"><span data-stu-id="a47c0-796">This <see cref="T:System.IAsyncResult" /> object was not created by calling <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> on this class.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a47c0-797">多次调用了 <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-797"><see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /> is called multiple times.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-798">流已关闭或出现了内部错误。</span><span class="sxs-lookup"><span data-stu-id="a47c0-798">The stream is closed or an internal error has occurred.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-799">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-799">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-800">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-800">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-801">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-801">How to: Write Text to a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md"><span data-ttu-id="a47c0-802">异步文件 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-802">Asynchronous File I/O</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="fileStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="a47c0-803">挂起的异步 I/O 请求。</span><span class="sxs-lookup"><span data-stu-id="a47c0-803">The pending asynchronous I/O request.</span></span></param>
        <summary><span data-ttu-id="a47c0-804">结束异步写入操作，在 I/O 操作完成之前一直阻止。</span><span class="sxs-lookup"><span data-stu-id="a47c0-804">Ends an asynchronous write operation and blocks until the I/O operation is complete.</span></span> <span data-ttu-id="a47c0-805">（请考虑改用 <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />。）</span><span class="sxs-lookup"><span data-stu-id="a47c0-805">(Consider using <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-806">在 .NET Framework 4 及更早版本中，必须使用 <xref:System.IO.FileStream.BeginWrite%2A> 和 <xref:System.IO.FileStream.EndWrite%2A> 等方法来实现异步文件操作。</span><span class="sxs-lookup"><span data-stu-id="a47c0-806">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.FileStream.BeginWrite%2A> and <xref:System.IO.FileStream.EndWrite%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="a47c0-807">这些方法在 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 仍可用以支持旧版代码;但是，新的异步方法（如 <xref:System.IO.FileStream.ReadAsync%2A>、<xref:System.IO.FileStream.WriteAsync%2A>、<xref:System.IO.Stream.CopyToAsync%2A>和 <xref:System.IO.FileStream.FlushAsync%2A>）可帮助你更轻松地实现异步文件操作。</span><span class="sxs-lookup"><span data-stu-id="a47c0-807">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.FileStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="a47c0-808">此方法重写 <xref:System.IO.Stream.EndWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-808">This method overrides <xref:System.IO.Stream.EndWrite%2A>.</span></span>  
  
 <span data-ttu-id="a47c0-809">必须对 <xref:System.IO.FileStream.BeginWrite%2A>每个 <xref:System.IAsyncResult> 只调用一次 <xref:System.IO.FileStream.EndWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-809"><xref:System.IO.FileStream.EndWrite%2A> must be called exactly once on every <xref:System.IAsyncResult> from <xref:System.IO.FileStream.BeginWrite%2A>.</span></span> <span data-ttu-id="a47c0-810">在 i/o 操作完成之前，将阻止 <xref:System.IO.FileStream.EndWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-810"><xref:System.IO.FileStream.EndWrite%2A> will block until the I/O operation has completed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a47c0-811">此代码示例是为 <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> 构造函数提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="a47c0-811">This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.</span></span>  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a47c0-812"><paramref name="asyncResult" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-812"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a47c0-813">此 <see cref="T:System.IAsyncResult" /> 对象不是通过对该类调用 <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 来创建的。</span><span class="sxs-lookup"><span data-stu-id="a47c0-813">This <see cref="T:System.IAsyncResult" /> object was not created by calling <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> on this class.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a47c0-814">多次调用了 <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-814"><see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /> is called multiple times.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-815">流已关闭或出现了内部错误。</span><span class="sxs-lookup"><span data-stu-id="a47c0-815">The stream is closed or an internal error has occurred.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-816">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-816">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-817">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-817">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-818">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-818">How to: Write Text to a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md"><span data-ttu-id="a47c0-819">异步文件 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-819">Asynchronous File I/O</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileStream ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileStream.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a47c0-820">确保垃圾回收器回收 <see langword="FileStream" /> 时释放资源并执行其他清理操作。</span><span class="sxs-lookup"><span data-stu-id="a47c0-820">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see langword="FileStream" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-821">当当前对象准备好完成时，垃圾回收器将调用 `Finalize`。</span><span class="sxs-lookup"><span data-stu-id="a47c0-821">The garbage collector calls `Finalize` when the current object is ready to be finalized.</span></span> <span data-ttu-id="a47c0-822">`Finalize` 关闭 `FileStream`。</span><span class="sxs-lookup"><span data-stu-id="a47c0-822">`Finalize` closes the `FileStream`.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-823">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-823">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-824">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-824">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-825">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-825">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a47c0-826">清除此流的缓冲区，使得所有缓冲数据都写入到文件中。</span><span class="sxs-lookup"><span data-stu-id="a47c0-826">Clears buffers for this stream and causes any buffered data to be written to the file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="fileStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a47c0-827">清除此流的缓冲区，使得所有缓冲数据都写入到文件中。</span><span class="sxs-lookup"><span data-stu-id="a47c0-827">Clears buffers for this stream and causes any buffered data to be written to the file.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-828">此方法重写 <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-828">This method overrides <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="a47c0-829">调用 <xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType> 方法时，也会刷新操作系统 i/o 缓冲区。</span><span class="sxs-lookup"><span data-stu-id="a47c0-829">When you call the <xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType> method, the operating system I/O buffer is also flushed.</span></span>  
  
 <span data-ttu-id="a47c0-830">除非显式调用对象 <xref:System.IO.FileStream.Flush%2A> 或释放，否则不会刷新流的编码器。</span><span class="sxs-lookup"><span data-stu-id="a47c0-830">A stream's encoder is not flushed unless you explicitly call <xref:System.IO.FileStream.Flush%2A> or dispose of the object.</span></span> <span data-ttu-id="a47c0-831">将 <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> 设置为 `true` 表示将数据从缓冲区刷新到流，但编码器状态不会被刷新。</span><span class="sxs-lookup"><span data-stu-id="a47c0-831">Setting <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> to `true` means that data will be flushed from the buffer to the stream, but the encoder state will not be flushed.</span></span> <span data-ttu-id="a47c0-832">这允许编码器保留其状态（部分字符），以使其能够正确编码下一个字符块。</span><span class="sxs-lookup"><span data-stu-id="a47c0-832">This allows the encoder to keep its state (partial characters) so that it can encode the next block of characters correctly.</span></span> <span data-ttu-id="a47c0-833">此方案影响 UTF8 和 UTF7，其中某些字符只能在编码器接收到相邻字符后编码。</span><span class="sxs-lookup"><span data-stu-id="a47c0-833">This scenario affects UTF8 and UTF7 where certain characters can only be encoded after the encoder receives the adjacent character or characters.</span></span>  
  
 <span data-ttu-id="a47c0-834">由于缓冲区可用于读取或写入，因此 <xref:System.IO.FileStream.Flush> 执行以下两个函数：</span><span class="sxs-lookup"><span data-stu-id="a47c0-834">Because a buffer can be used for either reading or writing, <xref:System.IO.FileStream.Flush> performs the following two functions:</span></span>  
  
-   <span data-ttu-id="a47c0-835">先前写入缓冲区的任何数据都将复制到该文件中，并且除其编码器状态外，还会清除该缓冲区。</span><span class="sxs-lookup"><span data-stu-id="a47c0-835">Any data previously written to the buffer is copied to the file and the buffer is cleared except for its encoder state.</span></span>  
  
-   <span data-ttu-id="a47c0-836">如果 <xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType> `true` 并且数据以前已从文件复制到缓冲区中进行读取，则文件中的当前位置将减少缓冲区中的未读字节数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-836">If <xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType> is `true` and data was previously copied from the file to the buffer for reading, the current position within the file is decremented by the number of unread bytes in the buffer.</span></span> <span data-ttu-id="a47c0-837">然后，将清除该缓冲区。</span><span class="sxs-lookup"><span data-stu-id="a47c0-837">The buffer is then cleared.</span></span>  
  
 <span data-ttu-id="a47c0-838">若要确保将中间文件缓冲区中的所有缓冲数据写入磁盘，请使用 <xref:System.IO.FileStream.Flush%28System.Boolean%29> 方法重载。</span><span class="sxs-lookup"><span data-stu-id="a47c0-838">Use the <xref:System.IO.FileStream.Flush%28System.Boolean%29> method overload when you want to ensure that all buffered data in intermediate file buffers is written to disk.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a47c0-839">此代码示例是为 <xref:System.IO.FileStream.Lock%2A> 方法提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="a47c0-839">This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.</span></span>  
  
 [!code-cpp[System.IO.FileStream3#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#4)]
 [!code-csharp[System.IO.FileStream3#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#4)]
 [!code-vb[System.IO.FileStream3#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-840">出现 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="a47c0-840">An I/O error occurred.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a47c0-841">流已关闭。</span><span class="sxs-lookup"><span data-stu-id="a47c0-841">The stream is closed.</span></span></exception>
        <altmember cref="M:System.IO.FileStream.Flush(System.Boolean)" />
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-842">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-842">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public virtual void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Flush (flushToDisk As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Flush(bool flushToDisk);" />
      <MemberSignature Language="F#" Value="override this.Flush : bool -&gt; unit" Usage="fileStream.Flush flushToDisk" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="flushToDisk"><span data-ttu-id="a47c0-843">如果刷新所有中间文件缓冲区，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-843"><see langword="true" /> to flush all intermediate file buffers; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="a47c0-844">清除此流的缓冲区，将所有缓冲数据都写入到文件中，并且也清除所有中间文件缓冲区。</span><span class="sxs-lookup"><span data-stu-id="a47c0-844">Clears buffers for this stream and causes any buffered data to be written to the file, and also clears all intermediate file buffers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-845">若要确保将中间文件缓冲区中的所有缓冲数据写入磁盘，请使用此重载。</span><span class="sxs-lookup"><span data-stu-id="a47c0-845">Use this overload when you want to ensure that all buffered data in intermediate file buffers is written to disk.</span></span>  
  
 <span data-ttu-id="a47c0-846">调用 <xref:System.IO.FileStream.Flush%2A> 方法时，也会刷新操作系统 i/o 缓冲区。</span><span class="sxs-lookup"><span data-stu-id="a47c0-846">When you call the <xref:System.IO.FileStream.Flush%2A> method, the operating system I/O buffer is also flushed.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileStream.Flush" />
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="a47c0-847">要监视取消请求的标记。</span><span class="sxs-lookup"><span data-stu-id="a47c0-847">The token to monitor for cancellation requests.</span></span></param>
        <summary><span data-ttu-id="a47c0-848">异步清理此流的所有缓冲区，导致所有缓冲数据都写入基础设备，并且监控取消请求。</span><span class="sxs-lookup"><span data-stu-id="a47c0-848">Asynchronously clears all buffers for this stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="a47c0-849">表示异步刷新操作的任务。</span><span class="sxs-lookup"><span data-stu-id="a47c0-849">A task that represents the asynchronous flush operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-850">如果在操作完成前取消该操作，则返回的任务将包含 <xref:System.Threading.Tasks.Task.Status%2A> 属性的 <xref:System.Threading.Tasks.TaskStatus.Canceled> 值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-850">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span> <span data-ttu-id="a47c0-851">如果释放了文件的句柄，则返回的任务将在 <xref:System.Threading.Tasks.Task.Exception%2A> 属性中包含 <xref:System.ObjectDisposedException> 异常。</span><span class="sxs-lookup"><span data-stu-id="a47c0-851">If the handle to the file is disposed, the returned task contains the <xref:System.ObjectDisposedException> exception in the <xref:System.Threading.Tasks.Task.Exception%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a47c0-852">已释放流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-852">The stream has been disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md"><span data-ttu-id="a47c0-853">取消</span><span class="sxs-lookup"><span data-stu-id="a47c0-853">Cancellation</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.FileSecurity" Usage="fileStream.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a47c0-854">获取 <see cref="T:System.Security.AccessControl.FileSecurity" /> 对象，该对象封装当前 <see cref="T:System.IO.FileStream" /> 对象所描述的文件的访问控制列表 (ACL) 项。</span><span class="sxs-lookup"><span data-stu-id="a47c0-854">Gets a <see cref="T:System.Security.AccessControl.FileSecurity" /> object that encapsulates the access control list (ACL) entries for the file described by the current <see cref="T:System.IO.FileStream" /> object.</span></span></summary>
        <returns><span data-ttu-id="a47c0-855">一个对象，该对象封装当前 <see cref="T:System.IO.FileStream" /> 对象所描述的文件的访问控制设置。</span><span class="sxs-lookup"><span data-stu-id="a47c0-855">An object that encapsulates the access control settings for the file described by the current <see cref="T:System.IO.FileStream" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-856">虽然 <xref:System.IO.FileStream> 类和 <xref:System.IO.FileStream.GetAccessControl%2A> 可用于检索现有文件的访问控制列表（ACL）项，但请考虑使用 <xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType> 方法，因为它更易于使用。</span><span class="sxs-lookup"><span data-stu-id="a47c0-856">While the <xref:System.IO.FileStream> class and <xref:System.IO.FileStream.GetAccessControl%2A> can be used to retrieve the access control list (ACL) entries of an existing file, consider using <xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType> method, as it is easier to use.</span></span>  
  
 <span data-ttu-id="a47c0-857">使用 <xref:System.IO.FileStream.GetAccessControl%2A> 方法可以检索文件的 ACL 项。</span><span class="sxs-lookup"><span data-stu-id="a47c0-857">Use the <xref:System.IO.FileStream.GetAccessControl%2A> method to retrieve the ACL entries for a file.</span></span>  
  
 <span data-ttu-id="a47c0-858">ACL 描述对给定文件具有或没有特定操作权限的个人和/或组。</span><span class="sxs-lookup"><span data-stu-id="a47c0-858">An ACL describes individuals and/or groups who have, or do not have, rights to specific actions on the given file.</span></span> <span data-ttu-id="a47c0-859">有关详细信息，请参阅[如何：添加或移除访问控制列表项](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-859">For more information, see [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a47c0-860">文件关闭。</span><span class="sxs-lookup"><span data-stu-id="a47c0-860">The file is closed.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-861">打开文件时发生 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="a47c0-861">An I/O error occurred while opening the file.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="a47c0-862">找不到文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-862">The file could not be found.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a47c0-863">当前平台不支持此操作。</span><span class="sxs-lookup"><span data-stu-id="a47c0-863">This operation is not supported on the current platform.</span></span>  
  
 <span data-ttu-id="a47c0-864">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-864">-or-</span></span>  
  
 <span data-ttu-id="a47c0-865">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-865">The caller does not have the required permission.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.IO.FileStream.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use SafeFileHandle instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a47c0-866">获取当前 <see langword="FileStream" /> 对象所封装文件的操作系统文件句柄。</span><span class="sxs-lookup"><span data-stu-id="a47c0-866">Gets the operating system file handle for the file that the current <see langword="FileStream" /> object encapsulates.</span></span></summary>
        <value><span data-ttu-id="a47c0-867">此 <see langword="FileStream" /> 对象所封装文件的操作系统文件句柄；如果 <see langword="FileStream" /> 已关闭，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="a47c0-867">The operating system file handle for the file encapsulated by this <see langword="FileStream" /> object, or -1 if the <see langword="FileStream" /> has been closed.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-868">此属性是用于操作系统提供的系统调用（如 Windows `ReadFile`）的操作系统句柄。</span><span class="sxs-lookup"><span data-stu-id="a47c0-868">This property is an operating system handle for use with operating-system-provided system calls (such as `ReadFile` on Windows).</span></span> <span data-ttu-id="a47c0-869">它不会与需要文件描述符的 C 库函数（如 `fread`）一起使用。</span><span class="sxs-lookup"><span data-stu-id="a47c0-869">It will not work with C library functions that expect a file descriptor, such as `fread`.</span></span>  
  
 <span data-ttu-id="a47c0-870">操作系统句柄可能已同步或异步打开，具体取决于调用了哪个 `FileStream` 构造函数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-870">The operating system handle might have been opened synchronously or asynchronously, depending on which `FileStream` constructor was called.</span></span> <span data-ttu-id="a47c0-871">使用 <xref:System.IO.FileStream.IsAsync%2A> 属性来发现此句柄是否已异步打开。</span><span class="sxs-lookup"><span data-stu-id="a47c0-871">Use the <xref:System.IO.FileStream.IsAsync%2A> property to discover whether this handle was opened asynchronously.</span></span> <span data-ttu-id="a47c0-872">在 Win32 中，这意味着打开了重叠 IO 的句柄，需要不同的参数来 `ReadFile` 和 `WriteFile`。</span><span class="sxs-lookup"><span data-stu-id="a47c0-872">In Win32, this means the handle was opened for overlapped IO, and it requires different parameters to `ReadFile` and `WriteFile`.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a47c0-873">如果创建了一个 `FileStream`，传递了其句柄，某些操作将移动句柄的文件指针，然后再次使用 `FileStream`，则可能发生数据损坏。</span><span class="sxs-lookup"><span data-stu-id="a47c0-873">Data corruption might occur if a `FileStream` is created, its handle is passed, some operation moves the handle's file pointer, and then the `FileStream` is used again.</span></span> <span data-ttu-id="a47c0-874">多个线程无法同时安全地写入同一文件，`FileStream` 缓冲代码假定它以独占方式控制句柄。</span><span class="sxs-lookup"><span data-stu-id="a47c0-874">Multiple threads cannot safely write to the same file simultaneously, and `FileStream` buffering code assumes that it exclusively controls the handle.</span></span> <span data-ttu-id="a47c0-875">如果 `FileStream` 检测到其他进程已移动文件指针，`FileStream` 可能会引发 <xref:System.IO.IOException>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-875">`FileStream` might throw an <xref:System.IO.IOException> if `FileStream` detects that some other process has moved the file pointer.</span></span> <span data-ttu-id="a47c0-876">若要避免这种情况，请不要将任何数据写入到 `FileStream` 可能已缓冲的部分文件中，然后将文件指针还原到 `FileStream`上最后一次调用方法时所处的位置。</span><span class="sxs-lookup"><span data-stu-id="a47c0-876">To avoid this, do not write any data into a portion of the file that `FileStream` might have buffered, and restore the file pointer to the location it had when methods were last called on `FileStream`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="a47c0-877">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-877">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="a47c0-878">用于访问非托管代码的能力。</span><span class="sxs-lookup"><span data-stu-id="a47c0-878">for the ability to access unmanaged code.</span></span> <span data-ttu-id="a47c0-879">关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> 安全操作： <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-879">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> Security action: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="a47c0-880">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="a47c0-880">requires full trust for the immediate caller.</span></span> <span data-ttu-id="a47c0-881">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="a47c0-881">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-882">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-882">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-883">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-883">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-884">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-884">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public virtual bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAsync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool" Usage="System.IO.FileStream.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a47c0-885">获取一个值，它指示 <see langword="FileStream" /> 是异步打开还是同步打开的。</span><span class="sxs-lookup"><span data-stu-id="a47c0-885">Gets a value that indicates whether the <see langword="FileStream" /> was opened asynchronously or synchronously.</span></span></summary>
        <value><span data-ttu-id="a47c0-886">如果 <see langword="true" /> 是异步打开的，则为 <see langword="FileStream" />，否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-886"><see langword="true" /> if the <see langword="FileStream" /> was opened asynchronously; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-887">`IsAsync` 属性检测是否异步打开了 `FileStream` 句柄，使代码可以正确使用 <xref:System.IO.FileStream.Handle%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="a47c0-887">The `IsAsync` property detects whether the `FileStream` handle was opened asynchronously, enabling your code to use the <xref:System.IO.FileStream.Handle%2A> property correctly.</span></span> <span data-ttu-id="a47c0-888">在 Win32 中，`IsAsync` 为 true 意味着句柄是针对重叠 i/o 打开的，因此需要不同的参数来 `ReadFile` 和 `WriteFile`。</span><span class="sxs-lookup"><span data-stu-id="a47c0-888">In Win32, `IsAsync` being true means the handle was opened for overlapped I/O, and thus requires different parameters to `ReadFile` and `WriteFile`.</span></span>  
  
 <span data-ttu-id="a47c0-889">使用具有 `isAsync`、`useAsync`或 `options` 参数的构造函数创建 <xref:System.IO.FileStream> 类的实例时，可以指定此值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-889">You specify this value when you create an instance of the <xref:System.IO.FileStream> class using a constructor that has an `isAsync`, `useAsync`, or `options` parameter.</span></span> <span data-ttu-id="a47c0-890">如果 `true`属性，则流将使用重叠的 i/o 以异步方式执行文件操作。</span><span class="sxs-lookup"><span data-stu-id="a47c0-890">When the property is `true`, the stream utilizes overlapped I/O to perform file operations asynchronously.</span></span> <span data-ttu-id="a47c0-891">不过，不必 `true` <xref:System.IO.FileStream.IsAsync%2A> 属性来调用 <xref:System.IO.FileStream.ReadAsync%2A>、<xref:System.IO.FileStream.WriteAsync%2A>或 <xref:System.IO.Stream.CopyToAsync%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="a47c0-891">However, the <xref:System.IO.FileStream.IsAsync%2A> property does not have to be `true` to call the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, or <xref:System.IO.Stream.CopyToAsync%2A> method.</span></span> <span data-ttu-id="a47c0-892">当 `false` <xref:System.IO.FileStream.IsAsync%2A> 属性并且调用异步读写操作时，UI 线程仍不会被阻止，但实际的 i/o 操作将以同步方式执行。</span><span class="sxs-lookup"><span data-stu-id="a47c0-892">When the <xref:System.IO.FileStream.IsAsync%2A> property is `false` and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a47c0-893">此代码示例是为 <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> 构造函数提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="a47c0-893">This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.</span></span>  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-894">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-894">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-895">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-895">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-896">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-896">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.FileStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a47c0-897">获取流的长度（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="a47c0-897">Gets the length in bytes of the stream.</span></span></summary>
        <value><span data-ttu-id="a47c0-898">表示流长度（以字节为单位）的长值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-898">A long value representing the length of the stream in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-899">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-899">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a47c0-900">下面的示例使用 `Length` 和 `Position` 属性检查文件尾条件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-900">The following example uses the `Length` and `Position` properties to check for an end-of-file condition.</span></span>  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a47c0-901">此流的 <see cref="P:System.IO.FileStream.CanSeek" /> 为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-901"><see cref="P:System.IO.FileStream.CanSeek" /> for this stream is <see langword="false" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-902">出现 I/O 错误，例如文件被关闭。</span><span class="sxs-lookup"><span data-stu-id="a47c0-902">An I/O error, such as the file being closed, occurred.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-903">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-903">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-904">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-904">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-905">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-905">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public virtual void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Lock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Lock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Lock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Lock : int64 * int64 -&gt; unit&#xA;override this.Lock : int64 * int64 -&gt; unit" Usage="fileStream.Lock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="length" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="position"><span data-ttu-id="a47c0-906">要锁定的范围的起始处。</span><span class="sxs-lookup"><span data-stu-id="a47c0-906">The beginning of the range to lock.</span></span> <span data-ttu-id="a47c0-907">此参数的值必须大于或等于零 (0)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-907">The value of this parameter must be equal to or greater than zero (0).</span></span></param>
        <param name="length"><span data-ttu-id="a47c0-908">要锁定的范围。</span><span class="sxs-lookup"><span data-stu-id="a47c0-908">The range to be locked.</span></span></param>
        <summary><span data-ttu-id="a47c0-909">防止其他进程读取或写入 <see cref="T:System.IO.FileStream" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-909">Prevents other processes from reading from or writing to the <see cref="T:System.IO.FileStream" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-910">锁定文件流范围将使锁定进程的线程独占访问该文件流的范围。</span><span class="sxs-lookup"><span data-stu-id="a47c0-910">Locking a range of a file stream gives the threads of the locking process exclusive access to that range of the file stream.</span></span>  
  
 <span data-ttu-id="a47c0-911">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-911">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a47c0-912">下面的代码示例演示如何锁定部分文件，以便其他进程即使对文件具有读/写访问权限，也无法访问该文件的该部分。</span><span class="sxs-lookup"><span data-stu-id="a47c0-912">The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file.</span></span> <span data-ttu-id="a47c0-913">在不同的命令窗口中同时运行程序，并使用不同的控制台输入选项进行调查。</span><span class="sxs-lookup"><span data-stu-id="a47c0-913">Run the program simultaneously in different command windows and investigate using the different console input options.</span></span>  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a47c0-914"><paramref name="position" /> 或 <paramref name="length" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-914"><paramref name="position" /> or <paramref name="length" /> is negative.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a47c0-915">文件关闭。</span><span class="sxs-lookup"><span data-stu-id="a47c0-915">The file is closed.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-916">另一个进程已锁定了文件的一部分，因此进程无法访问该文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-916">The process cannot access the file because another process has locked a portion of the file.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-917">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-917">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-918">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-918">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-919">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-919">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.FileStream.Name" />
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a47c0-920">获取 <see langword="FileStream" /> 中已打开的文件的绝对路径。</span><span class="sxs-lookup"><span data-stu-id="a47c0-920">Gets the absolute path of the file opened in the <see langword="FileStream" />.</span></span></summary>
        <value><span data-ttu-id="a47c0-921">一个字符串，它是文件的绝对路径。</span><span class="sxs-lookup"><span data-stu-id="a47c0-921">A string that is the absolute path of the file.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="a47c0-922">如果绝对路径未知，则此属性返回的字符串类似于 "[Unknown]"。</span><span class="sxs-lookup"><span data-stu-id="a47c0-922">If the absolute path is not known, this property returns a string similar to "[Unknown]".</span></span>

 <span data-ttu-id="a47c0-923">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-923">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a47c0-924">此代码示例是为 <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> 构造函数提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="a47c0-924">This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.</span></span>  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="a47c0-925">用于访问路径。</span><span class="sxs-lookup"><span data-stu-id="a47c0-925">for access to the path.</span></span> <span data-ttu-id="a47c0-926">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="a47c0-926">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-927">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-927">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-928">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-928">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-929">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-929">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.FileStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a47c0-930">获取或设置此流的当前位置。</span><span class="sxs-lookup"><span data-stu-id="a47c0-930">Gets or sets the current position of this stream.</span></span></summary>
        <value><span data-ttu-id="a47c0-931">此流的当前位置。</span><span class="sxs-lookup"><span data-stu-id="a47c0-931">The current position of this stream.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-932">支持查找超出流长度的任何位置。</span><span class="sxs-lookup"><span data-stu-id="a47c0-932">Seeking to any location beyond the length of the stream is supported.</span></span>  <span data-ttu-id="a47c0-933">当你超出文件长度时，文件大小会增长。</span><span class="sxs-lookup"><span data-stu-id="a47c0-933">When you seek beyond the length of the file, the file size grows.</span></span>  <span data-ttu-id="a47c0-934">在 Microsoft Windows NT 和更高版本中，添加到文件末尾的所有数据均设置为零。</span><span class="sxs-lookup"><span data-stu-id="a47c0-934">In Microsoft Windows NT and newer, any data added to the end of the file is set to zero.</span></span>  <span data-ttu-id="a47c0-935">在 Microsoft Windows 98 或更早版本中，添加到文件末尾的任何数据都不会设置为零，这意味着以前删除的数据对流可见。</span><span class="sxs-lookup"><span data-stu-id="a47c0-935">In Microsoft Windows 98 or earlier, any data added to the end of the file is not set to zero, which means that previously deleted data is visible to the stream.</span></span> <span data-ttu-id="a47c0-936">如果在 Windows 98 或更早版本中超出流的末尾，则将流位置设置为较大的值可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="a47c0-936">Setting the position of the stream to a large value beyond the end of the stream in Windows 98 or earlier may result in an exception being raised.</span></span>  
  
 <span data-ttu-id="a47c0-937">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-937">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a47c0-938">下面的示例使用 `Length` 和 `Position` 属性检查文件尾条件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-938">The following example uses the `Length` and `Position` properties to check for an end-of-file condition.</span></span>  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a47c0-939">流不支持查找。</span><span class="sxs-lookup"><span data-stu-id="a47c0-939">The stream does not support seeking.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-940">出现 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="a47c0-940">An I/O error occurred.</span></span>  
  
<span data-ttu-id="a47c0-941">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-941">-or-</span></span>
  
 <span data-ttu-id="a47c0-942">将位置设置为非常大的值，此值超出 Windows 98 或更早版本中的流的末尾。</span><span class="sxs-lookup"><span data-stu-id="a47c0-942">The position was set to a very large value beyond the end of the stream in Windows 98 or earlier.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a47c0-943">试图将位置设置为负值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-943">Attempted to set the position to a negative value.</span></span></exception>
        <exception cref="T:System.IO.EndOfStreamException"><span data-ttu-id="a47c0-944">试图越过不支持此值的流的末尾进行查找。</span><span class="sxs-lookup"><span data-stu-id="a47c0-944">Attempted seeking past the end of a stream that does not support this.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-945">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-945">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-946">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-946">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-947">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-947">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;byte&gt; -&gt; int" Usage="fileStream.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="a47c0-948">内存的区域。</span><span class="sxs-lookup"><span data-stu-id="a47c0-948">A region of memory.</span></span> <span data-ttu-id="a47c0-949">当此方法返回时，此区域的内容将替换为从当前文件流读取的字节。</span><span class="sxs-lookup"><span data-stu-id="a47c0-949">When this method returns, the contents of this region are replaced by the bytes read from the current file stream.</span></span></param>
        <summary><span data-ttu-id="a47c0-950">从当前文件流中读取字节序列，并在该文件流中按照读取的字节数提升位置。</span><span class="sxs-lookup"><span data-stu-id="a47c0-950">Reads a sequence of bytes from the current file stream and advances the position within the file stream by the number of bytes read.</span></span></summary>
        <returns><span data-ttu-id="a47c0-951">读入缓冲区中的总字节数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-951">The total number of bytes read into the buffer.</span></span> <span data-ttu-id="a47c0-952">如果很多字节当前不可用，则这可小于在缓冲区中分配的字节数；如果已到达流结尾，则为零 (0)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-952">This can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a47c0-953">使用 <xref:System.IO.FileStream.CanRead%2A> 属性可确定当前实例是否支持读取。</span><span class="sxs-lookup"><span data-stu-id="a47c0-953">Use the <xref:System.IO.FileStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span> <span data-ttu-id="a47c0-954">使用 <xref:System.IO.FileStream.ReadAsync%2A> 方法从当前流中异步读取。</span><span class="sxs-lookup"><span data-stu-id="a47c0-954">Use the <xref:System.IO.FileStream.ReadAsync%2A> method to read asynchronously from the current stream.</span></span>

<span data-ttu-id="a47c0-955">此方法从当前文件流中读取最多 `buffer.Length` 个字节，并将它们存储在 `buffer`中。</span><span class="sxs-lookup"><span data-stu-id="a47c0-955">This method reads a maximum of `buffer.Length` bytes from the current file stream and stores them in `buffer`.</span></span> <span data-ttu-id="a47c0-956">文件流中的当前位置由读取的字节数提前，但是，如果发生异常，文件流中的当前位置将保持不变。</span><span class="sxs-lookup"><span data-stu-id="a47c0-956">The current position within the file stream is advanced by the number of bytes read; however, if an exception occurs, the current position within the file stream remains unchanged.</span></span> <span data-ttu-id="a47c0-957">如果没有数据可用，则方法将被阻止，直到至少有一个字节的数据可供读取。</span><span class="sxs-lookup"><span data-stu-id="a47c0-957">The method will block until at least one byte of data can be read, in the event that no data is available.</span></span> <span data-ttu-id="a47c0-958">仅当文件流中没有更多的数据，但不需要更多的数据时（如闭合套接字或文件尾），`Read` 才返回0。</span><span class="sxs-lookup"><span data-stu-id="a47c0-958">`Read` returns 0 only when there is no more data in the file stream and no more is expected (such as a closed socket or end of file).</span></span> <span data-ttu-id="a47c0-959">即使尚未到达文件流的末尾，方法也可以随意返回比请求的更少的字节。</span><span class="sxs-lookup"><span data-stu-id="a47c0-959">The method is free to return fewer bytes than requested even if the end of the file stream has not been reached.</span></span>

<span data-ttu-id="a47c0-960">使用 <xref:System.IO.BinaryReader> 读取基元数据类型。</span><span class="sxs-lookup"><span data-stu-id="a47c0-960">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] array, int32 offset, int32 count) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="fileStream.Read (array, offset, count)" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="a47c0-961">当此方法返回时，包含指定的字节数组，此数组中 <paramref name="offset" /> 和 (<paramref name="offset" /> + <paramref name="count" /> - 1<c>)</c> 之间的值被从当前源中读取的字节所替换。</span><span class="sxs-lookup"><span data-stu-id="a47c0-961">When this method returns, contains the specified byte array with the values between <paramref name="offset" /> and (<paramref name="offset" /> + <paramref name="count" /> - 1<c>)</c> replaced by the bytes read from the current source.</span></span></param>
        <param name="offset"><span data-ttu-id="a47c0-962"><paramref name="array" /> 中的字节偏移量，将在此处放置读取的字节。</span><span class="sxs-lookup"><span data-stu-id="a47c0-962">The byte offset in <paramref name="array" /> at which the read bytes will be placed.</span></span></param>
        <param name="count"><span data-ttu-id="a47c0-963">最多读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-963">The maximum number of bytes to read.</span></span></param>
        <summary><span data-ttu-id="a47c0-964">从流中读取字节块并将该数据写入给定缓冲区中。</span><span class="sxs-lookup"><span data-stu-id="a47c0-964">Reads a block of bytes from the stream and writes the data in a given buffer.</span></span></summary>
        <returns><span data-ttu-id="a47c0-965">读入缓冲区中的总字节数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-965">The total number of bytes read into the buffer.</span></span> <span data-ttu-id="a47c0-966">如果字节数当前不可用，则总字节数可能小于所请求的字节数；如果已到达流结尾，则为零。</span><span class="sxs-lookup"><span data-stu-id="a47c0-966">This might be less than the number of bytes requested if that number of bytes are not currently available, or zero if the end of the stream is reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-967">此方法重写 <xref:System.IO.Stream.Read%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-967">This method overrides <xref:System.IO.Stream.Read%2A>.</span></span>  
  
 <span data-ttu-id="a47c0-968">`offset` 参数提供了 `array` （缓冲区索引）中的字节偏移量，从此处开始读取，`count` 参数提供要从此流中读取的最大字节数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-968">The `offset` parameter gives the offset of the byte in `array` (the buffer index) at which to begin reading, and the `count` parameter gives the maximum number of bytes to be read from this stream.</span></span> <span data-ttu-id="a47c0-969">返回的值是读取的实际字节数，或者如果到达流的末尾，则为零。</span><span class="sxs-lookup"><span data-stu-id="a47c0-969">The returned value is the actual number of bytes read, or zero if the end of the stream is reached.</span></span> <span data-ttu-id="a47c0-970">如果读取操作成功，则流的当前位置将按读取的字节数提前。</span><span class="sxs-lookup"><span data-stu-id="a47c0-970">If the read operation is successful, the current position of the stream is advanced by the number of bytes read.</span></span> <span data-ttu-id="a47c0-971">如果发生异常，则流的当前位置不变。</span><span class="sxs-lookup"><span data-stu-id="a47c0-971">If an exception occurs, the current position of the stream is unchanged.</span></span>  
  
 <span data-ttu-id="a47c0-972">仅在到达流的末尾后，<xref:System.IO.FileStream.Read%2A> 方法返回零。</span><span class="sxs-lookup"><span data-stu-id="a47c0-972">The <xref:System.IO.FileStream.Read%2A> method returns zero only after reaching the end of the stream.</span></span> <span data-ttu-id="a47c0-973">否则，<xref:System.IO.FileStream.Read%2A> 始终从流中读取至少一个字节，然后返回。</span><span class="sxs-lookup"><span data-stu-id="a47c0-973">Otherwise, <xref:System.IO.FileStream.Read%2A> always reads at least one byte from the stream before returning.</span></span> <span data-ttu-id="a47c0-974">如果在调用 <xref:System.IO.FileStream.Read%2A>时流中没有可用数据，则该方法将一直阻止到至少有一个字节的数据返回。</span><span class="sxs-lookup"><span data-stu-id="a47c0-974">If no data is available from the stream upon a call to <xref:System.IO.FileStream.Read%2A>, the method will block until at least one byte of data can be returned.</span></span> <span data-ttu-id="a47c0-975">即使尚未到达流的末尾，实现也可以自由返回比请求更少的字节。</span><span class="sxs-lookup"><span data-stu-id="a47c0-975">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
 <span data-ttu-id="a47c0-976">使用 <xref:System.IO.BinaryReader> 读取基元数据类型。</span><span class="sxs-lookup"><span data-stu-id="a47c0-976">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>  
  
 <span data-ttu-id="a47c0-977">不要中断正在执行读取操作的线程。</span><span class="sxs-lookup"><span data-stu-id="a47c0-977">Do not interrupt a thread that is performing a read operation.</span></span> <span data-ttu-id="a47c0-978">虽然阻止该应用程序后，应用程序可能似乎已成功运行，但中断会降低应用程序的性能和可靠性。</span><span class="sxs-lookup"><span data-stu-id="a47c0-978">Although the application may appear to run successfully after the thread is unblocked, the interruption can decrease your application's performance and reliability.</span></span>  
  
 <span data-ttu-id="a47c0-979">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-979">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a47c0-980">下面的示例读取 <xref:System.IO.FileStream> 中的内容并将其写入另一个 <xref:System.IO.FileStream>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-980">The following example reads the contents from a <xref:System.IO.FileStream> and writes it into another <xref:System.IO.FileStream>.</span></span>  
  
 [!code-csharp[FSRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSRead/CS/fsread.cs#1)]
 [!code-vb[FSRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSRead/VB/fsread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a47c0-981"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-981"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a47c0-982"><paramref name="offset" /> 或 <paramref name="count" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-982"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a47c0-983">流不支持读取。</span><span class="sxs-lookup"><span data-stu-id="a47c0-983">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-984">出现 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="a47c0-984">An I/O error occurred.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a47c0-985"><paramref name="offset" /> 和 <paramref name="count" /> 描述 <paramref name="array" /> 中的无效范围。</span><span class="sxs-lookup"><span data-stu-id="a47c0-985"><paramref name="offset" /> and <paramref name="count" /> describe an invalid range in <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a47c0-986">在流关闭后调用方法。</span><span class="sxs-lookup"><span data-stu-id="a47c0-986">Methods were called after the stream was closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-987">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-987">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-988">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-988">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-989">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-989">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="fileStream.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="a47c0-990">要写入数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="a47c0-990">The buffer to write the data into.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="a47c0-991">要监视取消请求的标记。</span><span class="sxs-lookup"><span data-stu-id="a47c0-991">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="a47c0-992">默认值是 <see cref="P:System.Threading.CancellationToken.None" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-992">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="a47c0-993">从当前文件流异步读取字节的序列，将其写入某内存区域，按读取的字节数向前移动文件流中的位置，并监视取消请求。</span><span class="sxs-lookup"><span data-stu-id="a47c0-993">Asynchronously reads a sequence of bytes from the current file stream and writes them to a memory region, advances the position within the file stream by the number of bytes read, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="a47c0-994">一个表示异步读取操作并将读取的总字节数包装到缓冲区中的任务。</span><span class="sxs-lookup"><span data-stu-id="a47c0-994">A task that represents the asynchronous read operation and wraps the total number of bytes read into the buffer.</span></span> <span data-ttu-id="a47c0-995">如果当前可用字节数少于所请求的字节数，则该结果值可小于所请求的字节数；如果已到达流结尾时，则为 0（零）。</span><span class="sxs-lookup"><span data-stu-id="a47c0-995">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a47c0-996">利用 `ReadAsync` 方法，你可以在不阻塞主线程的情况下执行占用大量资源的文件操作。</span><span class="sxs-lookup"><span data-stu-id="a47c0-996">The `ReadAsync` method enables you to perform resource-intensive file operations without blocking the main thread.</span></span> <span data-ttu-id="a47c0-997">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="a47c0-997">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="a47c0-998">异步方法与 Visual Basic 和C#中的 `async` 和 `await` 关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="a47c0-998">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="a47c0-999">使用 <xref:System.IO.FileStream.CanRead%2A> 属性可确定当前实例是否支持读取。</span><span class="sxs-lookup"><span data-stu-id="a47c0-999">Use the <xref:System.IO.FileStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>

<span data-ttu-id="a47c0-1000">如果在操作完成前取消该操作，则返回的任务将包含 <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithtype> 属性的 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1000">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithtype> property.</span></span> <span data-ttu-id="a47c0-1001">如果释放了文件的句柄，则返回的任务将在 <xref:System.Threading.Tasks.Task.Exception?displayProperty=nameWithType> 属性中包含 <xref:System.ObjectDisposedException> 异常。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1001">If the handle to the file is disposed, the returned task contains the <xref:System.ObjectDisposedException> exception in the <xref:System.Threading.Tasks.Task.Exception?displayProperty=nameWithType> property.</span></span>

## Examples

<span data-ttu-id="a47c0-1002">下面的示例演示如何以异步方式从文件读取。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1002">The following example shows how to read from a file asynchronously.</span></span>  

[!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
[!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="fileStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="a47c0-1003">要写入数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1003">The buffer to write the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="a47c0-1004"><paramref name="buffer" /> 中的字节偏移量，从该偏移量开始写入从流中读取的数据。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1004">The byte offset in <paramref name="buffer" /> at which to begin writing data from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="a47c0-1005">最多读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1005">The maximum number of bytes to read.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="a47c0-1006">要监视取消请求的标记。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1006">The token to monitor for cancellation requests.</span></span></param>
        <summary><span data-ttu-id="a47c0-1007">从当前文件流异步读取字节的序列，将其写入从指定偏移量开始的字节数组，按读取的字节数向前移动文件流中的位置，并监视取消请求。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1007">Asynchronously reads a sequence of bytes from the current file stream and writes them to a byte array beginning at a specified offset, advances the position within the file stream by the number of bytes read, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="a47c0-1008">一个表示异步读取操作并将读取的总字节数包装到缓冲区中的任务。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1008">A task that represents the asynchronous read operation and wraps the total number of bytes read into the buffer.</span></span> <span data-ttu-id="a47c0-1009">如果当前可用字节数少于所请求的字节数，则该结果值可小于所请求的字节数；如果已到达流结尾时，则为 0（零）。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1009">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a47c0-1010">利用 `ReadAsync` 方法，你可以在不阻塞主线程的情况下执行占用大量资源的文件操作。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1010">The `ReadAsync` method enables you to perform resource-intensive file operations without blocking the main thread.</span></span> <span data-ttu-id="a47c0-1011">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1011">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="a47c0-1012">异步方法与 Visual Basic 和C#中的 `async` 和 `await` 关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1012">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="a47c0-1013">使用 <xref:System.IO.FileStream.CanRead%2A> 属性可确定当前实例是否支持读取。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1013">Use the <xref:System.IO.FileStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>

<span data-ttu-id="a47c0-1014">如果在操作完成前取消该操作，则返回的任务将包含 <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithType> 属性的 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1014">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="a47c0-1015">如果释放了文件的句柄，则返回的任务将在 <xref:System.Threading.Tasks.Task.Exception?displayProperty=nameWithType> 属性中包含 <xref:System.ObjectDisposedException> 异常。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1015">If the handle to the file is disposed, the returned task contains the <xref:System.ObjectDisposedException> exception in the <xref:System.Threading.Tasks.Task.Exception?displayProperty=nameWithType> property.</span></span>

## Examples

<span data-ttu-id="a47c0-1016">下面的示例演示如何以异步方式从文件读取。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1016">The following example shows how to read from a file asynchronously.</span></span>

[!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
[!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a47c0-1017"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1017"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a47c0-1018"><paramref name="offset" /> 或 <paramref name="count" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1018"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a47c0-1019"><paramref name="offset" /> 和 <paramref name="count" /> 的总和大于缓冲区长度。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1019">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a47c0-1020">流不支持读取。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1020">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a47c0-1021">已释放流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1021">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a47c0-1022">之前的读取操作当前正在使用流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1022">The stream is currently in use by a previous read operation.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md"><span data-ttu-id="a47c0-1023">取消</span><span class="sxs-lookup"><span data-stu-id="a47c0-1023">Cancellation</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="fileStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a47c0-1024">从文件中读取一个字节，并将读取位置提升一个字节。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1024">Reads a byte from the file and advances the read position one byte.</span></span></summary>
        <returns><span data-ttu-id="a47c0-1025">强制转换为 <see cref="T:System.Int32" /> 的字节；或者如果已到达流的末尾，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1025">The byte, cast to an <see cref="T:System.Int32" />, or -1 if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-1026">此方法重写 <xref:System.IO.Stream.ReadByte%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1026">This method overrides <xref:System.IO.Stream.ReadByte%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a47c0-1027">使用 <xref:System.IO.FileStream.CanRead%2A> 属性可确定当前实例是否支持读取。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1027">Use the <xref:System.IO.FileStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span> <span data-ttu-id="a47c0-1028">有关附加信息，请参见 <xref:System.IO.Stream.CanRead%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1028">For additional information, see <xref:System.IO.Stream.CanRead%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a47c0-1029">下面的代码示例演示了如何按字节将数据写入文件，然后验证是否已正确写入数据。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1029">The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.</span></span>  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a47c0-1030">当前流不支持读取。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1030">The current stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a47c0-1031">当前流已关闭。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1031">The current stream is closed.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="a47c0-1032"><see langword="Stream" /> 上的默认实现创建新的单字节数组，然后调用 <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1032">The default implementation on <see langword="Stream" /> creates a new single-byte array and then calls <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />.</span></span> <span data-ttu-id="a47c0-1033">尽管这是正确的，但效率低下。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1033">While this is formally correct, it is inefficient.</span></span> <span data-ttu-id="a47c0-1034">具有内部缓冲区的任何流都应该重写此方法，并提供一个更高效的版本来直接读取缓冲区，避免在每次调用时进行额外的数组分配。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1034">Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.</span></span>  
  
<span data-ttu-id="a47c0-1035">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1035">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span></para></block>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-1036">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-1036">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-1037">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-1037">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-1038">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-1038">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.SafeFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SafeFileHandle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Microsoft::Win32::SafeHandles::SafeFileHandle ^ SafeFileHandle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeFileHandle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.FileStream.SafeFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a47c0-1039">获取 <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> 对象，它代表当前 <see cref="T:System.IO.FileStream" /> 对象所封装的文件的操作系统文件句柄。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1039">Gets a <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> object that represents the operating system file handle for the file that the current <see cref="T:System.IO.FileStream" /> object encapsulates.</span></span></summary>
        <value><span data-ttu-id="a47c0-1040">一个对象，该对象表示当前 <see cref="T:System.IO.FileStream" /> 对象封装的文件的操作系统文件句柄。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1040">An object that represents the operating system file handle for the file that the current <see cref="T:System.IO.FileStream" /> object encapsulates.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-1041"><xref:System.IO.FileStream.SafeFileHandle%2A> 属性会自动刷新流并将当前流位置设置为0。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1041">The <xref:System.IO.FileStream.SafeFileHandle%2A> property automatically flushes the stream and sets the current stream position to 0.</span></span>  <span data-ttu-id="a47c0-1042">这允许移动文件，或使用此属性返回的 <xref:System.IO.FileStream.SafeFileHandle%2A> 由另一个流重置流位置。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1042">This allows the file to be moved or the stream position to be reset by another stream using the <xref:System.IO.FileStream.SafeFileHandle%2A> returned by this property.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="a47c0-1043">用于调用非托管代码的权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1043">for permission to call unmanaged code.</span></span>  
  
<span data-ttu-id="a47c0-1044">安全操作：链接请求</span><span class="sxs-lookup"><span data-stu-id="a47c0-1044">Security action: Link Demand</span></span> 
<span data-ttu-id="a47c0-1045">关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="a47c0-1045">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="a47c0-1046">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1046">requires full trust for the immediate caller.</span></span> <span data-ttu-id="a47c0-1047">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1047">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-1048">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-1048">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-1049">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-1049">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-1050">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-1050">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="fileStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="a47c0-1051">相对于 <paramref name="origin" /> 的点，从此处开始查找。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1051">The point relative to <paramref name="origin" /> from which to begin seeking.</span></span></param>
        <param name="origin"><span data-ttu-id="a47c0-1052">使用 <paramref name="offset" /> 类型的值，将开始位置、结束位置或当前位置指定为 <see cref="T:System.IO.SeekOrigin" /> 的参考点。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1052">Specifies the beginning, the end, or the current position as a reference point for <paramref name="offset" />, using a value of type <see cref="T:System.IO.SeekOrigin" />.</span></span></param>
        <summary><span data-ttu-id="a47c0-1053">将该流的当前位置设置为给定值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1053">Sets the current position of this stream to the given value.</span></span></summary>
        <returns><span data-ttu-id="a47c0-1054">流中的新位置。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1054">The new position in the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-1055">此方法重写 <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1055">This method overrides <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a47c0-1056">使用 <xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType> 属性可确定当前实例是否支持查找。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1056">Use the <xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType> property to determine whether the current instance supports seeking.</span></span> <span data-ttu-id="a47c0-1057">有关附加信息，请参见 <xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1057">For additional information, see <xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="a47c0-1058">您可以查找超出流长度的任何位置。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1058">You can seek to any location beyond the length of the stream.</span></span> <span data-ttu-id="a47c0-1059">当你超出文件长度时，文件大小会增长。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1059">When you seek beyond the length of the file, the file size grows.</span></span> <span data-ttu-id="a47c0-1060">在 Windows NT 和更高版本中，添加到文件末尾的数据设置为零。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1060">In Windows NT and later versions, data added to the end of the file is set to zero.</span></span> <span data-ttu-id="a47c0-1061">在 Windows 98 或更早版本中，添加到文件末尾的数据未设置为零，这意味着以前删除的数据对流可见。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1061">In Windows 98 or earlier versions, data added to the end of the file is not set to zero, which means that previously deleted data is visible to the stream.</span></span>  
  
 <span data-ttu-id="a47c0-1062">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1062">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a47c0-1063">下面的示例演示如何将数据按字节写入文件，然后验证是否已正确写入数据。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1063">The following example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.</span></span>  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 <span data-ttu-id="a47c0-1064">下面的示例通过将各种 <xref:System.IO.SeekOrigin> 值与 <xref:System.IO.FileStream.Seek%2A> 方法一起使用，从文件末尾到文件开头的反向读取文本。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1064">The following example reads text in the reverse direction, from the end of file to the beginning of the file, by using the various <xref:System.IO.SeekOrigin> values with the <xref:System.IO.FileStream.Seek%2A> method.</span></span>  
  
 [!code-csharp[System.IO.FileStream.Seek#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.filestream.seek/cs/source.cs#1)]
 [!code-vb[System.IO.FileStream.Seek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.filestream.seek/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-1065">出现 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1065">An I/O error occurred.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a47c0-1066">该流不支持查找，例如如果 <see langword="FileStream" /> 是从管道或控制台输出构造的，则不支持查找。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1066">The stream does not support seeking, such as if the <see langword="FileStream" /> is constructed from a pipe or console output.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a47c0-1067">试图在流的开始位置之前进行查找。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1067">Seeking is attempted before the beginning of the stream.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a47c0-1068">在流关闭后调用方法。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1068">Methods were called after the stream was closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-1069">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-1069">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-1070">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-1070">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-1071">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-1071">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.FileSecurity -&gt; unit" Usage="fileStream.SetAccessControl fileSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileSecurity"><span data-ttu-id="a47c0-1072">描述要应用于当前文件的 ACL 项的对象。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1072">An object that describes an ACL entry to apply to the current file.</span></span></param>
        <summary><span data-ttu-id="a47c0-1073">将 <see cref="T:System.Security.AccessControl.FileSecurity" /> 对象所描述的访问控制列表 (ACL) 项应用于当前 <see cref="T:System.IO.FileStream" /> 对象所描述的文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1073">Applies access control list (ACL) entries described by a <see cref="T:System.Security.AccessControl.FileSecurity" /> object to the file described by the current <see cref="T:System.IO.FileStream" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-1074">虽然 <xref:System.IO.FileStream> 类和 <xref:System.IO.FileStream.SetAccessControl%2A> 可用于现有文件，但请考虑使用 <xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType> 方法，因为它更易于使用。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1074">While the <xref:System.IO.FileStream> class and <xref:System.IO.FileStream.SetAccessControl%2A> can be used on an existing file, consider using the <xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType> method as it is easier to use.</span></span>  
  
 <span data-ttu-id="a47c0-1075"><xref:System.IO.FileStream.SetAccessControl%2A> 方法将访问控制列表（ACL）项应用于表示 noninherited ACL 列表的文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1075">The <xref:System.IO.FileStream.SetAccessControl%2A> method applies access control list (ACL) entries to a file that represents the noninherited ACL list.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a47c0-1076">为 `fileSecurity` 参数指定的 ACL 将替换该文件的现有 ACL。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1076">The ACL specified for the `fileSecurity` parameter replaces the existing ACL for the file.</span></span> <span data-ttu-id="a47c0-1077">若要为新用户添加权限，请使用 <xref:System.IO.FileStream.GetAccessControl%2A> 方法获取现有 ACL，对其进行修改，然后使用 <xref:System.IO.FileStream.SetAccessControl%2A> 将其应用回文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1077">To add permissions for a new user, use the <xref:System.IO.FileStream.GetAccessControl%2A> method to obtain the existing ACL, modify it, and then use <xref:System.IO.FileStream.SetAccessControl%2A> to apply it back to the file.</span></span>  
  
 <span data-ttu-id="a47c0-1078">ACL 描述对给定文件具有或没有特定操作权限的个人和/或组。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1078">An ACL describes individuals and/or groups who have, or do not have, rights to specific actions on the given file.</span></span> <span data-ttu-id="a47c0-1079">有关详细信息，请参阅[如何：添加或移除访问控制列表项](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1079">For more information, see [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a47c0-1080">文件关闭。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1080">The file is closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a47c0-1081"><paramref name="fileSecurity" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1081">The <paramref name="fileSecurity" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="a47c0-1082">未能找到或修改该文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1082">The file could not be found or modified.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="a47c0-1083">当前进程不具有打开该文件的权限。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1083">The current process does not have access to open the file.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="fileStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a47c0-1084">流的新长度。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1084">The new length of the stream.</span></span></param>
        <summary><span data-ttu-id="a47c0-1085">将该流的长度设置为给定值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1085">Sets the length of this stream to the given value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-1086">此方法重写 <xref:System.IO.Stream.SetLength%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1086">This method overrides <xref:System.IO.Stream.SetLength%2A>.</span></span>  
  
 <span data-ttu-id="a47c0-1087">如果给定值小于流的当前长度，则流将被截断。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1087">If the given value is less than the current length of the stream, the stream is truncated.</span></span> <span data-ttu-id="a47c0-1088">在这种情况下，如果当前位置大于新的长度，则将当前位置移到流的最后一个字节。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1088">In this scenario, if the current position is greater than the new length, the current position is moved to the last byte of the stream.</span></span> <span data-ttu-id="a47c0-1089">如果给定的值大于流的当前长度，则将展开流，当前位置将保持不变。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1089">If the given value is larger than the current length of the stream, the stream is expanded, and the current position remains the same.</span></span> <span data-ttu-id="a47c0-1090">如果流已展开，则新旧长度之间的流内容不确定。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1090">If the stream is expanded, the contents of the stream between the old and the new length are undefined.</span></span>  
  
 <span data-ttu-id="a47c0-1091">流必须支持写入和查找 `SetLength` 才能工作。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1091">A stream must support both writing and seeking for `SetLength` to work.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a47c0-1092">使用 <xref:System.IO.FileStream.CanWrite%2A> 属性来确定当前实例是否支持写入，并使用 <xref:System.IO.FileStream.CanSeek%2A> 属性来确定是否支持查找。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1092">Use the <xref:System.IO.FileStream.CanWrite%2A> property to determine whether the current instance supports writing, and the <xref:System.IO.FileStream.CanSeek%2A> property to determine whether seeking is supported.</span></span> <span data-ttu-id="a47c0-1093">有关更多信息，请参阅 <xref:System.IO.Stream.CanWrite%2A> 和 <xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1093">For additional information, see <xref:System.IO.Stream.CanWrite%2A> and <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
 <span data-ttu-id="a47c0-1094">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1094">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-1095">发生了 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1095">An I/O error has occurred.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a47c0-1096">该流不支持写入和查找。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1096">The stream does not support both writing and seeking.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a47c0-1097">试图将 <paramref name="value" /> 参数设置为小于 0。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1097">Attempted to set the <paramref name="value" /> parameter to less than 0.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-1098">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-1098">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-1099">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-1099">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-1100">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-1100">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public virtual void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Unlock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Unlock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Unlock : int64 * int64 -&gt; unit&#xA;override this.Unlock : int64 * int64 -&gt; unit" Usage="fileStream.Unlock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="length" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="position"><span data-ttu-id="a47c0-1101">要取消锁定的范围的开始处。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1101">The beginning of the range to unlock.</span></span></param>
        <param name="length"><span data-ttu-id="a47c0-1102">要取消锁定的范围。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1102">The range to be unlocked.</span></span></param>
        <summary><span data-ttu-id="a47c0-1103">允许其他进程访问以前锁定的某个文件的全部或部分。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1103">Allows access by other processes to all or part of a file that was previously locked.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-1104">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1104">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a47c0-1105">下面的代码示例演示如何锁定部分文件，以便其他进程即使对文件具有读/写访问权限也无法访问该文件的该部分，然后对该文件的指定部分解除锁定。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1105">The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file, and then unlock the specified part of the file .</span></span> <span data-ttu-id="a47c0-1106">在不同的命令窗口中同时运行程序，并使用不同的控制台输入选项进行调查。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1106">Run the program simultaneously in different command windows and investigate using the different console input options.</span></span>  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a47c0-1107"><paramref name="position" /> 或 <paramref name="length" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1107"><paramref name="position" /> or <paramref name="length" /> is negative.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-1108">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-1108">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-1109">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-1109">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-1110">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-1110">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="fileStream.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="a47c0-1111">内存的区域。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1111">A region of memory.</span></span> <span data-ttu-id="a47c0-1112">此方法将此区域的内容复制到当前文件流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1112">This method copies the contents of this region to the current file stream.</span></span></param>
        <summary><span data-ttu-id="a47c0-1113">将字节的序列从只读范围写入当前文件流，并按写入的字节数向前移动此文件流中的当前位置。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1113">Writes a sequence of bytes from a read-only span to the current file stream and advances the current position within this file stream by the number of bytes written.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a47c0-1114">使用 <xref:System.IO.FileStream.CanWrite%2A> 属性可确定当前实例是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1114">Use the <xref:System.IO.FileStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="a47c0-1115">使用 <xref:System.IO.FileStream.WriteAsync%2A> 方法异步写入当前流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1115">Use the <xref:System.IO.FileStream.WriteAsync%2A> method to write asynchronously to the current stream.</span></span>

<span data-ttu-id="a47c0-1116">如果写入操作成功，文件流中的位置将按写入的字节数向前移动。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1116">If the write operation is successful, the position within the file stream advances by the number of bytes written.</span></span> <span data-ttu-id="a47c0-1117">如果发生异常，文件流中的位置将保持不变。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1117">If an exception occurs, the position within the file stream remains unchanged.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="fileStream.Write (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="a47c0-1118">包含要写入该流的数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1118">The buffer containing data to write to the stream.</span></span></param>
        <param name="offset"><span data-ttu-id="a47c0-1119"><paramref name="array" /> 中的从零开始的字节偏移量，从此处开始将字节复制到该流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1119">The zero-based byte offset in <paramref name="array" /> from which to begin copying bytes to the stream.</span></span></param>
        <param name="count"><span data-ttu-id="a47c0-1120">最多写入的字节数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1120">The maximum number of bytes to write.</span></span></param>
        <summary><span data-ttu-id="a47c0-1121">将字节块写入文件流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1121">Writes a block of bytes to the file stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-1122">此方法重写 <xref:System.IO.Stream.Write%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1122">This method overrides <xref:System.IO.Stream.Write%2A>.</span></span>  
  
 <span data-ttu-id="a47c0-1123">`offset` 参数提供了 `array` （缓冲区索引）中的字节偏移量，从此处开始复制，`count` 参数提供要写入流中的字节数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1123">The `offset` parameter gives the offset of the byte in `array` (the buffer index) at which to begin copying, and the `count` parameter gives the number of bytes that will be written to the stream.</span></span> <span data-ttu-id="a47c0-1124">如果写入操作成功，则流的当前位置将按写入的字节数提前。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1124">If the write operation is successful, the current position of the stream is advanced by the number of bytes written.</span></span> <span data-ttu-id="a47c0-1125">如果发生异常，则流的当前位置不变。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1125">If an exception occurs, the current position of the stream is unchanged.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a47c0-1126">使用 <xref:System.IO.FileStream.CanWrite%2A> 属性可确定当前实例是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1126">Use the <xref:System.IO.FileStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="a47c0-1127">有关附加信息，请参见 <xref:System.IO.Stream.CanWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1127">For additional information, see <xref:System.IO.Stream.CanWrite%2A>.</span></span>  
  
 <span data-ttu-id="a47c0-1128">不要中断正在执行写操作的线程。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1128">Do not interrupt a thread that is performing a write operation.</span></span> <span data-ttu-id="a47c0-1129">虽然阻止该应用程序后，应用程序可能似乎已成功运行，但中断会降低应用程序的性能和可靠性。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1129">Although the application may appear to run successfully after the thread is unblocked, the interruption can decrease your application's performance and reliability.</span></span>  
  
 <span data-ttu-id="a47c0-1130">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1130">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a47c0-1131">此代码示例是为 <xref:System.IO.FileStream.Lock%2A> 方法提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1131">This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.</span></span>  
  
 [!code-cpp[System.IO.FileStream3#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#3)]
 [!code-csharp[System.IO.FileStream3#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#3)]
 [!code-vb[System.IO.FileStream3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a47c0-1132"><paramref name="array" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1132"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a47c0-1133"><paramref name="offset" /> 和 <paramref name="count" /> 描述 <paramref name="array" /> 中的无效范围。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1133"><paramref name="offset" /> and <paramref name="count" /> describe an invalid range in <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a47c0-1134"><paramref name="offset" /> 或 <paramref name="count" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1134"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a47c0-1135">出现 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1135">An I/O error occurred.</span></span>  
  
<span data-ttu-id="a47c0-1136">-或-</span><span class="sxs-lookup"><span data-stu-id="a47c0-1136">-or-</span></span>
  
 <span data-ttu-id="a47c0-1137">另一个线程可能导致操作系统的文件句柄的位置发生意外更改。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1137">Another thread may have caused an unexpected change in the position of the operating system's file handle.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a47c0-1138">流已关闭。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1138">The stream is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a47c0-1139">当前的流实例不支持写入。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1139">The current stream instance does not support writing.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-1140">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-1140">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-1141">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-1141">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-1142">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-1142">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="fileStream.WriteAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="a47c0-1143">从中写入数据的内存区域。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1143">The region of memory to write data from.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="a47c0-1144">要监视取消请求的标记。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1144">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="a47c0-1145">默认值是 <see cref="P:System.Threading.CancellationToken.None" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1145">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="a47c0-1146">将字节的序列从内存区域异步写入当前文件流，按写入的字节数向前移动该文件流中的当前位置，并监视取消请求。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1146">Asynchronously writes a sequence of bytes from a memory region to the current file stream, advances the current position within this file stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="a47c0-1147">表示异步写入操作的任务。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1147">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a47c0-1148">利用 `WriteAsync` 方法，你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1148">The `WriteAsync` method lets you perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="a47c0-1149">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1149">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="a47c0-1150">异步方法与 Visual Basic 和C#中的 `async` 和 `await` 关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1150">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="a47c0-1151">使用 <xref:System.IO.FileStream.CanWrite%2A> 属性可确定当前实例是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1151">Use the <xref:System.IO.FileStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>

<span data-ttu-id="a47c0-1152">如果在操作完成前取消该操作，则返回的任务将包含 <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithType> 属性的 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1152">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithType> property.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="a47c0-1153">从中写入数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1153">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="a47c0-1154"><paramref name="buffer" /> 中的从零开始的字节偏移量，从此处开始将字节复制到该流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1154">The zero-based byte offset in <paramref name="buffer" /> from which to begin copying bytes to the stream.</span></span></param>
        <param name="count"><span data-ttu-id="a47c0-1155">最多写入的字节数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1155">The maximum number of bytes to write.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="a47c0-1156">要监视取消请求的标记。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1156">The token to monitor for cancellation requests.</span></span></param>
        <summary><span data-ttu-id="a47c0-1157">将字节的序列异步写入当前流，将该流中的当前位置向前移动写入的字节数，并监视取消请求。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1157">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="a47c0-1158">表示异步写入操作的任务。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1158">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-1159">利用 <xref:System.IO.FileStream.WriteAsync%2A> 方法，你可以在不阻塞主线程的情况下执行占用大量资源的文件操作。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1159">The <xref:System.IO.FileStream.WriteAsync%2A> method enables you to perform resource-intensive file operations without blocking the main thread.</span></span> <span data-ttu-id="a47c0-1160">在 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 应用或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 应用中一个耗时的流操作可能阻塞 UI 线程并让您的应用看起来好像不工作时，这种性能的考虑就显得尤为重要了。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1160">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="a47c0-1161">异步方法与 Visual Basic 和C#中的 `async` 和 `await` 关键字结合使用。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1161">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="a47c0-1162">使用 <xref:System.IO.FileStream.CanWrite%2A> 属性可确定当前实例是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1162">Use the <xref:System.IO.FileStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>  
  
 <span data-ttu-id="a47c0-1163">如果在操作完成前取消该操作，则返回的任务将包含 <xref:System.Threading.Tasks.Task.Status%2A> 属性的 <xref:System.Threading.Tasks.TaskStatus.Canceled> 值。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1163">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span> <span data-ttu-id="a47c0-1164">如果释放了文件的句柄，则返回的任务将在 <xref:System.Threading.Tasks.Task.Exception%2A> 属性中包含 <xref:System.ObjectDisposedException> 异常。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1164">If the handle to the file is disposed, the returned task contains the <xref:System.ObjectDisposedException> exception in the <xref:System.Threading.Tasks.Task.Exception%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a47c0-1165">下面的示例演示如何以异步方式写入文件。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1165">The following example shows how to write asynchronously to a file.</span></span>  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a47c0-1166"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1166"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a47c0-1167"><paramref name="offset" /> 或 <paramref name="count" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1167"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a47c0-1168"><paramref name="offset" /> 和 <paramref name="count" /> 的总和大于缓冲区长度。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1168">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a47c0-1169">流不支持写入。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1169">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a47c0-1170">已释放流。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1170">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a47c0-1171">流正在由前一次写操作使用。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1171">The stream is currently in use by a previous write operation.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md"><span data-ttu-id="a47c0-1172">取消</span><span class="sxs-lookup"><span data-stu-id="a47c0-1172">Cancellation</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="fileStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a47c0-1173">要写入流的字节。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1173">A byte to write to the stream.</span></span></param>
        <summary><span data-ttu-id="a47c0-1174">一个字节写入文件流中的当前位置。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1174">Writes a byte to the current position in the file stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a47c0-1175">此方法重写 <xref:System.IO.Stream.WriteByte%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1175">This method overrides <xref:System.IO.Stream.WriteByte%2A>.</span></span>  
  
 <span data-ttu-id="a47c0-1176">使用 `WriteByte` 可以有效地将字节写入 `FileStream`。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1176">Use `WriteByte` to write a byte to a `FileStream` efficiently.</span></span> <span data-ttu-id="a47c0-1177">如果流已关闭或不可写，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1177">If the stream is closed or not writable, an exception will be thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a47c0-1178">使用 <xref:System.IO.FileStream.CanWrite%2A> 属性可确定当前实例是否支持写入。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1178">Use the <xref:System.IO.FileStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="a47c0-1179">有关附加信息，请参见 <xref:System.IO.Stream.CanWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1179">For additional information, see <xref:System.IO.Stream.CanWrite%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a47c0-1180">下面的代码示例演示了如何按字节将数据写入文件，然后验证是否已正确写入数据。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1180">The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.</span></span>  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a47c0-1181">流已关闭。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1181">The stream is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a47c0-1182">流不支持写入。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1182">The stream does not support writing.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="a47c0-1183"><see langword="Stream" /> 上的默认实现创建新的单字节数组，然后调用 <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1183">The default implementation on <see langword="Stream" /> creates a new single-byte array and then calls <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />.</span></span> <span data-ttu-id="a47c0-1184">尽管这是正确的，但效率低下。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1184">While this is formally correct, it is inefficient.</span></span> <span data-ttu-id="a47c0-1185">具有内部缓冲区的任何流都应该重写此方法，并提供一个更高效的版本来直接读取缓冲区，避免在每次调用时进行额外的数组分配。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1185">Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.</span></span>  
  
<span data-ttu-id="a47c0-1186">有关常见文件和目录操作的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="a47c0-1186">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span></para></block>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="a47c0-1187">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="a47c0-1187">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="a47c0-1188">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-1188">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="a47c0-1189">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="a47c0-1189">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
