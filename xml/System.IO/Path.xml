<Type Name="Path" FullName="System.IO.Path">
  <Metadata><Meta Name="ms.openlocfilehash" Value="26c33d1afd158bc25e5e2659a56c32ca49306cd6" /><Meta Name="ms.sourcegitcommit" Value="8b09499854b5b7b909802126edc1f1fca0054c10" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="02/01/2020" /><Meta Name="ms.locfileid" Value="76946206" /></Metadata><TypeSignature Language="C#" Value="public static class Path" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Path extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Path" />
  <TypeSignature Language="VB.NET" Value="Public Class Path" />
  <TypeSignature Language="C++ CLI" Value="public ref class Path abstract sealed" />
  <TypeSignature Language="F#" Value="type Path = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="f1caf-101">对包含文件或目录路径信息的 <see cref="T:System.String" /> 实例执行操作。</span><span class="sxs-lookup"><span data-stu-id="f1caf-101">Performs operations on <see cref="T:System.String" /> instances that contain file or directory path information.</span></span> <span data-ttu-id="f1caf-102">这些操作是以跨平台的方式执行的。</span><span class="sxs-lookup"><span data-stu-id="f1caf-102">These operations are performed in a cross-platform manner.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="f1caf-103">路径是提供文件或目录的位置的字符串。</span><span class="sxs-lookup"><span data-stu-id="f1caf-103">A path is a string that provides the location of a file or directory.</span></span> <span data-ttu-id="f1caf-104">路径不一定指向磁盘上的位置;例如，路径可能映射到内存中或设备上的某个位置。</span><span class="sxs-lookup"><span data-stu-id="f1caf-104">A path does not necessarily point to a location on disk; for example, a path might map to a location in memory or on a device.</span></span> <span data-ttu-id="f1caf-105">路径的准确格式由当前平台决定。</span><span class="sxs-lookup"><span data-stu-id="f1caf-105">The exact format of a path is determined by the current platform.</span></span> <span data-ttu-id="f1caf-106">例如，在某些系统中，路径可以从驱动器或卷号开始，而此元素在其他系统中不存在。</span><span class="sxs-lookup"><span data-stu-id="f1caf-106">For example, on some systems, a path can start with a drive or volume letter, while this element is not present in other systems.</span></span> <span data-ttu-id="f1caf-107">在某些系统上，文件路径可以包含扩展，这表示文件中存储的信息的类型。</span><span class="sxs-lookup"><span data-stu-id="f1caf-107">On some systems, file paths can contain extensions, which indicate the type of information stored in the file.</span></span> <span data-ttu-id="f1caf-108">文件扩展名的格式依赖于平台;例如，某些系统将扩展限制为三个字符，而其他系统则不限制。</span><span class="sxs-lookup"><span data-stu-id="f1caf-108">The format of a file name extension is platform-dependent; for example, some systems limit extensions to three characters, and others do not.</span></span> <span data-ttu-id="f1caf-109">当前平台还决定了用于分隔路径中的元素的字符集，以及指定路径时不能使用的字符集。</span><span class="sxs-lookup"><span data-stu-id="f1caf-109">The current platform also determines the set of characters used to separate the elements of a path, and the set of characters that cannot be used when specifying paths.</span></span> <span data-ttu-id="f1caf-110">由于这些差异，`Path` 类的字段以及 `Path` 类的某些成员的确切行为取决于平台。</span><span class="sxs-lookup"><span data-stu-id="f1caf-110">Because of these differences, the fields of the `Path` class as well as the exact behavior of some members of the `Path` class are platform-dependent.</span></span>  
  
 <span data-ttu-id="f1caf-111">路径可以包含绝对或相对位置信息。</span><span class="sxs-lookup"><span data-stu-id="f1caf-111">A path can contain absolute or relative location information.</span></span> <span data-ttu-id="f1caf-112">绝对路径完全指定位置：可以唯一地标识文件或目录，而不考虑当前位置。</span><span class="sxs-lookup"><span data-stu-id="f1caf-112">Absolute paths fully specify a location: the file or directory can be uniquely identified regardless of the current location.</span></span> <span data-ttu-id="f1caf-113">相对路径指定部分位置：在定位使用相对路径指定的文件时，当前位置用作起始点。</span><span class="sxs-lookup"><span data-stu-id="f1caf-113">Relative paths specify a partial location: the current location is used as the starting point when locating a file specified with a relative path.</span></span> <span data-ttu-id="f1caf-114">若要确定当前目录，请调用 <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1caf-114">To determine the current directory, call <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.</span></span>  

 <span data-ttu-id="f1caf-115">.NET Core 1.1 及更高版本和 .NET Framework 4.6.2 及更高版本还支持访问作为设备名称的文件系统对象，例如 "\\？ \C：\"。</span><span class="sxs-lookup"><span data-stu-id="f1caf-115">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support access to file system objects that are device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="f1caf-116">有关 Windows 上的文件路径格式的详细信息，请参阅[windows 系统上的文件路径格式](~/docs/standard/io/file-path-formats.md)。</span><span class="sxs-lookup"><span data-stu-id="f1caf-116">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span>

 <span data-ttu-id="f1caf-117">`Path` 类的大多数成员不与文件系统进行交互，并且不验证路径字符串指定的文件是否存在。</span><span class="sxs-lookup"><span data-stu-id="f1caf-117">Most members of the `Path` class do not interact with the file system and do not verify the existence of the file specified by a path string.</span></span> <span data-ttu-id="f1caf-118">修改路径字符串的 `Path` 类成员（如 <xref:System.IO.Path.ChangeExtension%2A>）对文件系统中的文件名称不起作用。</span><span class="sxs-lookup"><span data-stu-id="f1caf-118">`Path` class members that modify a path string, such as <xref:System.IO.Path.ChangeExtension%2A>, have no effect on names of files in the file system.</span></span> <span data-ttu-id="f1caf-119">但 `Path` 成员将验证指定路径字符串的内容，如果字符串包含在路径字符串中无效的字符，则会引发 <xref:System.ArgumentException> 异常，如 <xref:System.IO.Path.GetInvalidPathChars%2A> 方法返回的字符中所定义的那样。</span><span class="sxs-lookup"><span data-stu-id="f1caf-119">`Path` members do, however, validate the contents of a specified path string, and throw an <xref:System.ArgumentException> exception if the string contains characters that are not valid in path strings, as defined in the characters returned from the <xref:System.IO.Path.GetInvalidPathChars%2A> method.</span></span> <span data-ttu-id="f1caf-120">例如，在基于 Windows 的桌面平台上，无效路径字符可能包括引号（"）、小于（\<）、大于号（>）、管道（&#124;）、backspace （\b）、null （\ 0）和 Unicode 字符16到18以及20到25。</span><span class="sxs-lookup"><span data-stu-id="f1caf-120">For example, on Windows-based desktop platforms, invalid path characters might include quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0), and Unicode characters 16 through 18 and 20 through 25.</span></span>  
  
 <span data-ttu-id="f1caf-121">使用 `Path` 类的成员可以快速轻松地执行常见操作，例如确定文件扩展名是否为路径的一部分，以及将两个字符串组合成一个路径名称。</span><span class="sxs-lookup"><span data-stu-id="f1caf-121">The members of the `Path` class enable you to quickly and easily perform common operations such as determining whether a file name extension is part of a path, and combining two strings into one path name.</span></span>  
  
 <span data-ttu-id="f1caf-122">`Path` 类的所有成员都是静态的，因此可以在没有路径实例的情况下调用。</span><span class="sxs-lookup"><span data-stu-id="f1caf-122">All members of the `Path` class are static and can therefore be called without having an instance of a path.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1caf-123">在接受路径作为输入字符串的成员中，该路径必须格式正确，否则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="f1caf-123">In members that accept a path as an input string, that path must be well-formed or an exception is raised.</span></span> <span data-ttu-id="f1caf-124">例如，如果路径是完全限定的，但以空格开头，则不会在类的方法中剪裁路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-124">For example, if a path is fully qualified but begins with a space, the path is not trimmed in methods of the class.</span></span> <span data-ttu-id="f1caf-125">因此，路径格式不正确，并引发异常。</span><span class="sxs-lookup"><span data-stu-id="f1caf-125">Therefore, the path is malformed and an exception is raised.</span></span> <span data-ttu-id="f1caf-126">同样，路径或路径的组合不能完全限定两次。</span><span class="sxs-lookup"><span data-stu-id="f1caf-126">Similarly, a path or a combination of paths cannot be fully qualified twice.</span></span> <span data-ttu-id="f1caf-127">例如，在大多数情况下，"c：\temp c：\windows" 也会引发异常。</span><span class="sxs-lookup"><span data-stu-id="f1caf-127">For example, "c:\temp c:\windows" also raises an exception in most cases.</span></span> <span data-ttu-id="f1caf-128">使用接受路径字符串的方法时，请确保路径格式正确。</span><span class="sxs-lookup"><span data-stu-id="f1caf-128">Ensure that your paths are well-formed when using methods that accept a path string.</span></span>  
  
 <span data-ttu-id="f1caf-129">在接受路径的成员中，路径可以引用文件或只引用目录。</span><span class="sxs-lookup"><span data-stu-id="f1caf-129">In members that accept a path, the path can refer to a file or just a directory.</span></span> <span data-ttu-id="f1caf-130">指定的路径还可以引用服务器和共享名称的相对路径或通用命名约定（UNC）路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-130">The specified path can also refer to a relative path or a Universal Naming Convention (UNC) path for a server and share name.</span></span> <span data-ttu-id="f1caf-131">例如，以下所有内容都是可接受的路径：</span><span class="sxs-lookup"><span data-stu-id="f1caf-131">For example, all the following are acceptable paths:</span></span>  
  
-   <span data-ttu-id="f1caf-132">"c：\\\MyDir\\" 中C#的 "\MyFile.txt" 或 "c:\MyDir\MyFile.txt" 中的 Visual Basic。</span><span class="sxs-lookup"><span data-stu-id="f1caf-132">"c:\\\MyDir\\\MyFile.txt" in C#, or "c:\MyDir\MyFile.txt" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="f1caf-133">Visual Basic 中的 "c：\\C#\MyDir" 或 "c:\MyDir"。</span><span class="sxs-lookup"><span data-stu-id="f1caf-133">"c:\\\MyDir" in C#, or "c:\MyDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="f1caf-134">Visual Basic 中的 "MyDir\\C#\MySubdir" 或 "MyDir\MySubDir"。</span><span class="sxs-lookup"><span data-stu-id="f1caf-134">"MyDir\\\MySubdir" in C#, or "MyDir\MySubDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="f1caf-135">\\中的 "\\\\\\\MyServer\\C#\MyShare" 或 "Visual Basic \MyServer\MyShare"。</span><span class="sxs-lookup"><span data-stu-id="f1caf-135">"\\\\\\\MyServer\\\MyShare" in C#, or "\\\MyServer\MyShare" in Visual Basic.</span></span>  
  
 <span data-ttu-id="f1caf-136">由于所有这些操作都是针对字符串执行的，因此无法验证结果在所有方案中是否有效。</span><span class="sxs-lookup"><span data-stu-id="f1caf-136">Because all these operations are performed on strings, it is impossible to verify that the results are valid in all scenarios.</span></span> <span data-ttu-id="f1caf-137">例如，<xref:System.IO.Path.GetExtension%2A> 方法会分析传递给它的字符串，并返回该字符串的扩展名。</span><span class="sxs-lookup"><span data-stu-id="f1caf-137">For example, the <xref:System.IO.Path.GetExtension%2A> method parses a string that you pass to it and returns the extension from that string.</span></span> <span data-ttu-id="f1caf-138">但是，这并不意味着磁盘上存在具有该扩展名的文件。</span><span class="sxs-lookup"><span data-stu-id="f1caf-138">However, this does not mean that a file with that extension exists on the disk.</span></span>  
  
 <span data-ttu-id="f1caf-139">有关常见 i/o 任务的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="f1caf-139">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>   
  
## Examples  
 <span data-ttu-id="f1caf-140">下面的示例演示了 `Path` 类的一些主要成员。</span><span class="sxs-lookup"><span data-stu-id="f1caf-140">The following example demonstrates some of the main members of the `Path` class.</span></span>  
  
 [!code-cpp[path class#1](~/samples/snippets/cpp/VS_Snippets_CLR/Path Class/CPP/path class.cpp#1)]
 [!code-csharp[path class#1](~/samples/snippets/csharp/VS_Snippets_CLR/Path Class/CS/path class.cs#1)]
 [!code-vb[path class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Path Class/VB/path class.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f1caf-141">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="f1caf-141">File and Stream I/O</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f1caf-142">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-142">How to: Read Text from a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f1caf-143">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-143">How to: Write Text to a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md"><span data-ttu-id="f1caf-144">如何：对新建的数据文件进行读取和写入</span><span class="sxs-lookup"><span data-stu-id="f1caf-144">How to: Read and Write to a Newly Created Data File</span></span></related>
    <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-145">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-145">File path formats on Windows systems</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="AltDirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char AltDirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.AltDirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AltDirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable AltDirectorySeparatorChar : char" Usage="System.IO.Path.AltDirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f1caf-146">提供平台特定的替换字符，该替换字符用于在反映分层文件系统组织的路径字符串中分隔目录级别。</span><span class="sxs-lookup"><span data-stu-id="f1caf-146">Provides a platform-specific alternate character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="f1caf-147">此字段可以具有与 <xref:System.IO.Path.DirectorySeparatorChar>相同的值。</span><span class="sxs-lookup"><span data-stu-id="f1caf-147">This field can have the same value as <xref:System.IO.Path.DirectorySeparatorChar>.</span></span> <span data-ttu-id="f1caf-148">`AltDirectorySeparatorChar` 和 <xref:System.IO.Path.DirectorySeparatorChar> 都适用于在路径字符串中分隔目录级别。</span><span class="sxs-lookup"><span data-stu-id="f1caf-148">`AltDirectorySeparatorChar` and <xref:System.IO.Path.DirectorySeparatorChar> are both valid for separating directory levels in a path string.</span></span>  
  
<span data-ttu-id="f1caf-149">此字段的值在基于 Windows 和 Unix 的操作系统上都是一个斜杠（"/"）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-149">The value of this field is a slash ('/') on both Windows and Unix-based operating systems.</span></span>  
  
## Examples  

<span data-ttu-id="f1caf-150">下面的示例显示 Windows 和基于 Unix 的系统上 <xref:System.IO.Path> 字段值。</span><span class="sxs-lookup"><span data-stu-id="f1caf-150">The following example displays <xref:System.IO.Path> field values on Windows and on Unix-based systems.</span></span> <span data-ttu-id="f1caf-151">请注意，Windows 支持使用正斜杠（由 <xref:System.IO.Path.AltDirectorySeparatorChar> 字段返回）或反斜杠（由 <xref:System.IO.Path.DirectorySeparatorChar> 字段返回）作为路径分隔符，而基于 Unix 的系统只支持正斜杠。</span><span class="sxs-lookup"><span data-stu-id="f1caf-151">Note that Windows supports either the forward slash (which is returned by the <xref:System.IO.Path.AltDirectorySeparatorChar> field) or the backslash (which is returned by the <xref:System.IO.Path.DirectorySeparatorChar> field) as path separator characters, while Unix-based systems support only the forward slash.</span></span>

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f1caf-152">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="f1caf-152">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f1caf-153">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-153">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f1caf-154">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-154">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ChangeExtension">
      <MemberSignature Language="C#" Value="public static string ChangeExtension (string path, string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ChangeExtension(string path, string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.ChangeExtension(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ChangeExtension (path As String, extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ChangeExtension(System::String ^ path, System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member ChangeExtension : string * string -&gt; string" Usage="System.IO.Path.ChangeExtension (path, extension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="f1caf-155">要修改的路径信息。</span><span class="sxs-lookup"><span data-stu-id="f1caf-155">The path information to modify.</span></span> <span data-ttu-id="f1caf-156">该路径不能包含在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定义的任何字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-156">The path cannot contain any of the characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></param>
        <param name="extension"><span data-ttu-id="f1caf-157">新的扩展名（有或没有前导句点）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-157">The new extension (with or without a leading period).</span></span> <span data-ttu-id="f1caf-158">指定 <see langword="null" /> 以从 <paramref name="path" /> 移除现有扩展名。</span><span class="sxs-lookup"><span data-stu-id="f1caf-158">Specify <see langword="null" /> to remove an existing extension from <paramref name="path" />.</span></span></param>
        <summary><span data-ttu-id="f1caf-159">更改路径字符串的扩展名。</span><span class="sxs-lookup"><span data-stu-id="f1caf-159">Changes the extension of a path string.</span></span></summary>
        <returns><span data-ttu-id="f1caf-160">已修改的路径信息。</span><span class="sxs-lookup"><span data-stu-id="f1caf-160">The modified path information.</span></span>  
  
<span data-ttu-id="f1caf-161">在基于 Windows 的桌面平台上，如果 <paramref name="path" /> 是 <see langword="null" /> 或空字符串 (“”)，则返回的路径信息是未修改的。</span><span class="sxs-lookup"><span data-stu-id="f1caf-161">On Windows-based desktop platforms, if <paramref name="path" /> is <see langword="null" /> or an empty string (""), the path information is returned unmodified.</span></span> <span data-ttu-id="f1caf-162">如果 <paramref name="extension" /> 为 <see langword="null" />，则返回的字符串包含指定的路径（其扩展名已移除）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-162">If <paramref name="extension" /> is <see langword="null" />, the returned string contains the specified path with its extension removed.</span></span> <span data-ttu-id="f1caf-163">如果 <paramref name="path" /> 不具有扩展名且 <paramref name="extension" /> 不为 <see langword="null" />，则返回的路径字符串包含追加到 <paramref name="extension" /> 结尾的 <paramref name="path" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-163">If <paramref name="path" /> has no extension, and <paramref name="extension" /> is not <see langword="null" />, the returned path string contains <paramref name="extension" /> appended to the end of <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1caf-164">如果 `path` 和 `extension` 都不包含句点（.），`ChangeExtension` 将添加句点。</span><span class="sxs-lookup"><span data-stu-id="f1caf-164">If neither `path` nor `extension` contains a period (.), `ChangeExtension` adds the period.</span></span>  
  
 <span data-ttu-id="f1caf-165">`extension` 参数可包含多个句点和任意有效的路径字符，可以为任意长度。</span><span class="sxs-lookup"><span data-stu-id="f1caf-165">The `extension` parameter can contain multiple periods and any valid path characters, and can be any length.</span></span> <span data-ttu-id="f1caf-166">如果 `null``extension`，则返回的字符串将包含 `path`，其中包含上一个句点以及删除后的所有字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-166">If `extension` is `null`, the returned string contains the contents of `path` with the last period and all characters following it removed.</span></span>  
  
 <span data-ttu-id="f1caf-167">如果 `extension` 为空字符串，则返回的路径字符串包含与上一个句点后面的任何字符 `path` 的内容。</span><span class="sxs-lookup"><span data-stu-id="f1caf-167">If `extension` is an empty string, the returned path string contains the contents of `path` with any characters following the last period removed.</span></span>  
  
 <span data-ttu-id="f1caf-168">如果 `path` 没有扩展，并且 `extension` 未 `null`，则返回的字符串将包含 `path` 后跟 `extension`。</span><span class="sxs-lookup"><span data-stu-id="f1caf-168">If `path` does not have an extension and `extension` is not `null`, the returned string contains `path` followed by `extension`.</span></span>  
  
 <span data-ttu-id="f1caf-169">如果 `extension` 未 `null` 并且不包含前导句点，则添加句点。</span><span class="sxs-lookup"><span data-stu-id="f1caf-169">If `extension` is not `null` and does not contain a leading period, the period is added.</span></span>  
  
 <span data-ttu-id="f1caf-170">如果 `path` 包含由多个时间段分隔的多个扩展，则返回的字符串将包含 `path` 的内容，其中最后一个句点和它后面的所有字符都由 `extension`替换。</span><span class="sxs-lookup"><span data-stu-id="f1caf-170">If `path` contains a multiple extension separated by multiple periods, the returned string contains the contents of `path` with the last period and all characters following it replaced by `extension`.</span></span> <span data-ttu-id="f1caf-171">例如，如果 `path` 是 "\Dir1\examples\pathtests.csx.txt"，并且 `extension` 为 "cs"，则修改后的路径为 "\Dir1\examples\pathtests.csx.cs"。</span><span class="sxs-lookup"><span data-stu-id="f1caf-171">For example, if `path` is "\Dir1\examples\pathtests.csx.txt" and `extension` is "cs", the modified path is "\Dir1\examples\pathtests.csx.cs".</span></span>  
  
 <span data-ttu-id="f1caf-172">不能验证返回的结果在所有方案中都有效。</span><span class="sxs-lookup"><span data-stu-id="f1caf-172">It is not possible to verify that the returned results are valid in all scenarios.</span></span> <span data-ttu-id="f1caf-173">例如，如果 `path` 为空，则追加 `extension`。</span><span class="sxs-lookup"><span data-stu-id="f1caf-173">For example, if `path` is empty, `extension` is appended.</span></span>  
  
 <span data-ttu-id="f1caf-174">有关常见 i/o 任务的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="f1caf-174">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1caf-175">下面的示例演示如何使用 `ChangeExtension` 方法。</span><span class="sxs-lookup"><span data-stu-id="f1caf-175">The following example demonstrates a use of the `ChangeExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#1)]
 [!code-csharp[System.IO.Path Members#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#1)]
 [!code-vb[System.IO.Path Members#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f1caf-176"><paramref name="path" /> 包含 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中已定义的一个或多个无效字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-176"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-177">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-177">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f1caf-178">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="f1caf-178">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f1caf-179">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-179">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f1caf-180">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-180">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f1caf-181">将多个字符串组合成一个路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-181">Combines strings into a path.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="f1caf-182">此方法旨在将各个字符串连接到表示文件路径的单个字符串。</span><span class="sxs-lookup"><span data-stu-id="f1caf-182">This method is intended to concatenate individual strings into a single string that represents a file path.</span></span> <span data-ttu-id="f1caf-183">但是，如果第一个参数不包含一个根路径，则将忽略以前的任何路径组件，并且返回的字符串将以该根路径组件开头。</span><span class="sxs-lookup"><span data-stu-id="f1caf-183">However, if an argument other than the first contains a rooted path, any previous path components are ignored, and the returned string begins with that rooted path component.</span></span> <span data-ttu-id="f1caf-184">作为 `Combine` 方法的替代方法，请考虑使用 <xref:System.IO.Path.Join%2A> 或 <xref:System.IO.Path.TryJoin%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f1caf-184">As an alternative to the `Combine` method, consider using the <xref:System.IO.Path.Join%2A> or <xref:System.IO.Path.TryJoin%2A> methods.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f1caf-185">此方法假定第一个参数是一个绝对路径，并且以下参数或参数是相对路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-185">This method assumes that the first argument is an absolute path and that the following argument or arguments are relative paths.</span></span> <span data-ttu-id="f1caf-186">如果不是这种情况，尤其是在任何后续参数都是用户输入的字符串时，请改为调用 <xref:System.IO.Path.Join%2A> 或 <xref:System.IO.Path.TryJoin%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f1caf-186">If this is not the case, and particularly if any subsequent arguments are strings input by the user, call the <xref:System.IO.Path.Join%2A> or <xref:System.IO.Path.TryJoin%2A> method instead.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Combine : string[] -&gt; string" Usage="System.IO.Path.Combine paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths"><span data-ttu-id="f1caf-187">由路径的各部分构成的数组。</span><span class="sxs-lookup"><span data-stu-id="f1caf-187">An array of parts of the path.</span></span></param>
        <summary><span data-ttu-id="f1caf-188">将字符串数组组合成一个路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-188">Combines an array of strings into a path.</span></span></summary>
        <returns><span data-ttu-id="f1caf-189">已组合的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-189">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="f1caf-190">`paths` 应是要合并的路径部分的数组。</span><span class="sxs-lookup"><span data-stu-id="f1caf-190">`paths` should be an array of the parts of the path to combine.</span></span> <span data-ttu-id="f1caf-191">如果其中一个后续路径是绝对路径，则合并操作将从该绝对路径开始重置，同时丢弃以前的所有组合路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-191">If the one of the subsequent paths is an absolute path, then the combine operation resets starting with that absolute path, discarding all previous combined paths.</span></span>  

<span data-ttu-id="f1caf-192">如果 `paths` 中的任何元素都不是驱动器，并且不是以 <xref:System.IO.Path.DirectorySeparatorChar> 或 <xref:System.IO.Path.AltDirectorySeparatorChar> 字符结尾，则 `Combine` 方法将在该元素和下一个元素之间添加 <xref:System.IO.Path.DirectorySeparatorChar> 字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-192">If any element in `paths` but the last one is not a drive and does not end with either the <xref:System.IO.Path.DirectorySeparatorChar> or the <xref:System.IO.Path.AltDirectorySeparatorChar> character, the `Combine` method adds a <xref:System.IO.Path.DirectorySeparatorChar> character between that element and the next one.</span></span> <span data-ttu-id="f1caf-193">请注意，如果元素以路径分隔符字符结尾，而该路径分隔符对于目标平台不适用，则 `Combine` 方法将保留原始路径分隔符并追加一个受支持的路径分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-193">Note that, if the element ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="f1caf-194">下面的示例将反斜杠用作路径分隔符时，比较基于 Windows 和 Unix 的系统上的结果。</span><span class="sxs-lookup"><span data-stu-id="f1caf-194">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span>

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#1)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#1)]  

 <span data-ttu-id="f1caf-195">将从组合路径中省略长度为零的字符串。</span><span class="sxs-lookup"><span data-stu-id="f1caf-195">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="f1caf-196">如果参数有空白，则不会对其进行分析。</span><span class="sxs-lookup"><span data-stu-id="f1caf-196">The parameters are not parsed if they have white space.</span></span>  
  
 <span data-ttu-id="f1caf-197">不是目录和文件名的所有无效字符都被 `Combine` 方法解释为不可接受的，因为您可以使用这些字符搜索通配符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-197">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="f1caf-198">例如，如果您要从中创建文件，则 `Path.Combine("c:\\", "*.txt")` 可能无效，它作为搜索字符串有效。</span><span class="sxs-lookup"><span data-stu-id="f1caf-198">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="f1caf-199">因此，`Combine` 方法成功解释了此方法。</span><span class="sxs-lookup"><span data-stu-id="f1caf-199">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
## Examples  
 <span data-ttu-id="f1caf-200">下面的示例将字符串数组合并到路径中。</span><span class="sxs-lookup"><span data-stu-id="f1caf-200">The following example combines an array of strings into a path.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#3)]
 [!code-vb[System.IO.Path.Combine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f1caf-201">数组中的一个字符串包含 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定义的一个或多个无效字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-201">One of the strings in the array contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f1caf-202">数组中的一个字符串为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-202">One of the strings in the array is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-203">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-203">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="f1caf-204">要组合的第一个路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-204">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="f1caf-205">要组合的第二个路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-205">The second path to combine.</span></span></param>
        <summary><span data-ttu-id="f1caf-206">将两个字符串组合成一个路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-206">Combines two strings into a path.</span></span></summary>
        <returns><span data-ttu-id="f1caf-207">已组合的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-207">The combined paths.</span></span> <span data-ttu-id="f1caf-208">如果指定的路径之一是零长度字符串，则该方法返回其他路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-208">If one of the specified paths is a zero-length string, this method returns the other path.</span></span> <span data-ttu-id="f1caf-209">如果 <paramref name="path2" /> 包含绝对路径，则该方法返回 <paramref name="path2" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-209">If <paramref name="path2" /> contains an absolute path, this method returns <paramref name="path2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1caf-210">如果 `path1` 不是驱动器引用（即 "C：" 或 "D："），并且不是以 <xref:System.IO.Path.DirectorySeparatorChar>、<xref:System.IO.Path.AltDirectorySeparatorChar>或 <xref:System.IO.Path.VolumeSeparatorChar>中定义的有效分隔符结尾，则在串联之前会将 <xref:System.IO.Path.DirectorySeparatorChar> 追加到 `path1`。</span><span class="sxs-lookup"><span data-stu-id="f1caf-210">If `path1` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` before concatenation.</span></span> <span data-ttu-id="f1caf-211">请注意，如果 `path1` 以与目标平台不适用的路径分隔符结尾，则 `Combine` 方法会保留原始路径分隔符并追加受支持的字符分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-211">Note that if `path1` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="f1caf-212">下面的示例将反斜杠用作路径分隔符时，比较基于 Windows 和 Unix 的系统上的结果。</span><span class="sxs-lookup"><span data-stu-id="f1caf-212">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span>  
  
[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#2)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#2)]  

 <span data-ttu-id="f1caf-213">如果 `path2` 不包含根（例如，如果 `path2` 不是以分隔符字符或驱动器规范开头），则会将这两个路径与一个中间分隔符字符串联在一起。</span><span class="sxs-lookup"><span data-stu-id="f1caf-213">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="f1caf-214">如果 `path2` 包含一个根，则返回 `path2`。</span><span class="sxs-lookup"><span data-stu-id="f1caf-214">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="f1caf-215">如果参数有空白，则不会对其进行分析。</span><span class="sxs-lookup"><span data-stu-id="f1caf-215">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="f1caf-216">因此，如果 `path2` 包括空格（例如 "\file.txt"），则 <xref:System.IO.Path.Combine%2A> 方法会将 `path2` 追加到 `path1`，而不是仅返回 `path2`。</span><span class="sxs-lookup"><span data-stu-id="f1caf-216">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1` instead of returning only `path2`.</span></span>  
  
 <span data-ttu-id="f1caf-217">不是目录和文件名的所有无效字符都被 `Combine` 方法解释为不可接受的，因为您可以使用这些字符搜索通配符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-217">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="f1caf-218">例如，如果您要从中创建文件，则 `Path.Combine("c:\\", "*.txt")` 可能无效，它作为搜索字符串有效。</span><span class="sxs-lookup"><span data-stu-id="f1caf-218">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="f1caf-219">因此，`Combine` 方法成功解释了此方法。</span><span class="sxs-lookup"><span data-stu-id="f1caf-219">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
 <span data-ttu-id="f1caf-220">有关常见 i/o 任务的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="f1caf-220">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1caf-221">下面的示例演示如何在基于 Windows 的桌面平台上使用 `Combine` 方法。</span><span class="sxs-lookup"><span data-stu-id="f1caf-221">The following example demonstrates using the `Combine` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[pathcombine#1](~/samples/snippets/cpp/VS_Snippets_CLR/pathcombine/CPP/pathcombine.cpp#1)]
 [!code-csharp[pathcombine#1](~/samples/snippets/csharp/VS_Snippets_CLR/pathcombine/CS/pathcombine.cs#1)]
 [!code-vb[pathcombine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/pathcombine/VB/pathcombine.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f1caf-222"><paramref name="path1" /> 或 <paramref name="path2" /> 包含一个或多个在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定义的无效字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-222"><paramref name="path1" /> or <paramref name="path2" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f1caf-223"><paramref name="path1" /> 或 <paramref name="path2" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-223"><paramref name="path1" /> or <paramref name="path2" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-224">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-224">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f1caf-225">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="f1caf-225">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f1caf-226">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-226">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f1caf-227">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-227">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="f1caf-228">要组合的第一个路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-228">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="f1caf-229">要组合的第二个路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-229">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="f1caf-230">要组合的第三个路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-230">The third path to combine.</span></span></param>
        <summary><span data-ttu-id="f1caf-231">将三个字符串组合成一个路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-231">Combines three strings into a path.</span></span></summary>
        <returns><span data-ttu-id="f1caf-232">已组合的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-232">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1caf-233">`path1` 应为绝对路径（例如，"d:\archives" 或 "\\\archives\public"）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-233">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").</span></span> <span data-ttu-id="f1caf-234">如果 `path2` 或 `path3` 也是绝对路径，则合并操作将放弃所有以前合并的路径，并重置为该绝对路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-234">If `path2` or `path3` is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="f1caf-235">将从组合路径中省略长度为零的字符串。</span><span class="sxs-lookup"><span data-stu-id="f1caf-235">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="f1caf-236">如果 `path1` 或 `path2` 不是驱动器引用（即 "C：" 或 "D："），并且不是以 <xref:System.IO.Path.DirectorySeparatorChar>、<xref:System.IO.Path.AltDirectorySeparatorChar>或 <xref:System.IO.Path.VolumeSeparatorChar>中定义的有效分隔符结尾，则 <xref:System.IO.Path.DirectorySeparatorChar> 在串联前追加到 `path1` 或 `path2`。</span><span class="sxs-lookup"><span data-stu-id="f1caf-236">If `path1` or `path2` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` or `path2` before concatenation.</span></span> <span data-ttu-id="f1caf-237">请注意，如果 `path1` 或 `path2` 以与目标平台不适用的路径分隔符结尾，则 `Combine` 方法将保留原始路径分隔符并追加一个受支持的字符分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-237">Note that if `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="f1caf-238">下面的示例将反斜杠用作路径分隔符时，比较基于 Windows 和 Unix 的系统上的结果。</span><span class="sxs-lookup"><span data-stu-id="f1caf-238">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span> 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#3)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#3)]  

 <span data-ttu-id="f1caf-239">如果 `path2` 不包含根（例如，如果 `path2` 不是以分隔符字符或驱动器规范开头），则会将这两个路径与一个中间分隔符字符串联在一起。</span><span class="sxs-lookup"><span data-stu-id="f1caf-239">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="f1caf-240">如果 `path2` 包含一个根，则返回 `path2`。</span><span class="sxs-lookup"><span data-stu-id="f1caf-240">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="f1caf-241">如果参数有空白，则不会对其进行分析。</span><span class="sxs-lookup"><span data-stu-id="f1caf-241">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="f1caf-242">因此，如果 `path2` 包括空格（例如 "\file.txt"），<xref:System.IO.Path.Combine%2A> 方法会将 `path2` 追加到 `path1`。</span><span class="sxs-lookup"><span data-stu-id="f1caf-242">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="f1caf-243">不是目录和文件名的所有无效字符都被 `Combine` 方法解释为不可接受的，因为您可以使用这些字符搜索通配符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-243">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="f1caf-244">例如，如果您要从中创建文件，则 `Path.Combine("c:\\", "*.txt")` 可能无效，它作为搜索字符串有效。</span><span class="sxs-lookup"><span data-stu-id="f1caf-244">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="f1caf-245">因此，`Combine` 方法成功解释了此方法。</span><span class="sxs-lookup"><span data-stu-id="f1caf-245">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1caf-246">下面的示例将三个路径组合在一起。</span><span class="sxs-lookup"><span data-stu-id="f1caf-246">The following example combines three paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#1)]
 [!code-vb[System.IO.Path.Combine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f1caf-247"><paramref name="path1" />、<paramref name="path2" /> 或 <paramref name="path3" /> 包含一个或多个在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定义的无效字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-247"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f1caf-248"><paramref name="path1" />、<paramref name="path2" /> 或 <paramref name="path3" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-248"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-249">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-249">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="f1caf-250">要组合的第一个路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-250">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="f1caf-251">要组合的第二个路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-251">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="f1caf-252">要组合的第三个路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-252">The third path to combine.</span></span></param>
        <param name="path4"><span data-ttu-id="f1caf-253">要组合的第四个路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-253">The fourth path to combine.</span></span></param>
        <summary><span data-ttu-id="f1caf-254">将四个字符串组合成一个路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-254">Combines four strings into a path.</span></span></summary>
        <returns><span data-ttu-id="f1caf-255">已组合的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-255">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1caf-256">`path1` 应为绝对路径（例如，"d:\archives" 或 "\\\archives\public"）。如果其中一个后续路径也是绝对路径，则合并操作会丢弃所有以前合并的路径，并重置为该绝对路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-256">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").If one of the subsequent paths is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="f1caf-257">将从组合路径中省略长度为零的字符串。</span><span class="sxs-lookup"><span data-stu-id="f1caf-257">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="f1caf-258">如果 `path1`、`path2`或 `path3` 不是驱动器引用（即 "C：" 或 "D："），并且不是以 <xref:System.IO.Path.DirectorySeparatorChar>、<xref:System.IO.Path.AltDirectorySeparatorChar>或 <xref:System.IO.Path.VolumeSeparatorChar>中定义的有效分隔符结尾，则在串联之前会将 <xref:System.IO.Path.DirectorySeparatorChar> 追加到其中。</span><span class="sxs-lookup"><span data-stu-id="f1caf-258">If `path1`, `path2`, or `path3` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to it before concatenation.</span></span> <span data-ttu-id="f1caf-259">请注意，如果 `path1`、`path2`或 `path3` 以路径分隔符而不适合目标平台结束，则 `Combine` 方法将保留原始路径分隔符并追加一个受支持的字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-259">Note that if `path1`, `path2`, or `path3` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="f1caf-260">下面的示例将反斜杠用作路径分隔符时，比较基于 Windows 和 Unix 的系统上的结果。</span><span class="sxs-lookup"><span data-stu-id="f1caf-260">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span> 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#4)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#4)]   
  
 <span data-ttu-id="f1caf-261">如果 `path2` 不包含根（例如，如果 `path2` 不是以分隔符字符或驱动器规范开头），则会将这两个路径与一个中间分隔符字符串联在一起。</span><span class="sxs-lookup"><span data-stu-id="f1caf-261">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="f1caf-262">如果 `path2` 包含一个根，则返回 `path2`。</span><span class="sxs-lookup"><span data-stu-id="f1caf-262">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="f1caf-263">如果参数有空白，则不会对其进行分析。</span><span class="sxs-lookup"><span data-stu-id="f1caf-263">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="f1caf-264">因此，如果 `path2` 包括空格（例如 "\file.txt"），<xref:System.IO.Path.Combine%2A> 方法会将 `path2` 追加到 `path1`。</span><span class="sxs-lookup"><span data-stu-id="f1caf-264">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="f1caf-265">不是目录和文件名的所有无效字符都被 `Combine` 方法解释为不可接受的，因为您可以使用这些字符搜索通配符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-265">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="f1caf-266">例如，如果您要从中创建文件，则 `Path.Combine("c:\\", "*.txt")` 可能无效，它作为搜索字符串有效。</span><span class="sxs-lookup"><span data-stu-id="f1caf-266">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="f1caf-267">因此，`Combine` 方法成功解释了此方法。</span><span class="sxs-lookup"><span data-stu-id="f1caf-267">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1caf-268">下面的示例将四个路径组合在一起。</span><span class="sxs-lookup"><span data-stu-id="f1caf-268">The following example combines four paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#2)]
 [!code-vb[System.IO.Path.Combine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f1caf-269"><paramref name="path1" />、<paramref name="path2" />、<paramref name="path3" /> 或 <paramref name="path4" /> 包含一个或多个在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定义的无效字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-269"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f1caf-270"><paramref name="path1" />、<paramref name="path2" />、<paramref name="path3" /> 或 <paramref name="path4" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-270"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-271">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-271">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char DirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char DirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.DirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char DirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable DirectorySeparatorChar : char" Usage="System.IO.Path.DirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f1caf-272">提供平台特定的字符，该字符用于在反映分层文件系统组织的路径字符串中分隔目录级别。</span><span class="sxs-lookup"><span data-stu-id="f1caf-272">Provides a platform-specific character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="f1caf-273"><xref:System.IO.Path.AltDirectorySeparatorChar> 和 `DirectorySeparatorChar` 都适用于在路径字符串中分隔目录级别。</span><span class="sxs-lookup"><span data-stu-id="f1caf-273"><xref:System.IO.Path.AltDirectorySeparatorChar> and `DirectorySeparatorChar` are both valid for separating directory levels in a path string.</span></span>  
  
<span data-ttu-id="f1caf-274">使用 .NET Core 开发在多个平台上运行的应用程序时：</span><span class="sxs-lookup"><span data-stu-id="f1caf-274">When you are using .NET Core to develop applications that run on multiple platforms:</span></span>

- <span data-ttu-id="f1caf-275">如果你想要对目录分隔符进行硬编码，则应使用正斜杠（`/`）字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-275">If you prefer to hard-code the directory separator character, you should use the forward slash (`/`) character.</span></span> <span data-ttu-id="f1caf-276">它是 Unix 系统上唯一可识别的目录分隔符，如示例的输出所示，是 Windows 上的 <xref:System.IO.Path.AltDirectorySeparatorChar>。</span><span class="sxs-lookup"><span data-stu-id="f1caf-276">It is the only recognized directory separator character on Unix systems, as the output from the example shows, and is the <xref:System.IO.Path.AltDirectorySeparatorChar> on Windows.</span></span>

- <span data-ttu-id="f1caf-277">使用字符串串联在运行时动态检索路径分隔符，并将其合并到文件系统路径中。</span><span class="sxs-lookup"><span data-stu-id="f1caf-277">Use string concatenation to dynamically retrieve the path separator character at runtime and incorporate it into file system paths.</span></span> <span data-ttu-id="f1caf-278">例如，</span><span class="sxs-lookup"><span data-stu-id="f1caf-278">For example,</span></span> 

   ```csharp
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ```

   ```vb
   separator = Path.DirectorySeparatorChar
   path = $"{separator}users{separator}user1{separator}"
   ``` 

   <span data-ttu-id="f1caf-279">你还可以从 "<xref:System.IO.Path.AltDirectorySeparatorChar>" 属性检索值，因为它在基于 Windows 和 Unx 的系统上是相同的。</span><span class="sxs-lookup"><span data-stu-id="f1caf-279">You can also retrieve the value from the <xref:System.IO.Path.AltDirectorySeparatorChar> property, since it is the same on both Windows and Unx-based systems.</span></span>

- <span data-ttu-id="f1caf-280">检索 <xref:System.IO.Path.AltDirectorySeparatorChar> 属性</span><span class="sxs-lookup"><span data-stu-id="f1caf-280">Retrieve the <xref:System.IO.Path.AltDirectorySeparatorChar> property</span></span>

<span data-ttu-id="f1caf-281">如果你的应用程序不是跨平台的，你可以使用适用于你的系统的分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-281">If your application is not cross-platform, you can use the separator appropriate for your system.</span></span>

## Examples  

<span data-ttu-id="f1caf-282">下面的示例显示 Windows 和基于 Unix 的系统上 <xref:System.IO.Path> 字段值。</span><span class="sxs-lookup"><span data-stu-id="f1caf-282">The following example displays <xref:System.IO.Path> field values on Windows and on Unix-based systems.</span></span> <span data-ttu-id="f1caf-283">请注意，Windows 支持使用正斜杠（由 <xref:System.IO.Path.AltDirectorySeparatorChar> 字段返回）或反斜杠（由 <xref:System.IO.Path.DirectorySeparatorChar> 字段返回）作为路径分隔符，而基于 Unix 的系统只支持正斜杠。</span><span class="sxs-lookup"><span data-stu-id="f1caf-283">Note that Windows supports either the forward slash (which is returned by the <xref:System.IO.Path.AltDirectorySeparatorChar> field) or the backslash (which is returned by the <xref:System.IO.Path.DirectorySeparatorChar> field) as path separator characters, while Unix-based systems support only the forward slash.</span></span>  

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f1caf-284">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="f1caf-284">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-285">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-285">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f1caf-286">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-286">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f1caf-287">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-287">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EndsInDirectorySeparator">
      <MemberSignature Language="C#" Value="public static bool EndsInDirectorySeparator (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsInDirectorySeparator(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.EndsInDirectorySeparator(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndsInDirectorySeparator (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EndsInDirectorySeparator(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member EndsInDirectorySeparator : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.EndsInDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="f1caf-288">要分析的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-288">The path to analyze.</span></span></param>
        <summary><span data-ttu-id="f1caf-289">返回一个值，该值指示指定为只读范围的路径是否以目录分隔符结尾。</span><span class="sxs-lookup"><span data-stu-id="f1caf-289">Returns a value that indicates whether the path, specified as a read-only span, ends in a directory separator.</span></span></summary>
        <returns><span data-ttu-id="f1caf-290">如果该路径以目录分隔符结尾，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-290"><see langword="true" /> if the path ends in a directory separator; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsInDirectorySeparator">
      <MemberSignature Language="C#" Value="public static bool EndsInDirectorySeparator (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsInDirectorySeparator(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.EndsInDirectorySeparator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndsInDirectorySeparator (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EndsInDirectorySeparator(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EndsInDirectorySeparator : string -&gt; bool" Usage="System.IO.Path.EndsInDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="f1caf-291">要分析的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-291">The path to analyze.</span></span></param>
        <summary><span data-ttu-id="f1caf-292">返回一个值，该值指示指定的路径是否以目录分隔符结尾。</span><span class="sxs-lookup"><span data-stu-id="f1caf-292">Returns a value that indicates whether the specified path ends in a directory separator.</span></span></summary>
        <returns><span data-ttu-id="f1caf-293">如果该路径以目录分隔符结尾，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-293"><see langword="true" /> if the path ends in a directory separator; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetDirectoryName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetDirectoryName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetDirectoryName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="f1caf-294">要从中检索目录信息的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-294">The path to retrieve the directory information from.</span></span></param>
        <summary><span data-ttu-id="f1caf-295">返回由字符范围表示的指定路径的目录信息。</span><span class="sxs-lookup"><span data-stu-id="f1caf-295">Returns the directory information for the specified path represented by a character span.</span></span></summary>
        <returns><span data-ttu-id="f1caf-296"><paramref name="path" /> 的目录信息，如果 <paramref name="path" /> 为 <see langword="null" />空范围或根（例如 \,C: 或\\server\share），则为空跨度。</span><span class="sxs-lookup"><span data-stu-id="f1caf-296">Directory information for <paramref name="path" />, or an empty span if <paramref name="path" /> is <see langword="null" />, an empty span, or a root (such as \, C:, or \\server\share).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="f1caf-297">与字符串重载不同，此方法不会将目录分隔符标准化。</span><span class="sxs-lookup"><span data-stu-id="f1caf-297">Unlike the string overload, this method doesn't normalize directory separators.</span></span>

          ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-298">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-298">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static string GetDirectoryName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : string -&gt; string" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="f1caf-299">文件或目录的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-299">The path of a file or directory.</span></span></param>
        <summary><span data-ttu-id="f1caf-300">返回指定路径字符串的目录信息。</span><span class="sxs-lookup"><span data-stu-id="f1caf-300">Returns the directory information for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="f1caf-301"><paramref name="path" /> 的目录信息；如果 <see langword="null" /> 表示根目录或为 null，则为 <paramref name="path" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-301">Directory information for <paramref name="path" />, or <see langword="null" /> if <paramref name="path" /> denotes a root directory or is null.</span></span> <span data-ttu-id="f1caf-302">如果 <see cref="F:System.String.Empty" /> 不包含目录信息，则返回 <paramref name="path" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-302">Returns <see cref="F:System.String.Empty" /> if <paramref name="path" /> does not contain directory information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1caf-303">在大多数情况下，此方法返回的字符串包含路径中的所有字符，但不包括最后的 <xref:System.IO.Path.DirectorySeparatorChar> 或 <xref:System.IO.Path.AltDirectorySeparatorChar>。</span><span class="sxs-lookup"><span data-stu-id="f1caf-303">In most cases, the string returned by this method consists of all characters in the path up to but not including the last <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span> <span data-ttu-id="f1caf-304">如果路径包含根目录（如 "c：\\"），则返回 null。</span><span class="sxs-lookup"><span data-stu-id="f1caf-304">If the path consists of a root directory, such as "c:\\", null is returned.</span></span> <span data-ttu-id="f1caf-305">请注意，此方法不支持使用 "file：" 的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-305">Note that this method does not support paths using "file:".</span></span> <span data-ttu-id="f1caf-306">由于返回的路径不包括 <xref:System.IO.Path.DirectorySeparatorChar> 或 <xref:System.IO.Path.AltDirectorySeparatorChar>，因此将返回的路径传递回 <xref:System.IO.Path.GetDirectoryName%2A> 方法会导致对结果字符串的每个后续调用截断一个文件夹级别。</span><span class="sxs-lookup"><span data-stu-id="f1caf-306">Because the returned path does not include the <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, passing the returned path back into the <xref:System.IO.Path.GetDirectoryName%2A> method will result in the truncation of one folder level per subsequent call on the result string.</span></span> <span data-ttu-id="f1caf-307">例如，将路径 "C:\Directory\SubDirectory\test.txt" 传递到 <xref:System.IO.Path.GetDirectoryName%2A> 方法将返回 "C:\Directory\SubDirectory"。</span><span class="sxs-lookup"><span data-stu-id="f1caf-307">For example, passing the path "C:\Directory\SubDirectory\test.txt" into the <xref:System.IO.Path.GetDirectoryName%2A> method will return "C:\Directory\SubDirectory".</span></span> <span data-ttu-id="f1caf-308">将该字符串 "C:\Directory\SubDirectory" 传递到 <xref:System.IO.Path.GetDirectoryName%2A> 将导致 "C:\Directory"。</span><span class="sxs-lookup"><span data-stu-id="f1caf-308">Passing that string, "C:\Directory\SubDirectory", into <xref:System.IO.Path.GetDirectoryName%2A> will result in "C:\Directory".</span></span>  
  
 <span data-ttu-id="f1caf-309">有关常见 i/o 任务的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="f1caf-309">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1caf-310">下面的示例演示如何在基于 Windows 的桌面平台上使用 `GetDirectoryName` 方法。</span><span class="sxs-lookup"><span data-stu-id="f1caf-310">The following example demonstrates using the `GetDirectoryName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#3)]
 [!code-csharp[System.IO.Path Members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#3)]
 [!code-vb[System.IO.Path Members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f1caf-311">该 <paramref name="path" /> 参数包含无效字符，为空，或仅包含空格。</span><span class="sxs-lookup"><span data-stu-id="f1caf-311">The <paramref name="path" /> parameter contains invalid characters, is empty, or contains only white spaces.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="f1caf-312">在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.IO.IOException" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-312">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="f1caf-313"><paramref name="path" /> 参数超过系统定义的最大长度。</span><span class="sxs-lookup"><span data-stu-id="f1caf-313">The <paramref name="path" /> parameter is longer than the system-defined maximum length.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-314">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-314">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f1caf-315">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="f1caf-315">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f1caf-316">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-316">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f1caf-317">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-317">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="f1caf-318">从中获取扩展名的文件路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-318">The file path from which to get the extension.</span></span></param>
        <summary><span data-ttu-id="f1caf-319">返回由只读字符范围表示的文件路径的扩展名。</span><span class="sxs-lookup"><span data-stu-id="f1caf-319">Returns the extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="f1caf-320">指定路径的扩展名（包括句点“.”）；如果 <see cref="P:System.ReadOnlySpan`1.Empty" /> 没有扩展信息，则为 <paramref name="path" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-320">The extension of the specified path (including the period, "."), or <see cref="P:System.ReadOnlySpan`1.Empty" /> if <paramref name="path" /> does not have extension information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="f1caf-321">此方法通过搜索句点（"."）的 `path` 来获取 `path` 的扩展，从只读范围中的最后一个字符开始直到其第一个字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-321">This method obtains the extension of `path` by searching `path` for a period ("."), starting from the last character in the read-only span and continuing toward its first character.</span></span> <span data-ttu-id="f1caf-322">如果在 <xref:System.IO.Path.DirectorySeparatorChar> 或 <xref:System.IO.Path.AltDirectorySeparatorChar> 字符之前找到句点，则返回的只读范围将包含句点和后面的字符;否则，将返回 <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1caf-322">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned read-only span contains the period and the characters after it; otherwise, <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> is returned.</span></span>  

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-323">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-323">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static string GetExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : string -&gt; string" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="f1caf-324">从中获取扩展名的路径字符串。</span><span class="sxs-lookup"><span data-stu-id="f1caf-324">The path string from which to get the extension.</span></span></param>
        <summary><span data-ttu-id="f1caf-325">返回指定路径字符串的扩展名（包括句点“.”）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-325">Returns the extension (including the period ".") of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="f1caf-326">指定路径的扩展名（包含句点“.”）、或 <see langword="null" />、或 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-326">The extension of the specified path (including the period "."), or <see langword="null" />, or <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="f1caf-327">如果 <paramref name="path" /> 为 <see langword="null" />，则 <see cref="M:System.IO.Path.GetExtension(System.String)" /> 返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-327">If <paramref name="path" /> is <see langword="null" />, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see langword="null" />.</span></span> <span data-ttu-id="f1caf-328">如果 <paramref name="path" /> 不具有扩展名信息，则 <see cref="M:System.IO.Path.GetExtension(System.String)" /> 返回 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-328">If <paramref name="path" /> does not have extension information, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="f1caf-329">此方法通过搜索句点（.） `path`，从 `path` 中的最后一个字符开始直到第一个字符，从而获取 `path` 的扩展。</span><span class="sxs-lookup"><span data-stu-id="f1caf-329">This method obtains the extension of `path` by searching `path` for a period (.), starting with the last character in `path` and continuing toward the first character.</span></span> <span data-ttu-id="f1caf-330">如果在 <xref:System.IO.Path.DirectorySeparatorChar> 或 <xref:System.IO.Path.AltDirectorySeparatorChar> 字符之前找到句点，则返回的字符串将包含句点和后面的字符;否则，将返回 <xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1caf-330">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned string contains the period and the characters after it; otherwise, <xref:System.String.Empty?displayProperty=nameWithType> is returned.</span></span>  
  
 <span data-ttu-id="f1caf-331">有关常见 i/o 任务的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="f1caf-331">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>
 
## Examples  
 <span data-ttu-id="f1caf-332">下面的示例演示如何在基于 Windows 的桌面平台上使用 `GetExtension` 方法。</span><span class="sxs-lookup"><span data-stu-id="f1caf-332">The following example demonstrates using the `GetExtension` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#4)]
 [!code-csharp[System.IO.Path Members#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#4)]
 [!code-vb[System.IO.Path Members#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f1caf-333"><paramref name="path" /> 包含 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中已定义的一个或多个无效字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-333"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-334">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-334">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f1caf-335">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="f1caf-335">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f1caf-336">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-336">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f1caf-337">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-337">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="f1caf-338">一个只读范围，包含从中获取文件名和扩展名的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-338">A read-only span that contains the path from which to obtain the file name and extension.</span></span></param>
        <summary><span data-ttu-id="f1caf-339">返回由只读字符范围表示的文件路径的文件名和扩展名。</span><span class="sxs-lookup"><span data-stu-id="f1caf-339">Returns the file name and extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="f1caf-340"><paramref name="path" /> 中最后的目录分隔符后的字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-340">The characters after the last directory separator character in <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="f1caf-341">返回的只读范围包含在 `path`中最后一个分隔符后面的路径的字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-341">The returned read-only span contains the characters of the path that follow the last separator in `path`.</span></span> <span data-ttu-id="f1caf-342">如果 `path` 中的最后一个字符是一个卷或目录分隔符字符，则该方法将返回 <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1caf-342">If the last character in `path` is a volume or directory separator character, the method returns <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f1caf-343">如果 `path` 不包含分隔符，该方法将返回 `path`。</span><span class="sxs-lookup"><span data-stu-id="f1caf-343">If `path` contains no separator character, the method returns `path`.</span></span>

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-344">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-344">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static string GetFileName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : string -&gt; string" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="f1caf-345">从中获取文件名和扩展名的路径字符串。</span><span class="sxs-lookup"><span data-stu-id="f1caf-345">The path string from which to obtain the file name and extension.</span></span></param>
        <summary><span data-ttu-id="f1caf-346">返回指定路径字符串的文件名和扩展名。</span><span class="sxs-lookup"><span data-stu-id="f1caf-346">Returns the file name and extension of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="f1caf-347"><paramref name="path" /> 中最后的目录分隔符后的字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-347">The characters after the last directory separator character in <paramref name="path" />.</span></span> <span data-ttu-id="f1caf-348">如果 <paramref name="path" /> 的最后一个字符是目录或卷分隔符，则此方法返回 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-348">If the last character of <paramref name="path" /> is a directory or volume separator character, this method returns <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="f1caf-349">如果 <paramref name="path" /> 为 <see langword="null" />，则此方法返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-349">If <paramref name="path" /> is <see langword="null" />, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="f1caf-350">如果文件路径 `null`，则返回的值为 `null`。</span><span class="sxs-lookup"><span data-stu-id="f1caf-350">The returned value is `null` if the file path is `null`.</span></span>  
  
<span data-ttu-id="f1caf-351">用于确定文件名开头的分隔符用于 <xref:System.IO.Path.DirectorySeparatorChar> 和 <xref:System.IO.Path.AltDirectorySeparatorChar>。</span><span class="sxs-lookup"><span data-stu-id="f1caf-351">The separator characters used to determine the start of the file name are <xref:System.IO.Path.DirectorySeparatorChar> and <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span>  

<span data-ttu-id="f1caf-352">由于*\\*是 Unix 上的合法文件名，在基于 unix 的平台下运行的 `GetFileName` 不能从基于 windows 的路径（如*C：\\mydir\\myfile.txt*）正确返回文件名，但在基于 windows 的平台下运行 `GetFileName` 可从基于 unix 的路径（如 */tmp/myfile.ext*）正确返回文件名，因此 `GetFileName` 方法的行为在基于 unix 和基于 Windows 的平台上并不完全相同。</span><span class="sxs-lookup"><span data-stu-id="f1caf-352">Because *\\* is a legal file name on Unix, `GetFileName` running under Unix-based platforms cannot correctly return the file name from a Windows-based path like *C:\\mydir\\myfile.ext*, but `GetFileName` running under Windows-based platforms can correctly return the file name from a Unix-based path like */tmp/myfile.ext*, so the behavior of the `GetFileName` method is not strictly the same on Unix-based and Windows-based platforms.</span></span>

<span data-ttu-id="f1caf-353">有关常见 i/o 任务的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="f1caf-353">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1caf-354">下面的示例演示了基于 Windows 的桌面平台上的 `GetFileName` 方法的行为。</span><span class="sxs-lookup"><span data-stu-id="f1caf-354">The following example demonstrates the behavior of the `GetFileName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#5)]
 [!code-csharp[System.IO.Path Members#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#5)]
 [!code-vb[System.IO.Path Members#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f1caf-355"><paramref name="path" /> 包含 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中已定义的一个或多个无效字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-355"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-356">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-356">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f1caf-357">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="f1caf-357">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f1caf-358">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-358">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f1caf-359">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-359">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileNameWithoutExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="f1caf-360">一个只读范围，包含从中获取没有扩展名的文件名的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-360">A read-only span that contains the path from which to obtain the file name without the extension.</span></span></param>
        <summary><span data-ttu-id="f1caf-361">返回文件名，该文件名不带由只读字符范围表示的文件路径扩展名。</span><span class="sxs-lookup"><span data-stu-id="f1caf-361">Returns the file name without the extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="f1caf-362">由 <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" /> 返回的只读范围中的字符，但不包括最后一个句点 (.) 及其后面的所有字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-362">The characters in the read-only span returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-363">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-363">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static string GetFileNameWithoutExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileNameWithoutExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileNameWithoutExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : string -&gt; string" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="f1caf-364">文件的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-364">The path of the file.</span></span></param>
        <summary><span data-ttu-id="f1caf-365">返回不具有扩展名的指定路径字符串的文件名。</span><span class="sxs-lookup"><span data-stu-id="f1caf-365">Returns the file name of the specified path string without the extension.</span></span></summary>
        <returns><span data-ttu-id="f1caf-366">由 <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" /> 返回的字符串，但不包括最后的句点 (.) 以及之后的所有字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-366">The string returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1caf-367">此方法不会验证路径或文件名是否存在。</span><span class="sxs-lookup"><span data-stu-id="f1caf-367">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="f1caf-368">有关常见 i/o 任务的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="f1caf-368">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1caf-369">下面的示例演示如何使用 `GetFileNameWithoutExtension` 方法。</span><span class="sxs-lookup"><span data-stu-id="f1caf-369">The following example demonstrates a use of the `GetFileNameWithoutExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#6)]
 [!code-csharp[System.IO.Path Members#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#6)]
 [!code-vb[System.IO.Path Members#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f1caf-370"><paramref name="path" /> 包含 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中已定义的一个或多个无效字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-370"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-371">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-371">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f1caf-372">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="f1caf-372">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f1caf-373">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-373">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f1caf-374">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-374">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string -&gt; string" Usage="System.IO.Path.GetFullPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="f1caf-375">要获取其绝对路径信息的文件或目录。</span><span class="sxs-lookup"><span data-stu-id="f1caf-375">The file or directory for which to obtain absolute path information.</span></span></param>
        <summary><span data-ttu-id="f1caf-376">返回指定路径字符串的绝对路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-376">Returns the absolute path for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="f1caf-377"><paramref name="path" /> 的完全限定的位置，例如“C:\MyFile.txt”。</span><span class="sxs-lookup"><span data-stu-id="f1caf-377">The fully qualified location of <paramref name="path" />, such as "C:\MyFile.txt".</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="f1caf-378">绝对路径包含定位系统中的文件或目录所需的所有信息。</span><span class="sxs-lookup"><span data-stu-id="f1caf-378">The absolute path includes all information required to locate a file or directory on a system.</span></span>  
  
 <span data-ttu-id="f1caf-379">`path` 指定的文件或目录不存在。</span><span class="sxs-lookup"><span data-stu-id="f1caf-379">The file or directory specified by `path` is not required to exist.</span></span> <span data-ttu-id="f1caf-380">例如，如果*c:\temp\newdir*为当前目录，则对文件名调用 `GetFullPath` （如*test.txt* ）将返回*c:\temp\newdir\test.txt*。</span><span class="sxs-lookup"><span data-stu-id="f1caf-380">For example, if *c:\temp\newdir* is the current directory, calling `GetFullPath` on a file name such as *test.txt* returns *c:\temp\newdir\test.txt*.</span></span> <span data-ttu-id="f1caf-381">文件不需要存在。</span><span class="sxs-lookup"><span data-stu-id="f1caf-381">The file need not exist.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="f1caf-382">如果 `path` 是相对路径，则此重载返回可基于当前驱动器和当前目录的完全限定路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-382">If `path` is a relative path, this overload returns a fully qualified path that can be based on the current drive and current directory.</span></span> <span data-ttu-id="f1caf-383">当应用程序执行时，当前驱动器和当前目录可以随时更改。</span><span class="sxs-lookup"><span data-stu-id="f1caf-383">The current drive and current directory can change at any time as an application executes.</span></span> <span data-ttu-id="f1caf-384">因此，不能提前确定此重载返回的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-384">As a result, the path returned by this overload cannot be determined in advance.</span></span> <span data-ttu-id="f1caf-385">若要返回确定性路径，请调用 <xref:System.IO.Path.GetFullPath(System.String,System.String)> 重载。</span><span class="sxs-lookup"><span data-stu-id="f1caf-385">To return a deterministic path, call the <xref:System.IO.Path.GetFullPath(System.String,System.String)> overload.</span></span> <span data-ttu-id="f1caf-386">还可以调用 <xref:System.IO.Path.IsPathFullyQualified%2A> 方法来确定路径是完全限定路径还是相对路径，从而确定是否需要调用 `GetFullPath`。</span><span class="sxs-lookup"><span data-stu-id="f1caf-386">You can also call the <xref:System.IO.Path.IsPathFullyQualified%2A> method to determine whether a path is fully qualified or relative and therefore whether a call to `GetFullPath` is necessary.</span></span>

 <span data-ttu-id="f1caf-387">但是，如果 `path` 存在，则调用方必须具有获取 `path`的路径信息的权限。</span><span class="sxs-lookup"><span data-stu-id="f1caf-387">However, if `path` does exist, the caller must have permission to obtain path information for `path`.</span></span> <span data-ttu-id="f1caf-388">请注意，与 <xref:System.IO.Path> 类的大多数成员不同，此方法访问文件系统。</span><span class="sxs-lookup"><span data-stu-id="f1caf-388">Note that unlike most members of the <xref:System.IO.Path> class, this method accesses the file system.</span></span>  
  
 <span data-ttu-id="f1caf-389">此方法使用当前目录和当前卷信息完全限定 `path`。</span><span class="sxs-lookup"><span data-stu-id="f1caf-389">This method uses the current directory and current volume information to fully qualify `path`.</span></span> <span data-ttu-id="f1caf-390">如果仅在 `path`中指定文件名，`GetFullPath` 将返回当前目录的完全限定路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-390">If you specify a file name only in `path`, `GetFullPath` returns the fully qualified path of the current directory.</span></span>  
  
 <span data-ttu-id="f1caf-391">如果传入短文件名，则会将其扩展到长文件名。</span><span class="sxs-lookup"><span data-stu-id="f1caf-391">If you pass in a short file name, it is expanded to a long file name.</span></span>  
  
 <span data-ttu-id="f1caf-392">如果路径不包含有效字符，则无效，除非它包含一个或多个 "." 字符，后跟任意数量的空格;然后，它将被分析为 "." 或 "..."。</span><span class="sxs-lookup"><span data-stu-id="f1caf-392">If a path contains no significant characters, it is invalid unless it contains one or more "." characters followed by any number of spaces; then it will be parsed as either "." or "..".</span></span>  

<span data-ttu-id="f1caf-393">.NET Core 1.1 及更高版本和 .NET Framework 4.6.2 及更高版本还支持包含设备名称的路径，例如 "\\？ \C：\"。</span><span class="sxs-lookup"><span data-stu-id="f1caf-393">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support paths that include device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="f1caf-394">有关 Windows 上的文件路径格式的详细信息，请参阅[windows 系统上的文件路径格式](~/docs/standard/io/file-path-formats.md)。</span><span class="sxs-lookup"><span data-stu-id="f1caf-394">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="f1caf-395">有关常见 i/o 任务的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="f1caf-395">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>
  
## Examples  
 <span data-ttu-id="f1caf-396">下面的示例演示基于 Windows 的桌面平台上的 `GetFullPath` 方法。</span><span class="sxs-lookup"><span data-stu-id="f1caf-396">The following example demonstrates the `GetFullPath` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#7)]
 [!code-csharp[System.IO.Path Members#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#7)]
 [!code-vb[System.IO.Path Members#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f1caf-397"><paramref name="path" /> 是一个零长度字符串，仅包含空格或者包含 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中已定义一个或多个无效字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-397"><paramref name="path" /> is a zero-length string, contains only white space, or contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>  
  
<span data-ttu-id="f1caf-398">-或-</span><span class="sxs-lookup"><span data-stu-id="f1caf-398">-or-</span></span> 
<span data-ttu-id="f1caf-399">系统无法检索绝对路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-399">The system could not retrieve the absolute path.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f1caf-400">调用方没有所需的权限。</span><span class="sxs-lookup"><span data-stu-id="f1caf-400">The caller does not have the required permissions.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f1caf-401"><paramref name="path" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-401"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f1caf-402"><paramref name="path" /> 包含一个冒号（“:”），此冒号不是卷标识符（如，“c:\\”）的一部分。</span><span class="sxs-lookup"><span data-stu-id="f1caf-402"><paramref name="path" /> contains a colon (":") that is not part of a volume identifier (for example, "c:\\").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="f1caf-403">指定的路径和/或文件名超过了系统定义的最大长度。</span><span class="sxs-lookup"><span data-stu-id="f1caf-403">The specified path, file name, or both exceed the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="f1caf-404">用于访问路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-404">for access to the path.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-405">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-405">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f1caf-406">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="f1caf-406">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f1caf-407">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-407">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f1caf-408">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-408">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path, string basePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path, string basePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String, basePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path, System::String ^ basePath);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string * string -&gt; string" Usage="System.IO.Path.GetFullPath (path, basePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="basePath" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="f1caf-409">连接到 <paramref name="basePath" /> 的相对路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-409">A relative path to concatenate to <paramref name="basePath" />.</span></span></param>
        <param name="basePath"><span data-ttu-id="f1caf-410">完全限定路径的开头。</span><span class="sxs-lookup"><span data-stu-id="f1caf-410">The beginning of a fully qualified path.</span></span></param>
        <summary><span data-ttu-id="f1caf-411">返回完全限定的基本路径和相对路径的绝对路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-411">Returns an absolute path from a fully qualified base path and a relative path.</span></span></summary>
        <returns><span data-ttu-id="f1caf-412">绝对路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-412">The absolute path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="f1caf-413">如果 `path` 为空路径，则该方法将返回 `basePath`。</span><span class="sxs-lookup"><span data-stu-id="f1caf-413">If `path` is an empty path, the method returns `basePath`.</span></span> <span data-ttu-id="f1caf-414">如果 `path` 是完全限定的路径，则该方法将 `path` 传递到 <xref:System.IO.Path.GetFullPath(System.String)> 方法并返回结果。</span><span class="sxs-lookup"><span data-stu-id="f1caf-414">If `path` is a fully qualified path, the method passes `path` to the <xref:System.IO.Path.GetFullPath(System.String)> method and returns the result.</span></span>

<span data-ttu-id="f1caf-415">使用相对路径时，使用此方法可基于指定的卷和根目录返回确定性路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-415">Use this method to return a deterministic path based on a specified volume and rooted directory when you're using relative paths.</span></span> <span data-ttu-id="f1caf-416">使用预定义的 `basePath` （而不是基于当前驱动器目录）来防止当前驱动器和目录中发生意外更改引起的不需要的文件路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-416">Using a predefined `basePath` rather than one based on the current drive directory guards against unwanted file paths caused by unexpected changes in the current drive and directory.</span></span> 

## <a name="example"></a><span data-ttu-id="f1caf-417">示例</span><span class="sxs-lookup"><span data-stu-id="f1caf-417">Example</span></span>

<span data-ttu-id="f1caf-418">下面的示例定义了一个 `basePath`的变量，用于表示应用程序的当前目录。</span><span class="sxs-lookup"><span data-stu-id="f1caf-418">The following example defines a variable, `basePath`, to represent an application's current directory.</span></span> <span data-ttu-id="f1caf-419">然后，它将其传递到 `GetFullPath` 方法，以获取应用程序的数据目录的完全限定路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-419">It then passes it to the `GetFullPath` method to get a fully qualified path to the application's data directory.</span></span>

[!code-csharp[Path.GetFullPath(String,String)](~/samples/snippets/csharp/api/system.io/path/getfullpath/program.cs)] 
[!code-vb[Path.GetFullPath(String,String)](~/samples/snippets/visualbasic/api/system.io/path/getfullpath/program.vb)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f1caf-420"><paramref name="path" /> 或 <paramref name="basePath" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-420"><paramref name="path" /> or <paramref name="basePath" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f1caf-421"><paramref name="basePath" /> 不是完全限定的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-421"><paramref name="basePath" /> is not a fully qualified path.</span></span>

<span data-ttu-id="f1caf-422">-或-</span><span class="sxs-lookup"><span data-stu-id="f1caf-422">-or-</span></span>

<span data-ttu-id="f1caf-423"><paramref name="path" /> 或 <paramref name="basePath" /> 包含无效的路径字符，例如 U+0000。</span><span class="sxs-lookup"><span data-stu-id="f1caf-423"><paramref name="path" /> or <paramref name="basePath" /> contains invalid path characters, such as U+0000.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidFileNameChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidFileNameChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidFileNameChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidFileNameChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidFileNameChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidFileNameChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidFileNameChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidFileNameChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f1caf-424">获取包含不允许在文件名中使用的字符的数组。</span><span class="sxs-lookup"><span data-stu-id="f1caf-424">Gets an array containing the characters that are not allowed in file names.</span></span></summary>
        <returns><span data-ttu-id="f1caf-425">包含不允许在文件名中使用的字符的数组。</span><span class="sxs-lookup"><span data-stu-id="f1caf-425">An array containing the characters that are not allowed in file names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1caf-426">从此方法返回的数组不保证包含在文件和目录名称中无效的完整字符集。</span><span class="sxs-lookup"><span data-stu-id="f1caf-426">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="f1caf-427">完整的无效字符集可能因文件系统而异。</span><span class="sxs-lookup"><span data-stu-id="f1caf-427">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="f1caf-428">例如，在基于 Windows 的桌面平台上，无效路径字符可能包括 ASCII/Unicode 字符1到31、引号（"）、小于（\<）、大于（>）、管道（&#124;）、backspace （\b）、null （\ 0）和制表符（\t）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-428">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1caf-429">下面的示例演示 <xref:System.IO.Path.GetInvalidFileNameChars%2A> 方法和 <xref:System.IO.Path.GetInvalidPathChars%2A> 方法来检索无效字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-429">The following example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidPathChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidPathChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidPathChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidPathChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidPathChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidPathChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidPathChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f1caf-430">获取包含不允许在路径名中使用的字符的数组。</span><span class="sxs-lookup"><span data-stu-id="f1caf-430">Gets an array containing the characters that are not allowed in path names.</span></span></summary>
        <returns><span data-ttu-id="f1caf-431">包含不允许在路径名中使用的字符的数组。</span><span class="sxs-lookup"><span data-stu-id="f1caf-431">An array containing the characters that are not allowed in path names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1caf-432">从此方法返回的数组不保证包含在文件和目录名称中无效的完整字符集。</span><span class="sxs-lookup"><span data-stu-id="f1caf-432">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="f1caf-433">完整的无效字符集可能因文件系统而异。</span><span class="sxs-lookup"><span data-stu-id="f1caf-433">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="f1caf-434">例如，在基于 Windows 的桌面平台上，无效路径字符可能包括 ASCII/Unicode 字符1到31、引号（"）、小于（\<）、大于（>）、管道（&#124;）、backspace （\b）、null （\ 0）和制表符（\t）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-434">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1caf-435">下面的示例演示 <xref:System.IO.Path.GetInvalidFileNameChars%2A> 方法和 <xref:System.IO.Path.GetInvalidPathChars%2A> 方法来检索无效字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-435">The following example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetPathRoot (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetPathRoot(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetPathRoot(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="f1caf-436">字符的只读范围，包含要从中获取根目录信息的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-436">A read-only span of characters containing the path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="f1caf-437">从指定字符范围包含的路径中获取根目录信息。</span><span class="sxs-lookup"><span data-stu-id="f1caf-437">Gets the root directory information from the path contained in the specified character span.</span></span></summary>
        <returns><span data-ttu-id="f1caf-438">字符的只读范围，包含 <paramref name="path" /> 的根目录。</span><span class="sxs-lookup"><span data-stu-id="f1caf-438">A read-only span of characters containing the root directory of <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="f1caf-439">此方法不会验证路径或文件是否存在。</span><span class="sxs-lookup"><span data-stu-id="f1caf-439">This method does not verify that the path or file exists.</span></span>

<span data-ttu-id="f1caf-440">与字符串重载不同，此方法不会将目录分隔符标准化。</span><span class="sxs-lookup"><span data-stu-id="f1caf-440">Unlike the string overload, this method doesn't normalize directory separators.</span></span>

<span data-ttu-id="f1caf-441">如果是以下情况，则 `ReadOnlySpan<System.Char>` 为 "有效空"：</span><span class="sxs-lookup"><span data-stu-id="f1caf-441">A `ReadOnlySpan<System.Char>` is "effectively empty" if:</span></span>

- <span data-ttu-id="f1caf-442">在 Windows 中，对这段字符调用 <xref:System.ReadOnlySpan%601.IsEmpty?displayProperty=nameWithType> 将返回 `true`，或者其所有字符均为空格（' '）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-442">In Windows, calling <xref:System.ReadOnlySpan%601.IsEmpty?displayProperty=nameWithType> on this span of characters returns `true`, or all its characters are spaces (' ').</span></span>
- <span data-ttu-id="f1caf-443">在 Unix 中，对此字符范围调用 <xref:System.ReadOnlySpan%601.IsEmpty?displayProperty=nameWithType> 将返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="f1caf-443">In Unix, calling <xref:System.ReadOnlySpan%601.IsEmpty?displayProperty=nameWithType> on this span of characters returns `true`.</span></span>

<span data-ttu-id="f1caf-444">此方法返回的只读字符范围的可能模式如下所示：</span><span class="sxs-lookup"><span data-stu-id="f1caf-444">Possible patterns for the read-only character span returned by this method are as follows:</span></span>

- <span data-ttu-id="f1caf-445"><xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> （`path` <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1caf-445"><xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> (`path` was <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>.</span></span>

- <span data-ttu-id="f1caf-446"><xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> （`path` 在当前驱动器或卷上指定了相对路径）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-446"><xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> (`path` specified a relative path on the current drive or volume).</span></span>

- <span data-ttu-id="f1caf-447">"\" （Unix： `path` 在当前驱动器上指定了绝对路径）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-447">"\" (Unix: `path` specified an absolute path on the current drive).</span></span>

- <span data-ttu-id="f1caf-448">"X：" （Windows： `path` 在驱动器上指定了相对路径，其中*X*表示驱动器或卷号）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-448">"X:" (Windows: `path` specified a relative path on a drive, where *X* represents a drive or volume letter).</span></span>

- <span data-ttu-id="f1caf-449">"X：\" （Windows： `path` 在给定驱动器上指定了绝对路径）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-449">"X:\" (Windows: `path` specified an absolute path on a given drive).</span></span>

- <span data-ttu-id="f1caf-450">"\\\ComputerName\SharedFolder" （Windows： UNC 路径）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-450">"\\\ComputerName\SharedFolder" (Windows: a UNC path).</span></span>

- <span data-ttu-id="f1caf-451">"\\\\\?\C：" （Windows： DOS 设备路径，在 .NET Core 1.1 和更高版本中受支持，并且在 .NET Framework 4.6.2 及更高版本中）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-451">"\\\\\?\C:" (Windows: a DOS device path, supported in .NET Core 1.1 and later versions, and in .NET Framework 4.6.2 and later versions).</span></span>
 
<span data-ttu-id="f1caf-452">有关 Windows 上的文件路径的详细信息，请参阅[windows 系统上的文件路径格式](~/docs/standard/io/file-path-formats.md)。</span><span class="sxs-lookup"><span data-stu-id="f1caf-452">For more information on file paths on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="f1caf-453">有关常见 i/o 任务的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="f1caf-453">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>


          ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-454">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-454">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static string GetPathRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPathRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPathRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : string -&gt; string" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="f1caf-455">一个字符串，包含要从中获取根目录信息的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-455">A string containing the path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="f1caf-456">从指定字符串包含的路径中获取根目录信息。</span><span class="sxs-lookup"><span data-stu-id="f1caf-456">Gets the root directory information from the path contained in the specified string.</span></span></summary>
        <returns><span data-ttu-id="f1caf-457">如果为根路径，则为 <paramref name="path" /> 的根目录。</span><span class="sxs-lookup"><span data-stu-id="f1caf-457">The root directory of <paramref name="path" /> if it is rooted.</span></span>

<span data-ttu-id="f1caf-458">-或-</span><span class="sxs-lookup"><span data-stu-id="f1caf-458">-or-</span></span> 
<span data-ttu-id="f1caf-459">如果 <see cref="F:System.String.Empty" /> 不包含根目录信息，则为 <paramref name="path" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-459"><see cref="F:System.String.Empty" /> if <paramref name="path" /> does not contain root directory information.</span></span>

<span data-ttu-id="f1caf-460">-或-</span><span class="sxs-lookup"><span data-stu-id="f1caf-460">-or-</span></span> 
<span data-ttu-id="f1caf-461">如果 <see langword="null" /> 为 <paramref name="path" /> 或实际上为空，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-461"><see langword="null" /> if <paramref name="path" /> is <see langword="null" /> or is effectively empty.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="f1caf-462">此方法不会验证路径或文件是否存在。</span><span class="sxs-lookup"><span data-stu-id="f1caf-462">This method does not verify that the path or file exists.</span></span>

<span data-ttu-id="f1caf-463">此方法将规范化目录分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-463">This method will normalize directory separators.</span></span>

<span data-ttu-id="f1caf-464">如果是以下情况，则字符串为 "有效空"：</span><span class="sxs-lookup"><span data-stu-id="f1caf-464">A string is "effectively empty" if:</span></span>

- <span data-ttu-id="f1caf-465">在 Windows 中，对此字符串调用 `IsEmpty` 将返回 `true`，或者其所有字符均为空格（""）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-465">In Windows, calling `IsEmpty` on this string returns `true`, or all its characters are spaces (' ').</span></span>
- <span data-ttu-id="f1caf-466">在 Unix 中，对此字符串调用 <xref:System.String.IsNullOrEmpty%2A> 将返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="f1caf-466">In Unix, calling <xref:System.String.IsNullOrEmpty%2A> on this string returns `true`.</span></span>

<span data-ttu-id="f1caf-467">此方法返回的字符串的可能模式如下所示：</span><span class="sxs-lookup"><span data-stu-id="f1caf-467">Possible patterns for the string returned by this method are as follows:</span></span>

- <span data-ttu-id="f1caf-468">`null` （`path` 为 null 或空字符串）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-468">`null` (`path` was null or an empty string).</span></span>

- <span data-ttu-id="f1caf-469">空字符串（`path` 在当前驱动器或卷上指定了相对路径）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-469">An empty string (`path` specified a relative path on the current drive or volume).</span></span>

- <span data-ttu-id="f1caf-470">"\" （Unix： `path` 在当前驱动器上指定了绝对路径）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-470">"\" (Unix: `path` specified an absolute path on the current drive).</span></span>

- <span data-ttu-id="f1caf-471">"X：" （Windows： `path` 在驱动器上指定了相对路径，其中*X*表示驱动器或卷号）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-471">"X:" (Windows: `path` specified a relative path on a drive, where *X* represents a drive or volume letter).</span></span>

- <span data-ttu-id="f1caf-472">"X：\" （Windows： `path` 在给定驱动器上指定了绝对路径）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-472">"X:\" (Windows: `path` specified an absolute path on a given drive).</span></span>

- <span data-ttu-id="f1caf-473">"\\\ComputerName\SharedFolder" （Windows： UNC 路径）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-473">"\\\ComputerName\SharedFolder" (Windows: a UNC path).</span></span>

- <span data-ttu-id="f1caf-474">"\\\\\?\C：" （Windows： DOS 设备路径，在 .NET Core 1.1 和更高版本中受支持，并且在 .NET Framework 4.6.2 及更高版本中）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-474">"\\\\\?\C:" (Windows: a DOS device path, supported in .NET Core 1.1 and later versions, and in .NET Framework 4.6.2 and later versions).</span></span>
 
<span data-ttu-id="f1caf-475">有关 Windows 上的文件路径的详细信息，请参阅[windows 系统上的文件路径格式](~/docs/standard/io/file-path-formats.md)。</span><span class="sxs-lookup"><span data-stu-id="f1caf-475">For more information on file paths on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="f1caf-476">有关常见 i/o 任务的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="f1caf-476">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>

## Examples
<span data-ttu-id="f1caf-477">下面的示例演示如何使用 `GetPathRoot` 方法。</span><span class="sxs-lookup"><span data-stu-id="f1caf-477">The following example demonstrates a use of the `GetPathRoot` method.</span></span>

[!code-cpp[System.IO.Path Members#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#8)]
[!code-csharp[System.IO.Path Members#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#8)]
[!code-vb[System.IO.Path Members#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#8)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f1caf-478">仅限 .NET Framework：<paramref name="path" /> 包含一个或多个在 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中定义的无效字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-478">.NET Framework only: <paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>

<span data-ttu-id="f1caf-479">-或-</span><span class="sxs-lookup"><span data-stu-id="f1caf-479">-or-</span></span>

<span data-ttu-id="f1caf-480">仅限 .NET Framework：<see cref="F:System.String.Empty" /> 已传递给 <paramref name="path" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-480">.NET Framework only: <see cref="F:System.String.Empty" /> was passed to <paramref name="path" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-481">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-481">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f1caf-482">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="f1caf-482">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f1caf-483">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-483">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f1caf-484">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-484">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetRandomFileName">
      <MemberSignature Language="C#" Value="public static string GetRandomFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRandomFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRandomFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRandomFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRandomFileName();" />
      <MemberSignature Language="F#" Value="static member GetRandomFileName : unit -&gt; string" Usage="System.IO.Path.GetRandomFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f1caf-485">返回随机文件夹名或文件名。</span><span class="sxs-lookup"><span data-stu-id="f1caf-485">Returns a random folder name or file name.</span></span></summary>
        <returns><span data-ttu-id="f1caf-486">随机文件夹名或文件名。</span><span class="sxs-lookup"><span data-stu-id="f1caf-486">A random folder name or file name.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1caf-487"><xref:System.IO.Path.GetRandomFileName%2A> 方法返回一个可用作文件夹名称或文件名的经过加密的强随机字符串。</span><span class="sxs-lookup"><span data-stu-id="f1caf-487">The <xref:System.IO.Path.GetRandomFileName%2A> method returns a cryptographically strong, random string that can be used as either a folder name or a file name.</span></span> <span data-ttu-id="f1caf-488">与 <xref:System.IO.Path.GetTempFileName%2A>不同，<xref:System.IO.Path.GetRandomFileName%2A> 不会创建文件。</span><span class="sxs-lookup"><span data-stu-id="f1caf-488">Unlike <xref:System.IO.Path.GetTempFileName%2A>, <xref:System.IO.Path.GetRandomFileName%2A> does not create a file.</span></span> <span data-ttu-id="f1caf-489">如果文件系统的安全性非常重要，则应使用此方法而不是 <xref:System.IO.Path.GetTempFileName%2A>。</span><span class="sxs-lookup"><span data-stu-id="f1caf-489">When the security of your file system is paramount, this method should be used instead of <xref:System.IO.Path.GetTempFileName%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1caf-490">下面的示例显示 <xref:System.IO.Path.GetRandomFileName%2A> 方法的输出。</span><span class="sxs-lookup"><span data-stu-id="f1caf-490">The following example show output from the <xref:System.IO.Path.GetRandomFileName%2A> method.</span></span>  
  
 [!code-csharp[System.IO.Path Members#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers20.cs#20)]
 [!code-vb[System.IO.Path Members#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers20.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelativePath">
      <MemberSignature Language="C#" Value="public static string GetRelativePath (string relativeTo, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRelativePath(string relativeTo, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRelativePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRelativePath (relativeTo As String, path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRelativePath(System::String ^ relativeTo, System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetRelativePath : string * string -&gt; string" Usage="System.IO.Path.GetRelativePath (relativeTo, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="path" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="relativeTo"><span data-ttu-id="f1caf-491">相对于结果的源路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-491">The source path the result should be relative to.</span></span> <span data-ttu-id="f1caf-492">此路径始终被视为目录。</span><span class="sxs-lookup"><span data-stu-id="f1caf-492">This path is always considered to be a directory.</span></span></param>
        <param name="path"><span data-ttu-id="f1caf-493">目标路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-493">The destination path.</span></span></param>
        <summary><span data-ttu-id="f1caf-494">返回从一个路径到另一个路径的相对路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-494">Returns a relative path from one path to another.</span></span></summary>
        <returns><span data-ttu-id="f1caf-495">相对路径，如果路径不共享同一根，则为 <paramref name="path" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-495">The relative path, or <paramref name="path" /> if the paths don't share the same root.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="f1caf-496">在计算差之前，可以通过调用 <xref:System.IO.Path.GetFullPath%2A> 方法解析路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-496">Paths are resolved by calling the <xref:System.IO.Path.GetFullPath%2A> method before calculating the difference.</span></span> <span data-ttu-id="f1caf-497">方法使用适用于当前平台的默认文件路径比较（适用于 Windows 和 MacOs 的<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>，<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> 适用于 Linux）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-497">The method uses the default file path comparison for the current platform (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> for Windows and MacOs, <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> for Linux.</span></span> 

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f1caf-498"><paramref name="relativeTo" /> 或 <paramref name="path" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-498"><paramref name="relativeTo" /> or <paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-499">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-499">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="System.IO.Path.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f1caf-500">在磁盘上创建磁唯一命名的零字节的临时文件并返回该文件的完整路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-500">Creates a uniquely named, zero-byte temporary file on disk and returns the full path of that file.</span></span></summary>
        <returns><span data-ttu-id="f1caf-501">临时文件的完整路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-501">The full path of the temporary file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1caf-502">此方法创建一个文件扩展名为 .TMP 的临时文件。</span><span class="sxs-lookup"><span data-stu-id="f1caf-502">This method creates a temporary file with a .TMP file extension.</span></span> <span data-ttu-id="f1caf-503">该临时文件创建于用户的临时文件夹中，该文件夹是 <xref:System.IO.Path.GetTempPath%2A> 方法返回的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-503">The temporary file is created within the user's temporary folder, which is the path returned by the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
 <span data-ttu-id="f1caf-504">如果用于创建65535个以上的文件而不删除以前的临时文件，则 <xref:System.IO.Path.GetTempFileName%2A> 方法将引发 <xref:System.IO.IOException>。</span><span class="sxs-lookup"><span data-stu-id="f1caf-504">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if it is used to create more than 65535 files without deleting previous temporary files.</span></span>  
  
 <span data-ttu-id="f1caf-505">如果没有可用的唯一临时文件名，<xref:System.IO.Path.GetTempFileName%2A> 方法将引发 <xref:System.IO.IOException>。</span><span class="sxs-lookup"><span data-stu-id="f1caf-505">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if no unique temporary file name is available.</span></span> <span data-ttu-id="f1caf-506">若要解决此错误，请删除所有不需要的临时文件。</span><span class="sxs-lookup"><span data-stu-id="f1caf-506">To resolve this error, delete all unneeded temporary files.</span></span>  
  
 <span data-ttu-id="f1caf-507">有关常见 i/o 任务的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="f1caf-507">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="f1caf-508">发生 I/O 错误，例如没有提供唯一的临时文件名。</span><span class="sxs-lookup"><span data-stu-id="f1caf-508">An I/O error occurs, such as no unique temporary file name is available.</span></span>  
  
<span data-ttu-id="f1caf-509">-或-</span><span class="sxs-lookup"><span data-stu-id="f1caf-509">-or-</span></span>
  
 <span data-ttu-id="f1caf-510">此方法无法创建临时文件。</span><span class="sxs-lookup"><span data-stu-id="f1caf-510">This method was unable to create a temporary file.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="f1caf-511">用于写入临时目录。</span><span class="sxs-lookup"><span data-stu-id="f1caf-511">for writing to the temporary directory.</span></span> <span data-ttu-id="f1caf-512">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span><span class="sxs-lookup"><span data-stu-id="f1caf-512">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f1caf-513">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="f1caf-513">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f1caf-514">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-514">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f1caf-515">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-515">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTempPath">
      <MemberSignature Language="C#" Value="public static string GetTempPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempPath();" />
      <MemberSignature Language="F#" Value="static member GetTempPath : unit -&gt; string" Usage="System.IO.Path.GetTempPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f1caf-516">返回当前用户的临时文件夹的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-516">Returns the path of the current user's temporary folder.</span></span></summary>
        <returns><span data-ttu-id="f1caf-517">临时文件夹的路径，以反斜杠结尾。</span><span class="sxs-lookup"><span data-stu-id="f1caf-517">The path to the temporary folder, ending with a backslash.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1caf-518">此方法按以下顺序检查环境变量是否存在，并使用找到的第一个路径：</span><span class="sxs-lookup"><span data-stu-id="f1caf-518">This method checks for the existence of environment variables in the following order and uses the first path found:</span></span>  

# <a name="windowstabwindows"></a>[<span data-ttu-id="f1caf-519">Windows</span><span class="sxs-lookup"><span data-stu-id="f1caf-519">Windows</span></span>](#tab/windows)

1.  <span data-ttu-id="f1caf-520">TMP 环境变量指定的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-520">The path specified by the TMP environment variable.</span></span>   
  
2.  <span data-ttu-id="f1caf-521">由 TEMP 环境变量指定的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-521">The path specified by the TEMP environment variable.</span></span>  
  
3.  <span data-ttu-id="f1caf-522">USERPROFILE 环境变量指定的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-522">The path specified by the USERPROFILE environment variable.</span></span>  
  
4.  <span data-ttu-id="f1caf-523">Windows 目录。</span><span class="sxs-lookup"><span data-stu-id="f1caf-523">The Windows directory.</span></span>  

# <a name="linuxtablinux"></a>[<span data-ttu-id="f1caf-524">Linux</span><span class="sxs-lookup"><span data-stu-id="f1caf-524">Linux</span></span>](#tab/linux)

1. <span data-ttu-id="f1caf-525">TMPDIR 环境变量指定的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-525">The path specified by the TMPDIR environment variable.</span></span>  

---

## Examples  
 <span data-ttu-id="f1caf-526">下面的代码演示如何调用 <xref:System.IO.Path.GetTempPath%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f1caf-526">The following code shows how to call the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
```vb  
Dim result As String = Path.GetTempPath()  
Console.WriteLine(result)  
```  
  
```csharp  
string result = Path.GetTempPath();  
Console.WriteLine(result);  
```  
  
 <span data-ttu-id="f1caf-527">此示例生成与下面类似的输出。</span><span class="sxs-lookup"><span data-stu-id="f1caf-527">This example produces output similar to the following.</span></span>  
  
```  
C:\Users\UserName\AppData\Local\Temp\  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f1caf-528">调用方没有所需的权限。</span><span class="sxs-lookup"><span data-stu-id="f1caf-528">The caller does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission"><span data-ttu-id="f1caf-529">用于对环境变量进行不受限制的访问。</span><span class="sxs-lookup"><span data-stu-id="f1caf-529">for unrestricted access to environment variables.</span></span> <span data-ttu-id="f1caf-530">关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="f1caf-530">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f1caf-531">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="f1caf-531">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f1caf-532">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-532">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f1caf-533">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-533">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="f1caf-534">用于搜索扩展名的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-534">The path to search for an extension.</span></span></param>
        <summary><span data-ttu-id="f1caf-535">确定指定字符范围表示的路径是否包含文件扩展名。</span><span class="sxs-lookup"><span data-stu-id="f1caf-535">Determines whether the path represented by the specified character span includes a file name extension.</span></span></summary>
        <returns><span data-ttu-id="f1caf-536">如果路径中最后一个目录分隔符或卷分隔符之后的字符包括句点 (.)，并且后面跟有一个或多个字符，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-536"><see langword="true" /> if the characters that follow the last directory separator character or volume separator in the path include a period (".") followed by one or more characters; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="f1caf-537">`path` 中的尾随句点不被视为扩展。</span><span class="sxs-lookup"><span data-stu-id="f1caf-537">A trailing period in `path` is not considered an extension.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-538">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-538">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : string -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="f1caf-539">用于搜索扩展名的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-539">The path to search for an extension.</span></span></param>
        <summary><span data-ttu-id="f1caf-540">确定路径是否包括文件扩展名。</span><span class="sxs-lookup"><span data-stu-id="f1caf-540">Determines whether a path includes a file name extension.</span></span></summary>
        <returns><span data-ttu-id="f1caf-541">如果路径中最后一个目录分隔符（<see langword="true" />\ 或 /）或卷分隔符 (:) 之后的字符包括句点 (.)，并且后面跟有一个或多个字符，则为 \\；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-541"><see langword="true" /> if the characters that follow the last directory separator (\\\ or /) or volume separator (:) in the path include a period (.) followed by one or more characters; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1caf-542">从 `path`末尾开始，此方法会搜索一个句点（.），后跟至少一个字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-542">Starting from the end of `path`, this method searches for a period (.) followed by at least one character.</span></span> <span data-ttu-id="f1caf-543">如果在遇到 <xref:System.IO.Path.DirectorySeparatorChar>、<xref:System.IO.Path.AltDirectorySeparatorChar>或 <xref:System.IO.Path.VolumeSeparatorChar> 字符之前找到此模式，则此方法将返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="f1caf-543">If this pattern is found before a <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar> character is encountered, this method returns `true`.</span></span>  
  
 <span data-ttu-id="f1caf-544">有关常见 i/o 任务的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="f1caf-544">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1caf-545">下面的示例演示 `HasExtension` 方法的用法。</span><span class="sxs-lookup"><span data-stu-id="f1caf-545">The following example demonstrates the use of the `HasExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#11)]
 [!code-csharp[System.IO.Path Members#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#11)]
 [!code-vb[System.IO.Path Members#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f1caf-546"><paramref name="path" /> 包含 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中已定义的一个或多个无效字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-546"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-547">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-547">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f1caf-548">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="f1caf-548">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f1caf-549">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-549">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f1caf-550">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-550">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="InvalidPathChars">
      <MemberSignature Language="C#" Value="public static readonly char[] InvalidPathChars;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char[] InvalidPathChars" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.InvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InvalidPathChars As Char() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;char&gt; ^ InvalidPathChars;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidPathChars : char[]" Usage="System.IO.Path.InvalidPathChars" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("see GetInvalidPathChars and GetInvalidFileNameChars methods.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f1caf-551">提供平台特定的字符数组，这些字符不能在传递到 <see cref="T:System.IO.Path" /> 类的成员的路径字符串自变量中指定。</span><span class="sxs-lookup"><span data-stu-id="f1caf-551">Provides a platform-specific array of characters that cannot be specified in path string arguments passed to members of the <see cref="T:System.IO.Path" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1caf-552">从此方法返回的数组不保证包含在文件和目录名称中无效的完整字符集。</span><span class="sxs-lookup"><span data-stu-id="f1caf-552">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="f1caf-553">完整的无效字符集可能因文件系统而异。</span><span class="sxs-lookup"><span data-stu-id="f1caf-553">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="f1caf-554">例如，在基于 Windows 的桌面平台上，无效路径字符可能包括 ASCII/Unicode 字符1到31、引号（"）、小于（\<）、大于（>）、管道（&#124;）、backspace （\b）、null （\ 0）和制表符（\t）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-554">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f1caf-555">如果你认为你的代码可能在不受信任的代码所在的应用程序域中执行，请不要使用 <xref:System.IO.Path.InvalidPathChars>。</span><span class="sxs-lookup"><span data-stu-id="f1caf-555">Do not use <xref:System.IO.Path.InvalidPathChars> if you think your code might execute in the same application domain as untrusted code.</span></span> <span data-ttu-id="f1caf-556"><xref:System.IO.Path.InvalidPathChars> 是数组，因此可以覆盖其元素。</span><span class="sxs-lookup"><span data-stu-id="f1caf-556"><xref:System.IO.Path.InvalidPathChars> is an array, so its elements can be overwritten.</span></span> <span data-ttu-id="f1caf-557">如果不受信任的代码覆盖 <xref:System.IO.Path.InvalidPathChars>的元素，则可能会导致您的代码以可利用的方式发生故障。</span><span class="sxs-lookup"><span data-stu-id="f1caf-557">If untrusted code overwrites elements of <xref:System.IO.Path.InvalidPathChars>, it might cause your code to malfunction in ways that could be exploited.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1caf-558">下面的示例演示 `InvalidPathChars` 属性的用法。</span><span class="sxs-lookup"><span data-stu-id="f1caf-558">The following example demonstrates the use of the `InvalidPathChars` property.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f1caf-559">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="f1caf-559">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f1caf-560">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-560">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f1caf-561">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-561">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathFullyQualified">
      <Docs>
        <summary><span data-ttu-id="f1caf-562">返回一个值，指示文件路径是否完全限定。</span><span class="sxs-lookup"><span data-stu-id="f1caf-562">Returns a value that indicates whether a file path is fully qualified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="f1caf-563">`IsPathFullyQualified` 方法的重载将处理同时使用 <xref:System.IO.Path.DirectorySeparatorChar> 和 <xref:System.IO.Path.AltDirectorySeparatorChar> 字符的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-563">The overloads of the `IsPathFullyQualified` method handle paths that use both the <xref:System.IO.Path.DirectorySeparatorChar> and the <xref:System.IO.Path.AltDirectorySeparatorChar> characters.</span></span> <span data-ttu-id="f1caf-564">它不会对作为参数传递给它的路径执行任何验证。</span><span class="sxs-lookup"><span data-stu-id="f1caf-564">It does not perform any validation on the path that is passed to it as an argument.</span></span> <span data-ttu-id="f1caf-565">因此，Uri 被解释为相对路径并返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="f1caf-565">As a result, URIs are interpreted as relative paths and return `false`.</span></span> 

<span data-ttu-id="f1caf-566">完全限定的路径（如 `IsPathFullyQualified` 方法所指示）和根路径（如 <xref:System.IO.Path.IsPathRooted%2A> 方法所示）之间存在差异。</span><span class="sxs-lookup"><span data-stu-id="f1caf-566">There is a difference between a fully qualified path (as indicated by the `IsPathFullyQualified` method) and a rooted path (as indicated by the <xref:System.IO.Path.IsPathRooted%2A> method).</span></span> <span data-ttu-id="f1caf-567">*完全限定的路径*或*绝对路径*始终定义从特定驱动器或设备到目标文件或目录的准确路径，而不依赖于当前驱动器或当前目录。</span><span class="sxs-lookup"><span data-stu-id="f1caf-567">A *fully qualified path* or *absolute path* always defines an exact path from a particular drive or device to a target file or directory, and does not depend on the current drive or current directory.</span></span> <span data-ttu-id="f1caf-568">例如，在 Windows 系统上， *C：/users/user1/documents/reports/2019/一月/reports。 pdf*定义从 C：盘的根目录到目标文件的绝对路径，即 "*格式*"。</span><span class="sxs-lookup"><span data-stu-id="f1caf-568">For example, on Windows systems, *C:/users/user1/documents/reports/2019/january/highlights.pdf* defines an absolute path from the root of the C: drive to the target file, *highlights.pdf*.</span></span> <span data-ttu-id="f1caf-569">*根路径*指定起始驱动器或根目录，但取决于当前目录（如果该目录是指定驱动器的根）或当前驱动器（如果它在根目录下）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-569">A *rooted path* specifies either a starting drive or root directory, but depends on either the current directory (if it is rooted by a specified drive) or the current drive (if it is rooted by the root directory).</span></span> <span data-ttu-id="f1caf-570">下面的示例演示完全限定的路径和根路径之间的差异。</span><span class="sxs-lookup"><span data-stu-id="f1caf-570">The following example illustrates the difference between fully qualified paths and rooted paths.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="f1caf-571">文件路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-571">A file path.</span></span></param>
        <summary><span data-ttu-id="f1caf-572">返回一个值，该值指示由指定字符范围表示的文件路径是否固定到特定驱动器或 UNC 路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-572">Returns a value that indicates whether the file path represented by the specified character span is fixed to a specific drive or UNC path.</span></span></summary>
        <returns><span data-ttu-id="f1caf-573">如果路径固定到特定驱动器或 UNC 路径，为 <see langword="true" />；如果路径相对于当前驱动器或工作目录，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-573"><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  


         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-574">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-574">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : string -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="f1caf-575">文件路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-575">A file path.</span></span></param>
        <summary><span data-ttu-id="f1caf-576">返回一个值，该值指示指定的文件路径是否固定到特定驱动器或 UNC 路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-576">Returns a value that indicates whether the specified file path is fixed to a specific drive or UNC path.</span></span></summary>
        <returns><span data-ttu-id="f1caf-577">如果路径固定到特定驱动器或 UNC 路径，为 <see langword="true" />；如果路径相对于当前驱动器或工作目录，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-577"><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="f1caf-578">此方法处理使用备用目录分隔符的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-578">This method handles paths that use the alternate directory separator.</span></span> <span data-ttu-id="f1caf-579">经常出现错误，因为根路径（<xref:System.IO.Path.IsPathRooted(System.String)>）不是相对路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-579">It's a frequent mistake to assume that rooted paths (<xref:System.IO.Path.IsPathRooted(System.String)>) aren't relative.</span></span> <span data-ttu-id="f1caf-580">例如，"C:a" 是驱动器相关的，也就是说，它是针对 C：（root，但相对）的当前目录进行解析。</span><span class="sxs-lookup"><span data-stu-id="f1caf-580">For example, "C:a" is drive relative, that is, it's resolved against the current directory for C: (rooted, but relative).</span></span> <span data-ttu-id="f1caf-581">"C:\a" 是根路径而不是相对路径，也就是说，当前目录不用于修改路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-581">"C:\a" is rooted and not relative, that is, the current directory isn't used to modify the path.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f1caf-582"><paramref name="path" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-582"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-583">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-583">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathRooted">
      <Docs>
        <summary><span data-ttu-id="f1caf-584">返回一个值，指示文件路径是否包含根。</span><span class="sxs-lookup"><span data-stu-id="f1caf-584">Returns a value that indicates whether a file path contains a root.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="f1caf-585">**根路径**是固定到特定驱动器或 UNIC 路径的文件路径;它与相对于当前驱动器或工作目录的路径相比较。</span><span class="sxs-lookup"><span data-stu-id="f1caf-585">A **rooted path** is file path that is fixed to a specific drive or UNIC path; it contrasts with a path that is relative to the current drive or working directory.</span></span> <span data-ttu-id="f1caf-586">例如，在 Windows 系统上，以反斜杠（例如 "\Documents"）或驱动器号和冒号（如 "C:Documents"）开头的根路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-586">For example, on Windows systems, a rooted path begins with a backslash (for example, "\Documents") or a drive letter and colon (for example, "C:Documents").</span></span> 

<span data-ttu-id="f1caf-587">请注意，根路径可以是绝对路径（即，完全限定的路径），也可以是相对路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-587">Note that rooted paths can be either absolute (that is, fully qualified) or relative.</span></span> <span data-ttu-id="f1caf-588">绝对根路径是从驱动器根目录到特定目录的完全限定路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-588">An absolute rooted path is a fully qualified path from the root of a drive to a specific directory.</span></span> <span data-ttu-id="f1caf-589">相对 root 路径指定驱动器，但将根据当前目录解析其完全限定路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-589">A relative rooted path specifies a drive, but its fully qualified path is resolved against the current directory.</span></span> <span data-ttu-id="f1caf-590">以下示例演示了差异。</span><span class="sxs-lookup"><span data-stu-id="f1caf-590">The following example illustrates the difference.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="f1caf-591">要测试的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-591">The path to test.</span></span></param>
        <summary><span data-ttu-id="f1caf-592">返回一个值，该值指示表示文件路径的指定字符范围是否包含根。</span><span class="sxs-lookup"><span data-stu-id="f1caf-592">Returns a value that indicates whether the specified character span that represents a file path contains a root.</span></span></summary>
        <returns><span data-ttu-id="f1caf-593">如果 <see langword="true" /> 包含一个根，则为 <paramref name="path" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-593"><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-594">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-594">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : string -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="f1caf-595">要测试的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-595">The path to test.</span></span></param>
        <summary><span data-ttu-id="f1caf-596">返回一个值，该值指示指定的路径字符串是否包含根。</span><span class="sxs-lookup"><span data-stu-id="f1caf-596">Returns a value indicating whether the specified path string contains a root.</span></span></summary>
        <returns><span data-ttu-id="f1caf-597">如果 <see langword="true" /> 包含一个根，则为 <paramref name="path" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-597"><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1caf-598">如果第一个字符是目录分隔符（如 "\\"），或者如果路径以驱动器号和冒号（:) 开头，则 <xref:System.IO.Path.IsPathRooted%2A> 方法返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="f1caf-598">The <xref:System.IO.Path.IsPathRooted%2A> method returns `true` if the first character is a directory separator character such as "\\", or if the path starts with a drive letter and colon (:).</span></span> <span data-ttu-id="f1caf-599">例如，它返回 `path` 字符串 `true`，如 "\\\MyDir\\\MyFile.txt"、"C：\\\MyDir" 或 "C:MyDir"。</span><span class="sxs-lookup"><span data-stu-id="f1caf-599">For example, it returns `true` for `path` strings such as "\\\MyDir\\\MyFile.txt", "C:\\\MyDir", or "C:MyDir".</span></span> <span data-ttu-id="f1caf-600">它将返回 `path` 字符串 `false`，如 "MyDir"。</span><span class="sxs-lookup"><span data-stu-id="f1caf-600">It returns `false` for `path` strings such as "MyDir".</span></span>  
  
 <span data-ttu-id="f1caf-601">此方法不会验证路径或文件名是否存在。</span><span class="sxs-lookup"><span data-stu-id="f1caf-601">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="f1caf-602">有关常见 i/o 任务的列表，请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="f1caf-602">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  

## Examples  
 <span data-ttu-id="f1caf-603">下面的示例演示如何使用 `IsPathRooted` 方法来测试三个字符串。</span><span class="sxs-lookup"><span data-stu-id="f1caf-603">The following example demonstrates how the `IsPathRooted` method can be used to test three strings.</span></span>  
  
 [!code-cpp[System.IO.Path Members#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#12)]
 [!code-csharp[System.IO.Path Members#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#12)]
 [!code-vb[System.IO.Path Members#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f1caf-604"><paramref name="path" /> 包含 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 中已定义的一个或多个无效字符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-604"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-605">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-605">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f1caf-606">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="f1caf-606">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f1caf-607">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-607">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f1caf-608">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-608">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Join : string[] -&gt; string" Usage="System.IO.Path.Join paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths"><span data-ttu-id="f1caf-609">路径的数组。</span><span class="sxs-lookup"><span data-stu-id="f1caf-609">An array of paths.</span></span></param>
        <summary><span data-ttu-id="f1caf-610">将路径数组连接到一个路径中。</span><span class="sxs-lookup"><span data-stu-id="f1caf-610">Concatenates an array of paths into a single path.</span></span></summary>
        <returns><span data-ttu-id="f1caf-611">连接的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-611">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="f1caf-612">此方法只是将 `paths` 中的所有字符串连接在一起，并在其中任何路径组件之间添加目录分隔符（如果尚未存在）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-612">This method simply concatenates all the strings in `paths` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="f1caf-613">如果 `paths` 中任何路径的 <xref:System.String.Length> 都为零，则该方法将连接剩余的参数。</span><span class="sxs-lookup"><span data-stu-id="f1caf-613">If the <xref:System.String.Length> of any of the paths in `paths` is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="f1caf-614">如果生成的串联字符串的长度为零，则该方法将返回 <xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1caf-614">If the resulting concatenated string's length is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="f1caf-615">如果 `paths`中的任何路径（最后一个路径除外）以不适合目标平台的路径分隔符结尾，则 `Join` 方法会保留原始路径分隔符并追加支持的路径分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-615">If any of the paths in `paths`, except for the last one, ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="f1caf-616">使用 Windows 反斜杠（"\"）字符的硬编码路径中会出现此问题，该字符在基于 Unix 的系统上未被识别为路径分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-616">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="f1caf-617">若要解决此问题，可以：</span><span class="sxs-lookup"><span data-stu-id="f1caf-617">To work around this issue, you can:</span></span>

- <span data-ttu-id="f1caf-618">检索 <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> 属性的值，而不是对目录分隔符进行硬编码。</span><span class="sxs-lookup"><span data-stu-id="f1caf-618">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="f1caf-619">使用正斜杠（"/"）作为目录分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-619">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="f1caf-620">此字符由基于 Unix 的系统上的 <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> 属性以及 Windows 系统上的 <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> 属性返回。</span><span class="sxs-lookup"><span data-stu-id="f1caf-620">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="f1caf-621">与 <xref:System.IO.Path.Combine%2A> 方法不同，<xref:System.IO.Path.Join%2A> 方法不会尝试根返回的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-621">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="f1caf-622">（也就是说，如果 `paths`中的任何路径（最后一个路径除外）都是绝对路径，则 `Join` 方法在 <xref:System.IO.Path.Combine%2A> 方法时不会丢弃以前的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-622">(That is, if any of the paths in `paths`, except for the last one, is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>

<span data-ttu-id="f1caf-623">不是目录和文件名的所有无效字符都被 `Join` 方法解释为不可接受的，因为您可以使用这些字符搜索通配符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-623">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="f1caf-624">例如，当创建文件时 `Path.Join("c:\\", "temp", "*.txt")` 可能会无效，但它作为搜索字符串有效。</span><span class="sxs-lookup"><span data-stu-id="f1caf-624">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="f1caf-625">因此，`Join` 方法成功解释它。</span><span class="sxs-lookup"><span data-stu-id="f1caf-625">The `Join` method therefore successfully interprets it.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="f1caf-626">包含要加入的第一个路径的字符范围。</span><span class="sxs-lookup"><span data-stu-id="f1caf-626">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="f1caf-627">包含要加入的第二个路径的字符范围。</span><span class="sxs-lookup"><span data-stu-id="f1caf-627">A character span that contains the second path to join.</span></span></param>
        <summary><span data-ttu-id="f1caf-628">将两个路径组件连接到一个路径中。</span><span class="sxs-lookup"><span data-stu-id="f1caf-628">Concatenates two path components into a single path.</span></span></summary>
        <returns><span data-ttu-id="f1caf-629">已组合的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-629">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="f1caf-630">此方法只是将 `path` 和 `path2` 连接起来，并在两个路径组件之间添加目录分隔符（如果在 `path1` 或 `path2`的开头不存在一个）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-630">This method simply concatenates `path` and `path2` and adds a directory separator character between the two path components if one is not already present at the end of `path1` or the beginning of `path2`.</span></span> <span data-ttu-id="f1caf-631">如果 `path1` 或 `path2` 的 <xref:System.ReadOnlySpan%601.Length> 为零，则该方法返回其他路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-631">If the <xref:System.ReadOnlySpan%601.Length> of either `path1` or `path2` is zero, the method returns the other path.</span></span> <span data-ttu-id="f1caf-632">如果 `path1` 和 `path2` 的 <xref:System.ReadOnlySpan%601.Length> 都为零，则该方法将返回 <xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1caf-632">If the <xref:System.ReadOnlySpan%601.Length> of both `path1` and `path2` is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> 

<span data-ttu-id="f1caf-633">如果 `path1` 以不适合目标平台的路径分隔符结尾，`Join` 方法将保留原始路径分隔符，并追加受支持的字符分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-633">If `path1` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="f1caf-634">使用 Windows 反斜杠（"\"）字符的硬编码路径中会出现此问题，该字符在基于 Unix 的系统上未被识别为路径分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-634">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="f1caf-635">若要解决此问题，可以：</span><span class="sxs-lookup"><span data-stu-id="f1caf-635">To work around this issue, you can:</span></span>

- <span data-ttu-id="f1caf-636">检索 <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> 属性的值，而不是对目录分隔符进行硬编码。</span><span class="sxs-lookup"><span data-stu-id="f1caf-636">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="f1caf-637">使用正斜杠（"/"）作为目录分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-637">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="f1caf-638">此字符由基于 Unix 的系统上的 <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> 属性以及 Windows 系统上的 <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> 属性返回。</span><span class="sxs-lookup"><span data-stu-id="f1caf-638">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span> 

<span data-ttu-id="f1caf-639">与 <xref:System.IO.Path.Combine%2A> 方法不同，<xref:System.IO.Path.Join%2A> 方法不会尝试根返回的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-639">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="f1caf-640">（也就是说，如果 `path2` 是绝对路径，则 `Join` 方法不会丢弃 `path1`，并 `path2` <xref:System.IO.Path.Combine%2A> 方法返回。）下面的示例说明了这两种方法返回的路径之间的差异。</span><span class="sxs-lookup"><span data-stu-id="f1caf-640">(That is, if `path2` is an absolute path, the `Join` method does not discard `path1` and return `path2` as the <xref:System.IO.Path.Combine%2A> method does.) The following example illustrates the difference in the paths returned by the two methods.</span></span> <span data-ttu-id="f1caf-641">如果 `path2` 的源是用户输入，则在 <xref:System.IO.Path.Combine%2A> 方法中，用户可以访问应用程序不打算访问的文件系统资源（例如， *C：/Users/User1/Documents/金融/* ）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-641">If the source of `path2` is user input, the <xref:System.IO.Path.Combine%2A> method makes it possible for a user to access a file system resource (such as *C:/Users/User1/Documents/Financial/* in the case of the example) that the application did not intend to make accessible.</span></span>  

<span data-ttu-id="f1caf-642">不是目录和文件名的所有无效字符都被 `Join` 方法解释为不可接受的，因为您可以使用这些字符搜索通配符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-642">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="f1caf-643">例如，当创建文件时 `Path.Join("c:\\", "*.txt")` 可能会无效，但它作为搜索字符串有效。</span><span class="sxs-lookup"><span data-stu-id="f1caf-643">For example, while `Path.Join("c:\\", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="f1caf-644">因此，`Join` 方法成功解释它。</span><span class="sxs-lookup"><span data-stu-id="f1caf-644">The `Join` method therefore successfully interprets it.</span></span> 

## <a name="example"></a><span data-ttu-id="f1caf-645">示例</span><span class="sxs-lookup"><span data-stu-id="f1caf-645">Example</span></span>

<span data-ttu-id="f1caf-646">下面的示例说明 <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> 和 <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> 方法返回的路径之间的差异。</span><span class="sxs-lookup"><span data-stu-id="f1caf-646">The following example illustrates the difference in the paths returned by the <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> and <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="f1caf-647">如果第一个字符串是包含驱动器和根目录的完全限定路径，第二个字符串是第一个路径的相对路径，则这两个方法将产生相同的结果。</span><span class="sxs-lookup"><span data-stu-id="f1caf-647">When the first string is an fully qualified path that includes a drive and root directory and the second is a relative path from the first path, the two methods produce identical results.</span></span> <span data-ttu-id="f1caf-648">在第二次和第三次调用 `ShowPathInformation` 方法时，这两种方法返回的字符串是分叉的。</span><span class="sxs-lookup"><span data-stu-id="f1caf-648">In the second and third calls to the `ShowPathInformation` method, the strings returned by the two methods diverge.</span></span> <span data-ttu-id="f1caf-649">在第二个方法调用中，第一个字符串参数是驱动器，而第二个参数是根目录。</span><span class="sxs-lookup"><span data-stu-id="f1caf-649">In the second method call, the first string argument is a drive, while the second is a rooted directory.</span></span> <span data-ttu-id="f1caf-650">`Join` 方法将两个字符串连接在一起，并保留重复的路径分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-650">The `Join` method concatenates the two strings and preserves duplicate path separators.</span></span> <span data-ttu-id="f1caf-651">`Combine` 方法放弃驱动器并返回当前驱动器上的根目录。</span><span class="sxs-lookup"><span data-stu-id="f1caf-651">The `Combine` method abandons the drive and returns a rooted directory on the current drive.</span></span> <span data-ttu-id="f1caf-652">如果应用程序的当前驱动器为 C：\该字符串用于访问目录中的一个或一些文件，它将访问 C：而不是 d：</span><span class="sxs-lookup"><span data-stu-id="f1caf-652">If the application's current drive is C:\ and the string is used to access a file or files in the directory, it would access C: instead of D:.</span></span> <span data-ttu-id="f1caf-653">最后，由于对 `ShowPathInformation` 的第三次调用中的两个参数均为根参数，因此 `Join` 方法只是附加它们以创建过程文件路径，而 `Combine` 方法会丢弃第一个字符串并返回第二个字符串。</span><span class="sxs-lookup"><span data-stu-id="f1caf-653">Finally, because both arguments in the third call to `ShowPathInformation` are rooted, the `Join` method simply appends them to create a nonsensical file path, while the `Combine` method discards the first string and returns the second.</span></span> <span data-ttu-id="f1caf-654">使用此字符串进行文件访问可能会给应用程序带来对敏感文件的意外访问权限。</span><span class="sxs-lookup"><span data-stu-id="f1caf-654">Using this string for file access could give the application unintended access to sensitive files.</span></span>  

[!code-csharp[Path.Join(String,String)](~/samples/snippets/csharp/api/system.io/path/combine2/program.cs)]
[!code-vb[Path.Join(String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine2/program.vb)]


       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-655">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-655">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Join : string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="f1caf-656">要联接的第一个路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-656">The first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="f1caf-657">要联接的第二个路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-657">The second path to join.</span></span></param>
        <summary><span data-ttu-id="f1caf-658">将两个路径连接到一个路径中。</span><span class="sxs-lookup"><span data-stu-id="f1caf-658">Concatenates two paths into a single path.</span></span></summary>
        <returns><span data-ttu-id="f1caf-659">连接的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-659">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="f1caf-660">此方法只连接 `path` 和 `path2` 并在任何路径组件之间添加目录分隔符（如果尚未存在）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-660">This method simply concatenates `path` and `path2` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="f1caf-661">如果 `path1` 或 `path2` 的长度为零，则该方法将连接剩余参数。</span><span class="sxs-lookup"><span data-stu-id="f1caf-661">If the length of either `path1` or `path2` is zero, the method concatenates the remaining argument.</span></span> <span data-ttu-id="f1caf-662">如果生成的串联字符串的长度为零，则该方法将返回 <xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1caf-662">If the length of the resulting concatenated string is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="f1caf-663">如果 `path1` 以不适合目标平台的路径分隔符结尾，`Join` 方法将保留原始路径分隔符，并追加受支持的字符分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-663">If `path1` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="f1caf-664">使用 Windows 反斜杠（"\"）字符的硬编码路径中会出现此问题，该字符在基于 Unix 的系统上未被识别为路径分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-664">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="f1caf-665">若要解决此问题，可以：</span><span class="sxs-lookup"><span data-stu-id="f1caf-665">To work around this issue, you can:</span></span>

- <span data-ttu-id="f1caf-666">检索 <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> 属性的值，而不是对目录分隔符进行硬编码。</span><span class="sxs-lookup"><span data-stu-id="f1caf-666">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="f1caf-667">使用正斜杠（"/"）作为目录分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-667">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="f1caf-668">此字符由基于 Unix 的系统上的 <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> 属性以及 Windows 系统上的 <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> 属性返回。</span><span class="sxs-lookup"><span data-stu-id="f1caf-668">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="f1caf-669">与 <xref:System.IO.Path.Combine%2A> 方法不同，<xref:System.IO.Path.Join%2A> 方法不会尝试根返回的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-669">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="f1caf-670">（也就是说，如果 `path2` 是绝对路径，则 `Join` 方法不会像 <xref:System.IO.Path.Combine%2A> 方法那样丢弃以前的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-670">(That is, if `path2` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>

<span data-ttu-id="f1caf-671">不是目录和文件名的所有无效字符都被 `Join` 方法解释为不可接受的，因为您可以使用这些字符搜索通配符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-671">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="f1caf-672">例如，当创建文件时 `Path.Join("c:\\", "temp", "*.txt")` 可能会无效，但它作为搜索字符串有效。</span><span class="sxs-lookup"><span data-stu-id="f1caf-672">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="f1caf-673">因此，`Join` 方法成功解释它。</span><span class="sxs-lookup"><span data-stu-id="f1caf-673">The `Join` method therefore successfully interprets it.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="f1caf-674">包含要加入的第一个路径的字符范围。</span><span class="sxs-lookup"><span data-stu-id="f1caf-674">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="f1caf-675">包含要加入的第二个路径的字符范围。</span><span class="sxs-lookup"><span data-stu-id="f1caf-675">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="f1caf-676">包含要加入的第三个路径的字符范围。</span><span class="sxs-lookup"><span data-stu-id="f1caf-676">A character span that contains the third path to join.</span></span></param>
        <summary><span data-ttu-id="f1caf-677">将三个路径组件连接到一个路径中。</span><span class="sxs-lookup"><span data-stu-id="f1caf-677">Concatenates three path components into a single path.</span></span></summary>
        <returns><span data-ttu-id="f1caf-678">连接的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-678">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="f1caf-679">此方法只连接 `path`、`path2`和 `path3`，并在任何路径组件之间添加目录分隔符（如果尚未存在）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-679">This method simply concatenates `path`, `path2`, and `path3` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="f1caf-680">如果 `path1`、`path2`或 `path3` 参数的 <xref:System.ReadOnlySpan%601.Length> 都为零，则该方法将连接剩余的参数。</span><span class="sxs-lookup"><span data-stu-id="f1caf-680">If the <xref:System.ReadOnlySpan%601.Length> of any of `path1`, `path2`, or `path3` arguments is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="f1caf-681">如果所有组件的 <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> 都为零，则该方法将返回 <xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1caf-681">If the <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> of all components is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="f1caf-682">如果 `path1` 或 `path2` 以与目标平台不适用的路径分隔符结尾，则 `Join` 方法将保留原始路径分隔符并追加受支持的字符分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-682">If `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="f1caf-683">使用 Windows 反斜杠（"\"）字符的硬编码路径中会出现此问题，该字符在基于 Unix 的系统上未被识别为路径分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-683">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="f1caf-684">若要解决此问题，可以：</span><span class="sxs-lookup"><span data-stu-id="f1caf-684">To work around this issue, you can:</span></span>

- <span data-ttu-id="f1caf-685">检索 <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> 属性的值，而不是对目录分隔符进行硬编码。</span><span class="sxs-lookup"><span data-stu-id="f1caf-685">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="f1caf-686">使用正斜杠（"/"）作为目录分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-686">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="f1caf-687">此字符由基于 Unix 的系统上的 <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> 属性以及 Windows 系统上的 <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> 属性返回。</span><span class="sxs-lookup"><span data-stu-id="f1caf-687">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="f1caf-688">与 <xref:System.IO.Path.Combine%2A> 方法不同，<xref:System.IO.Path.Join%2A> 方法不会尝试根返回的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-688">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="f1caf-689">（也就是说，如果 `path2` 或 `path2` 是绝对路径，则 `Join` 方法不会像 <xref:System.IO.Path.Combine%2A> 方法那样丢弃以前的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-689">(That is, if `path2` or `path2` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>
  
<span data-ttu-id="f1caf-690">不是目录和文件名的所有无效字符都被 `Join` 方法解释为不可接受的，因为您可以使用这些字符搜索通配符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-690">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="f1caf-691">例如，当创建文件时 `Path.Join("c:\\", "temp", "*.txt")` 可能会无效，但它作为搜索字符串有效。</span><span class="sxs-lookup"><span data-stu-id="f1caf-691">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="f1caf-692">因此，`Join` 方法成功解释它。</span><span class="sxs-lookup"><span data-stu-id="f1caf-692">The `Join` method therefore successfully interprets it.</span></span>

## <a name="example"></a><span data-ttu-id="f1caf-693">示例</span><span class="sxs-lookup"><span data-stu-id="f1caf-693">Example</span></span>

<span data-ttu-id="f1caf-694">下面的示例说明 <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> 和 <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> 方法返回的路径之间的差异。</span><span class="sxs-lookup"><span data-stu-id="f1caf-694">The following example illustrates the difference in the paths returned by the <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> and <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="f1caf-695">如果第一个字符串是包含驱动器和根目录的完全限定路径，第二个字符串是第一个路径的相对路径，则这两个方法将产生相同的结果。</span><span class="sxs-lookup"><span data-stu-id="f1caf-695">When the first string is a fully qualified path that includes a drive and root directory and the second is a relative path from the first path, the two methods produce identical results.</span></span> <span data-ttu-id="f1caf-696">在第二次和第三次调用 `ShowPathInformation` 方法时，这两种方法返回的字符串是分叉的。</span><span class="sxs-lookup"><span data-stu-id="f1caf-696">In the second and third calls to the `ShowPathInformation` method, the strings returned by the two methods diverge.</span></span> <span data-ttu-id="f1caf-697">在第二个方法调用中，第一个字符串参数是驱动器，而第二个参数是根目录。</span><span class="sxs-lookup"><span data-stu-id="f1caf-697">In the second method call, the first string argument is a drive, while the second is a rooted directory.</span></span> <span data-ttu-id="f1caf-698">`Join` 方法将两个字符串连接在一起，并保留重复的路径分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-698">The `Join` method concatenates the two strings and preserves duplicate path separators.</span></span> <span data-ttu-id="f1caf-699">调用 <xref:System.IO.Path.GetFullPath%2A> 方法将消除重复。</span><span class="sxs-lookup"><span data-stu-id="f1caf-699">A call to the <xref:System.IO.Path.GetFullPath%2A> method would eliminate the duplication.</span></span> <span data-ttu-id="f1caf-700">`Combine` 方法放弃驱动器并返回当前驱动器上的根目录。</span><span class="sxs-lookup"><span data-stu-id="f1caf-700">The `Combine` method abandons the drive and returns a rooted directory on the current drive.</span></span> <span data-ttu-id="f1caf-701">如果应用程序的当前驱动器为 C：\该字符串用于访问目录中的一个或一些文件，它将访问 C：而不是 d：</span><span class="sxs-lookup"><span data-stu-id="f1caf-701">If the application's current drive is C:\ and the string is used to access a file or files in the directory, it would access C: instead of D:.</span></span> <span data-ttu-id="f1caf-702">最后，由于对 `ShowPathInformation` 的第三次调用中的最后一个参数是根，因此 `Join` 方法只是将其追加到前两个自变量，以创建过程文件路径，而 `Combine` 方法会丢弃前两个字符串并返回第三个字符串。</span><span class="sxs-lookup"><span data-stu-id="f1caf-702">Finally, because the final argument in the third call to `ShowPathInformation` are rooted, the `Join` method simply appends it to the first two arguments to create a nonsensical file path, while the `Combine` method discards the first two strings and returns the third.</span></span> <span data-ttu-id="f1caf-703">使用此字符串进行文件访问可能会给应用程序带来对敏感文件的意外访问权限。</span><span class="sxs-lookup"><span data-stu-id="f1caf-703">Using this string for file access could give the application unintended access to sensitive files.</span></span>

[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/csharp/api/system.io/path/combine3/program.cs)]
[!code-vb[Path.Join(String,String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine3/program.vb)]

       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-704">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-704">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="f1caf-705">要联接的第一个路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-705">The first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="f1caf-706">要联接的第二个路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-706">The second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="f1caf-707">要联接的第三个路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-707">The third path to join.</span></span></param>
        <summary><span data-ttu-id="f1caf-708">将三个路径连接到一个路径中。</span><span class="sxs-lookup"><span data-stu-id="f1caf-708">Concatenates three paths into a single path.</span></span></summary>
        <returns><span data-ttu-id="f1caf-709">连接的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-709">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="f1caf-710">此方法只连接 `path`、`path2`和 `path3`，并在任何路径组件之间添加目录分隔符（如果尚未存在）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-710">This method simply concatenates `path`, `path2`, and `path3` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="f1caf-711">如果任何 `path1`、`path2` 或 `path3` 参数的长度为零，则该方法将连接剩余的参数。</span><span class="sxs-lookup"><span data-stu-id="f1caf-711">If the length of any of `path1`, `path2` or `path3` argument is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="f1caf-712">如果生成的串联字符串的长度为零，则该方法将返回 <xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1caf-712">If the length of the resulting concatenated string is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="f1caf-713">如果 `path1` 或 `path2` 以与目标平台不适用的路径分隔符结尾，则 `Join` 方法将保留原始路径分隔符并追加受支持的字符分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-713">If `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="f1caf-714">使用 Windows 反斜杠（"\"）字符的硬编码路径中会出现此问题，该字符在基于 Unix 的系统上未被识别为路径分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-714">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="f1caf-715">若要解决此问题，可以：</span><span class="sxs-lookup"><span data-stu-id="f1caf-715">To work around this issue, you can:</span></span>

- <span data-ttu-id="f1caf-716">检索 <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> 属性的值，而不是对目录分隔符进行硬编码。</span><span class="sxs-lookup"><span data-stu-id="f1caf-716">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="f1caf-717">使用正斜杠（"/"）作为目录分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-717">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="f1caf-718">此字符由基于 Unix 的系统上的 <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> 属性以及 Windows 系统上的 <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> 属性返回。</span><span class="sxs-lookup"><span data-stu-id="f1caf-718">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="f1caf-719">与 <xref:System.IO.Path.Combine%2A> 方法不同，<xref:System.IO.Path.Join%2A> 方法不会尝试根返回的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-719">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="f1caf-720">（也就是说，如果 `path2` 或 `path2` 是绝对路径，则 `Join` 方法不会像 <xref:System.IO.Path.Combine%2A> 方法那样丢弃以前的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-720">(That is, if `path2` or `path2` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>

<span data-ttu-id="f1caf-721">不是目录和文件名的所有无效字符都被 `Join` 方法解释为不可接受的，因为您可以使用这些字符搜索通配符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-721">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="f1caf-722">例如，当创建文件时 `Path.Join("c:\\", "temp", "*.txt")` 可能会无效，但它作为搜索字符串有效。</span><span class="sxs-lookup"><span data-stu-id="f1caf-722">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="f1caf-723">因此，`Join` 方法成功解释它。</span><span class="sxs-lookup"><span data-stu-id="f1caf-723">The `Join` method therefore successfully interprets it.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, ReadOnlySpan&lt;char&gt; path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.ReadOnlySpan`1&lt;char&gt; path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), path4 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, ReadOnlySpan&lt;char&gt; path4);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="path4" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="f1caf-724">包含要加入的第一个路径的字符范围。</span><span class="sxs-lookup"><span data-stu-id="f1caf-724">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="f1caf-725">包含要加入的第二个路径的字符范围。</span><span class="sxs-lookup"><span data-stu-id="f1caf-725">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="f1caf-726">包含要加入的第三个路径的字符范围。</span><span class="sxs-lookup"><span data-stu-id="f1caf-726">A character span that contains the third path to join.</span></span></param>
        <param name="path4"><span data-ttu-id="f1caf-727">包含要联接的第四个路径的字符跨度。</span><span class="sxs-lookup"><span data-stu-id="f1caf-727">A character span that contains the fourth path to join.</span></span></param>
        <summary><span data-ttu-id="f1caf-728">将四个路径组件连接到一个路径中。</span><span class="sxs-lookup"><span data-stu-id="f1caf-728">Concatenates four path components into a single path.</span></span></summary>
        <returns><span data-ttu-id="f1caf-729">连接的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-729">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="f1caf-730">此方法只连接 `path`、`path2`、`path3` 和 `path4`，并在任何路径组件之间添加目录分隔符（如果尚未存在）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-730">This method simply concatenates `path`, `path2`, `path3` and `path4` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="f1caf-731">如果 `path1`、`path2`、`path3` 或 `path4` 参数的 <xref:System.ReadOnlySpan%601.Length> 都为零，则该方法将连接剩余的参数。</span><span class="sxs-lookup"><span data-stu-id="f1caf-731">If the <xref:System.ReadOnlySpan%601.Length> of any of `path1`, `path2`, `path3` or `path4` argument is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="f1caf-732">如果所有组件的 <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> 都为零，则该方法将返回 <xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1caf-732">If the <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> of all components is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="f1caf-733">如果 `path1` 或 `path2` 或 `path3` 以路径分隔符而不适合目标平台结束，则 `Join` 方法将保留原始路径分隔符，并追加受支持的字符分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-733">If `path1` or `path2` or `path3` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="f1caf-734">使用 Windows 反斜杠（"\"）字符的硬编码路径中会出现此问题，该字符在基于 Unix 的系统上未被识别为路径分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-734">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="f1caf-735">若要解决此问题，可以：</span><span class="sxs-lookup"><span data-stu-id="f1caf-735">To work around this issue, you can:</span></span>

- <span data-ttu-id="f1caf-736">检索 <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> 属性的值，而不是对目录分隔符进行硬编码。</span><span class="sxs-lookup"><span data-stu-id="f1caf-736">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="f1caf-737">使用正斜杠（"/"）作为目录分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-737">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="f1caf-738">此字符由基于 Unix 的系统上的 <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> 属性以及 Windows 系统上的 <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> 属性返回。</span><span class="sxs-lookup"><span data-stu-id="f1caf-738">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="f1caf-739">与 <xref:System.IO.Path.Combine%2A> 方法不同，<xref:System.IO.Path.Join%2A> 方法不会尝试根返回的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-739">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="f1caf-740">（也就是说，如果 `path2` 或 `path2` 或 `path3` 是绝对路径，则 `Join` 方法不会丢弃先前的路径，因为 <xref:System.IO.Path.Combine%2A> 方法会。</span><span class="sxs-lookup"><span data-stu-id="f1caf-740">(That is, if `path2` or `path2` or `path3` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>

<span data-ttu-id="f1caf-741">不是目录和文件名的所有无效字符都被 `Join` 方法解释为不可接受的，因为您可以使用这些字符搜索通配符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-741">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="f1caf-742">例如，当创建文件时 `Path.Join("c:\\", "temp", "*.txt")` 可能会无效，但它作为搜索字符串有效。</span><span class="sxs-lookup"><span data-stu-id="f1caf-742">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="f1caf-743">因此，`Join` 方法成功解释它。</span><span class="sxs-lookup"><span data-stu-id="f1caf-743">The `Join` method therefore successfully interprets it.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="f1caf-744">要联接的第一个路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-744">The first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="f1caf-745">要联接的第二个路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-745">The second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="f1caf-746">要联接的第三个路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-746">The third path to join.</span></span></param>
        <param name="path4"><span data-ttu-id="f1caf-747">要联接的第四个路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-747">The fourth path to join.</span></span></param>
        <summary><span data-ttu-id="f1caf-748">将四个路径连接到一个路径中。</span><span class="sxs-lookup"><span data-stu-id="f1caf-748">Concatenates four paths into a single path.</span></span></summary>
        <returns><span data-ttu-id="f1caf-749">连接的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-749">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="f1caf-750">此方法只连接 `path`、`path2`、`path3` 和 `path4`，并在任何路径组件之间添加目录分隔符（如果尚未存在）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-750">This method simply concatenates `path`, `path2`, `path3` and `path4` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="f1caf-751">如果任何 `path1`、`path2`、`path3` 或 `path4` 参数的长度为零，则该方法将连接剩余的参数。</span><span class="sxs-lookup"><span data-stu-id="f1caf-751">If the length of any of `path1`, `path2`, `path3` or `path4` argument is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="f1caf-752">如果生成的串联字符串的长度为零，则该方法将返回 <xref:System.String.Empty?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f1caf-752">If the length of the resulting concatenated string is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="f1caf-753">如果 `path1` 或 `path2` 或 `path3` 以路径分隔符而不适合目标平台结束，则 `Join` 方法将保留原始路径分隔符，并追加受支持的字符分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-753">If `path1` or `path2` or `path3` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="f1caf-754">使用 Windows 反斜杠（"\"）字符的硬编码路径中会出现此问题，该字符在基于 Unix 的系统上未被识别为路径分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-754">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="f1caf-755">若要解决此问题，可以：</span><span class="sxs-lookup"><span data-stu-id="f1caf-755">To work around this issue, you can:</span></span>

- <span data-ttu-id="f1caf-756">检索 <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> 属性的值，而不是对目录分隔符进行硬编码。</span><span class="sxs-lookup"><span data-stu-id="f1caf-756">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="f1caf-757">使用正斜杠（"/"）作为目录分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-757">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="f1caf-758">此字符由基于 Unix 的系统上的 <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> 属性以及 Windows 系统上的 <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> 属性返回。</span><span class="sxs-lookup"><span data-stu-id="f1caf-758">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="f1caf-759">与 <xref:System.IO.Path.Combine%2A> 方法不同，<xref:System.IO.Path.Join%2A> 方法不会尝试根返回的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-759">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="f1caf-760">（也就是说，如果 `path2` 或 `path2` 或 `path3` 是绝对路径，则 `Join` 方法不会丢弃先前的路径，因为 <xref:System.IO.Path.Combine%2A> 方法会。</span><span class="sxs-lookup"><span data-stu-id="f1caf-760">(That is, if `path2` or `path2` or `path3` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>

<span data-ttu-id="f1caf-761">不是目录和文件名的所有无效字符都被 `Join` 方法解释为不可接受的，因为您可以使用这些字符搜索通配符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-761">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="f1caf-762">例如，当创建文件时 `Path.Join("c:\\", "temp", "*.txt")` 可能会无效，但它作为搜索字符串有效。</span><span class="sxs-lookup"><span data-stu-id="f1caf-762">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="f1caf-763">因此，`Join` 方法成功解释它。</span><span class="sxs-lookup"><span data-stu-id="f1caf-763">The `Join` method therefore successfully interprets it.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSeparator">
      <MemberSignature Language="C#" Value="public static readonly char PathSeparator;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char PathSeparator" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.PathSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PathSeparator As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char PathSeparator;" />
      <MemberSignature Language="F#" Value=" staticval mutable PathSeparator : char" Usage="System.IO.Path.PathSeparator" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f1caf-764">用于在环境变量中分隔路径字符串的平台特定的分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-764">A platform-specific separator character used to separate path strings in environment variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1caf-765">在基于 Windows 的桌面平台上，此字段的值为分号（;)默认情况下，在其他平台上可能会有所不同。</span><span class="sxs-lookup"><span data-stu-id="f1caf-765">On Windows-based desktop platforms, the value of this field is the semicolon (;) by default, but might vary on other platforms.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1caf-766">下面的示例演示如何使用 `PathSeparator` 字段。</span><span class="sxs-lookup"><span data-stu-id="f1caf-766">The following example demonstrates the use of the `PathSeparator` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f1caf-767">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="f1caf-767">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f1caf-768">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-768">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f1caf-769">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-769">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TrimEndingDirectorySeparator">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimEndingDirectorySeparator (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimEndingDirectorySeparator(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TrimEndingDirectorySeparator(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrimEndingDirectorySeparator (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; TrimEndingDirectorySeparator(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member TrimEndingDirectorySeparator : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.TrimEndingDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="f1caf-770">要剪裁的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-770">The path to trim.</span></span></param>
        <summary><span data-ttu-id="f1caf-771">剪裁一个超出指定路径根目录的尾随目录分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-771">Trims one trailing directory separator beyond the root of the specified path.</span></span></summary>
        <returns><span data-ttu-id="f1caf-772">不带任何尾随目录分隔符的 <paramref name="path" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-772">The <paramref name="path" /> without any trailing directory separators.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEndingDirectorySeparator">
      <MemberSignature Language="C#" Value="public static string TrimEndingDirectorySeparator (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string TrimEndingDirectorySeparator(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TrimEndingDirectorySeparator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrimEndingDirectorySeparator (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ TrimEndingDirectorySeparator(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member TrimEndingDirectorySeparator : string -&gt; string" Usage="System.IO.Path.TrimEndingDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="f1caf-773">要剪裁的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-773">The path to trim.</span></span></param>
        <summary><span data-ttu-id="f1caf-774">剪裁一个超出指定路径根目录的尾随目录分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-774">Trims one trailing directory separator beyond the root of the specified path.</span></span></summary>
        <returns><span data-ttu-id="f1caf-775">不带任何尾随目录分隔符的 <paramref name="path" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-775">The <paramref name="path" /> without any trailing directory separators.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryJoin">
      <Docs>
        <summary><span data-ttu-id="f1caf-776">尝试将各个路径组件连接到预分配的字符范围，并返回一个值指示操作是否成功。</span><span class="sxs-lookup"><span data-stu-id="f1caf-776">Attempts to concatenate individual path components to a preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="f1caf-777">目标字符跨度必须足够大才能容纳连接的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-777">The destination character span must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="f1caf-778">然后，可以通过调用 <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> 方法检索串联路径，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="f1caf-778">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the following example illustrates.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/TryJoin/program.cs)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; * int -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="f1caf-779">包含要加入的第一个路径的字符范围。</span><span class="sxs-lookup"><span data-stu-id="f1caf-779">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="f1caf-780">包含要加入的第二个路径的字符范围。</span><span class="sxs-lookup"><span data-stu-id="f1caf-780">A character span that contains the second path to join.</span></span></param>
        <param name="destination"><span data-ttu-id="f1caf-781">用于保存连接的路径的字符范围。</span><span class="sxs-lookup"><span data-stu-id="f1caf-781">A character span to hold the concatenated path.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="f1caf-782">方法返回时，为一个指示写入 <paramref name="destination" /> 的字符数的值。</span><span class="sxs-lookup"><span data-stu-id="f1caf-782">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="f1caf-783">尝试将两个路径组件连接到一个预分配的字符范围，并返回一个值，该值指示操作是否成功。</span><span class="sxs-lookup"><span data-stu-id="f1caf-783">Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="f1caf-784">如果此串联运算成功，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-784"><see langword="true" /> if the concatenation operation is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="f1caf-785">`destination` 必须足够大才能容纳连接的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-785">`destination` must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="f1caf-786">然后，可以通过调用 <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> 方法来检索串联路径，如示例所示。</span><span class="sxs-lookup"><span data-stu-id="f1caf-786">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the example illustrates.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-787">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-787">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; * int -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, path3, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="f1caf-788">包含要加入的第一个路径的字符范围。</span><span class="sxs-lookup"><span data-stu-id="f1caf-788">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="f1caf-789">包含要加入的第二个路径的字符范围。</span><span class="sxs-lookup"><span data-stu-id="f1caf-789">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="f1caf-790">包含要加入的第三个路径的字符范围。</span><span class="sxs-lookup"><span data-stu-id="f1caf-790">A character span that contains the third path to join.</span></span></param>
        <param name="destination"><span data-ttu-id="f1caf-791">用于保存连接的路径的字符范围。</span><span class="sxs-lookup"><span data-stu-id="f1caf-791">A character span to hold the concatenated path.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="f1caf-792">方法返回时，为一个指示写入 <paramref name="destination" /> 的字符数的值。</span><span class="sxs-lookup"><span data-stu-id="f1caf-792">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="f1caf-793">尝试将两个路径组件连接到一个预分配的字符范围，并返回一个值，该值指示操作是否成功。</span><span class="sxs-lookup"><span data-stu-id="f1caf-793">Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="f1caf-794">如果此串联运算成功，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f1caf-794"><see langword="true" /> if the concatenation operation is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="f1caf-795">`destination` 必须足够大才能容纳连接的路径。</span><span class="sxs-lookup"><span data-stu-id="f1caf-795">`destination` must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="f1caf-796">然后，可以通过调用 <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> 方法来检索串联路径，如示例所示。</span><span class="sxs-lookup"><span data-stu-id="f1caf-796">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the example illustrates.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="f1caf-797">Windows 系统中的文件路径格式</span><span class="sxs-lookup"><span data-stu-id="f1caf-797">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="VolumeSeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char VolumeSeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char VolumeSeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.VolumeSeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VolumeSeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char VolumeSeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable VolumeSeparatorChar : char" Usage="System.IO.Path.VolumeSeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f1caf-798">提供平台特定的卷分隔符。</span><span class="sxs-lookup"><span data-stu-id="f1caf-798">Provides a platform-specific volume separator character.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f1caf-799">此字段的值是一个冒号（:)在 Windows 和 Macintosh 上，在 UNIX 操作系统上使用斜杠（/）。</span><span class="sxs-lookup"><span data-stu-id="f1caf-799">The value of this field is a colon (:) on Windows and Macintosh, and a slash (/) on UNIX operating systems.</span></span> <span data-ttu-id="f1caf-800">这对于分析路径（如 "c：\windows" 或 "MacVolume： System Folder"）最为有用。</span><span class="sxs-lookup"><span data-stu-id="f1caf-800">This is most useful for parsing paths such as "c:\windows" or "MacVolume:System Folder".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f1caf-801">下面的示例演示如何使用 `VolumeSeparatorChar` 字段。</span><span class="sxs-lookup"><span data-stu-id="f1caf-801">The following example demonstrates the use of the `VolumeSeparatorChar` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f1caf-802">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="f1caf-802">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f1caf-803">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-803">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f1caf-804">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="f1caf-804">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
