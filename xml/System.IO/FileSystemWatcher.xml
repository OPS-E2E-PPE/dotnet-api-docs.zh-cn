<Type Name="FileSystemWatcher" FullName="System.IO.FileSystemWatcher">
  <Metadata><Meta Name="ms.openlocfilehash" Value="495426ea0fe1406df39d5fe7a65d8b1e252cb591" /><Meta Name="ms.sourcegitcommit" Value="8b09499854b5b7b909802126edc1f1fca0054c10" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="02/01/2020" /><Meta Name="ms.locfileid" Value="76946315" /></Metadata><TypeSignature Language="C#" Value="public class FileSystemWatcher : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystemWatcher extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileSystemWatcher" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemWatcher&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemWatcher : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type FileSystemWatcher = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultEvent("Changed")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.IO.IODescription("")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.IO.IODescription("FileSystemWatcherDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="ca1e6-101">侦听文件系统更改通知，并在目录或目录中的文件发生更改时引发事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-101">Listens to the file system change notifications and raises events when a directory, or file in a directory, changes.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1e6-102">使用 <xref:System.IO.FileSystemWatcher> 来监视指定目录中的更改。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-102">Use <xref:System.IO.FileSystemWatcher> to watch for changes in a specified directory.</span></span> <span data-ttu-id="ca1e6-103">可以监视指定目录的文件和子目录中的更改。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-103">You can watch for changes in files and subdirectories of the specified directory.</span></span> <span data-ttu-id="ca1e6-104">你可以创建一个组件来监视本地计算机、网络驱动器或远程计算机上的文件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-104">You can create a component to watch files on a local computer, a network drive, or a remote computer.</span></span>  
  
 <span data-ttu-id="ca1e6-105">若要监视所有文件中的更改，请将 <xref:System.IO.FileSystemWatcher.Filter%2A> 属性设置为空字符串（""）或使用通配符（"\*。\*"）。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-105">To watch for changes in all files, set the <xref:System.IO.FileSystemWatcher.Filter%2A> property to an empty string ("") or use wildcards ("\*.\*").</span></span> <span data-ttu-id="ca1e6-106">若要查看特定文件，请将 <xref:System.IO.FileSystemWatcher.Filter%2A> 属性设置为文件名。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-106">To watch a specific file, set the <xref:System.IO.FileSystemWatcher.Filter%2A> property to the file name.</span></span> <span data-ttu-id="ca1e6-107">例如，若要监视文件 MyDoc 中的更改，请将 <xref:System.IO.FileSystemWatcher.Filter%2A> 属性设置为 "MyDoc"。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-107">For example, to watch for changes in the file MyDoc.txt, set the <xref:System.IO.FileSystemWatcher.Filter%2A> property to "MyDoc.txt".</span></span> <span data-ttu-id="ca1e6-108">还可以监视特定类型的文件中的更改。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-108">You can also watch for changes in a certain type of file.</span></span> <span data-ttu-id="ca1e6-109">例如，若要监视文本文件中的更改，请将 <xref:System.IO.FileSystemWatcher.Filter%2A> 属性设置为 "\*.txt"。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-109">For example, to watch for changes in text files, set the <xref:System.IO.FileSystemWatcher.Filter%2A> property to "\*.txt".</span></span>  
  
 <span data-ttu-id="ca1e6-110">可以在目录或文件中监视几种类型的更改。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-110">There are several types of changes you can watch for in a directory or file.</span></span> <span data-ttu-id="ca1e6-111">例如，你可以监视 `Attributes`、`LastWrite` 日期和时间，或者文件或目录的 `Size` 的更改。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-111">For example, you can watch for changes in `Attributes`, the `LastWrite` date and time, or the `Size` of files or directories.</span></span> <span data-ttu-id="ca1e6-112">这是通过将 <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> 属性设置为 <xref:System.IO.NotifyFilters> 值之一来完成的。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-112">This is done by setting the <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> property to one of the <xref:System.IO.NotifyFilters> values.</span></span> <span data-ttu-id="ca1e6-113">有关可以观看的更改类型的详细信息，请参阅 <xref:System.IO.NotifyFilters>。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-113">For more information on the type of changes you can watch, see <xref:System.IO.NotifyFilters>.</span></span>  
  
 <span data-ttu-id="ca1e6-114">可以监视文件或目录的重命名、删除或创建。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-114">You can watch for renaming, deletion, or creation of files or directories.</span></span> <span data-ttu-id="ca1e6-115">例如，若要监视是否重命名了文本文件，请将 <xref:System.IO.FileSystemWatcher.Filter%2A> 属性设置为 "\* .txt"，并使用为其参数指定的 <xref:System.IO.WatcherChangeTypes.Renamed> 调用 <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-115">For example, to watch for renaming of text files, set the <xref:System.IO.FileSystemWatcher.Filter%2A> property to "\*.txt" and call the <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> method with a <xref:System.IO.WatcherChangeTypes.Renamed> specified for its parameter.</span></span>  
  
 <span data-ttu-id="ca1e6-116">Windows 操作系统会将文件更改的组件通知到 <xref:System.IO.FileSystemWatcher>所创建的缓冲区中。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-116">The Windows operating system notifies your component of file changes in a buffer created by the <xref:System.IO.FileSystemWatcher>.</span></span> <span data-ttu-id="ca1e6-117">如果短时间内有很多更改，则缓冲区可能溢出。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-117">If there are many changes in a short time, the buffer can overflow.</span></span> <span data-ttu-id="ca1e6-118">这会使组件失去对目录中的更改的跟踪，并且它将只提供覆盖通知。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-118">This causes the component to lose track of changes in the directory, and it will only provide blanket notification.</span></span> <span data-ttu-id="ca1e6-119">用 <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> 属性增加缓冲区的大小会消耗大量资源，因为它来自无法换出到磁盘的非分页内存，因此，请将缓冲区保持得足够小但足以避免丢失任何文件更改事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-119">Increasing the size of the buffer with the <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> property is expensive, as it comes from non-paged memory that cannot be swapped out to disk, so keep the buffer as small yet large enough to not miss any file change events.</span></span> <span data-ttu-id="ca1e6-120">若要避免缓冲区溢出，请使用 <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> 和 <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> 属性，以便可以筛选出不需要的更改通知。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-120">To avoid a buffer overflow, use the <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> and <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> properties so you can filter out unwanted change notifications.</span></span>  
  
 <span data-ttu-id="ca1e6-121">有关 <xref:System.IO.FileSystemWatcher>实例的初始属性值的列表，请参阅 <xref:System.IO.FileSystemWatcher.%23ctor%2A> 构造函数。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-121">For a list of initial property values for an instance of <xref:System.IO.FileSystemWatcher>, see the <xref:System.IO.FileSystemWatcher.%23ctor%2A> constructor.</span></span>  
  
 <span data-ttu-id="ca1e6-122">使用 <xref:System.IO.FileSystemWatcher> 类时，请注意以下各项。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-122">Please note the following when using the <xref:System.IO.FileSystemWatcher> class.</span></span>  
  
-   <span data-ttu-id="ca1e6-123">不会忽略隐藏的文件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-123">Hidden files are not ignored.</span></span>  
  
-   <span data-ttu-id="ca1e6-124">在某些系统中，<xref:System.IO.FileSystemWatcher> 使用短8.3 文件名格式对文件进行更改。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-124">In some systems, <xref:System.IO.FileSystemWatcher> reports changes to files using the short 8.3 file name format.</span></span> <span data-ttu-id="ca1e6-125">例如，将 "LongFileName" 更改为 "LongFil ~。Lon "。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-125">For example, a change to  "LongFileName.LongExtension" could be reported as "LongFil~.Lon".</span></span>  
  
-   <span data-ttu-id="ca1e6-126">此类包含应用于所有成员的类级别的链接要求和继承要求。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-126">This class contains a link demand and an inheritance demand at the class level that applies to all members.</span></span> <span data-ttu-id="ca1e6-127">当直接调用方或派生类不具有完全信任权限时，将引发 <xref:System.Security.SecurityException>。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-127">A <xref:System.Security.SecurityException> is thrown when either the immediate caller or the derived class does not have full-trust permission.</span></span> <span data-ttu-id="ca1e6-128">有关安全要求的详细信息，请参阅[链接需求](~/docs/framework/misc/link-demands.md)。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-128">For details about security demands, see [Link Demands](~/docs/framework/misc/link-demands.md).</span></span>  
  
-   <span data-ttu-id="ca1e6-129">可以为用于通过网络监视目录的 <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> 属性设置的最大大小为 64 KB。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-129">The maximum size you can set for the <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> property for monitoring a directory over the network is 64 KB.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ca1e6-130">不支持在 Windows 98 上运行 <xref:System.IO.FileSystemWatcher>。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-130">Running <xref:System.IO.FileSystemWatcher> on Windows 98 is not supported.</span></span>  
  
## <a name="copying-and-moving-folders"></a><span data-ttu-id="ca1e6-131">复制和移动文件夹</span><span class="sxs-lookup"><span data-stu-id="ca1e6-131">Copying and moving folders</span></span>  
 <span data-ttu-id="ca1e6-132">操作系统和 <xref:System.IO.FileSystemWatcher> 对象会将剪切和粘贴操作或移动操作解释为文件夹及其内容的重命名操作。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-132">The operating system and <xref:System.IO.FileSystemWatcher> object interpret a cut-and-paste action or a move action as a rename action for a folder and its contents.</span></span> <span data-ttu-id="ca1e6-133">如果将包含文件的文件夹剪切并粘贴到被监视的文件夹中，则 <xref:System.IO.FileSystemWatcher> 对象只会将该文件夹报告为新文件夹，但不报告其内容，因为它们实质上只是已重命名。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-133">If you cut and paste a folder with files into a folder being watched, the <xref:System.IO.FileSystemWatcher> object reports only the folder as new, but not its contents because they are essentially only renamed.</span></span>  
  
 <span data-ttu-id="ca1e6-134">若要通知文件夹内容已移动或复制到监视的文件夹，请提供下表中所建议 <xref:System.IO.FileSystemWatcher.OnChanged%2A> 和 <xref:System.IO.FileSystemWatcher.OnRenamed%2A> 事件处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-134">To be notified that the contents of folders have been moved or copied into a watched folder, provide <xref:System.IO.FileSystemWatcher.OnChanged%2A> and <xref:System.IO.FileSystemWatcher.OnRenamed%2A> event handler methods as suggested in the following table.</span></span>  
  
|<span data-ttu-id="ca1e6-135">事件处理程序</span><span class="sxs-lookup"><span data-stu-id="ca1e6-135">Event Handler</span></span>|<span data-ttu-id="ca1e6-136">处理的事件</span><span class="sxs-lookup"><span data-stu-id="ca1e6-136">Events Handled</span></span>|<span data-ttu-id="ca1e6-137">执行速度</span><span class="sxs-lookup"><span data-stu-id="ca1e6-137">Performs</span></span>|  
|-------------------|--------------------|--------------|  
|<xref:System.IO.FileSystemWatcher.OnChanged%2A>|<span data-ttu-id="ca1e6-138"><xref:System.IO.FileSystemWatcher.Changed>、<xref:System.IO.FileSystemWatcher.Created>、<xref:System.IO.FileSystemWatcher.Deleted></span><span class="sxs-lookup"><span data-stu-id="ca1e6-138"><xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted></span></span>|<span data-ttu-id="ca1e6-139">报告文件属性中的更改、创建的文件和删除的文件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-139">Report changes in file attributes, created files, and deleted files.</span></span>|  
|<xref:System.IO.FileSystemWatcher.OnRenamed%2A>|<xref:System.IO.FileSystemWatcher.Renamed>|<span data-ttu-id="ca1e6-140">列出重命名的文件和文件夹的新路径和新路径，如果需要，请进行递归扩展。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-140">List the old and new paths of renamed files and folders, expanding recursively if needed.</span></span>|  
  
## <a name="events-and-buffer-sizes"></a><span data-ttu-id="ca1e6-141">事件和缓冲区大小</span><span class="sxs-lookup"><span data-stu-id="ca1e6-141">Events and Buffer Sizes</span></span>  
 <span data-ttu-id="ca1e6-142">请注意，有几个因素可能会影响引发的文件系统更改事件，如下所述：</span><span class="sxs-lookup"><span data-stu-id="ca1e6-142">Note that several factors can affect which file system change events are raised, as described by the following:</span></span>  
  
-   <span data-ttu-id="ca1e6-143">常见的文件系统操作可能会引发多个事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-143">Common file system operations might raise more than one event.</span></span> <span data-ttu-id="ca1e6-144">例如，当文件从一个目录移到另一个目录时，可能会引发多个 <xref:System.IO.FileSystemWatcher.OnChanged%2A>，某些 <xref:System.IO.FileSystemWatcher.OnCreated%2A> 和 <xref:System.IO.FileSystemWatcher.OnDeleted%2A> 事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-144">For example, when a file is moved from one directory to another, several <xref:System.IO.FileSystemWatcher.OnChanged%2A> and some <xref:System.IO.FileSystemWatcher.OnCreated%2A> and <xref:System.IO.FileSystemWatcher.OnDeleted%2A> events might be raised.</span></span> <span data-ttu-id="ca1e6-145">移动文件是一项复杂的操作，它包含多个简单操作，因此引发了多个事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-145">Moving a file is a complex operation that consists of multiple simple operations, therefore raising multiple events.</span></span> <span data-ttu-id="ca1e6-146">同样，某些应用程序（例如，防病毒软件）可能会导致 <xref:System.IO.FileSystemWatcher>检测到的其他文件系统事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-146">Likewise, some applications (for example, antivirus software) might cause additional file system events that are detected by <xref:System.IO.FileSystemWatcher>.</span></span>  
  
-   <span data-ttu-id="ca1e6-147"><xref:System.IO.FileSystemWatcher> 可以监视磁盘，只要它们未被切换或删除。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-147">The <xref:System.IO.FileSystemWatcher> can watch disks as long as they are not switched or removed.</span></span> <span data-ttu-id="ca1e6-148"><xref:System.IO.FileSystemWatcher> 不会引发 Cd 和 Dvd 事件，因为时间戳和属性无法更改。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-148">The <xref:System.IO.FileSystemWatcher> does not raise events for CDs and DVDs, because time stamps and properties cannot change.</span></span> <span data-ttu-id="ca1e6-149">远程计算机必须安装其中一个所需的平台，组件才能正常运行。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-149">Remote computers must have one of the required platforms installed for the component to function properly.</span></span>  
  
-   <span data-ttu-id="ca1e6-150">如果多个 <xref:System.IO.FileSystemWatcher> 对象在 Windows XP Service Pack 1 之前、Windows 2000 SP2 或更早版本中监视相同的 UNC 路径，则只有其中一个对象会引发事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-150">If multiple <xref:System.IO.FileSystemWatcher> objects are watching the same UNC path in Windows XP prior to Service Pack 1, or Windows 2000 SP2 or earlier, then only one of the objects will raise an event.</span></span> <span data-ttu-id="ca1e6-151">在运行 Windows XP SP1 和更高版本、Windows 2000 SP3 或更高版本或 Windows Server 2003 的计算机上，所有 <xref:System.IO.FileSystemWatcher> 对象将引发相应的事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-151">On machines running Windows XP SP1 and newer, Windows 2000 SP3 or newer or Windows Server 2003, all <xref:System.IO.FileSystemWatcher> objects will raise the appropriate events.</span></span>  
  
 <span data-ttu-id="ca1e6-152">请注意，当超过缓冲区大小时，<xref:System.IO.FileSystemWatcher> 可能会遗漏事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-152">Note that a <xref:System.IO.FileSystemWatcher> may miss an event when the buffer size is exceeded.</span></span> <span data-ttu-id="ca1e6-153">若要避免丢失事件，请遵循以下准则：</span><span class="sxs-lookup"><span data-stu-id="ca1e6-153">To avoid missing events, follow these guidelines:</span></span>  
  
-   <span data-ttu-id="ca1e6-154">通过设置 <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> 属性增加缓冲区大小。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-154">Increase the buffer size by setting the <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> property.</span></span>  
  
-   <span data-ttu-id="ca1e6-155">避免监视包含长文件名的文件，因为较长的文件名有助于填充缓冲区。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-155">Avoid watching files with long file names, because a long file name contributes to filling up the buffer.</span></span> <span data-ttu-id="ca1e6-156">请考虑使用较短的名称重命名这些文件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-156">Consider renaming these files using shorter names.</span></span>  
  
-   <span data-ttu-id="ca1e6-157">使事件处理代码尽可能简短。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-157">Keep your event handling code as short as possible.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ca1e6-158">下面的示例创建一个 <xref:System.IO.FileSystemWatcher> 以监视运行时指定的目录。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-158">The following example creates a <xref:System.IO.FileSystemWatcher> to watch the directory specified at run time.</span></span> <span data-ttu-id="ca1e6-159">组件设置为监视 `LastWrite` 和 `LastAccess` 时间的更改、创建、删除或重命名目录中的文本文件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-159">The component is set to watch for changes in `LastWrite` and `LastAccess` time, the creation, deletion, or renaming of text files in the directory.</span></span> <span data-ttu-id="ca1e6-160">如果更改、创建或删除了某个文件，则该文件的路径将打印到控制台。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-160">If a file is changed, created, or deleted, the path to the file prints to the console.</span></span> <span data-ttu-id="ca1e6-161">重命名文件后，旧路径和新路径将打印到控制台。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-161">When a file is renamed, the old and new paths print to the console.</span></span>  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ca1e6-162">用于从 <see cref="T:System.Diagnostics.ProcessStartInfo" /> 类派生。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-162">for deriving from the <see cref="T:System.Diagnostics.ProcessStartInfo" /> class.</span></span> <span data-ttu-id="ca1e6-163">需求值： <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />;命名权限集： <see langword="FullTrust" />。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-163">Demand value: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />; Named Permission Sets: <see langword="FullTrust" />.</span></span></permission>
    <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
    <altmember cref="T:System.IO.NotifyFilters" />
    <altmember cref="T:System.IO.FileSystemEventArgs" />
    <altmember cref="T:System.IO.FileSystemEventHandler" />
    <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
    <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
    <altmember cref="T:System.IO.InternalBufferOverflowException" />
    <altmember cref="T:System.IO.RenamedEventArgs" />
    <altmember cref="T:System.IO.RenamedEventHandler" />
    <altmember cref="T:System.IO.WaitForChangedResult" />
    <altmember cref="T:System.IO.WatcherChangeTypes" />
    <related type="ExternalDocumentation" href="https://github.com/microsoftarchive/msdn-code-gallery-community-s-z/tree/master/Using%20a%20FileSystemWatcher%20Component%20in%20a%20Windows%20Form%20with%20C%23"><span data-ttu-id="ca1e6-164">在 Windows 窗体中使用 FileSystemWatcher 组件</span><span class="sxs-lookup"><span data-stu-id="ca1e6-164">Using a FileSystemWatcher Component in a Windows Form</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ca1e6-165">初始化 <see cref="T:System.IO.FileSystemWatcher" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-165">Initializes a new instance of the <see cref="T:System.IO.FileSystemWatcher" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ca1e6-166">初始化 <see cref="T:System.IO.FileSystemWatcher" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-166">Initializes a new instance of the <see cref="T:System.IO.FileSystemWatcher" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1e6-167">不能查看没有 Windows NT 或 Windows 2000 的远程计算机。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-167">You cannot watch a remote computer that does not have Windows NT or Windows 2000.</span></span> <span data-ttu-id="ca1e6-168">不能从 Windows NT 4.0 计算机上观看远程 Windows NT 4.0 计算机。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-168">You cannot watch a remote Windows NT 4.0 computer from a Windows NT 4.0 computer.</span></span>  
  
 <span data-ttu-id="ca1e6-169">下表显示了 <xref:System.IO.FileSystemWatcher>实例的初始属性值。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-169">The following table shows initial property values for an instance of <xref:System.IO.FileSystemWatcher>.</span></span>  
  
|<span data-ttu-id="ca1e6-170">properties</span><span class="sxs-lookup"><span data-stu-id="ca1e6-170">Property</span></span>|<span data-ttu-id="ca1e6-171">初始值</span><span class="sxs-lookup"><span data-stu-id="ca1e6-171">Initial Value</span></span>|  
|--------------|-------------------|  
|<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>|<span data-ttu-id="ca1e6-172">`LastWrite`、`FileName`和 `DirectoryName` 的按位 "或" 组合</span><span class="sxs-lookup"><span data-stu-id="ca1e6-172">bitwise OR combination of `LastWrite`, `FileName`, and `DirectoryName`</span></span>|  
|<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.Filter%2A>|<span data-ttu-id="ca1e6-173">"\*.\*"（观看所有文件。）</span><span class="sxs-lookup"><span data-stu-id="ca1e6-173">"\*.\*" (Watch all files.)</span></span>|  
|<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>|<span data-ttu-id="ca1e6-174">8192</span><span class="sxs-lookup"><span data-stu-id="ca1e6-174">8192</span></span>|  
|<xref:System.IO.FileSystemWatcher.Path%2A>|<span data-ttu-id="ca1e6-175">空字符串（""）</span><span class="sxs-lookup"><span data-stu-id="ca1e6-175">empty string ("")</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="ca1e6-176">在设置 <xref:System.IO.FileSystemWatcher.Path%2A> 并 `true`<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> 之前，该组件不会监视指定的目录。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-176">The component will not watch the specified directory until the <xref:System.IO.FileSystemWatcher.Path%2A> is set, and <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> is `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ca1e6-177">下面的示例创建一个 <xref:System.IO.FileSystemWatcher> 对象来监视运行时指定的目录。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-177">The following example creates a <xref:System.IO.FileSystemWatcher> object to watch the directory specified at run time.</span></span> <span data-ttu-id="ca1e6-178"><xref:System.IO.FileSystemWatcher> 对象监视 `LastWrite` 和 `LastAccess` 时间发生的更改，以及用于创建、删除或重命名目录中的文本文件的。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-178">The <xref:System.IO.FileSystemWatcher> object watches for changes in `LastWrite` and `LastAccess` times, and for the creation, deletion, or renaming of text files in the directory.</span></span> <span data-ttu-id="ca1e6-179">如果更改、创建或删除了某个文件，则该文件的路径将显示在控制台中。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-179">If a file is changed, created, or deleted, the path to the file displays to the console.</span></span> <span data-ttu-id="ca1e6-180">重命名文件后，旧路径和新路径将显示在控制台中。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-180">When a file is renamed, the old and new paths display to the console.</span></span>  
  
 <span data-ttu-id="ca1e6-181">此示例使用 <xref:System.Diagnostics> 和 <xref:System.IO> 命名空间。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-181">This example uses the <xref:System.Diagnostics> and <xref:System.IO> namespaces.</span></span>  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="ca1e6-182">完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-182">for full trust for the immediate caller.</span></span> <span data-ttu-id="ca1e6-183">此成员不能由部分信任的代码使用。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-183">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="ca1e6-184">要监视的目录，以标准表示法或通用命名约定 (UNC) 表示法表示。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-184">The directory to monitor, in standard or Universal Naming Convention (UNC) notation.</span></span></param>
        <summary><span data-ttu-id="ca1e6-185">在给定要监视的指定目录的情况下，初始化 <see cref="T:System.IO.FileSystemWatcher" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-185">Initializes a new instance of the <see cref="T:System.IO.FileSystemWatcher" /> class, given the specified directory to monitor.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ca1e6-186">在设置 <xref:System.IO.FileSystemWatcher.Path%2A> 并 `true`<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> 之前，该组件不会监视指定的目录。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-186">The component will not watch the specified directory until the <xref:System.IO.FileSystemWatcher.Path%2A> is set, and <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> is `true`.</span></span>  
  
 <span data-ttu-id="ca1e6-187">组件可以查看个人计算机、网络驱动器或远程计算机上的文件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-187">The component can watch files on your personal computer, a network drive, or a remote computer.</span></span>  
  
 <span data-ttu-id="ca1e6-188">不能查看没有 Windows NT 或 Windows 2000 的远程计算机。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-188">You cannot watch a remote computer that does not have Windows NT or Windows 2000.</span></span> <span data-ttu-id="ca1e6-189">不能从 Windows NT 4.0 计算机上观看远程 Windows NT 4.0 计算机。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-189">You cannot watch a remote Windows NT 4.0 computer from a Windows NT 4.0 computer.</span></span> <span data-ttu-id="ca1e6-190">默认情况下，将设置 <xref:System.IO.FileSystemWatcher.Filter%2A> 属性来监视所有文件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-190">The <xref:System.IO.FileSystemWatcher.Filter%2A> property is set by default to watch all files.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ca1e6-191"><paramref name="path" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-191">The <paramref name="path" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ca1e6-192"><paramref name="path" /> 参数为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-192">The <paramref name="path" /> parameter is an empty string ("").</span></span>  
  
<span data-ttu-id="ca1e6-193">-或-</span><span class="sxs-lookup"><span data-stu-id="ca1e6-193">-or-</span></span> 
<span data-ttu-id="ca1e6-194">通过 <paramref name="path" /> 参数指定的路径不存在。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-194">The path specified through the <paramref name="path" /> parameter does not exist.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="ca1e6-195"><paramref name="path" /> 过长。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-195"><paramref name="path" /> is too long.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="ca1e6-196">完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-196">for full trust for the immediate caller.</span></span> <span data-ttu-id="ca1e6-197">此成员不能由部分信任的代码使用。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-197">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, filter As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string * string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher (path, filter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="ca1e6-198">要监视的目录，以标准表示法或通用命名约定 (UNC) 表示法表示。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-198">The directory to monitor, in standard or Universal Naming Convention (UNC) notation.</span></span></param>
        <param name="filter"><span data-ttu-id="ca1e6-199">要监视的文件的类型。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-199">The type of files to watch.</span></span> <span data-ttu-id="ca1e6-200">例如，“\*.txt”监视所有文本文件的更改。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-200">For example, "\*.txt" watches for changes to all text files.</span></span></param>
        <summary><span data-ttu-id="ca1e6-201">在给定要监视的指定目录和文件类型的情况下，初始化 <see cref="T:System.IO.FileSystemWatcher" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-201">Initializes a new instance of the <see cref="T:System.IO.FileSystemWatcher" /> class, given the specified directory and type of files to monitor.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="ca1e6-202">在设置 <xref:System.IO.FileSystemWatcher.Path%2A> 并 `true`<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> 之前，该组件不会监视指定的目录。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-202">The component will not watch the specified directory until the <xref:System.IO.FileSystemWatcher.Path%2A> is set, and <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> is `true`.</span></span>  
  
 <span data-ttu-id="ca1e6-203">组件可以查看个人计算机、网络驱动器或远程计算机上的文件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-203">The component can watch files on your personal computer, a network drive, or a remote computer.</span></span>  
  
 <span data-ttu-id="ca1e6-204">不能查看没有 Windows NT 或 Windows 2000 的远程计算机。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-204">You cannot watch a remote computer that does not have Windows NT or Windows 2000.</span></span> <span data-ttu-id="ca1e6-205">不能从 Windows NT 4.0 计算机上观看远程 Windows NT 4.0 计算机。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-205">You cannot watch a remote Windows NT 4.0 computer from a Windows NT 4.0 computer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ca1e6-206"><paramref name="path" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-206">The <paramref name="path" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="ca1e6-207">-或-</span><span class="sxs-lookup"><span data-stu-id="ca1e6-207">-or-</span></span> 
<span data-ttu-id="ca1e6-208"><paramref name="filter" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-208">The <paramref name="filter" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ca1e6-209"><paramref name="path" /> 参数为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-209">The <paramref name="path" /> parameter is an empty string ("").</span></span>  
  
<span data-ttu-id="ca1e6-210">-或-</span><span class="sxs-lookup"><span data-stu-id="ca1e6-210">-or-</span></span> 
<span data-ttu-id="ca1e6-211">通过 <paramref name="path" /> 参数指定的路径不存在。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-211">The path specified through the <paramref name="path" /> parameter does not exist.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="ca1e6-212"><paramref name="path" /> 过长。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-212"><paramref name="path" /> is too long.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="ca1e6-213">完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-213">for full trust for the immediate caller.</span></span> <span data-ttu-id="ca1e6-214">此成员不能由部分信任的代码使用。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-214">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="fileSystemWatcher.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ca1e6-215">开始初始化在窗体上使用或由另一个组件使用的 <see cref="T:System.IO.FileSystemWatcher" />。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-215">Begins the initialization of a <see cref="T:System.IO.FileSystemWatcher" /> used on a form or used by another component.</span></span> <span data-ttu-id="ca1e6-216">初始化发生在运行时。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-216">The initialization occurs at run time.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1e6-217">[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] 设计环境使用此方法开始初始化在窗体上使用或由另一个组件使用的组件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-217">The [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] design environment uses this method to start the initialization of a component used on a form or used by another component.</span></span> <span data-ttu-id="ca1e6-218"><xref:System.IO.FileSystemWatcher.EndInit%2A> 方法结束初始化。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-218">The <xref:System.IO.FileSystemWatcher.EndInit%2A> method ends the initialization.</span></span> <span data-ttu-id="ca1e6-219">使用 <xref:System.IO.FileSystemWatcher.BeginInit%2A> 和 <xref:System.IO.FileSystemWatcher.EndInit%2A> 方法可防止控件在完全初始化之前被使用。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-219">Using the <xref:System.IO.FileSystemWatcher.BeginInit%2A> and <xref:System.IO.FileSystemWatcher.EndInit%2A> methods prevents the control from being used before it is fully initialized.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : System.IO.FileSystemEventHandler " Usage="member this.Changed : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory change matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Changed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ca1e6-220">当更改指定 <see cref="P:System.IO.FileSystemWatcher.Path" /> 中的文件和目录时发生。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-220">Occurs when a file or directory in the specified <see cref="P:System.IO.FileSystemWatcher.Path" /> is changed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1e6-221">当对受监视目录中的文件或目录的大小、系统属性、上次写入时间、上次访问时间或安全权限进行更改时，将引发 <xref:System.IO.FileSystemWatcher.Changed> 事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-221">The <xref:System.IO.FileSystemWatcher.Changed> event is raised when changes are made to the size, system attributes, last write time, last access time, or security permissions of a file or directory in the directory being monitored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ca1e6-222">常见的文件系统操作可能会引发多个事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-222">Common file system operations might raise more than one event.</span></span> <span data-ttu-id="ca1e6-223">例如，当文件从一个目录移到另一个目录时，可能会引发多个 <xref:System.IO.FileSystemWatcher.OnChanged%2A>，某些 <xref:System.IO.FileSystemWatcher.OnCreated%2A> 和 <xref:System.IO.FileSystemWatcher.OnDeleted%2A> 事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-223">For example, when a file is moved from one directory to another, several <xref:System.IO.FileSystemWatcher.OnChanged%2A> and some <xref:System.IO.FileSystemWatcher.OnCreated%2A> and <xref:System.IO.FileSystemWatcher.OnDeleted%2A> events might be raised.</span></span> <span data-ttu-id="ca1e6-224">移动文件是一项复杂的操作，它包含多个简单操作，因此引发了多个事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-224">Moving a file is a complex operation that consists of multiple simple operations, therefore raising multiple events.</span></span> <span data-ttu-id="ca1e6-225">同样，某些应用程序（例如，防病毒软件）可能会导致 <xref:System.IO.FileSystemWatcher>检测到的其他文件系统事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-225">Likewise, some applications (for example, antivirus software) might cause additional file system events that are detected by <xref:System.IO.FileSystemWatcher>.</span></span>  
  
 <span data-ttu-id="ca1e6-226">使用 <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> 限制处理此事件时引发的通知数。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-226">Use <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> to restrict the number of notifications raised when this event is handled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ca1e6-227">重命名某个文件时，会意外引发 <xref:System.IO.FileSystemWatcher.Changed> 事件，但在重命名该目录时不会引发该事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-227">The <xref:System.IO.FileSystemWatcher.Changed> event is raised unexpectedly when a file is renamed, but is not raised when a directory is renamed.</span></span> <span data-ttu-id="ca1e6-228">若要监视重命名，请使用 <xref:System.IO.FileSystemWatcher.Renamed> 事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-228">To watch for renaming, use the <xref:System.IO.FileSystemWatcher.Renamed> event.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ca1e6-229"><xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> 属性不 `null`时，引发 <xref:System.IO.FileSystemWatcher.Changed> 事件相对于其他 <xref:System.IO.FileSystemWatcher> 事件的顺序可能会更改。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-229">The order in which the <xref:System.IO.FileSystemWatcher.Changed> event is raised in relation to the other <xref:System.IO.FileSystemWatcher> events may change when the <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> property is not `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ca1e6-230">下面的示例使用 <xref:System.IO.FileSystemWatcher.Changed> 事件，每当跟踪的文件发生更改时，都会将文件路径显示到控制台。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-230">The following example uses the <xref:System.IO.FileSystemWatcher.Changed> event to display the file path to the console whenever the watched file is changed.</span></span>  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Created;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Created" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Created" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Created As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Created;" />
      <MemberSignature Language="F#" Value="member this.Created : System.IO.FileSystemEventHandler " Usage="member this.Created : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory creation matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Created")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ca1e6-231">当在指定 <see cref="P:System.IO.FileSystemWatcher.Path" /> 中创建文件和目录时发生。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-231">Occurs when a file or directory in the specified <see cref="P:System.IO.FileSystemWatcher.Path" /> is created.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1e6-232">一些常见的情况（例如，复制或移动文件或目录）不与事件直接对应，但这种情况确实会引发事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-232">Some common occurrences, such as copying or moving a file or directory, do not correspond directly to an event, but these occurrences do cause events to be raised.</span></span> <span data-ttu-id="ca1e6-233">复制文件或目录时，系统将在文件被复制到的目录中引发 <xref:System.IO.FileSystemWatcher.Created> 事件（如果正在监视该目录）。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-233">When you copy a file or directory, the system raises a <xref:System.IO.FileSystemWatcher.Created> event in the directory to which the file was copied, if that directory is being watched.</span></span> <span data-ttu-id="ca1e6-234">如果从中复制的目录正在由 <xref:System.IO.FileSystemWatcher>的另一个实例进行跟踪，则不会引发任何事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-234">If the directory from which you copied was being watched by another instance of <xref:System.IO.FileSystemWatcher>, no event would be raised.</span></span> <span data-ttu-id="ca1e6-235">例如，您创建 <xref:System.IO.FileSystemWatcher>的两个实例。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-235">For example, you create two instances of <xref:System.IO.FileSystemWatcher>.</span></span> <span data-ttu-id="ca1e6-236">FileSystemWatcher1 设置为监视 "C:\My Documents"，FileSystemWatcher2 设置为观看 "C:\Your Documents"。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-236">FileSystemWatcher1 is set to watch "C:\My Documents", and FileSystemWatcher2 is set to watch "C:\Your Documents".</span></span> <span data-ttu-id="ca1e6-237">如果将 "我的文档" 中的文件复制到 "你的文档"，则 FileSystemWatcher2 将引发 <xref:System.IO.FileSystemWatcher.Created> 事件，但不会为 FileSystemWatcher1 引发事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-237">If you copy a file from "My Documents" into "Your Documents", a <xref:System.IO.FileSystemWatcher.Created> event will be raised by FileSystemWatcher2, but no event is raised for FileSystemWatcher1.</span></span> <span data-ttu-id="ca1e6-238">与复制不同，移动文件或目录将引发两个事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-238">Unlike copying, moving a file or directory would raise two events.</span></span> <span data-ttu-id="ca1e6-239">在上一示例中，如果已将文件从 "我的文档" 移到 "你的文档"，则 FileSystemWatcher2 会引发 <xref:System.IO.FileSystemWatcher.Created> 事件，并且 FileSystemWatcher1 会引发一个 <xref:System.IO.FileSystemWatcher.Deleted> 事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-239">From the previous example, if you moved a file from "My Documents" to "Your Documents", a <xref:System.IO.FileSystemWatcher.Created> event would be raised by FileSystemWatcher2 and a <xref:System.IO.FileSystemWatcher.Deleted> event would be raised by FileSystemWatcher1.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ca1e6-240">常见的文件系统操作可能会引发多个事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-240">Common file system operations might raise more than one event.</span></span> <span data-ttu-id="ca1e6-241">例如，当文件从一个目录移到另一个目录时，可能会引发多个 <xref:System.IO.FileSystemWatcher.OnChanged%2A>，某些 <xref:System.IO.FileSystemWatcher.OnCreated%2A> 和 <xref:System.IO.FileSystemWatcher.OnDeleted%2A> 事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-241">For example, when a file is moved from one directory to another, several <xref:System.IO.FileSystemWatcher.OnChanged%2A> and some <xref:System.IO.FileSystemWatcher.OnCreated%2A> and <xref:System.IO.FileSystemWatcher.OnDeleted%2A> events might be raised.</span></span> <span data-ttu-id="ca1e6-242">移动文件是一项复杂的操作，它包含多个简单操作，因此引发了多个事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-242">Moving a file is a complex operation that consists of multiple simple operations, therefore raising multiple events.</span></span> <span data-ttu-id="ca1e6-243">同样，某些应用程序（例如，防病毒软件）可能会导致 <xref:System.IO.FileSystemWatcher>检测到的其他文件系统事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-243">Likewise, some applications (for example, antivirus software) might cause additional file system events that are detected by <xref:System.IO.FileSystemWatcher>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ca1e6-244"><xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> 属性不 `null`时，引发 <xref:System.IO.FileSystemWatcher.Created> 事件相对于其他 <xref:System.IO.FileSystemWatcher> 事件的顺序可能会更改。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-244">The order in which the <xref:System.IO.FileSystemWatcher.Created> event is raised in relation to the other <xref:System.IO.FileSystemWatcher> events may change when the <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> property is not `null`.</span></span>  
  
 <span data-ttu-id="ca1e6-245">一旦创建文件，就会引发 <xref:System.IO.FileSystemWatcher.OnCreated%2A> 事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-245">The <xref:System.IO.FileSystemWatcher.OnCreated%2A> event is raised as soon as a file is created.</span></span> <span data-ttu-id="ca1e6-246">如果将文件复制或传输到受监视的目录，将立即引发 <xref:System.IO.FileSystemWatcher.OnCreated%2A> 事件，后跟一个或多个 <xref:System.IO.FileSystemWatcher.OnChanged%2A> 事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-246">If a file is being copied or transferred into a watched directory, the <xref:System.IO.FileSystemWatcher.OnCreated%2A> event will be raised immediately, followed by one or more <xref:System.IO.FileSystemWatcher.OnChanged%2A> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ca1e6-247">下面的示例使用 <xref:System.IO.FileSystemWatcher.Created> 事件在每次创建受监视文件时显示控制台的文件路径。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-247">The following example uses the <xref:System.IO.FileSystemWatcher.Created> event to display the file path to the console whenever the watched file is created.</span></span>  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Deleted" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Deleted;" />
      <MemberSignature Language="F#" Value="member this.Deleted : System.IO.FileSystemEventHandler " Usage="member this.Deleted : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory deletion matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Deleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ca1e6-248">删除指定 <see cref="P:System.IO.FileSystemWatcher.Path" /> 中的文件或目录时发生。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-248">Occurs when a file or directory in the specified <see cref="P:System.IO.FileSystemWatcher.Path" /> is deleted.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1e6-249">一些常见的情况（例如，复制或移动文件或目录）不与事件直接对应，但这种情况确实会引发事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-249">Some common occurrences, such as copying or moving a file or directory, do not correspond directly to an event, but these occurrences do cause events to be raised.</span></span> <span data-ttu-id="ca1e6-250">复制文件或目录时，系统将在文件被复制到的目录中引发 <xref:System.IO.FileSystemWatcher.Created> 事件（如果正在监视该目录）。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-250">When you copy a file or directory, the system raises a <xref:System.IO.FileSystemWatcher.Created> event in the directory to which the file was copied, if that directory is being watched.</span></span> <span data-ttu-id="ca1e6-251">如果从中复制的目录正在由 <xref:System.IO.FileSystemWatcher>的另一个实例进行跟踪，则不会引发任何事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-251">If the directory from which you copied was being watched by another instance of <xref:System.IO.FileSystemWatcher>, no event would be raised.</span></span> <span data-ttu-id="ca1e6-252">例如，您创建 <xref:System.IO.FileSystemWatcher>的两个实例。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-252">For example, you create two instances of <xref:System.IO.FileSystemWatcher>.</span></span> <span data-ttu-id="ca1e6-253">FileSystemWatcher1 设置为监视 "C:\My Documents"，FileSystemWatcher2 设置为观看 "C:\Your Documents"。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-253">FileSystemWatcher1 is set to watch "C:\My Documents", and FileSystemWatcher2 is set to watch "C:\Your Documents".</span></span> <span data-ttu-id="ca1e6-254">如果将 "我的文档" 中的文件复制到 "你的文档"，则 FileSystemWatcher2 将引发 <xref:System.IO.FileSystemWatcher.Created> 事件，但不会为 FileSystemWatcher1 引发事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-254">If you copy a file from "My Documents" into "Your Documents", a <xref:System.IO.FileSystemWatcher.Created> event will be raised by FileSystemWatcher2, but no event is raised for FileSystemWatcher1.</span></span> <span data-ttu-id="ca1e6-255">与复制不同，移动文件或目录将引发两个事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-255">Unlike copying, moving a file or directory would raise two events.</span></span> <span data-ttu-id="ca1e6-256">在上一示例中，如果已将文件从 "我的文档" 移到 "你的文档"，则 FileSystemWatcher2 会引发 <xref:System.IO.FileSystemWatcher.Created> 事件，并且 FileSystemWatcher1 会引发一个 <xref:System.IO.FileSystemWatcher.Deleted> 事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-256">From the previous example, if you moved a file from "My Documents" to "Your Documents", a <xref:System.IO.FileSystemWatcher.Created> event would be raised by FileSystemWatcher2 and a <xref:System.IO.FileSystemWatcher.Deleted> event would be raised by FileSystemWatcher1.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ca1e6-257">常见的文件系统操作可能会引发多个事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-257">Common file system operations might raise more than one event.</span></span> <span data-ttu-id="ca1e6-258">例如，当文件从一个目录移到另一个目录时，可能会引发多个 <xref:System.IO.FileSystemWatcher.OnChanged%2A>，某些 <xref:System.IO.FileSystemWatcher.OnCreated%2A> 和 <xref:System.IO.FileSystemWatcher.OnDeleted%2A> 事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-258">For example, when a file is moved from one directory to another, several <xref:System.IO.FileSystemWatcher.OnChanged%2A> and some <xref:System.IO.FileSystemWatcher.OnCreated%2A> and <xref:System.IO.FileSystemWatcher.OnDeleted%2A> events might be raised.</span></span> <span data-ttu-id="ca1e6-259">移动文件是一项复杂的操作，它包含多个简单操作，因此引发了多个事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-259">Moving a file is a complex operation that consists of multiple simple operations, therefore raising multiple events.</span></span> <span data-ttu-id="ca1e6-260">同样，某些应用程序（例如，防病毒软件）可能会导致 <xref:System.IO.FileSystemWatcher>检测到的其他文件系统事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-260">Likewise, some applications (for example, antivirus software) might cause additional file system events that are detected by <xref:System.IO.FileSystemWatcher>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ca1e6-261"><xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> 属性不 `null`时，引发 <xref:System.IO.FileSystemWatcher.Deleted> 事件相对于其他 <xref:System.IO.FileSystemWatcher> 事件的顺序可能会更改。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-261">The order in which the <xref:System.IO.FileSystemWatcher.Deleted> event is raised in relation to the other <xref:System.IO.FileSystemWatcher> events may change when the <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> property is not `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ca1e6-262">下面的示例使用 <xref:System.IO.FileSystemWatcher.Deleted> 事件在每次删除受监视文件时显示控制台的文件路径。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-262">The following example uses the <xref:System.IO.FileSystemWatcher.Deleted> event to display the file path to the console whenever the watched file is deleted.</span></span>  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="fileSystemWatcher.Dispose " FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="override this.Dispose : unit -&gt; unit" Usage="fileSystemWatcher.Dispose " FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ca1e6-263">释放 <see cref="T:System.IO.FileSystemWatcher" /> 使用的非托管资源。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-263">Releases the unmanaged resources used by the <see cref="T:System.IO.FileSystemWatcher" />.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="fileSystemWatcher.Dispose disposing" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileSystemWatcher.Dispose disposing" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="ca1e6-264">如果为 <see langword="true" />，则托管及非托管资源都释放；如果为 <see langword="false" />，则仅释放非托管资源。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-264"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="ca1e6-265">释放 <see cref="T:System.IO.FileSystemWatcher" /> 使用的非托管资源并选择性地释放托管资源。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-265">Releases the unmanaged resources used by the <see cref="T:System.IO.FileSystemWatcher" /> and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1e6-266">此方法由 public <xref:System.ComponentModel.Component.Dispose%2A> 方法和 <xref:System.Object.Finalize%2A> 方法调用。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-266">This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="ca1e6-267"><xref:System.ComponentModel.Component.Dispose%2A> 调用受保护的 <xref:System.IO.FileSystemWatcher.Dispose%2A> 方法，并将 `disposing` 参数设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-267"><xref:System.ComponentModel.Component.Dispose%2A> invokes the protected <xref:System.IO.FileSystemWatcher.Dispose%2A> method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="ca1e6-268"><xref:System.Object.Finalize%2A> 调用 `disposing` 设置为 `false`的 <xref:System.IO.FileSystemWatcher.Dispose%2A>。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-268"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.FileSystemWatcher.Dispose%2A> with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="ca1e6-269">当 `disposing` 参数为 `true` 时，此方法释放该 <xref:System.IO.Compression.DeflateStream> 引用的、由任何托管对象持有的全部资源。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-269">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.IO.Compression.DeflateStream> references.</span></span> <span data-ttu-id="ca1e6-270">此方法将调用每个被引用对象的 <xref:System.ComponentModel.Component.Dispose%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-270">This method invokes the <xref:System.ComponentModel.Component.Dispose%2A> method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="ca1e6-271">
            <see cref="M:System.ComponentModel.Component.Dispose" /> 可以由其他对象多次调用。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-271">
            <see cref="M:System.ComponentModel.Component.Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="ca1e6-272"><see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" /> 重写时，请注意不要引用先前在调用 <see cref="M:System.ComponentModel.Component.Dispose" />之前已释放的对象。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-272">When overriding <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" /> be careful not to reference objects that have been previously disposed of in an earlier call to <see cref="M:System.ComponentModel.Component.Dispose" />.</span></span> <span data-ttu-id="ca1e6-273">有关如何实现 <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />的详细信息，请参阅[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-273">For more information about how to implement <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
<span data-ttu-id="ca1e6-274">有关 <see cref="M:System.ComponentModel.Component.Dispose" /> 和 <see cref="M:System.Object.Finalize" />的详细信息，请参阅[清理非托管资源](~/docs/standard/garbage-collection/unmanaged.md)。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-274">For more information about <see cref="M:System.ComponentModel.Component.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate if this instance is active")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Enabled")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ca1e6-275">获取或设置一个值，该值指示是否启用此组件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-275">Gets or sets a value indicating whether the component is enabled.</span></span></summary>
        <value><span data-ttu-id="ca1e6-276">如果启用此组件，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-276"><see langword="true" /> if the component is enabled; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="ca1e6-277">默认为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-277">The default is <see langword="false" />.</span></span> <span data-ttu-id="ca1e6-278">如果在 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] 的设计器上使用该组件，则默认值为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-278">If you are using the component on a designer in [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)], the default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1e6-279">除非将 <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> 设置为 `true`，否则组件不会引发事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-279">The component will not raise events unless you set <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> to `true`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ca1e6-280">除非已设置 <xref:System.IO.FileSystemWatcher.Path%2A> 属性并且 <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> `true`，组件才会监视指定的目录。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-280">The component will not watch the specified directory until the <xref:System.IO.FileSystemWatcher.Path%2A> property has been set and <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> is `true`.</span></span>  
  
 <span data-ttu-id="ca1e6-281"><xref:System.IO.FileSystemWatcher.WaitForChanged%2A> 方法允许调用事件处理程序以响应文件更改，即使此属性设置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-281">The <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> method allows event handlers to be invoked to respond to file changes even if this property is set to `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ca1e6-282">下面的示例创建一个 <xref:System.IO.FileSystemWatcher> 以监视运行时指定的目录。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-282">The following example creates a <xref:System.IO.FileSystemWatcher> to watch the directory specified at run time.</span></span> <span data-ttu-id="ca1e6-283">组件设置为监视 `LastWrite` 和 `LastAccess` 时间的更改、创建、删除或重命名目录中的文本文件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-283">The component is set to watch for changes in `LastWrite` and `LastAccess` time, the creation, deletion, or renaming of text files in the directory.</span></span> <span data-ttu-id="ca1e6-284">如果更改、创建或删除了某个文件，则该文件的路径将打印到控制台。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-284">If a file is changed, created, or deleted, the path to the file prints to the console.</span></span> <span data-ttu-id="ca1e6-285">重命名文件后，旧路径和新路径将打印到控制台。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-285">When a file is renamed, the old and new paths print to the console.</span></span>  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ca1e6-286"><see cref="T:System.IO.FileSystemWatcher" /> 对象已释放。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-286">The <see cref="T:System.IO.FileSystemWatcher" /> object has been disposed.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="ca1e6-287">当前操作系统不是 Microsoft Windows NT 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-287">The current operating system is not Microsoft Windows NT or later.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ca1e6-288">未能找到 <see cref="P:System.IO.FileSystemWatcher.Path" /> 中指定的目录。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-288">The directory specified in <see cref="P:System.IO.FileSystemWatcher.Path" /> could not be found.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ca1e6-289"><see cref="P:System.IO.FileSystemWatcher.Path" /> 尚未设置或无效。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-289"><see cref="P:System.IO.FileSystemWatcher.Path" /> has not been set or is invalid.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="fileSystemWatcher.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ca1e6-290">结束在窗体上使用或由另一个组件使用的 <see cref="T:System.IO.FileSystemWatcher" /> 的初始化。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-290">Ends the initialization of a <see cref="T:System.IO.FileSystemWatcher" /> used on a form or used by another component.</span></span> <span data-ttu-id="ca1e6-291">初始化发生在运行时。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-291">The initialization occurs at run time.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1e6-292">[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] 设计环境使用此方法来结束在窗体上使用或由另一个组件使用的组件的初始化。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-292">The [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] design environment uses this method to end the initialization of a component used on a form or used by another component.</span></span> <span data-ttu-id="ca1e6-293"><xref:System.IO.FileSystemWatcher.BeginInit%2A> 方法开始初始化。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-293">The <xref:System.IO.FileSystemWatcher.BeginInit%2A> method starts the initialization.</span></span> <span data-ttu-id="ca1e6-294">使用 <xref:System.IO.FileSystemWatcher.BeginInit%2A> 和 <xref:System.IO.FileSystemWatcher.EndInit%2A> 方法可防止控件在完全初始化之前被使用。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-294">Using the <xref:System.IO.FileSystemWatcher.BeginInit%2A> and <xref:System.IO.FileSystemWatcher.EndInit%2A> methods prevents the control from being used before it is fully initialized.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public event System.IO.ErrorEventHandler Error;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.ErrorEventHandler Error" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Error" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Error As ErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::ErrorEventHandler ^ Error;" />
      <MemberSignature Language="F#" Value="member this.Error : System.IO.ErrorEventHandler " Usage="member this.Error : System.IO.ErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.ErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ca1e6-295">当 <see cref="T:System.IO.FileSystemWatcher" /> 的实例无法继续监视更改或内部缓冲区溢出时发生。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-295">Occurs when the instance of <see cref="T:System.IO.FileSystemWatcher" /> is unable to continue monitoring changes or when the internal buffer overflows.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1e6-296">当某个事件阻止 <xref:System.IO.FileSystemWatcher> 对象监视更改时，将引发此事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-296">This event is raised whenever something prevents the <xref:System.IO.FileSystemWatcher> object from monitoring changes.</span></span> <span data-ttu-id="ca1e6-297">例如，如果对象正在监视远程目录中的更改，并且与该目录的连接丢失，则会引发 <xref:System.IO.FileSystemWatcher.Error> 事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-297">For example, if the object is monitoring changes in a remote directory and the connection to that directory is lost, the <xref:System.IO.FileSystemWatcher.Error> event is raised.</span></span>  
  
 <span data-ttu-id="ca1e6-298">系统通知您文件发生了更改，并将这些更改存储在组件创建并传递给 Api 的缓冲区中。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-298">The system notifies you of file changes, and it stores those changes in a buffer that the component creates and passes to the APIs.</span></span> <span data-ttu-id="ca1e6-299">如果短时间内有很多更改，则缓冲区可能溢出。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-299">If there are many changes in a short time, the buffer can overflow.</span></span> <span data-ttu-id="ca1e6-300">这会使组件失去对目录中的更改的跟踪，并且它将只提供覆盖通知。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-300">This causes the component to lose track of changes in the directory, and it will only provide blanket notification.</span></span> <span data-ttu-id="ca1e6-301">增加缓冲区的大小会消耗大量资源，因为它来自无法换出到磁盘的非分页内存，因此使缓冲区尽可能小。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-301">Increasing the size of the buffer is expensive, because it comes from non paged memory that cannot be swapped out to disk, so keep the buffer as small as possible.</span></span> <span data-ttu-id="ca1e6-302">若要避免缓冲区溢出，请使用 <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>、<xref:System.IO.FileSystemWatcher.Filter%2A>和 <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> 属性筛选出不需要的更改通知。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-302">To avoid a buffer overflow, use the <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.Filter%2A>, and <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> properties to filter out unwanted change notifications.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ca1e6-303">常见的文件系统操作可能会引发多个事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-303">Common file system operations might raise more than one event.</span></span> <span data-ttu-id="ca1e6-304">例如，当文件从一个目录移到另一个目录时，可能会引发多个 <xref:System.IO.FileSystemWatcher.OnChanged%2A>，某些 <xref:System.IO.FileSystemWatcher.OnCreated%2A> 和 <xref:System.IO.FileSystemWatcher.OnDeleted%2A> 事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-304">For example, when a file is moved from one directory to another, several <xref:System.IO.FileSystemWatcher.OnChanged%2A> and some <xref:System.IO.FileSystemWatcher.OnCreated%2A> and <xref:System.IO.FileSystemWatcher.OnDeleted%2A> events might be raised.</span></span> <span data-ttu-id="ca1e6-305">移动文件是一项复杂的操作，它包含多个简单操作，因此引发了多个事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-305">Moving a file is a complex operation that consists of multiple simple operations, therefore raising multiple events.</span></span> <span data-ttu-id="ca1e6-306">同样，某些应用程序（例如，防病毒软件）可能会导致 <xref:System.IO.FileSystemWatcher>检测到的其他文件系统事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-306">Likewise, some applications (for example, antivirus software) might cause additional file system events that are detected by <xref:System.IO.FileSystemWatcher>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : string with get, set" Usage="System.IO.FileSystemWatcher.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("*.*")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("File name filter pattern")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ca1e6-307">获取或设置用于确定在目录中监视哪些文件的筛选器字符串。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-307">Gets or sets the filter string used to determine what files are monitored in a directory.</span></span></summary>
        <value><span data-ttu-id="ca1e6-308">筛选器字符串。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-308">The filter string.</span></span> <span data-ttu-id="ca1e6-309">默认值为 "\*"。\*"（监视所有文件。）</span><span class="sxs-lookup"><span data-stu-id="ca1e6-309">The default is "\*.\*" (Watches all files.)</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1e6-310">若要查看所有文件中的更改，请将 <xref:System.IO.FileSystemWatcher.Filter%2A> 属性设置为空字符串（""）。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-310">To watch changes in all files, set the <xref:System.IO.FileSystemWatcher.Filter%2A> property to an empty string ("").</span></span> <span data-ttu-id="ca1e6-311">若要查看特定文件，请将 <xref:System.IO.FileSystemWatcher.Filter%2A> 属性设置为文件名。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-311">To watch a specific file, set the <xref:System.IO.FileSystemWatcher.Filter%2A> property to the file name.</span></span> <span data-ttu-id="ca1e6-312">例如，若要监视文件 MyDoc 中的更改，请将 <xref:System.IO.FileSystemWatcher.Filter%2A> 属性设置为 "MyDoc"。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-312">For example, to watch for changes in the file MyDoc.txt, set the <xref:System.IO.FileSystemWatcher.Filter%2A> property to "MyDoc.txt".</span></span> <span data-ttu-id="ca1e6-313">还可以监视特定类型的文件中的更改。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-313">You can also watch for changes in a certain type of file.</span></span> <span data-ttu-id="ca1e6-314">例如，若要监视任何文本文件中的更改，请将 <xref:System.IO.FileSystemWatcher.Filter%2A> 属性设置为 "\* .txt"。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-314">For example, to watch for changes in any text files, set the <xref:System.IO.FileSystemWatcher.Filter%2A> property to "\*.txt".</span></span> <span data-ttu-id="ca1e6-315">不支持使用多个筛选器，例如 "&#124;\*\*.doc"。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-315">Use of multiple filters such as "\*.txt&#124;\*.doc" is not supported.</span></span>  
  
 <span data-ttu-id="ca1e6-316"><xref:System.IO.FileSystemWatcher.Filter%2A> 属性可以在 <xref:System.IO.FileSystemWatcher> 对象开始接收事件之后更改。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-316">The <xref:System.IO.FileSystemWatcher.Filter%2A> property can be changed after the <xref:System.IO.FileSystemWatcher> object has started receiving events.</span></span>  
  
 <span data-ttu-id="ca1e6-317">有关筛选出不需要的通知的详细信息，请参阅 <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>、<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>和 <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-317">For more information about filtering out unwanted notifications, see the <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, and <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> properties.</span></span>  
  
 <span data-ttu-id="ca1e6-318"><xref:System.IO.FileSystemWatcher.Filter%2A> 接受通配符以匹配文件，如下面的示例中所示。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-318"><xref:System.IO.FileSystemWatcher.Filter%2A> accepts wildcards for matching files, as shown in the following examples.</span></span>  
  
|<span data-ttu-id="ca1e6-319">筛选器字符串</span><span class="sxs-lookup"><span data-stu-id="ca1e6-319">Filter string</span></span>|<span data-ttu-id="ca1e6-320">监视以下文件</span><span class="sxs-lookup"><span data-stu-id="ca1e6-320">Watches the following files</span></span>|  
|-------------------|---------------------------------|  
|<span data-ttu-id="ca1e6-321">\*.\*</span><span class="sxs-lookup"><span data-stu-id="ca1e6-321">\*.\*</span></span>|<span data-ttu-id="ca1e6-322">所有文件（默认值）。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-322">All files (default).</span></span> <span data-ttu-id="ca1e6-323">空字符串（""）还会监视所有文件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-323">An empty string ("") also watches all files.</span></span>|  
|<span data-ttu-id="ca1e6-324">\*.txt</span><span class="sxs-lookup"><span data-stu-id="ca1e6-324">\*.txt</span></span>|<span data-ttu-id="ca1e6-325">扩展名为 "txt" 的所有文件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-325">All files with a "txt" extension.</span></span>|  
|<span data-ttu-id="ca1e6-326">\*recipe.doc</span><span class="sxs-lookup"><span data-stu-id="ca1e6-326">\*recipe.doc</span></span>|<span data-ttu-id="ca1e6-327">所有以 "食谱" 结尾且扩展名为 "doc" 的文件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-327">All files ending in "recipe" with a "doc" extension.</span></span>|  
|<span data-ttu-id="ca1e6-328">win\*.xml</span><span class="sxs-lookup"><span data-stu-id="ca1e6-328">win\*.xml</span></span>|<span data-ttu-id="ca1e6-329">所有以 "win" 开头且扩展名为 "xml" 的文件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-329">All files beginning with "win" with an "xml" extension.</span></span>|  
|<span data-ttu-id="ca1e6-330">销售额 \* 200？。xls</span><span class="sxs-lookup"><span data-stu-id="ca1e6-330">Sales\*200?.xls</span></span>|<span data-ttu-id="ca1e6-331">匹配以下内容：</span><span class="sxs-lookup"><span data-stu-id="ca1e6-331">Matches the following:</span></span><br /><br /><span data-ttu-id="ca1e6-332">-2001 年7月，.xls</span><span class="sxs-lookup"><span data-stu-id="ca1e6-332">- Sales July 2001.xls</span></span> <br/><span data-ttu-id="ca1e6-333">-2002 年8月，.xls</span><span class="sxs-lookup"><span data-stu-id="ca1e6-333">- Sales Aug 2002.xls</span></span> <br/><span data-ttu-id="ca1e6-334">-2004 年3月，.xls</span><span class="sxs-lookup"><span data-stu-id="ca1e6-334">- Sales March 2004.xls</span></span><br /><br /> <span data-ttu-id="ca1e6-335">但不匹配：</span><span class="sxs-lookup"><span data-stu-id="ca1e6-335">but does not match:</span></span><br /><br /><span data-ttu-id="ca1e6-336">-1999 年11月的销售</span><span class="sxs-lookup"><span data-stu-id="ca1e6-336">- Sales Nov 1999.xls</span></span>|  
|<span data-ttu-id="ca1e6-337">MyReport.Doc</span><span class="sxs-lookup"><span data-stu-id="ca1e6-337">MyReport.Doc</span></span>|<span data-ttu-id="ca1e6-338">仅监视 MyReport</span><span class="sxs-lookup"><span data-stu-id="ca1e6-338">Watches only MyReport.doc</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="ca1e6-339">下面的示例创建一个 <xref:System.IO.FileSystemWatcher> 以监视运行时指定的目录。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-339">The following example creates a <xref:System.IO.FileSystemWatcher> to watch the directory specified at run time.</span></span> <span data-ttu-id="ca1e6-340">组件设置为监视 `LastWrite` 和 `LastAccess` 时间的更改、创建、删除或重命名目录中的文本文件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-340">The component is set to watch for changes in `LastWrite` and `LastAccess` time, the creation, deletion, or renaming of text files in the directory.</span></span> <span data-ttu-id="ca1e6-341">如果更改、创建或删除了某个文件，则该文件的路径将打印到控制台。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-341">If a file is changed, created, or deleted, the path to the file prints to the console.</span></span> <span data-ttu-id="ca1e6-342">重命名文件后，旧路径和新路径将打印到控制台。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-342">When a file is renamed, the old and new paths print to the console.</span></span>  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="Filters">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;string&gt; Filters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;string&gt; Filters" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Filters As Collection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ Filters { System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Filters : System.Collections.ObjectModel.Collection&lt;string&gt;" Usage="System.IO.FileSystemWatcher.Filters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ca1e6-343">获取用于确定在目录中监视哪些文件的所有筛选器的集合。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-343">Gets the collection of all the filters used to determine what files are monitored in a directory.</span></span></summary>
        <value><span data-ttu-id="ca1e6-344">筛选器集合。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-344">A filter collection.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileSystemWatcher ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileSystemWatcher.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ca1e6-345">释放由当前实例所持有的资源。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-345">Releases the resources held by the current instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
> <span data-ttu-id="ca1e6-346">应用程序代码不会调用此方法;它在垃圾回收期间自动调用，除非已禁用垃圾回收器的终止。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-346">Application code does not call this method; it is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled.</span></span> <span data-ttu-id="ca1e6-347">有关详细信息，请参阅 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 和 <xref:System.Object.Finalize>。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-347">For more information, see <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> and <xref:System.Object.Finalize>.</span></span> <span data-ttu-id="ca1e6-348">此方法重写 <xref:System.Object.Finalize>。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-348">This method overrides <xref:System.Object.Finalize>.</span></span>

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeSubdirectories">
      <MemberSignature Language="C#" Value="public bool IncludeSubdirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeSubdirectories" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeSubdirectories As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeSubdirectories { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeSubdirectories : bool with get, set" Usage="System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate we want to watch subdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_IncludeSubdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ca1e6-349">获取或设置一个值，该值指示是否应监视指定路径中的子目录。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-349">Gets or sets a value indicating whether subdirectories within the specified path should be monitored.</span></span></summary>
        <value><span data-ttu-id="ca1e6-350">如果要监视子目录，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-350"><see langword="true" /> if you want to monitor subdirectories; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="ca1e6-351">默认为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-351">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1e6-352">如果要监视包含在通过 <xref:System.IO.FileSystemWatcher.Path%2A> 属性指定的目录中的文件和目录的更改通知及其子目录，请将 <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> 设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-352">Set <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> to `true` when you want to watch for change notifications for files and directories contained within the directory specified through the <xref:System.IO.FileSystemWatcher.Path%2A> property, and its subdirectories.</span></span> <span data-ttu-id="ca1e6-353">将 <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> 属性设置为 `false` 有助于减少发送到内部缓冲区的通知数。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-353">Setting the <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> property to `false` helps reduce the number of notifications sent to the internal buffer.</span></span> <span data-ttu-id="ca1e6-354">有关筛选出不需要的通知的详细信息，请参阅 "<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>" 和 "<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>" 属性。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-354">For more information on filtering out unwanted notifications, see the <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> and <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> properties.</span></span>  
  
 <span data-ttu-id="ca1e6-355">`true`时，<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> 通过整个子树递归，而不只是直接子目录。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-355">When `true`, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> is recursive through the entire sub tree, not just the immediate child directories.</span></span> <span data-ttu-id="ca1e6-356">子树内的文件或目录的相对路径在 <xref:System.IO.FileSystemEventArgs> 的 <xref:System.IO.FileSystemEventArgs.Name%2A> 属性和 <xref:System.IO.RenamedEventArgs>的 <xref:System.IO.RenamedEventArgs.OldName%2A> 属性中返回，具体取决于所监视的更改。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-356">The relative path to a file or directory within the sub tree returns in the <xref:System.IO.FileSystemEventArgs.Name%2A> property of <xref:System.IO.FileSystemEventArgs> and the <xref:System.IO.RenamedEventArgs.OldName%2A> property of <xref:System.IO.RenamedEventArgs>, depending on changes you are watching for.</span></span> <span data-ttu-id="ca1e6-357">可以从 <xref:System.IO.FileSystemEventArgs> 的 <xref:System.IO.FileSystemEventArgs.FullPath%2A> 属性和 <xref:System.IO.RenamedEventArgs>的 <xref:System.IO.RenamedEventArgs.OldFullPath%2A> 属性获取完全限定路径，具体取决于所监视的更改。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-357">You can get the fully qualified path from the <xref:System.IO.FileSystemEventArgs.FullPath%2A> property of <xref:System.IO.FileSystemEventArgs> and the <xref:System.IO.RenamedEventArgs.OldFullPath%2A> property of <xref:System.IO.RenamedEventArgs>, depending on the changes you are watching for.</span></span>  
  
 <span data-ttu-id="ca1e6-358">如果在所监视目录的子树中创建了一个目录，并且 <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> `true`，则将自动监视该目录。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-358">If a directory is created in the sub tree of the directory you are watching, and <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> is `true`, that directory will automatically be watched.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemEventArgs.FullPath" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldFullPath" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
        <altmember cref="P:System.IO.FileSystemEventArgs.Name" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldName" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="InternalBufferSize">
      <MemberSignature Language="C#" Value="public int InternalBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InternalBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property InternalBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int InternalBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.InternalBufferSize : int with get, set" Usage="System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(8192)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ca1e6-359">获取或设置内部缓冲区的大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-359">Gets or sets the size (in bytes) of the internal buffer.</span></span></summary>
        <value><span data-ttu-id="ca1e6-360">内部缓冲区的大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-360">The internal buffer size in bytes.</span></span> <span data-ttu-id="ca1e6-361">默认值为 8192 (8 KB)。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-361">The default is 8192 (8 KB).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1e6-362">可以将缓冲区设置为 4 KB 或更大，但不能超过 64 KB。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-362">You can set the buffer to 4 KB or larger, but it must not exceed 64 KB.</span></span> <span data-ttu-id="ca1e6-363">如果尝试将 <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> 属性设置为小于4096个字节，则将放弃值并将 <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> 属性设置为4096个字节。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-363">If you try to set the <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> property to less than 4096 bytes, your value is discarded and the <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> property is set to 4096 bytes.</span></span> <span data-ttu-id="ca1e6-364">为了获得最佳性能，请在基于 Intel 的计算机上使用 4 KB 的倍数。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-364">For best performance, use a multiple of 4 KB on Intel-based computers.</span></span>  
  
 <span data-ttu-id="ca1e6-365">系统通知组件发生文件更改，并将这些更改存储在组件创建并传递给 Api 的缓冲区中。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-365">The system notifies the component of file changes, and it stores those changes in a buffer the component creates and passes to the APIs.</span></span> <span data-ttu-id="ca1e6-366">每个事件最多可以使用16个字节的内存，不包括文件名。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-366">Each event can use up to 16 bytes of memory, not including the file name.</span></span> <span data-ttu-id="ca1e6-367">如果短时间内有很多更改，则缓冲区可能溢出。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-367">If there are many changes in a short time, the buffer can overflow.</span></span> <span data-ttu-id="ca1e6-368">这会使组件失去对目录中的更改的跟踪，并且它将只提供覆盖通知。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-368">This causes the component to lose track of changes in the directory, and it will only provide blanket notification.</span></span> <span data-ttu-id="ca1e6-369">增加缓冲区的大小可防止丢失文件系统更改事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-369">Increasing the size of the buffer can prevent missing file system change events.</span></span> <span data-ttu-id="ca1e6-370">不过，增加缓冲区大小会消耗大量资源，因为它来自无法换出到磁盘的非分页内存，因此尽量使缓冲区尽可能小。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-370">However, increasing buffer size is expensive, because it comes from non-paged memory that cannot be swapped out to disk, so keep the buffer as small as possible.</span></span> <span data-ttu-id="ca1e6-371">若要避免缓冲区溢出，请使用 <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> 和 <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> 属性筛选出不需要的更改通知。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-371">To avoid a buffer overflow, use the <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> and <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> properties to filter out unwanted change notifications.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="NotifyFilter">
      <MemberSignature Language="C#" Value="public System.IO.NotifyFilters NotifyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.NotifyFilters NotifyFilter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyFilter As NotifyFilters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::NotifyFilters NotifyFilter { System::IO::NotifyFilters get(); void set(System::IO::NotifyFilters value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyFilter : System.IO.NotifyFilters with get, set" Usage="System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate which change event we want to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_ChangedFilter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.NotifyFilters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ca1e6-372">获取或设置要监视的更改的类型。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-372">Gets or sets the type of changes to watch for.</span></span></summary>
        <value><span data-ttu-id="ca1e6-373"><see cref="T:System.IO.NotifyFilters" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-373">One of the <see cref="T:System.IO.NotifyFilters" /> values.</span></span> <span data-ttu-id="ca1e6-374">默认值为 <see langword="LastWrite" />、<see langword="FileName" /> 和 <see langword="DirectoryName" /> 的按位“或”组合。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-374">The default is the bitwise OR combination of <see langword="LastWrite" />, <see langword="FileName" />, and <see langword="DirectoryName" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1e6-375">可以组合 <xref:System.IO.NotifyFilters> 枚举的成员来监视一次有多种类型的更改。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-375">You can combine the members of the <xref:System.IO.NotifyFilters> enumeration to watch for more than one type of change at a time.</span></span> <span data-ttu-id="ca1e6-376">例如，你可以监视文件大小的更改以及 `LastWrite` 时间中的更改。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-376">For example, you can watch for changes in size of a file, and for changes in the `LastWrite` time.</span></span> <span data-ttu-id="ca1e6-377">这会在文件或文件夹大小发生更改时引发事件，或在文件或文件夹的 `LastWrite` 时间发生更改时引发事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-377">This raises an event anytime there is a change in file or folder size, or a change in the `LastWrite` time of the file or folder.</span></span>  
  
 <span data-ttu-id="ca1e6-378">这是一种筛选掉不需要的通知的方法。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-378">This is one way to filter out unwanted notifications.</span></span> <span data-ttu-id="ca1e6-379">有关筛选出不需要的通知的详细信息，请参阅 <xref:System.IO.FileSystemWatcher.Filter%2A>、<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>和 <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-379">For more information on filtering out unwanted notifications, see the <xref:System.IO.FileSystemWatcher.Filter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, and <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> properties.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ca1e6-380">下面的示例创建一个 <xref:System.IO.FileSystemWatcher> 以监视运行时指定的目录。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-380">The following example creates a <xref:System.IO.FileSystemWatcher> to watch the directory specified at run time.</span></span> <span data-ttu-id="ca1e6-381">组件设置为监视 `LastWrite` 和 `LastAccess` 时间的更改、创建、删除或重命名目录中的文本文件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-381">The component is set to watch for changes in `LastWrite` and `LastAccess` time, the creation, deletion, or renaming of text files in the directory.</span></span> <span data-ttu-id="ca1e6-382">如果更改、创建或删除了某个文件，则该文件的路径将打印到控制台。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-382">If a file is changed, created, or deleted, the path to the file prints to the console.</span></span> <span data-ttu-id="ca1e6-383">重命名文件后，旧路径和新路径将打印到控制台。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-383">When a file is renamed, the old and new paths print to the console.</span></span>  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ca1e6-384">该值不是 <see cref="T:System.IO.NotifyFilters" /> 值的有效按位“或”组合。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-384">The value is not a valid bitwise OR combination of the <see cref="T:System.IO.NotifyFilters" /> values.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="ca1e6-385">正在设置的值无效。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-385">The value that is being set is not valid.</span></span></exception>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="ca1e6-386">一个包含事件数据的 <see cref="T:System.IO.FileSystemEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-386">A <see cref="T:System.IO.FileSystemEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="ca1e6-387">引发 <see cref="E:System.IO.FileSystemWatcher.Changed" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-387">Raises the <see cref="E:System.IO.FileSystemWatcher.Changed" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1e6-388">当对受监视目录中的文件或目录的大小、系统属性、上次写入时间、上次访问时间或安全权限进行更改时，将调用 <xref:System.IO.FileSystemWatcher.OnChanged%2A>。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-388"><xref:System.IO.FileSystemWatcher.OnChanged%2A> is called when changes are made to the size, system attributes, last write time, last access time, or security permissions of a file or directory in the directory being monitored.</span></span>  
  
 <span data-ttu-id="ca1e6-389">使用 <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> 属性可限制处理 <xref:System.IO.FileSystemWatcher.Changed> 事件时引发的事件数。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-389">Use the <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> property to restrict the number of events raised when the <xref:System.IO.FileSystemWatcher.Changed> event is handled.</span></span>  
  
 <span data-ttu-id="ca1e6-390">一旦创建文件，就会引发 <xref:System.IO.FileSystemWatcher.OnCreated%2A> 事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-390">The <xref:System.IO.FileSystemWatcher.OnCreated%2A> event is raised as soon as a file is created.</span></span> <span data-ttu-id="ca1e6-391">如果将文件复制或传输到受监视的目录，将立即引发 <xref:System.IO.FileSystemWatcher.OnCreated%2A> 事件，后跟一个或多个 <xref:System.IO.FileSystemWatcher.OnChanged%2A> 事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-391">If a file is being copied or transferred into a watched directory, the <xref:System.IO.FileSystemWatcher.OnCreated%2A> event will be raised immediately, followed by one or more <xref:System.IO.FileSystemWatcher.OnChanged%2A> events.</span></span>  
  
 <span data-ttu-id="ca1e6-392">引发事件时，将通过委托调用事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-392">Raising an event invokes the event handler through a delegate.</span></span> <span data-ttu-id="ca1e6-393">有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-393">For more information, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="ca1e6-394">当在派生类中重写 <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> 时，请确保调用基类的 <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-394">When overriding <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> in a derived class, be sure to call the base class's <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> method.</span></span></para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Changed" />
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnCreated">
      <MemberSignature Language="C#" Value="protected void OnCreated (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCreated(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCreated (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCreated(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnCreated : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="ca1e6-395">一个包含事件数据的 <see cref="T:System.IO.FileSystemEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-395">A <see cref="T:System.IO.FileSystemEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="ca1e6-396">引发 <see cref="E:System.IO.FileSystemWatcher.Created" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-396">Raises the <see cref="E:System.IO.FileSystemWatcher.Created" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1e6-397">当在受监视的目录中创建文件或目录时，将调用 <xref:System.IO.FileSystemWatcher.OnCreated%2A>。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-397"><xref:System.IO.FileSystemWatcher.OnCreated%2A> is called when a file or directory is created in the directory being monitored.</span></span>  
  
 <span data-ttu-id="ca1e6-398">一些常见的情况（例如，复制或移动文件或目录）不与事件直接对应，但这种情况确实会引发事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-398">Some common occurrences, such as copying or moving a file or directory, do not correspond directly to an event, but these occurrences do cause events to be raised.</span></span> <span data-ttu-id="ca1e6-399">复制文件或目录时，系统将在文件被复制到的目录中引发 <xref:System.IO.FileSystemWatcher.Created> 事件（如果正在监视该目录）。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-399">When you copy a file or directory, the system raises a <xref:System.IO.FileSystemWatcher.Created> event in the directory to which the file was copied, if that directory is being watched.</span></span> <span data-ttu-id="ca1e6-400">如果从中复制的目录正在由 <xref:System.IO.FileSystemWatcher>的另一个实例进行跟踪，则不会引发任何事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-400">If the directory from which you copied was being watched by another instance of <xref:System.IO.FileSystemWatcher>, no event would be raised.</span></span> <span data-ttu-id="ca1e6-401">例如，您创建 <xref:System.IO.FileSystemWatcher>的两个实例。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-401">For example, you create two instances of <xref:System.IO.FileSystemWatcher>.</span></span> <span data-ttu-id="ca1e6-402">FileSystemWatcher1 设置为监视 "C:\My Documents"，FileSystemWatcher2 设置为观看 "C:\Your Documents"。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-402">FileSystemWatcher1 is set to watch "C:\My Documents", and FileSystemWatcher2 is set to watch "C:\Your Documents".</span></span> <span data-ttu-id="ca1e6-403">如果从 "我的文档" 复制文件并将其粘贴到 "文档" 中，将在 FileSystemWatcher2 中引发 <xref:System.IO.FileSystemWatcher.Created> 事件，但不会为 FileSystemWatcher1 引发事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-403">If you copy a file from "My Documents" and paste it into "Your Documents", a <xref:System.IO.FileSystemWatcher.Created> event will be raised in FileSystemWatcher2, but no event is raised for FileSystemWatcher1.</span></span> <span data-ttu-id="ca1e6-404">与复制不同，移动文件或目录将引发两个事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-404">Unlike copying, moving a file or directory raises two events.</span></span> <span data-ttu-id="ca1e6-405">在上一示例中，如果已将文件从 "我的文档" 移动到 "文档"，将在 FileSystemWatcher2 中引发 <xref:System.IO.FileSystemWatcher.Created> 事件，并在 FileSystemWatcher1 中引发 <xref:System.IO.FileSystemWatcher.Deleted> 事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-405">From the previous example, if you moved a file from "My Documents" to "Your Documents", a <xref:System.IO.FileSystemWatcher.Created> event would be raised in FileSystemWatcher2 and a <xref:System.IO.FileSystemWatcher.Deleted> event would be raised in FileSystemWatcher1.</span></span>  
  
 <span data-ttu-id="ca1e6-406">一旦创建文件，就会引发 <xref:System.IO.FileSystemWatcher.OnCreated%2A> 事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-406">The <xref:System.IO.FileSystemWatcher.OnCreated%2A> event is raised as soon as a file is created.</span></span> <span data-ttu-id="ca1e6-407">如果将文件复制或传输到受监视的目录，将立即引发 <xref:System.IO.FileSystemWatcher.OnCreated%2A> 事件，后跟一个或多个 <xref:System.IO.FileSystemWatcher.OnChanged%2A> 事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-407">If a file is being copied or transferred into a watched directory, the <xref:System.IO.FileSystemWatcher.OnCreated%2A> event will be raised immediately, followed by one or more <xref:System.IO.FileSystemWatcher.OnChanged%2A> events.</span></span>  
  
 <span data-ttu-id="ca1e6-408">引发事件时，将通过委托调用事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-408">Raising an event invokes the event handler through a delegate.</span></span> <span data-ttu-id="ca1e6-409">有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-409">For more information, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="ca1e6-410">当在派生类中重写 <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> 时，请确保调用基类的 <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-410">When overriding <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> in a derived class, be sure to call the base class's <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> method.</span></span></para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnDeleted">
      <MemberSignature Language="C#" Value="protected void OnDeleted (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnDeleted(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnDeleted (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnDeleted(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnDeleted : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="ca1e6-411">一个包含事件数据的 <see cref="T:System.IO.FileSystemEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-411">A <see cref="T:System.IO.FileSystemEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="ca1e6-412">引发 <see cref="E:System.IO.FileSystemWatcher.Deleted" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-412">Raises the <see cref="E:System.IO.FileSystemWatcher.Deleted" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1e6-413">在被监视的目录中删除文件或目录时，将调用 <xref:System.IO.FileSystemWatcher.OnDeleted%2A>。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-413"><xref:System.IO.FileSystemWatcher.OnDeleted%2A> is called when a file or directory, within the directory being monitored, is deleted.</span></span>  
  
 <span data-ttu-id="ca1e6-414">一些常见的情况（例如，复制或移动文件或目录）不与事件直接对应，但这种情况确实会引发事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-414">Some common occurrences, such as copying or moving a file or directory, do not correspond directly to an event, but these occurrences do cause events to be raised.</span></span> <span data-ttu-id="ca1e6-415">复制文件或目录时，系统将在文件被复制到的目录中引发 <xref:System.IO.FileSystemWatcher.Created> 事件（如果正在监视该目录）。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-415">When you copy a file or directory, the system raises a <xref:System.IO.FileSystemWatcher.Created> event in the directory to which the file was copied, if that directory is being watched.</span></span> <span data-ttu-id="ca1e6-416">如果从中复制的目录正在由 <xref:System.IO.FileSystemWatcher>的另一个实例进行跟踪，则不会引发任何事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-416">If the directory from which you copied was being watched by another instance of <xref:System.IO.FileSystemWatcher>, no event would be raised.</span></span> <span data-ttu-id="ca1e6-417">例如，您创建 <xref:System.IO.FileSystemWatcher>的两个实例。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-417">For example, you create two instances of <xref:System.IO.FileSystemWatcher>.</span></span> <span data-ttu-id="ca1e6-418">FileSystemWatcher1 设置为监视 "C:\My Documents"，FileSystemWatcher2 设置为观看 "C:\Your Documents"。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-418">FileSystemWatcher1 is set to watch "C:\My Documents", and FileSystemWatcher2 is set to watch "C:\Your Documents".</span></span> <span data-ttu-id="ca1e6-419">如果将 "我的文档" 中的文件复制到 "你的文档"，则 FileSystemWatcher2 将引发 <xref:System.IO.FileSystemWatcher.Created> 事件，但不会为 FileSystemWatcher1 引发事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-419">If you copy a file from "My Documents" into "Your Documents", a <xref:System.IO.FileSystemWatcher.Created> event will be raised by FileSystemWatcher2, but no event is raised for FileSystemWatcher1.</span></span> <span data-ttu-id="ca1e6-420">与复制不同，移动文件或目录将引发两个事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-420">Unlike copying, moving a file or directory raises two events.</span></span> <span data-ttu-id="ca1e6-421">在上一示例中，如果已将文件从 "我的文档" 移到 "你的文档"，则 FileSystemWatcher2 会引发 <xref:System.IO.FileSystemWatcher.Created> 事件，并且 FileSystemWatcher1 会引发一个 <xref:System.IO.FileSystemWatcher.Deleted> 事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-421">From the previous example, if you moved a file from "My Documents" to "Your Documents", a <xref:System.IO.FileSystemWatcher.Created> event would be raised by FileSystemWatcher2 and a <xref:System.IO.FileSystemWatcher.Deleted> event would be raised by FileSystemWatcher1.</span></span>  
  
 <span data-ttu-id="ca1e6-422">引发事件时，将通过委托调用事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-422">Raising an event invokes the event handler through a delegate.</span></span> <span data-ttu-id="ca1e6-423">有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-423">For more information, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="ca1e6-424">当在派生类中重写 <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> 时，请确保调用基类的 <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-424">When overriding <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> in a derived class, be sure to call the base class's <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> method.</span></span></para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnError">
      <MemberSignature Language="C#" Value="protected void OnError (System.IO.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnError(class System.IO.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnError (e As ErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnError(System::IO::ErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnError : System.IO.ErrorEventArgs -&gt; unit" Usage="fileSystemWatcher.OnError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="ca1e6-425">包含事件数据的 <see cref="T:System.IO.ErrorEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-425">An <see cref="T:System.IO.ErrorEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="ca1e6-426">引发 <see cref="E:System.IO.FileSystemWatcher.Error" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-426">Raises the <see cref="E:System.IO.FileSystemWatcher.Error" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1e6-427">发生错误时调用 <xref:System.IO.FileSystemWatcher.OnError%2A>。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-427"><xref:System.IO.FileSystemWatcher.OnError%2A> is called when an error occurs.</span></span>  
  
 <span data-ttu-id="ca1e6-428">引发事件时，将通过委托调用事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-428">Raising an event invokes the event handler through a delegate.</span></span> <span data-ttu-id="ca1e6-429">有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-429">For more information, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="ca1e6-430">当在派生类中重写 <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> 时，请确保调用基类的 <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-430">When overriding <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> in a derived class, be sure to call the base class's <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> method.</span></span></para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Error" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="OnRenamed">
      <MemberSignature Language="C#" Value="protected void OnRenamed (System.IO.RenamedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnRenamed(class System.IO.RenamedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnRenamed (e As RenamedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnRenamed(System::IO::RenamedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnRenamed : System.IO.RenamedEventArgs -&gt; unit" Usage="fileSystemWatcher.OnRenamed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.RenamedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="ca1e6-431">一个包含事件数据的 <see cref="T:System.IO.RenamedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-431">A <see cref="T:System.IO.RenamedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="ca1e6-432">引发 <see cref="E:System.IO.FileSystemWatcher.Renamed" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-432">Raises the <see cref="E:System.IO.FileSystemWatcher.Renamed" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1e6-433">如果重命名了所监视的目录中的文件或目录，则会调用 <xref:System.IO.FileSystemWatcher.OnRenamed%2A>。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-433"><xref:System.IO.FileSystemWatcher.OnRenamed%2A> is called when a file or directory within the directory being monitored is renamed.</span></span> <span data-ttu-id="ca1e6-434">其 <xref:System.IO.RenamedEventArgs> 参数包含有关重命名操作的信息，例如更改类型、旧路径和新路径以及旧名称和新名称。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-434">Its <xref:System.IO.RenamedEventArgs> argument contains information about the renaming operation, such as the type of change, the old and new path, and the old and new name.</span></span> <span data-ttu-id="ca1e6-435">请注意，如果 <xref:System.IO.FileSystemWatcher> 不会从操作系统中获取匹配的旧名称和新名称事件，则重命名事件的 <xref:System.IO.FileSystemEventArgs.Name> 属性可能为 null。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-435">Note that its <xref:System.IO.FileSystemEventArgs.Name> property may be null for renamed events if the <xref:System.IO.FileSystemWatcher> does not get matching old and new name events from the operating system.</span></span> 
  
 <span data-ttu-id="ca1e6-436">引发事件时，将通过委托调用事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-436">Raising an event invokes the event handler through a delegate.</span></span> <span data-ttu-id="ca1e6-437">有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-437">For more information, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="ca1e6-438">当在派生类中重写 <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> 时，请确保调用基类的 <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> 方法。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-438">When overriding <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> in a derived class, be sure to call the base class's <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> method.</span></span></para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Renamed" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.IO.FileSystemWatcher.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The directory to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ca1e6-439">获取或设置要监视的目录的路径。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-439">Gets or sets the path of the directory to watch.</span></span></summary>
        <value><span data-ttu-id="ca1e6-440">要监视的路径。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-440">The path to monitor.</span></span> <span data-ttu-id="ca1e6-441">默认值为空字符串("")。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-441">The default is an empty string ("").</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1e6-442">这是目录的完全限定路径。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-442">This is a fully qualified path to a directory.</span></span> <span data-ttu-id="ca1e6-443">如果 `true`<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> 属性，则此目录是系统监视更改的根目录;否则，它是唯一受监视的目录。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-443">If the <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> property is `true`, this directory is the root at which the system watches for changes; otherwise it is the only directory watched.</span></span> <span data-ttu-id="ca1e6-444">若要查看特定文件，请将 <xref:System.IO.FileSystemWatcher.Path%2A> 属性设置为完全限定的正确目录，并将 <xref:System.IO.FileSystemWatcher.Filter%2A> 属性设置为文件名。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-444">To watch a specific file, set the <xref:System.IO.FileSystemWatcher.Path%2A> property to the fully qualified, correct directory, and the <xref:System.IO.FileSystemWatcher.Filter%2A> property to the file name.</span></span>  
  
 <span data-ttu-id="ca1e6-445"><xref:System.IO.FileSystemWatcher.Path%2A> 属性支持通用命名约定（UNC）路径。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-445">The <xref:System.IO.FileSystemWatcher.Path%2A> property supports Universal Naming Convention (UNC) paths.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ca1e6-446">必须先设置此属性，组件才能监视更改。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-446">This property must be set before the component can watch for changes.</span></span>  
  
 <span data-ttu-id="ca1e6-447">重命名目录时，<xref:System.IO.FileSystemWatcher> 会自动将自身重新附加到新重命名的项。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-447">When a directory is renamed, the <xref:System.IO.FileSystemWatcher> automatically reattaches itself to the newly renamed item.</span></span> <span data-ttu-id="ca1e6-448">例如，如果将 <xref:System.IO.FileSystemWatcher.Path%2A> 属性设置为 "C:\My Documents"，然后手动将目录重命名为 "C:\Your Documents"，则该组件将继续在新重命名的目录上侦听更改通知。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-448">For example, if you set the <xref:System.IO.FileSystemWatcher.Path%2A> property to "C:\My Documents" and then manually rename the directory to "C:\Your Documents", the component continues listening for change notifications on the newly renamed directory.</span></span> <span data-ttu-id="ca1e6-449">但是，当您要求 <xref:System.IO.FileSystemWatcher.Path%2A> 属性时，它包含旧路径。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-449">However, when you ask for the <xref:System.IO.FileSystemWatcher.Path%2A> property, it contains the old path.</span></span> <span data-ttu-id="ca1e6-450">出现这种情况的原因是，组件根据句柄确定哪些目录监视，而不是目录的名称。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-450">This happens because the component determines what directory watches based on the handle, rather than the name of the directory.</span></span> <span data-ttu-id="ca1e6-451">重命名不会影响句柄。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-451">Renaming does not affect the handle.</span></span> <span data-ttu-id="ca1e6-452">因此，如果你销毁组件，然后重新创建它而不更新 <xref:System.IO.FileSystemWatcher.Path%2A> 属性，则应用程序将失败，因为该目录已不再存在。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-452">So, if you destroy the component, and then recreate it without updating the <xref:System.IO.FileSystemWatcher.Path%2A> property, your application will fail because the directory no longer exists.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ca1e6-453">下面的示例创建一个 <xref:System.IO.FileSystemWatcher> 以监视运行时指定的目录。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-453">The following example creates a <xref:System.IO.FileSystemWatcher> to watch the directory specified at run time.</span></span> <span data-ttu-id="ca1e6-454">组件设置为监视 `LastWrite` 和 `LastAccess` 时间的更改、创建、删除或重命名目录中的文本文件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-454">The component is set to watch for changes in `LastWrite` and `LastAccess` time, the creation, deletion, or renaming of text files in the directory.</span></span> <span data-ttu-id="ca1e6-455">如果更改、创建或删除了某个文件，则该文件的路径将打印到控制台。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-455">If a file is changed, created, or deleted, the path to the file prints to the console.</span></span> <span data-ttu-id="ca1e6-456">重命名文件后，旧路径和新路径将打印到控制台。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-456">When a file is renamed, the old and new paths print to the console.</span></span>  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ca1e6-457">指定的路径不存在或找不到。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-457">The specified path does not exist or could not be found.</span></span>  
  
 <span data-ttu-id="ca1e6-458">-或-</span><span class="sxs-lookup"><span data-stu-id="ca1e6-458">-or-</span></span>  
  
 <span data-ttu-id="ca1e6-459">指定的路径包含通配符。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-459">The specified path contains wildcard characters.</span></span>  
  
 <span data-ttu-id="ca1e6-460">-或-</span><span class="sxs-lookup"><span data-stu-id="ca1e6-460">-or-</span></span>  
  
 <span data-ttu-id="ca1e6-461">指定的路径包含无效路径字符。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-461">The specified path contains invalid path characters.</span></span></exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
      </Docs>
    </Member>
    <Member MemberName="Renamed">
      <MemberSignature Language="C#" Value="public event System.IO.RenamedEventHandler Renamed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.RenamedEventHandler Renamed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Renamed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Renamed As RenamedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::RenamedEventHandler ^ Renamed;" />
      <MemberSignature Language="F#" Value="member this.Renamed : System.IO.RenamedEventHandler " Usage="member this.Renamed : System.IO.RenamedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory rename matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Renamed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.RenamedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ca1e6-462">重命名指定 <see cref="P:System.IO.FileSystemWatcher.Path" /> 中的文件或目录时发生。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-462">Occurs when a file or directory in the specified <see cref="P:System.IO.FileSystemWatcher.Path" /> is renamed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1e6-463">`Renamed` 事件是具有以下签名的 <xref:System.IO.RenamedEventHandler> 委托：</span><span class="sxs-lookup"><span data-stu-id="ca1e6-463">The `Renamed` event is an <xref:System.IO.RenamedEventHandler> delegate that has the following signature:</span></span>

 ```csharp
public delegate void Renamed(object sender, RenamedEventArgs e);
 ```
 ```vb
Public Delegate Sub RenamedEventHandler(sender As Object, e As RenamedEventArgs)
 ```
 <span data-ttu-id="ca1e6-464"><xref:System.IO.RenamedEventArgs> 对象提供有关重命名操作的信息，如重命名的类型（<xref:System.IO.FileSystemEventArgs.ChangeType> 属性）、旧名称和新名称，以及新旧路径。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-464">The <xref:System.IO.RenamedEventArgs> object provides information about the renaming operation, such as the type of the rename (the <xref:System.IO.FileSystemEventArgs.ChangeType> property), the old and new name, and the old and new path.</span></span> <span data-ttu-id="ca1e6-465">请注意，如果 <xref:System.IO.FileSystemWatcher> 不会从操作系统中获取匹配的旧名称和新名称事件，则重命名事件的 <xref:System.IO.FileSystemEventArgs.Name> 属性可能为 null。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-465">Note that the <xref:System.IO.FileSystemEventArgs.Name> property may be null for renamed events if the <xref:System.IO.FileSystemWatcher> does not get matching old and new name events from the operating system.</span></span>

 <span data-ttu-id="ca1e6-466">重命名所监视的目录不会引发通知。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-466">Renaming the directory you are watching will not raise a notification.</span></span> <span data-ttu-id="ca1e6-467">只会为你所监视的目录内的条目引发通知。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-467">Notifications are only raised for entries inside the directory you are watching.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ca1e6-468">下面的示例使用 <xref:System.IO.FileSystemWatcher.Renamed> 事件，只要对被跟踪的文件进行重命名，就会将文件路径显示到控制台。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-468">The following example uses the <xref:System.IO.FileSystemWatcher.Renamed> event to display the file path to the console whenever the watched file is renamed.</span></span>  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.IO.FileSystemWatcher.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ca1e6-469">获取或设置 <see cref="T:System.ComponentModel.ISite" /> 的 <see cref="T:System.IO.FileSystemWatcher" />。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-469">Gets or sets an <see cref="T:System.ComponentModel.ISite" /> for the <see cref="T:System.IO.FileSystemWatcher" />.</span></span></summary>
        <value><span data-ttu-id="ca1e6-470">一个针对 <see cref="T:System.ComponentModel.ISite" /> 的 <see cref="T:System.IO.FileSystemWatcher" />。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-470">An <see cref="T:System.ComponentModel.ISite" /> for the <see cref="T:System.IO.FileSystemWatcher" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1e6-471">站点将 <xref:System.ComponentModel.Component> 绑定到 <xref:System.ComponentModel.Design.IDesignerHost.Container%2A> 并启用它们之间的通信，并为容器提供管理其组件的方法。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-471">Sites bind a <xref:System.ComponentModel.Component> to a <xref:System.ComponentModel.Design.IDesignerHost.Container%2A> and enable communication between them, as well as provide a way for the container to manage its components.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The object used to marshal the event handler calls resulting from a directory change")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_SynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ca1e6-472">获取或设置用于封送因目录更改而发出的事件处理程序调用的对象。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-472">Gets or sets the object used to marshal the event handler calls issued as a result of a directory change.</span></span></summary>
        <value><span data-ttu-id="ca1e6-473"><see cref="T:System.ComponentModel.ISynchronizeInvoke" />，表示一个对象，该对象用于封送因目录更改而发出的事件处理程序调用。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-473">The <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> that represents the object used to marshal the event handler calls issued as a result of a directory change.</span></span> <span data-ttu-id="ca1e6-474">默认为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-474">The default is <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1e6-475">`null`<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> 时，处理 <xref:System.IO.FileSystemWatcher.Changed>、<xref:System.IO.FileSystemWatcher.Created>、<xref:System.IO.FileSystemWatcher.Deleted>和 <xref:System.IO.FileSystemWatcher.Renamed> 事件的方法将在系统线程池中的线程上调用。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-475">When <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> is `null`, methods handling the <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, and <xref:System.IO.FileSystemWatcher.Renamed> events are called on a thread from the system thread pool.</span></span> <span data-ttu-id="ca1e6-476">有关系统线程池的详细信息，请参阅 <xref:System.Threading.ThreadPool>。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-476">For more information on system thread pools, see <xref:System.Threading.ThreadPool>.</span></span>  
  
 <span data-ttu-id="ca1e6-477">当 <xref:System.IO.FileSystemWatcher.Changed>、<xref:System.IO.FileSystemWatcher.Created>、<xref:System.IO.FileSystemWatcher.Deleted>和 <xref:System.IO.FileSystemWatcher.Renamed> 事件由 visual Windows 窗体组件（如 <xref:System.Windows.Forms.Button>）处理时，通过系统线程池访问组件可能不起作用，或可能会导致异常。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-477">When the <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, and <xref:System.IO.FileSystemWatcher.Renamed> events are handled by a visual Windows Forms component, such as a <xref:System.Windows.Forms.Button>, accessing the component through the system thread pool might not work, or may result in an exception.</span></span> <span data-ttu-id="ca1e6-478">通过将 <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> 设置为 Windows 窗体组件来避免这种情况，这会导致处理 <xref:System.IO.FileSystemWatcher.Changed>、<xref:System.IO.FileSystemWatcher.Created>、<xref:System.IO.FileSystemWatcher.Deleted>和 <xref:System.IO.FileSystemWatcher.Renamed> 事件的方法在创建该组件的同一线程上调用。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-478">Avoid this by setting <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> to a Windows Forms component, which causes the methods that handle the <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, and <xref:System.IO.FileSystemWatcher.Renamed> events to be called on the same thread on which the component was created.</span></span>  
  
 <span data-ttu-id="ca1e6-479">如果在 Windows 窗体设计器的 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] 内使用 <xref:System.IO.FileSystemWatcher>，<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> 会自动将设置为包含 <xref:System.IO.FileSystemWatcher>的控件。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-479">If the <xref:System.IO.FileSystemWatcher> is used inside [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] in a Windows Forms designer, <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> automatically sets to the control that contains the <xref:System.IO.FileSystemWatcher>.</span></span> <span data-ttu-id="ca1e6-480">例如，如果你将 <xref:System.IO.FileSystemWatcher> 放置在 Form1 的设计器中（继承自 <xref:System.Windows.Forms.Form>），则 <xref:System.IO.FileSystemWatcher> 的 <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> 属性设置为 Form1 的实例。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-480">For example, if you place a <xref:System.IO.FileSystemWatcher> on a designer for Form1 (which inherits from <xref:System.Windows.Forms.Form>) the <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> property of <xref:System.IO.FileSystemWatcher> is set to the instance of Form1.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForChanged">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ca1e6-481">一种同步方法，该方法会返回包含已发生的更改上的特定信息的结构。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-481">A synchronous method that returns a structure that contains specific information on the change that occurred.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged changeType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
      </Parameters>
      <Docs>
        <param name="changeType"><span data-ttu-id="ca1e6-482">要监视的 <see cref="T:System.IO.WatcherChangeTypes" />。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-482">The <see cref="T:System.IO.WatcherChangeTypes" /> to watch for.</span></span></param>
        <summary><span data-ttu-id="ca1e6-483">一种同步方法，在给定要监视的更改的类型情况下，它会返回包含已发生的更改上的特定信息的结构。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-483">A synchronous method that returns a structure that contains specific information on the change that occurred, given the type of change you want to monitor.</span></span></summary>
        <returns><span data-ttu-id="ca1e6-484"><see cref="T:System.IO.WaitForChangedResult" />，包含关于已发生的更改的特定信息。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-484">A <see cref="T:System.IO.WaitForChangedResult" /> that contains specific information on the change that occurred.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1e6-485">此方法会无限期地等待，直到第一次更改发生，然后返回。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-485">This method waits indefinitely until the first change occurs and then returns.</span></span> <span data-ttu-id="ca1e6-486">这与使用 <xref:System.IO.FileSystemWatcher.WaitForChanged%2A>，并将 `timeout` 参数设置为-1。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-486">This is the same as using <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> with the `timeout` parameter set to -1.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ca1e6-487">此方法允许调用事件处理程序以响应文件更改，即使 <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> 属性设置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-487">This method allows an event handler to be invoked to respond to file changes even if the <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> property is set to `false`.</span></span>  
  
 <span data-ttu-id="ca1e6-488">在某些系统中，<xref:System.IO.FileSystemWatcher> 使用短8.3 文件名格式对文件进行更改。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-488">In some systems, <xref:System.IO.FileSystemWatcher> reports changes to files using the short 8.3 file name format.</span></span> <span data-ttu-id="ca1e6-489">例如，将 "LongFileName" 更改为 "LongFi ~。Lon "。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-489">For example, a change to  "LongFileName.LongExtension" could be reported as "LongFi~.Lon".</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType, int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes, timeout As Integer) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes * int -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged (changeType, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="changeType"><span data-ttu-id="ca1e6-490">要监视的 <see cref="T:System.IO.WatcherChangeTypes" />。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-490">The <see cref="T:System.IO.WatcherChangeTypes" /> to watch for.</span></span></param>
        <param name="timeout"><span data-ttu-id="ca1e6-491">超时前等待的时间（以毫秒表示）。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-491">The time (in milliseconds) to wait before timing out.</span></span></param>
        <summary><span data-ttu-id="ca1e6-492">一种同步方法，在给定要监视的更改的类型以及在超时前等待的时间（以毫秒表示）的情况下，它会返回包含已发生的更改上的特定信息的结构。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-492">A synchronous method that returns a structure that contains specific information on the change that occurred, given the type of change you want to monitor and the time (in milliseconds) to wait before timing out.</span></span></summary>
        <returns><span data-ttu-id="ca1e6-493"><see cref="T:System.IO.WaitForChangedResult" />，包含关于已发生的更改的特定信息。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-493">A <see cref="T:System.IO.WaitForChangedResult" /> that contains specific information on the change that occurred.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ca1e6-494">此方法将一直等待，直到发生更改或已超时。`timeout` 参数的值为-1 表示无限期等待。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-494">This method waits until a change occurs or it has timed out. A value of -1 for the `timeout` parameter means wait indefinitely.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ca1e6-495">此方法允许调用事件处理程序以响应文件更改，即使 <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> 属性设置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-495">This method allows an event handler to be invoked to respond to file changes even if the <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> property is set to `false`.</span></span>  
  
 <span data-ttu-id="ca1e6-496">在某些系统中，<xref:System.IO.FileSystemWatcher> 使用短8.3 文件名格式对文件进行更改。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-496">In some systems, <xref:System.IO.FileSystemWatcher> reports changes to files using the short 8.3 file name format.</span></span> <span data-ttu-id="ca1e6-497">例如，将 "LongFileName" 更改为 "LongFi ~。Lon "。</span><span class="sxs-lookup"><span data-stu-id="ca1e6-497">For example, a change to  "LongFileName.LongExtension" could be reported as "LongFi~.Lon".</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
  </Members>
</Type>
