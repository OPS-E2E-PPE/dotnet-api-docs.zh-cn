<Type Name="DependencyPropertyKey" FullName="System.Windows.DependencyPropertyKey">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a6e2c2bf33d13e1feb3e0866a2765f0b9625d4dc" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82487227" /></Metadata><TypeSignature Language="C#" Value="public sealed class DependencyPropertyKey" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyPropertyKey extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyPropertyKey" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyPropertyKey" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyPropertyKey sealed" />
  <TypeSignature Language="F#" Value="type DependencyPropertyKey = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="1182c-101">提供依赖项对象标识符，以便对只读依赖项对象进行有限的写访问。</span><span class="sxs-lookup"><span data-stu-id="1182c-101">Provides a dependency property identifier for limited write access to a read-only dependency property.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1182c-102"><xref:System.Windows.DependencyPropertyKey> 实例是使用 <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> 或 <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>方法，作为依赖属性注册调用的返回值获取的。</span><span class="sxs-lookup"><span data-stu-id="1182c-102"><xref:System.Windows.DependencyPropertyKey> instances are obtained as the return value of a dependency property registration call using the methods <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> or <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.</span></span>  
  
 <span data-ttu-id="1182c-103">注册依赖属性的类型可使用 <xref:System.Windows.DependencyPropertyKey> 调用 <xref:System.Windows.DependencyObject.SetValue%2A> 和 <xref:System.Windows.DependencyObject.ClearValue%2A>，以便将属性值作为类逻辑的一部分进行调整。</span><span class="sxs-lookup"><span data-stu-id="1182c-103">The types that register a dependency property can use the <xref:System.Windows.DependencyPropertyKey> in calls to <xref:System.Windows.DependencyObject.SetValue%2A> and <xref:System.Windows.DependencyObject.ClearValue%2A> that adjust the property's value as part of class logic.</span></span> <span data-ttu-id="1182c-104">如果密钥的访问级别允许，则相关类也可以使用该密钥和依赖属性。</span><span class="sxs-lookup"><span data-stu-id="1182c-104">If permitted by the access level of the key, related classes can use the key and the dependency property also.</span></span> <span data-ttu-id="1182c-105">例如，可以将密钥声明为内部密钥，同一程序集中的其他类型也可以设置该依赖属性。</span><span class="sxs-lookup"><span data-stu-id="1182c-105">For instance, you can declare the key as internal, and other types within the same assembly can also set that dependency property.</span></span>  
  
 <span data-ttu-id="1182c-106">不应将由只读依赖项属性注册返回的 <xref:System.Windows.DependencyPropertyKey> 设置为公共的，因为公开密钥会使属性可设置，因此摆将其注册为只读依赖属性的点。</span><span class="sxs-lookup"><span data-stu-id="1182c-106">The <xref:System.Windows.DependencyPropertyKey> returned by read-only dependency property registration should not be made public, because exposing the key makes the property settable, thus defeating the point of registering it as a read-only dependency property.</span></span> <span data-ttu-id="1182c-107">此外，公开密钥会导致可用的依赖项属性行为与它 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 属性包装器实现之间不匹配，这是类设计错误。</span><span class="sxs-lookup"><span data-stu-id="1182c-107">Also, exposing the key causes a mismatch between the available dependency property behaviors and its [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] property wrapper implementations, which is bad class design.</span></span>  
  
 <span data-ttu-id="1182c-108">应将 <xref:System.Windows.DependencyPropertyKey> <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> 值作为类的 `public static readonly`<xref:System.Windows.DependencyProperty> 公开，而不是公开密钥本身。</span><span class="sxs-lookup"><span data-stu-id="1182c-108">Instead of exposing the key itself, you should instead expose the <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> value of the <xref:System.Windows.DependencyPropertyKey> as a `public static readonly`<xref:System.Windows.DependencyProperty> on your class.</span></span> <span data-ttu-id="1182c-109">这使属性可以为某些属性系统操作（如枚举本地设置值）返回有效的依赖属性标识符。</span><span class="sxs-lookup"><span data-stu-id="1182c-109">This enables the property to return a valid dependency property identifier for certain property system operations such as enumerating locally set values.</span></span> <span data-ttu-id="1182c-110">但是，对于许多属性系统操作，获取的标识符没有 <xref:System.Windows.DependencyProperty> 的全部功能。</span><span class="sxs-lookup"><span data-stu-id="1182c-110">However, the identifier thus obtained does not have the full capabilities of a <xref:System.Windows.DependencyProperty> for many property system operations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1182c-111">下面的示例将注册一个只读依赖属性，并将该密钥用于其他类成员中的两个目的：实现 get "包装器"，并将其用作受保护确定操作的标识符，该操作根据其他属性值的计算设置值。</span><span class="sxs-lookup"><span data-stu-id="1182c-111">The following example registers a read-only dependency property, and also uses the key for two purposes in other class members: implementing the get "wrapper", and as the identifier for a protected determination operation that sets the value based on calculations of other property values.</span></span>  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName="DependencyProperty">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty DependencyProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyProperty DependencyProperty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyPropertyKey.DependencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyProperty As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyProperty ^ DependencyProperty { System::Windows::DependencyProperty ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyProperty : System.Windows.DependencyProperty" Usage="System.Windows.DependencyPropertyKey.DependencyProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1182c-112">获取与此专用只读依赖项对象标识符关联的依赖项对象标识符。</span><span class="sxs-lookup"><span data-stu-id="1182c-112">Gets the dependency property identifier associated with this specialized read-only dependency property identifier.</span></span></summary>
        <value><span data-ttu-id="1182c-113">相关的依赖项对象标识符。</span><span class="sxs-lookup"><span data-stu-id="1182c-113">The relevant dependency property identifier.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1182c-114">使用 <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> 值，只读属性的标识符可以使用与读写依赖项属性相同的某些接口参与公共属性系统操作。</span><span class="sxs-lookup"><span data-stu-id="1182c-114">The <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> value enables a read-only property's identifier to participate in common property system operations using some of the same interfaces as used for read-write dependency properties.</span></span>  
  
 <span data-ttu-id="1182c-115">为了实现只读依赖项属性的 get 属性访问器，你应在类上创建并公开 <xref:System.Windows.DependencyProperty> 标识符。</span><span class="sxs-lookup"><span data-stu-id="1182c-115">In order to implement the get property accessor for a read-only dependency property, you should create and expose a <xref:System.Windows.DependencyProperty> identifier on your class.</span></span> <span data-ttu-id="1182c-116">这有两种用途：</span><span class="sxs-lookup"><span data-stu-id="1182c-116">This serves two purposes:</span></span>  
  
-   <span data-ttu-id="1182c-117">你自己的类需要 <xref:System.Windows.DependencyProperty> 标识符才能实现属性包装的 get 访问器。</span><span class="sxs-lookup"><span data-stu-id="1182c-117">Your own class needs the <xref:System.Windows.DependencyProperty> identifier in order to implement the get accessor for the property wrapper.</span></span> <span data-ttu-id="1182c-118">将 <xref:System.Windows.DependencyProperty> 用作实现 get 访问器的 <xref:System.Windows.DependencyObject.GetValue%2A> 调用的参数。</span><span class="sxs-lookup"><span data-stu-id="1182c-118">You use the <xref:System.Windows.DependencyProperty> as a parameter for the <xref:System.Windows.DependencyObject.GetValue%2A> call that implements the get accessor.</span></span>  
  
-   <span data-ttu-id="1182c-119"><xref:System.Windows.DependencyProperty> 标识符向属性系统公开依赖属性，以便其他依赖元数据的方法可以在标准窗体中访问它。</span><span class="sxs-lookup"><span data-stu-id="1182c-119"><xref:System.Windows.DependencyProperty> identifiers expose your dependency property to the property system such that other methods that rely on metadata can access it in a standard form.</span></span> <span data-ttu-id="1182c-120">例如，如果你在某些 <xref:System.Windows.DependencyObject> 上调用了 <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A>，并且获取了本地设置的属性（值和标识符）的枚举，则为只读依赖属性返回的标识符将是你的 <xref:System.Windows.DependencyProperty> 值，而不是密钥。</span><span class="sxs-lookup"><span data-stu-id="1182c-120">For instance, if you called <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> on some <xref:System.Windows.DependencyObject> and obtained an enumeration of locally set properties (values and identifiers) the identifier returned for a read-only dependency property would be your <xref:System.Windows.DependencyProperty> value rather than the key.</span></span> <span data-ttu-id="1182c-121">如果未公开 <xref:System.Windows.DependencyProperty> 标识符，则不会以任何方式增加只读依赖项属性的安全性，它只会使涉及属性的操作对后续派生类和类实例更难使用。</span><span class="sxs-lookup"><span data-stu-id="1182c-121">Not exposing a <xref:System.Windows.DependencyProperty> identifier does not increase the security of your read-only dependency property in any way, it just makes operations that involve your property more awkward both for subsequent derived classes and class instances.</span></span>  
  
 <span data-ttu-id="1182c-122">若要公开类的 <xref:System.Windows.DependencyProperty> 标识符，请直接对键调用 <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A>。</span><span class="sxs-lookup"><span data-stu-id="1182c-122">To expose the  <xref:System.Windows.DependencyProperty> identifier on your class, you call <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> directly on your key.</span></span> <span data-ttu-id="1182c-123">使用此值在类上创建一个 `public static readonly`<xref:System.Windows.DependencyProperty> 标识符，该标识符与 <xref:System.Windows.DependencyPropertyKey>类似。</span><span class="sxs-lookup"><span data-stu-id="1182c-123">Use this value to create a `public static readonly`<xref:System.Windows.DependencyProperty> identifier on the class, which parallels the <xref:System.Windows.DependencyPropertyKey>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1182c-124">下面的示例调用 <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> 为类公开 `AquariumGraphic` 只读依赖项属性的 <xref:System.Windows.DependencyProperty> 标识符（`AquariumGraphicProperty`）。</span><span class="sxs-lookup"><span data-stu-id="1182c-124">The following example calls <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> to expose the <xref:System.Windows.DependencyProperty> identifier (`AquariumGraphicProperty`) for the `AquariumGraphic` read-only dependency property on a class.</span></span> <span data-ttu-id="1182c-125">该示例还显示了 <xref:System.Windows.DependencyPropertyKey> 创建（作为内部成员）和 `AquariumGraphic`的 get 访问器。</span><span class="sxs-lookup"><span data-stu-id="1182c-125">The example also shows the <xref:System.Windows.DependencyPropertyKey> creation (as an internal member) and the get accessor for `AquariumGraphic`.</span></span>  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyPropertyKey.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType"><span data-ttu-id="1182c-126">作为此依赖项对象存在基础以及应依据其重写元数据的类型。</span><span class="sxs-lookup"><span data-stu-id="1182c-126">The type on which this dependency property exists and metadata should be overridden.</span></span></param>
        <param name="typeMetadata"><span data-ttu-id="1182c-127">为此类型提供的元数据。</span><span class="sxs-lookup"><span data-stu-id="1182c-127">Metadata supplied for this type.</span></span></param>
        <summary><span data-ttu-id="1182c-128">重写由此依赖项对象标识符表示的只读依赖项对象的元数据。</span><span class="sxs-lookup"><span data-stu-id="1182c-128">Overrides the metadata of a read-only dependency property that is represented by this dependency property identifier.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1182c-129">重写只读依赖项属性的元数据的方式类似于重写读写依赖项属性的元数据，并且限制在键级别进行访问，因为在元数据中指定的行为可以更改集行为（例如，默认值）。</span><span class="sxs-lookup"><span data-stu-id="1182c-129">Overriding metadata on a read-only dependency property is done for similar reasons as overriding metadata on a read-write dependency property, and is restricted to access at the key level because behaviors specified in the metadata can change the set behavior (the default value, for instance).</span></span>  
  
 <span data-ttu-id="1182c-130">对于读写依赖项属性，在只读依赖项属性上重写元数据时，只应在属性系统正在使用该属性之前完成此操作（这相当于为注册该属性的对象的特定实例实例化的时间）。</span><span class="sxs-lookup"><span data-stu-id="1182c-130">As with read-write dependency properties, overriding metadata on a read-only dependency property should only be done prior to that property being placed in use by the property system (this equates to the time that specific instances of objects that register the property are instantiated).</span></span> <span data-ttu-id="1182c-131">只应在将自身作为此方法的 `forType` 参数的类型的静态构造函数中执行 <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> 调用，或对该类执行等效的初始化操作。</span><span class="sxs-lookup"><span data-stu-id="1182c-131">Calls to <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> should only be performed within the static constructors of the type that provides itself as the `forType` parameter of this method, or equivalent initialization for that class.</span></span>  
  
 <span data-ttu-id="1182c-132">此方法可以有效地转发到 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 方法，将 <xref:System.Windows.DependencyPropertyKey> 实例作为密钥参数传递。</span><span class="sxs-lookup"><span data-stu-id="1182c-132">This method effectively forwards to the <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method, passing the <xref:System.Windows.DependencyPropertyKey> instance as the key parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1182c-133">下面的示例将覆盖类继承的现有只读依赖项属性的元数据。</span><span class="sxs-lookup"><span data-stu-id="1182c-133">The following example overrides metadata for an existing read-only dependency property that a class inherits.</span></span> <span data-ttu-id="1182c-134">在这种情况下，方案目标是添加基属性元数据不具有的强制值回调。</span><span class="sxs-lookup"><span data-stu-id="1182c-134">In this case, the scenario goal was to add a coerce value callback that the base property metadata did not have.</span></span> <span data-ttu-id="1182c-135">你还可以重写元数据，因为重写元数据通常是适当的（更改默认值、添加 <xref:System.Windows.FrameworkPropertyMetadataOptions> 值等）</span><span class="sxs-lookup"><span data-stu-id="1182c-135">You could also override metadata for any of the other reasons that overriding metadata is typically appropriate (changing default value, adding <xref:System.Windows.FrameworkPropertyMetadataOptions> values, etc.)</span></span>  
  
 [!code-csharp[WPFAquariumSln#RODPOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodpoverride)]
 [!code-vb[WPFAquariumSln#RODPOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodpoverride)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1182c-136">尝试在读写依赖项对象上进行元数据重写（无法使用此签名完成该操作）。</span><span class="sxs-lookup"><span data-stu-id="1182c-136">Attempted metadata override on a read-write dependency property (cannot be done using this signature).</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1182c-137">当属性存在于提供的类型上时，已为该属性建立元数据。</span><span class="sxs-lookup"><span data-stu-id="1182c-137">Metadata was already established for the property as it exists on the provided type.</span></span></exception>
        <altmember cref="T:System.Windows.DependencyProperty" />
        <altmember cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      </Docs>
    </Member>
  </Members>
</Type>
