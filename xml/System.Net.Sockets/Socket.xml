<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7ca76bb12578121ed0daa4fdc58e686329bada61" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75170537" /></Metadata><TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="42801-101">实现 Berkeley 套接字接口。</span><span class="sxs-lookup"><span data-stu-id="42801-101">Implements the Berkeley sockets interface.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-102"><xref:System.Net.Sockets.Socket> 类提供一组丰富的用于网络通信的方法和属性。</span><span class="sxs-lookup"><span data-stu-id="42801-102">The <xref:System.Net.Sockets.Socket> class provides a rich set of methods and properties for network communications.</span></span> <span data-ttu-id="42801-103"><xref:System.Net.Sockets.Socket> 类允许使用 <xref:System.Net.Sockets.ProtocolType> 枚举中列出的任何通信协议执行同步和异步数据传输。</span><span class="sxs-lookup"><span data-stu-id="42801-103">The <xref:System.Net.Sockets.Socket> class allows you to perform both synchronous and asynchronous data transfer using any of the communication protocols listed in the <xref:System.Net.Sockets.ProtocolType> enumeration.</span></span>  
  
 <span data-ttu-id="42801-104"><xref:System.Net.Sockets.Socket> 类遵循异步方法 .NET Framework 命名模式。</span><span class="sxs-lookup"><span data-stu-id="42801-104">The <xref:System.Net.Sockets.Socket> class follows the .NET Framework naming pattern for asynchronous methods.</span></span> <span data-ttu-id="42801-105">例如，同步 <xref:System.Net.Sockets.Socket.Receive%2A> 方法与异步 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 和 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法相对应。</span><span class="sxs-lookup"><span data-stu-id="42801-105">For example, the synchronous <xref:System.Net.Sockets.Socket.Receive%2A> method corresponds to the asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods.</span></span>  
  
 <span data-ttu-id="42801-106">如果应用程序在执行过程中只需要一个线程，请使用以下方法，这些方法是为同步操作模式设计的。</span><span class="sxs-lookup"><span data-stu-id="42801-106">If your application only requires one thread during execution, use the following methods, which are designed for synchronous operation mode.</span></span>  
  
-   <span data-ttu-id="42801-107">如果使用面向连接的协议（例如 TCP），则服务器可以使用 <xref:System.Net.Sockets.Socket.Listen%2A> 方法侦听连接。</span><span class="sxs-lookup"><span data-stu-id="42801-107">If you are using a connection-oriented protocol such as TCP, your server can listen for connections using the <xref:System.Net.Sockets.Socket.Listen%2A> method.</span></span> <span data-ttu-id="42801-108"><xref:System.Net.Sockets.Socket.Accept%2A> 方法处理任何传入连接请求，并返回可用于与远程主机通信的 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-108">The <xref:System.Net.Sockets.Socket.Accept%2A> method processes any incoming connection requests and returns a <xref:System.Net.Sockets.Socket> that you can use to communicate data with the remote host.</span></span> <span data-ttu-id="42801-109">使用返回 <xref:System.Net.Sockets.Socket> 调用 <xref:System.Net.Sockets.Socket.Send%2A> 或 <xref:System.Net.Sockets.Socket.Receive%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-109">Use this returned <xref:System.Net.Sockets.Socket> to call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span> <span data-ttu-id="42801-110">如果要指定本地 IP 地址和端口号，请在调用 <xref:System.Net.Sockets.Socket.Listen%2A> 方法之前调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-110">Call the <xref:System.Net.Sockets.Socket.Bind%2A> method prior to calling the <xref:System.Net.Sockets.Socket.Listen%2A> method if you want to specify the local IP address and port number.</span></span> <span data-ttu-id="42801-111">如果希望基础服务提供商为你分配一个可用端口，请使用端口号零。</span><span class="sxs-lookup"><span data-stu-id="42801-111">Use a port number of zero if you want the underlying service provider to assign a free port for you.</span></span> <span data-ttu-id="42801-112">如果要连接到侦听主机，请调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-112">If you want to connect to a listening host, call the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="42801-113">若要传递数据，请调用 <xref:System.Net.Sockets.Socket.Send%2A> 或 <xref:System.Net.Sockets.Socket.Receive%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-113">To communicate data, call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
-   <span data-ttu-id="42801-114">如果使用的是无连接协议（如 UDP），则无需侦听连接。</span><span class="sxs-lookup"><span data-stu-id="42801-114">If you are using a connectionless protocol such as UDP, you do not need to listen for connections at all.</span></span> <span data-ttu-id="42801-115">调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法以接受任何传入的数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-115">Call the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method to accept any incoming datagrams.</span></span> <span data-ttu-id="42801-116">使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法将数据报发送到远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-116">Use the <xref:System.Net.Sockets.Socket.SendTo%2A> method to send datagrams to a remote host.</span></span>  
  
 <span data-ttu-id="42801-117">若要在执行过程中使用单独的线程来处理通信，请使用以下方法，这些方法是为异步操作模式设计的。</span><span class="sxs-lookup"><span data-stu-id="42801-117">To process communications using separate threads during execution, use the following methods, which are designed for asynchronous operation mode.</span></span>  
  
-   <span data-ttu-id="42801-118">如果使用面向连接的协议（如 TCP），请使用 <xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>和 <xref:System.Net.Sockets.Socket.EndConnect%2A> 方法连接到侦听主机。</span><span class="sxs-lookup"><span data-stu-id="42801-118">If you are using a connection-oriented protocol such as TCP, use the <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, and <xref:System.Net.Sockets.Socket.EndConnect%2A> methods to connect with a listening host.</span></span> <span data-ttu-id="42801-119">使用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 和 <xref:System.Net.Sockets.Socket.EndSend%2A> 或 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 和 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法以异步方式传递数据。</span><span class="sxs-lookup"><span data-stu-id="42801-119">Use the <xref:System.Net.Sockets.Socket.BeginSend%2A> and <xref:System.Net.Sockets.Socket.EndSend%2A> or <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods to communicate data asynchronously.</span></span> <span data-ttu-id="42801-120">可以使用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 和 <xref:System.Net.Sockets.Socket.EndAccept%2A>处理传入连接请求。</span><span class="sxs-lookup"><span data-stu-id="42801-120">Incoming connection requests can be processed using <xref:System.Net.Sockets.Socket.BeginAccept%2A> and <xref:System.Net.Sockets.Socket.EndAccept%2A>.</span></span>  
  
-   <span data-ttu-id="42801-121">如果使用的是无连接协议（如 UDP），则可以使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 和 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 发送数据报，并 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 和 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 接收数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-121">If you are using a connectionless protocol such as UDP, you can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.EndSendTo%2A> to send datagrams, and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> and <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> to receive datagrams.</span></span>  
  
 <span data-ttu-id="42801-122">如果对套接字执行多个异步操作，则这些操作不一定按启动顺序完成。</span><span class="sxs-lookup"><span data-stu-id="42801-122">If you perform multiple asynchronous operations on a socket, they do not necessarily complete in the order in which they are started.</span></span>  
  
 <span data-ttu-id="42801-123">完成发送和接收数据的操作后，请使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法禁用 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-123">When you are finished sending and receiving data, use the <xref:System.Net.Sockets.Socket.Shutdown%2A> method to disable the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-124">调用 <xref:System.Net.Sockets.Socket.Shutdown%2A>后，调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法以释放与 <xref:System.Net.Sockets.Socket>关联的所有资源。</span><span class="sxs-lookup"><span data-stu-id="42801-124">After calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method to release all resources associated with the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 <span data-ttu-id="42801-125"><xref:System.Net.Sockets.Socket> 类允许使用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法配置 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-125">The <xref:System.Net.Sockets.Socket> class allows you to configure your <xref:System.Net.Sockets.Socket> using the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span> <span data-ttu-id="42801-126">使用 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 方法检索这些设置。</span><span class="sxs-lookup"><span data-stu-id="42801-126">Retrieve these settings using the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-127">如果你正在编写一个相对简单的应用程序，并且不需要最佳性能，请考虑使用 <xref:System.Net.Sockets.TcpClient>、<xref:System.Net.Sockets.TcpListener>和 <xref:System.Net.Sockets.UdpClient>。</span><span class="sxs-lookup"><span data-stu-id="42801-127">If you are writing a relatively simple application and do not require maximum performance, consider using <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, and <xref:System.Net.Sockets.UdpClient>.</span></span> <span data-ttu-id="42801-128">这些类提供了更简单、更易于使用的界面来 <xref:System.Net.Sockets.Socket> 通信。</span><span class="sxs-lookup"><span data-stu-id="42801-128">These classes provide a simpler and more user-friendly interface to <xref:System.Net.Sockets.Socket> communications.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-129">下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket> 类将数据发送到 HTTP 服务器并接收响应。</span><span class="sxs-lookup"><span data-stu-id="42801-129">The following code example shows how the <xref:System.Net.Sockets.Socket> class can be used to send data to an HTTP server and receive the response.</span></span> <span data-ttu-id="42801-130">在收到整个页面之前，此示例将会阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-130">This example blocks until the entire page is received.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="42801-131">建立传出连接或接受传入的请求。</span><span class="sxs-lookup"><span data-stu-id="42801-131">To establish an outgoing connection or accept an incoming request.</span></span></permission>
    <threadsafe><span data-ttu-id="42801-132">此类的实例是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="42801-132">Instances of this class are thread safe.</span></span></threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
    <related type="Article" href="~/docs/framework/network-programming/index.md"><span data-ttu-id="42801-133">.NET Framework 中的网络编程</span><span class="sxs-lookup"><span data-stu-id="42801-133">Network Programming in the .NET Framework</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/best-practices-for-system-net-classes.md"><span data-ttu-id="42801-134">System.Net 类的最佳实践</span><span class="sxs-lookup"><span data-stu-id="42801-134">Best Practices for System.Net Classes</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/cache-management-for-network-applications.md"><span data-ttu-id="42801-135">网络应用程序的缓存管理</span><span class="sxs-lookup"><span data-stu-id="42801-135">Cache Management for Network Applications</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/internet-protocol-version-6.md"><span data-ttu-id="42801-136">Internet 协议版本 6</span><span class="sxs-lookup"><span data-stu-id="42801-136">Internet Protocol Version 6</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/network-programming-samples.md"><span data-ttu-id="42801-137">网络编程示例</span><span class="sxs-lookup"><span data-stu-id="42801-137">Network Programming Samples</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/network-tracing.md"><span data-ttu-id="42801-138">.NET Framework 中的网络跟踪</span><span class="sxs-lookup"><span data-stu-id="42801-138">Network Tracing in the .NET Framework</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/security-in-network-programming.md"><span data-ttu-id="42801-139">网络编程中的安全性</span><span class="sxs-lookup"><span data-stu-id="42801-139">Security in Network Programming</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/socket-performance-enhancements-in-version-3-5.md"><span data-ttu-id="42801-140">版本 3.5 中的套接字性能增强</span><span class="sxs-lookup"><span data-stu-id="42801-140">Socket Performance Enhancements in Version 3.5</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42801-141">初始化 <see cref="T:System.Net.Sockets.Socket" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="42801-141">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="socketInformation"><span data-ttu-id="42801-142"><see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> 返回的套接字信息。</span><span class="sxs-lookup"><span data-stu-id="42801-142">The socket information returned by <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span></span></param>
        <summary><span data-ttu-id="42801-143">使用 <see cref="T:System.Net.Sockets.Socket" /> 返回的指定的值初始化 <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="42801-143">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified value returned from <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-144">如果多次调用 <xref:System.Net.Sockets.Socket.%23ctor%2A> 构造函数并将同一字节数组作为每次调用的参数，则将创建多个具有相同基础套接字的托管 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-144">If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket>s with the same underlying socket.</span></span> <span data-ttu-id="42801-145">强烈建议您不要这样做。</span><span class="sxs-lookup"><span data-stu-id="42801-145">This practice is strongly discouraged.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType"><span data-ttu-id="42801-146"><see cref="T:System.Net.Sockets.SocketType" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-146">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></param>
        <param name="protocolType"><span data-ttu-id="42801-147"><see cref="T:System.Net.Sockets.ProtocolType" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-147">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></param>
        <summary><span data-ttu-id="42801-148">使用指定的地址族、套接字类型和协议初始化 <see cref="T:System.Net.Sockets.Socket" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="42801-148">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified socket type and protocol.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-149">`socketType` 参数指定 <xref:System.Net.Sockets.Socket> 类的类型，`protocolType` 参数指定 <xref:System.Net.Sockets.Socket>所使用的协议。</span><span class="sxs-lookup"><span data-stu-id="42801-149">The `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-150">这两个参数不是独立的。</span><span class="sxs-lookup"><span data-stu-id="42801-150">The two parameters are not independent.</span></span> <span data-ttu-id="42801-151">通常，<xref:System.Net.Sockets.Socket> 类型在协议中是隐式的。</span><span class="sxs-lookup"><span data-stu-id="42801-151">Often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol.</span></span> <span data-ttu-id="42801-152">如果 <xref:System.Net.Sockets.Socket> 类型和协议类型的组合导致无效 <xref:System.Net.Sockets.Socket>，则此构造函数将引发一个 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-152">If the combination of <xref:System.Net.Sockets.Socket> type and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-153">如果此构造函数引发 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-153">If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-154">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-154">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-155">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-155">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-156">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-156">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-157"><paramref name="socketType" /> 和 <paramref name="protocolType" /> 组合将导致套接字无效。</span><span class="sxs-lookup"><span data-stu-id="42801-157">The combination of  <paramref name="socketType" /> and <paramref name="protocolType" /> results in an invalid socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily"><span data-ttu-id="42801-158"><see cref="T:System.Net.Sockets.AddressFamily" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-158">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</span></span></param>
        <param name="socketType"><span data-ttu-id="42801-159"><see cref="T:System.Net.Sockets.SocketType" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-159">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></param>
        <param name="protocolType"><span data-ttu-id="42801-160"><see cref="T:System.Net.Sockets.ProtocolType" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-160">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></param>
        <summary><span data-ttu-id="42801-161">使用指定的地址族、套接字类型和协议初始化 <see cref="T:System.Net.Sockets.Socket" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="42801-161">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified address family, socket type and protocol.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-162">`addressFamily` 参数指定 <xref:System.Net.Sockets.Socket> 类使用的寻址方案，`socketType` 参数指定 <xref:System.Net.Sockets.Socket> 类的类型，而 `protocolType` 参数指定 <xref:System.Net.Sockets.Socket>使用的协议。</span><span class="sxs-lookup"><span data-stu-id="42801-162">The `addressFamily` parameter specifies the addressing scheme that the <xref:System.Net.Sockets.Socket> class uses, the `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class, and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-163">这三个参数不是独立的。</span><span class="sxs-lookup"><span data-stu-id="42801-163">The three parameters are not independent.</span></span> <span data-ttu-id="42801-164">某些地址族限制了可与它们一起使用的协议，并且 <xref:System.Net.Sockets.Socket> 类型在协议中是隐式的。</span><span class="sxs-lookup"><span data-stu-id="42801-164">Some address families restrict which protocols can be used with them, and often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol.</span></span> <span data-ttu-id="42801-165">如果地址族、<xref:System.Net.Sockets.Socket> 类型和协议类型的组合导致无效 <xref:System.Net.Sockets.Socket>，则此构造函数将引发一个 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-165">If the combination of address family, <xref:System.Net.Sockets.Socket> type, and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-166">如果此构造函数引发 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-166">If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-167">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-167">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-168">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-168">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-169">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-169">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-170">下面的代码示例演示如何创建 <xref:System.Net.Sockets.Socket> 类的实例。</span><span class="sxs-lookup"><span data-stu-id="42801-170">The following code example demonstrates how to create an instance of the <xref:System.Net.Sockets.Socket> class.</span></span>  
  
 [!code-cpp[Socket_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-171"><paramref name="addressFamily" />、<paramref name="socketType" /> 和 <paramref name="protocolType" /> 的组合会导致无效套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-171">The combination of <paramref name="addressFamily" />, <paramref name="socketType" />, and <paramref name="protocolType" /> results in an invalid socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="42801-172">为新建连接创建新的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="42801-172">Creates a new <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</span></span></summary>
        <returns><span data-ttu-id="42801-173">新建连接的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="42801-173">A <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-174"><xref:System.Net.Sockets.Socket.Accept%2A> 从侦听套接字的连接请求队列中同步提取第一个挂起的连接请求，然后创建并返回新的 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-174"><xref:System.Net.Sockets.Socket.Accept%2A> synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and returns a new <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-175">不能使用返回的 <xref:System.Net.Sockets.Socket> 接受来自连接队列的任何其他连接。</span><span class="sxs-lookup"><span data-stu-id="42801-175">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="42801-176">但是，你可以调用返回的 <xref:System.Net.Sockets.Socket> 的 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 方法来识别远程主机的网络地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-176">However, you can call the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> method of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.</span></span>  
  
 <span data-ttu-id="42801-177">在阻止模式下，<xref:System.Net.Sockets.Socket.Accept%2A> 会被阻止，直到传入连接尝试排入队列。</span><span class="sxs-lookup"><span data-stu-id="42801-177">In blocking mode, <xref:System.Net.Sockets.Socket.Accept%2A> blocks until an incoming connection attempt is queued.</span></span> <span data-ttu-id="42801-178">连接被接受后，原始 <xref:System.Net.Sockets.Socket> 将继续排队传入连接请求，直到你将其关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-178">Once a connection is accepted, the original <xref:System.Net.Sockets.Socket> continues queuing incoming connection requests until you close it.</span></span>  
  
 <span data-ttu-id="42801-179">如果使用非阻塞 <xref:System.Net.Sockets.Socket>调用此方法，并且没有任何连接请求排队，则 <xref:System.Net.Sockets.Socket.Accept%2A> 会引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-179">If you call this method using a non-blocking <xref:System.Net.Sockets.Socket>, and no connection requests are queued, <xref:System.Net.Sockets.Socket.Accept%2A> throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-180">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-180">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-181">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-181">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-182">在调用 <xref:System.Net.Sockets.Socket.Accept%2A> 方法之前，必须先调用 <xref:System.Net.Sockets.Socket.Listen%2A> 方法来侦听传入连接请求并对其进行排队。</span><span class="sxs-lookup"><span data-stu-id="42801-182">Before calling the <xref:System.Net.Sockets.Socket.Accept%2A> method, you must first call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-183">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-183">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-184">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-184">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-185">下面的代码示例接受简单的 <xref:System.Net.Sockets.Socket> 连接。</span><span class="sxs-lookup"><span data-stu-id="42801-185">The following code example accepts a simple <xref:System.Net.Sockets.Socket> connection.</span></span>  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-186">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-186">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-187"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-187">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-188">正在接受的套接字不会侦听连接。</span><span class="sxs-lookup"><span data-stu-id="42801-188">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="42801-189">在调用 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前必须调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="42801-189">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.Accept" />.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="42801-190">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="42801-190">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="42801-191">开始一个异步操作来接受一个传入的连接尝试。</span><span class="sxs-lookup"><span data-stu-id="42801-191">Begins an asynchronous operation to accept an incoming connection attempt.</span></span></summary>
        <returns><span data-ttu-id="42801-192">如果 I/O 操作挂起，则为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="42801-192"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="42801-193">操作完成时，将引发 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 参数的 <paramref name="e" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="42801-193">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="42801-194">如果 I/O 操作同步完成，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-194"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="42801-195">将不会引发 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 参数的 <paramref name="e" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</span><span class="sxs-lookup"><span data-stu-id="42801-195">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-196">面向连接的协议可以使用 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 方法异步处理传入的连接尝试。</span><span class="sxs-lookup"><span data-stu-id="42801-196">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="42801-197">异步接受连接使你能够在单独的执行线程中发送和接收数据。</span><span class="sxs-lookup"><span data-stu-id="42801-197">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="42801-198">在调用 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 方法之前，必须调用 <xref:System.Net.Sockets.Socket.Listen%2A> 方法来侦听传入连接请求并对其进行排队。</span><span class="sxs-lookup"><span data-stu-id="42801-198">Before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="42801-199">若要在完成时收到通知，必须创建一个回调方法，用于实现 EventHandler\<SocketAsyncEventArgs > 委托，并将其挂接到 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 事件。</span><span class="sxs-lookup"><span data-stu-id="42801-199">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and hook it to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="42801-200">需要 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 对象上的下列属性和事件：</span><span class="sxs-lookup"><span data-stu-id="42801-200">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="42801-201">调用方可以选择指定要用于传入连接的现有 <xref:System.Net.Sockets.Socket>，方法是指定要与 <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> 属性一起使用的 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-201">The caller can optionally specify an existing <xref:System.Net.Sockets.Socket> to use for the incoming connection by specifying the <xref:System.Net.Sockets.Socket> to use with the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="42801-202">如果 <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> 属性为 null，则将使用与当前 <xref:System.Net.Sockets.Socket.ProtocolType%2A> 相同的 <xref:System.Net.Sockets.Socket.AddressFamily%2A>、<xref:System.Net.Sockets.Socket.SocketType%2A>和 <xref:System.Net.Sockets.Socket> 构造新 <xref:System.Net.Sockets.Socket>，并将其设置为 <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="42801-202">If the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property is null, a new <xref:System.Net.Sockets.Socket> is constructed with the same <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, and <xref:System.Net.Sockets.Socket.ProtocolType%2A> as the current <xref:System.Net.Sockets.Socket> and set as the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="42801-203">调用方可以在调用 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 方法之前将 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 属性设置为所需的任何用户状态对象，以便可以在回调方法中检索信息。</span><span class="sxs-lookup"><span data-stu-id="42801-203">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="42801-204">如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。</span><span class="sxs-lookup"><span data-stu-id="42801-204">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="42801-205">（可选）可以在 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法成功完成后，提供缓冲区，用于接收套接字上的初始数据块。</span><span class="sxs-lookup"><span data-stu-id="42801-205">Optionally, a buffer may be provided in which to receive the initial block of data on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="42801-206">在这种情况下，需要将 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 属性设置为包含要接收数据的缓冲区，并且 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 属性需要设置为要在缓冲区中接收的数据的最大字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-206">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to receive and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the maximum number of bytes of data to receive in the buffer.</span></span> <span data-ttu-id="42801-207">可以使用 <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> 方法设置这些属性。</span><span class="sxs-lookup"><span data-stu-id="42801-207">These properties can be set using the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="42801-208">传入的缓冲区部分将在内部使用，供基础 Winsock AcceptEx 调用使用。</span><span class="sxs-lookup"><span data-stu-id="42801-208">Part of the buffer passed in will be consumed internally for use by the underlying Winsock AcceptEx call.</span></span> <span data-ttu-id="42801-209">这意味着返回的数据量将始终小于提供的 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 实例的 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 属性的值。</span><span class="sxs-lookup"><span data-stu-id="42801-209">This means that the amount of data returned will always be less than the value of the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> instance provided.</span></span> <span data-ttu-id="42801-210">基于套接字的地址族，在内部使用的缓冲区量会有所不同。</span><span class="sxs-lookup"><span data-stu-id="42801-210">The amount of the buffer used internally varies based on the address family of the socket.</span></span> <span data-ttu-id="42801-211">所需的最小缓冲区大小为288个字节。</span><span class="sxs-lookup"><span data-stu-id="42801-211">The minimum buffer size required is 288 bytes.</span></span> <span data-ttu-id="42801-212">如果指定较大的缓冲区大小，则 <xref:System.Net.Sockets.Socket> 将需要一些额外的数据（而不是 Winsock AcceptEx 调用接收到的地址数据），并将等待，直到收到此额外的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-212">If a larger buffer size is specified, then the <xref:System.Net.Sockets.Socket> will expect some extra data other than the address data received by the Winsock AcceptEx call and will wait until this extra data is received.</span></span> <span data-ttu-id="42801-213">如果发生超时，则会重置连接。</span><span class="sxs-lookup"><span data-stu-id="42801-213">If a timeout occurs, the connection is reset.</span></span> <span data-ttu-id="42801-214">因此，如果特定金额需要额外数据，则应将缓冲区大小设置为最小缓冲区大小加上此量。</span><span class="sxs-lookup"><span data-stu-id="42801-214">So if extra data is expected of  a specific amount, then the buffer size should be set to the minimum buffer size plus this amount.</span></span>  
  
 <span data-ttu-id="42801-215">完成回调方法应检查 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> 属性以确定 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 操作是否成功。</span><span class="sxs-lookup"><span data-stu-id="42801-215">The completion callback method should examine the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> property to determine if the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> operation was successful.</span></span>  
  
 <span data-ttu-id="42801-216">在某些情况下，如果未接受连接并导致 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> 属性设置为 <xref:System.Net.Sockets.SocketError.ConnectionReset>，则可能发生 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 事件。</span><span class="sxs-lookup"><span data-stu-id="42801-216">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event can occur in some cases when no connection has been accepted and cause the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> property to be set to <xref:System.Net.Sockets.SocketError.ConnectionReset>.</span></span> <span data-ttu-id="42801-217">这种情况可能是通过使用半开放式 SYN 类型扫描（SYN > SYN-ACK-> RST 序列）进行端口扫描引起的。</span><span class="sxs-lookup"><span data-stu-id="42801-217">This can occur as a result of port scanning using a half-open SYN type scan (a SYN -> SYN-ACK -> RST sequence).</span></span> <span data-ttu-id="42801-218">应准备使用 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 方法的应用程序来处理这种情况。</span><span class="sxs-lookup"><span data-stu-id="42801-218">Applications using the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method should be prepared to handle this condition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-219">自变量无效。</span><span class="sxs-lookup"><span data-stu-id="42801-219">An argument is not valid.</span></span> <span data-ttu-id="42801-220">如果所提供的缓冲区不够大，将会发生此异常。</span><span class="sxs-lookup"><span data-stu-id="42801-220">This exception occurs if the buffer provided is not large enough.</span></span> <span data-ttu-id="42801-221">缓冲区必须至少为 2 \* (sizeof(SOCKADDR_STORAGE + 16) 字节。</span><span class="sxs-lookup"><span data-stu-id="42801-221">The buffer must be at least 2 \* (sizeof(SOCKADDR_STORAGE + 16) bytes.</span></span>  
  
<span data-ttu-id="42801-222">如果指定了多个缓冲区，即 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 属性不为 null，也会发生此异常。</span><span class="sxs-lookup"><span data-stu-id="42801-222">This exception also occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-223">参数超出范围。</span><span class="sxs-lookup"><span data-stu-id="42801-223">An argument is out of range.</span></span> <span data-ttu-id="42801-224">如果 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> 小于 0，将会发生此异常。</span><span class="sxs-lookup"><span data-stu-id="42801-224">The exception occurs if the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-225">请求了无效操作。</span><span class="sxs-lookup"><span data-stu-id="42801-225">An invalid operation was requested.</span></span> <span data-ttu-id="42801-226">如果接收方 <see cref="T:System.Net.Sockets.Socket" /> 未侦听连接或者绑定了接受的套接字，将发生此异常。</span><span class="sxs-lookup"><span data-stu-id="42801-226">This exception occurs if the accepting <see cref="T:System.Net.Sockets.Socket" /> is not listening for connections or the accepted socket is bound.</span></span>  
  
<span data-ttu-id="42801-227"><see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 和 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 方法必须先于 <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> 方法调用。</span><span class="sxs-lookup"><span data-stu-id="42801-227">You must call the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> method before calling the <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method.</span></span>  
  
<span data-ttu-id="42801-228">如果套接字已连接或使用指定的 <paramref name="e" /> 参数的套接字操作已经在进行中，也会发生此异常。</span><span class="sxs-lookup"><span data-stu-id="42801-228">This exception also occurs if the socket is already connected or a socket operation was already in progress using the specified <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-229">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-229">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-230">此方法需要 Windows XP 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="42801-230">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-231"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-231">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-232">获取 <see cref="T:System.Net.Sockets.Socket" /> 的地址族。</span><span class="sxs-lookup"><span data-stu-id="42801-232">Gets the address family of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="42801-233"><see cref="T:System.Net.Sockets.AddressFamily" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-233">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-234"><xref:System.Net.Sockets.AddressFamily> 指定 <xref:System.Net.Sockets.Socket> 类的实例可以使用的寻址方案。</span><span class="sxs-lookup"><span data-stu-id="42801-234">The <xref:System.Net.Sockets.AddressFamily> specifies the addressing scheme that an instance of the <xref:System.Net.Sockets.Socket> class can use.</span></span> <span data-ttu-id="42801-235">此属性是只读的，在创建 <xref:System.Net.Sockets.Socket> 时设置。</span><span class="sxs-lookup"><span data-stu-id="42801-235">This property is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-236">下面的代码示例显示控制台 <xref:System.Net.Sockets.AddressFamily>、<xref:System.Net.Sockets.SocketType>和 <xref:System.Net.Sockets.ProtocolType>。</span><span class="sxs-lookup"><span data-stu-id="42801-236">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-237">获取已经从网络接收且可供读取的数据量。</span><span class="sxs-lookup"><span data-stu-id="42801-237">Gets the amount of data that has been received from the network and is available to be read.</span></span></summary>
        <value><span data-ttu-id="42801-238">从网络接收的、可供读取的数据的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-238">The number of bytes of data received from the network and available to be read.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-239">如果使用非阻塞 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Available%2A> 是在调用 <xref:System.Net.Sockets.Socket.Receive%2A>之前确定数据是否排队等待读取的好方法。</span><span class="sxs-lookup"><span data-stu-id="42801-239">If you are using a non-blocking <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> is a good way to determine whether data is queued for reading, before calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="42801-240">可用数据是要读取的网络缓冲区中排队的数据总量。</span><span class="sxs-lookup"><span data-stu-id="42801-240">The available data is the total amount of data queued in the network buffer for reading.</span></span> <span data-ttu-id="42801-241">如果网络缓冲区中没有数据排队，<xref:System.Net.Sockets.Socket.Available%2A> 将返回0。</span><span class="sxs-lookup"><span data-stu-id="42801-241">If no data is queued in the network buffer, <xref:System.Net.Sockets.Socket.Available%2A> returns 0.</span></span>  
  
 <span data-ttu-id="42801-242">如果远程主机关闭或关闭连接，<xref:System.Net.Sockets.Socket.Available%2A> 可能会引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-242">If the remote host shuts down or closes the connection, <xref:System.Net.Sockets.Socket.Available%2A> can throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-243">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-243">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-244">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-244">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-245">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-245">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-246">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-246">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-247">下面的代码示例将调用 IOControl 和 FIONREAD 以及可用属性的结果进行比较。</span><span class="sxs-lookup"><span data-stu-id="42801-247">The following code example compares the results of calling IOControl with FIONREAD and the Available property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-248">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-248">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-249"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-249">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42801-250">开始一个异步操作来接受一个传入的连接尝试。</span><span class="sxs-lookup"><span data-stu-id="42801-250">Begins an asynchronous operation to accept an incoming connection attempt.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="callback"><span data-ttu-id="42801-251"><see cref="T:System.AsyncCallback" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="42801-251">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="42801-252">包含此请求的状态信息的对象。</span><span class="sxs-lookup"><span data-stu-id="42801-252">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="42801-253">开始一个异步操作来接受一个传入的连接尝试。</span><span class="sxs-lookup"><span data-stu-id="42801-253">Begins an asynchronous operation to accept an incoming connection attempt.</span></span></summary>
        <returns><span data-ttu-id="42801-254">一个 <see cref="T:System.IAsyncResult" />，它引用异步 <see cref="T:System.Net.Sockets.Socket" /> 创建。</span><span class="sxs-lookup"><span data-stu-id="42801-254">An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-255">面向连接的协议可以使用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法异步处理传入的连接尝试。</span><span class="sxs-lookup"><span data-stu-id="42801-255">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="42801-256">异步接受连接使你能够在单独的执行线程中发送和接收数据。</span><span class="sxs-lookup"><span data-stu-id="42801-256">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="42801-257">在调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法之前，必须调用 <xref:System.Net.Sockets.Socket.Listen%2A> 方法来侦听传入连接请求并对其进行排队。</span><span class="sxs-lookup"><span data-stu-id="42801-257">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="42801-258">必须创建实现 <xref:System.AsyncCallback> 委托的回调方法，并将其名称传递到 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-258">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="42801-259">为此，必须至少通过 `state` 参数将侦听 <xref:System.Net.Sockets.Socket> 对象传递给 <xref:System.Net.Sockets.Socket.BeginAccept%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-259">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="42801-260">如果回调需要更多的信息，可以创建一个小类来容纳 <xref:System.Net.Sockets.Socket> 和其他所需的信息。</span><span class="sxs-lookup"><span data-stu-id="42801-260">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="42801-261">通过 `state` 参数将此类的实例传递给 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-261">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="42801-262">回调方法应调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-262">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="42801-263">当应用程序调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A>时，系统通常使用单独的线程来执行指定的回调方法，并在 <xref:System.Net.Sockets.Socket.EndAccept%2A> 上阻止，直到检索到挂起的连接。</span><span class="sxs-lookup"><span data-stu-id="42801-263">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span> <span data-ttu-id="42801-264"><xref:System.Net.Sockets.Socket.EndAccept%2A> 将返回一个新的 <xref:System.Net.Sockets.Socket> 对象，可用于发送和接收与远程主机的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-264"><xref:System.Net.Sockets.Socket.EndAccept%2A> will return a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="42801-265">不能使用返回的 <xref:System.Net.Sockets.Socket> 接受来自连接队列的任何其他连接。</span><span class="sxs-lookup"><span data-stu-id="42801-265">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="42801-266">如果希望在调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法后原始线程被阻止，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="42801-266">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-267">如果希望原始线程继续执行，请在回调方法中的 <xref:System.Threading.ManualResetEvent> 上调用 Set 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-267">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="42801-268">系统还可以使用调用线程调用回调方法。</span><span class="sxs-lookup"><span data-stu-id="42801-268">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="42801-269">在这种情况下，返回 <xref:System.IAsyncResult> 上的 <xref:System.IAsyncResult.CompletedSynchronously%2A> 属性将设置为指示 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法同步完成。</span><span class="sxs-lookup"><span data-stu-id="42801-269">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="42801-270">有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-270">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="42801-271">若要取消对 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法的挂起调用，请关闭 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-271">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-272">当异步操作正在进行时调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法时，会调用向 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法提供的回调。</span><span class="sxs-lookup"><span data-stu-id="42801-272">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="42801-273">对 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法的后续调用将引发 <xref:System.ObjectDisposedException>，以指示该操作已取消。</span><span class="sxs-lookup"><span data-stu-id="42801-273">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-274">您可以使用返回的 <xref:System.Net.Sockets.Socket> 的 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 属性来识别远程主机的网络地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-274">You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-275">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-275">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-276">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-276">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-277">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-277">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-278">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-278">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-279">对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。</span><span class="sxs-lookup"><span data-stu-id="42801-279">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="42801-280">第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。</span><span class="sxs-lookup"><span data-stu-id="42801-280">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-281">下面的代码示例尝试异步接收传入连接。</span><span class="sxs-lookup"><span data-stu-id="42801-281">The following code example attempts to receive an incoming connection asynchronously.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-282"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-282">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-283">此方法需要 Windows NT。</span><span class="sxs-lookup"><span data-stu-id="42801-283">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-284">正在接受的套接字不会侦听连接。</span><span class="sxs-lookup"><span data-stu-id="42801-284">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="42801-285">在调用 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前必须调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="42801-285">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span>  
  
<span data-ttu-id="42801-286">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-286">-or-</span></span> 
<span data-ttu-id="42801-287">已接受的套接字是绑定的。</span><span class="sxs-lookup"><span data-stu-id="42801-287">The accepted socket is bound.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-288"><paramref name="receiveSize" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-288"><paramref name="receiveSize" /> is less than 0.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-289">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-289">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="42801-290">异步客户端套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-290">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="42801-291">异步服务器套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-291">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="receiveSize"><span data-ttu-id="42801-292">要从发送方读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-292">The number of bytes to accept from the sender.</span></span></param>
        <param name="callback"><span data-ttu-id="42801-293"><see cref="T:System.AsyncCallback" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="42801-293">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="42801-294">包含此请求的状态信息的对象。</span><span class="sxs-lookup"><span data-stu-id="42801-294">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="42801-295">开始异步操作以接受传入的连接尝试并接收客户端应用程序发送的第一个数据块。</span><span class="sxs-lookup"><span data-stu-id="42801-295">Begins an asynchronous operation to accept an incoming connection attempt and receives the first block of data sent by the client application.</span></span></summary>
        <returns><span data-ttu-id="42801-296">一个 <see cref="T:System.IAsyncResult" />，它引用异步 <see cref="T:System.Net.Sockets.Socket" /> 创建。</span><span class="sxs-lookup"><span data-stu-id="42801-296">An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-297">面向连接的协议可以使用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法异步处理传入的连接尝试。</span><span class="sxs-lookup"><span data-stu-id="42801-297">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="42801-298">通过异步接受连接，可以在单独的执行线程中发送和接收数据。</span><span class="sxs-lookup"><span data-stu-id="42801-298">Accepting connections asynchronously enables you to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="42801-299">此重载允许您指定要在 `receiveSize` 参数的初始传输中接受的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-299">This overload allows you to specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.</span></span>  
  
 <span data-ttu-id="42801-300">在调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法之前，必须调用 <xref:System.Net.Sockets.Socket.Listen%2A> 方法来侦听传入连接请求并对其进行排队。</span><span class="sxs-lookup"><span data-stu-id="42801-300">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="42801-301">必须创建实现 <xref:System.AsyncCallback> 委托的回调方法，并将其名称传递到 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-301">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="42801-302">为此，必须至少通过 `state` 参数将侦听 <xref:System.Net.Sockets.Socket> 对象传递给 <xref:System.Net.Sockets.Socket.BeginAccept%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-302">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="42801-303">如果回调需要更多的信息，可以创建一个小类来容纳 <xref:System.Net.Sockets.Socket> 和其他所需的信息。</span><span class="sxs-lookup"><span data-stu-id="42801-303">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="42801-304">通过 `state` 参数将此类的实例传递给 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-304">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="42801-305">回调方法应调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-305">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="42801-306">当应用程序调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A>时，系统通常使用单独的线程来执行指定的回调方法，并在 <xref:System.Net.Sockets.Socket.EndAccept%2A> 上阻止，直到检索到挂起的连接。</span><span class="sxs-lookup"><span data-stu-id="42801-306">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span>  
  
 <span data-ttu-id="42801-307"><xref:System.Net.Sockets.Socket.EndAccept%2A> 返回一个新的 <xref:System.Net.Sockets.Socket>，可用于发送和接收与远程主机的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-307"><xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="42801-308">不能使用返回的 <xref:System.Net.Sockets.Socket> 接受来自连接队列的任何其他连接。</span><span class="sxs-lookup"><span data-stu-id="42801-308">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="42801-309">如果希望在调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法后原始线程被阻止，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="42801-309">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-310">如果希望原始线程继续执行，请在回调方法中的 <xref:System.Threading.ManualResetEvent> 上调用 Set 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-310">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="42801-311">系统还可以使用调用线程调用回调方法。</span><span class="sxs-lookup"><span data-stu-id="42801-311">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="42801-312">在这种情况下，返回 <xref:System.IAsyncResult> 上的 <xref:System.IAsyncResult.CompletedSynchronously%2A> 属性将设置为指示 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法同步完成。</span><span class="sxs-lookup"><span data-stu-id="42801-312">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="42801-313">有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-313">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="42801-314">若要取消对 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法的挂起调用，请关闭 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-314">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span>  <span data-ttu-id="42801-315">当异步操作正在进行时调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法时，会调用向 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法提供的回调。</span><span class="sxs-lookup"><span data-stu-id="42801-315">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="42801-316">对 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法的后续调用将引发 <xref:System.ObjectDisposedException>，以指示该操作已取消。</span><span class="sxs-lookup"><span data-stu-id="42801-316">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-317">可以调用使用返回的 <xref:System.Net.Sockets.Socket> 对象的 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 属性来识别远程主机的网络地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-317">You can call use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-318">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-318">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-319">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-319">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-320">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-320">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-321">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-321">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-322">对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。</span><span class="sxs-lookup"><span data-stu-id="42801-322">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="42801-323">第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。</span><span class="sxs-lookup"><span data-stu-id="42801-323">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-324">下面的代码示例打开套接字并接受异步连接。</span><span class="sxs-lookup"><span data-stu-id="42801-324">The following code example opens a socket and accepts an asynchronous connection.</span></span> <span data-ttu-id="42801-325">在此示例中，套接字接受前10个字节的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-325">In this example, the socket accepts the initial 10 bytes of data.</span></span> <span data-ttu-id="42801-326">回调委托将接收的字节数和数据显示在控制台上。</span><span class="sxs-lookup"><span data-stu-id="42801-326">The number of bytes received and the data are displayed on the console by the callback delegate.</span></span> <span data-ttu-id="42801-327">有关如何接收剩余数据的说明，请参阅 <xref:System.Net.Sockets.Socket.BeginReceive%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-327">See <xref:System.Net.Sockets.Socket.BeginReceive%2A> for a description of how the remaining data is received.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-328"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-328">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-329">此方法需要 Windows NT。</span><span class="sxs-lookup"><span data-stu-id="42801-329">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-330">正在接受的套接字不会侦听连接。</span><span class="sxs-lookup"><span data-stu-id="42801-330">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="42801-331">在调用 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前必须调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="42801-331">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span>  
  
<span data-ttu-id="42801-332">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-332">-or-</span></span> 
<span data-ttu-id="42801-333">已接受的套接字是绑定的。</span><span class="sxs-lookup"><span data-stu-id="42801-333">The accepted socket is bound.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-334"><paramref name="receiveSize" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-334"><paramref name="receiveSize" /> is less than 0.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-335">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-335">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="42801-336">异步客户端套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-336">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="42801-337">异步服务器套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-337">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="receiveSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="acceptSocket"><span data-ttu-id="42801-338">接受的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="42801-338">The accepted <see cref="T:System.Net.Sockets.Socket" /> object.</span></span> <span data-ttu-id="42801-339">此值可为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-339">This value may be <see langword="null" />.</span></span></param>
        <param name="receiveSize"><span data-ttu-id="42801-340">要接收的最大字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-340">The maximum number of bytes to receive.</span></span></param>
        <param name="callback"><span data-ttu-id="42801-341"><see cref="T:System.AsyncCallback" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="42801-341">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="42801-342">包含此请求的状态信息的对象。</span><span class="sxs-lookup"><span data-stu-id="42801-342">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="42801-343">开始异步操作以接受从指定套接字传入的连接尝试并接收客户端应用程序发送的第一个数据块。</span><span class="sxs-lookup"><span data-stu-id="42801-343">Begins an asynchronous operation to accept an incoming connection attempt from a specified socket and receives the first block of data sent by the client application.</span></span></summary>
        <returns><span data-ttu-id="42801-344">一个 <see cref="T:System.IAsyncResult" /> 对象，它引用异步 <see cref="T:System.Net.Sockets.Socket" /> 对象创建。</span><span class="sxs-lookup"><span data-stu-id="42801-344">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> object creation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-345">面向连接的协议可以使用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法异步处理传入的连接尝试。</span><span class="sxs-lookup"><span data-stu-id="42801-345">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="42801-346">异步接受连接使你能够在单独的执行线程中发送和接收数据。</span><span class="sxs-lookup"><span data-stu-id="42801-346">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="42801-347">此重载允许您在 `acceptSocket` 参数中指定已接受的套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-347">This overload allows you to specify the accepted socket in the `acceptSocket` parameter.</span></span> <span data-ttu-id="42801-348">如果 `null`此参数，则将通过 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法创建已接受的套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-348">If this parameter is `null`, the accepted socket is created by the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="42801-349">可以在 `receiveSize` 参数的初始传输中指定要接受的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-349">You can specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.</span></span>  
  
 <span data-ttu-id="42801-350">在调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法之前，必须调用 <xref:System.Net.Sockets.Socket.Listen%2A> 方法来侦听传入连接请求并对其进行排队。</span><span class="sxs-lookup"><span data-stu-id="42801-350">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="42801-351">必须创建实现 <xref:System.AsyncCallback> 委托的回调方法，并将其名称传递到 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-351">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="42801-352">为此，必须至少通过 `state` 参数将侦听 <xref:System.Net.Sockets.Socket> 对象传递给 <xref:System.Net.Sockets.Socket.BeginAccept%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-352">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="42801-353">如果回调需要更多的信息，可以创建一个小类来容纳 <xref:System.Net.Sockets.Socket> 和其他所需的信息。</span><span class="sxs-lookup"><span data-stu-id="42801-353">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="42801-354">通过 `state` 参数将此类的实例传递给 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-354">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="42801-355">回调方法应调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-355">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="42801-356">当应用程序调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A>时，系统通常使用单独的线程来执行指定的回调方法，并在 <xref:System.Net.Sockets.Socket.EndAccept%2A> 上阻止，直到检索到挂起的连接。</span><span class="sxs-lookup"><span data-stu-id="42801-356">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span>  
  
 <span data-ttu-id="42801-357"><xref:System.Net.Sockets.Socket.EndAccept%2A> 返回一个新的 <xref:System.Net.Sockets.Socket> 对象，可用于发送和接收与远程主机的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-357"><xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="42801-358">不能使用返回的 <xref:System.Net.Sockets.Socket> 接受来自连接队列的任何其他连接。</span><span class="sxs-lookup"><span data-stu-id="42801-358">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="42801-359">如果希望在调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法后原始线程被阻止，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="42801-359">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-360">如果希望原始线程继续执行，请在回调方法中的 <xref:System.Threading.ManualResetEvent> 上调用 Set 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-360">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="42801-361">系统还可以使用调用线程调用回调方法。</span><span class="sxs-lookup"><span data-stu-id="42801-361">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="42801-362">在这种情况下，返回 <xref:System.IAsyncResult> 上的 <xref:System.IAsyncResult.CompletedSynchronously%2A> 属性将设置为指示 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法同步完成。</span><span class="sxs-lookup"><span data-stu-id="42801-362">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="42801-363">有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-363">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="42801-364">若要取消对 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法的挂起调用，请关闭 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-364">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-365">当异步操作正在进行时调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法时，会调用向 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法提供的回调。</span><span class="sxs-lookup"><span data-stu-id="42801-365">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="42801-366">对 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法的后续调用将引发 <xref:System.ObjectDisposedException>，以指示该操作已取消。</span><span class="sxs-lookup"><span data-stu-id="42801-366">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-367">您可以使用返回的 <xref:System.Net.Sockets.Socket> 对象的 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 属性来识别远程主机的网络地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-367">You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-368">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-368">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-369">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-369">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-370">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-370">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-371">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-371">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-372">对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。</span><span class="sxs-lookup"><span data-stu-id="42801-372">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="42801-373">第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。</span><span class="sxs-lookup"><span data-stu-id="42801-373">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-374">下面的代码示例打开套接字并接受异步连接。</span><span class="sxs-lookup"><span data-stu-id="42801-374">The following code example opens a socket and accepts an asynchronous connection.</span></span> <span data-ttu-id="42801-375">在此示例中，套接字接受前10个字节的数据，`acceptSocket` 参数 `null`，这将强制 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法创建接受的套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-375">In this example, the socket accepts the initial 10 bytes of data and the `acceptSocket` parameter is `null`, which forces the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to create the accepted socket.</span></span> <span data-ttu-id="42801-376">回调委托将接收的字节数和数据显示在控制台上。</span><span class="sxs-lookup"><span data-stu-id="42801-376">The number of bytes received and the data are displayed on the console by the callback delegate.</span></span> <span data-ttu-id="42801-377">有关如何接收剩余数据的说明，请参阅 <xref:System.Net.Sockets.Socket.BeginReceive%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-377">See <xref:System.Net.Sockets.Socket.BeginReceive%2A> for a description of how the remaining data is received.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-378"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-378">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-379">此方法需要 Windows NT。</span><span class="sxs-lookup"><span data-stu-id="42801-379">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-380">正在接受的套接字不会侦听连接。</span><span class="sxs-lookup"><span data-stu-id="42801-380">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="42801-381">在调用 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前必须调用 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="42801-381">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span>  
  
<span data-ttu-id="42801-382">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-382">-or-</span></span> 
<span data-ttu-id="42801-383">已接受的套接字是绑定的。</span><span class="sxs-lookup"><span data-stu-id="42801-383">The accepted socket is bound.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-384"><paramref name="receiveSize" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-384"><paramref name="receiveSize" /> is less than 0.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-385">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-385">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="42801-386">异步客户端套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-386">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="42801-387">异步服务器套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-387">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42801-388">开始一个对远程主机连接的异步请求。</span><span class="sxs-lookup"><span data-stu-id="42801-388">Begins an asynchronous request for a remote host connection.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (remoteEP, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP"><span data-ttu-id="42801-389">表示远程主机的 <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="42801-389">An <see cref="T:System.Net.EndPoint" /> that represents the remote host.</span></span></param>
        <param name="end_point"><span data-ttu-id="42801-390">表示远程主机的 <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="42801-390">An <see cref="T:System.Net.EndPoint" /> that represents the remote host.</span></span></param>
        <param name="callback"><span data-ttu-id="42801-391"><see cref="T:System.AsyncCallback" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="42801-391">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="42801-392">包含此请求的状态信息的对象。</span><span class="sxs-lookup"><span data-stu-id="42801-392">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="42801-393">开始一个对远程主机连接的异步请求。</span><span class="sxs-lookup"><span data-stu-id="42801-393">Begins an asynchronous request for a remote host connection.</span></span></summary>
        <returns><span data-ttu-id="42801-394">引用异步连接的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="42801-394">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-395">如果你使用的是面向连接的协议，则 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法会启动到 `remoteEP` 参数的连接的异步请求。</span><span class="sxs-lookup"><span data-stu-id="42801-395">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method starts an asynchronous request for a connection to the `remoteEP` parameter.</span></span> <span data-ttu-id="42801-396">如果使用的是无连接协议，<xref:System.Net.Sockets.Socket.BeginConnect%2A> 会建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-396">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.BeginConnect%2A> establishes a default remote host.</span></span> <span data-ttu-id="42801-397">使用异步方式连接或设置默认远程主机使你能够在单独的执行线程中发送和接收数据。</span><span class="sxs-lookup"><span data-stu-id="42801-397">Connecting or setting the default remote host asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="42801-398">你可以创建一个实现 <xref:System.AsyncCallback> 委托的回调方法，并将其名称传递到 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-398">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method.</span></span> <span data-ttu-id="42801-399">至少必须将 <xref:System.Net.Sockets.Socket> 传递到 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 通过 `state` 参数。</span><span class="sxs-lookup"><span data-stu-id="42801-399">At the very minimum, you must pass the <xref:System.Net.Sockets.Socket> to <xref:System.Net.Sockets.Socket.BeginConnect%2A> through the `state` parameter.</span></span> <span data-ttu-id="42801-400">如果回调需要更多的信息，可以创建一个小类来保存 <xref:System.Net.Sockets.Socket>，并创建其他必需的信息。</span><span class="sxs-lookup"><span data-stu-id="42801-400">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information.</span></span> <span data-ttu-id="42801-401">通过 `state` 参数将此类的实例传递给 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-401">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="42801-402">回调方法应调用 <xref:System.Net.Sockets.Socket.EndConnect%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-402">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="42801-403">当应用程序调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A>时，系统将使用一个单独的线程来执行指定的回调方法，并将在 <xref:System.Net.Sockets.Socket.EndConnect%2A> 上受阻，直到 <xref:System.Net.Sockets.Socket> 成功连接或引发异常。</span><span class="sxs-lookup"><span data-stu-id="42801-403">When your application calls <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndConnect%2A> until the <xref:System.Net.Sockets.Socket> connects successfully or throws an exception.</span></span> <span data-ttu-id="42801-404">如果希望在调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法后原始线程被阻止，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-404">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="42801-405">如果希望原始线程继续执行，请在回调方法中的 <xref:System.Threading.ManualResetEvent> 上调用 Set 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-405">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="42801-406">有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-406">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="42801-407">如果使用的是无连接协议（如 UDP），则在发送和接收数据之前无需调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-407">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.BeginConnect%2A> before sending and receiving data.</span></span> <span data-ttu-id="42801-408">您可以使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 和 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 与远程主机通信。</span><span class="sxs-lookup"><span data-stu-id="42801-408">You can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> to communicate with a remote host.</span></span> <span data-ttu-id="42801-409">如果调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A>，则从指定的默认值以外的地址到达的任何数据报都将被丢弃。</span><span class="sxs-lookup"><span data-stu-id="42801-409">If you do call <xref:System.Net.Sockets.Socket.BeginConnect%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="42801-410">如果要将默认远程主机设置为广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 并将广播设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="42801-410">If you wish to set your default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="42801-411">如果无法做到这一点，<xref:System.Net.Sockets.Socket.BeginConnect%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-411">If you cannot, <xref:System.Net.Sockets.Socket.BeginConnect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="42801-412">如果使用面向连接的协议，且在调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A>之前未调用 <xref:System.Net.Sockets.Socket.Bind%2A>，则基础服务提供程序将分配最适当的本地网络地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-412">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="42801-413">如果使用的是无连接协议，则在调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 或 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法之前，服务提供程序将不会分配本地网络地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-413">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="42801-414">如果要更改默认远程主机，请通过所需的终结点再次调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-414">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="42801-415">若要取消对 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法的挂起调用，请关闭 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-415">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-416">当异步操作正在进行时调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法时，会调用向 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法提供的回调。</span><span class="sxs-lookup"><span data-stu-id="42801-416">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="42801-417">对 <xref:System.Net.Sockets.Socket.EndConnect%2A> 方法的后续调用将引发 <xref:System.ObjectDisposedException>，以指示该操作已取消。</span><span class="sxs-lookup"><span data-stu-id="42801-417">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-418">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-418">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-419">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-419">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-420">如果此套接字之前已断开连接，则必须在操作完成之前，将不会退出的线程上调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-420">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="42801-421">这是底层提供程序的限制。</span><span class="sxs-lookup"><span data-stu-id="42801-421">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-422">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-422">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-423">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-423">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-424">对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。</span><span class="sxs-lookup"><span data-stu-id="42801-424">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="42801-425">第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。</span><span class="sxs-lookup"><span data-stu-id="42801-425">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-426">下面的代码示例启动异步连接尝试。</span><span class="sxs-lookup"><span data-stu-id="42801-426">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-427"><paramref name="remoteEP" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-427"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-428">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-428">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-429"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-429">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="42801-430">调用堆栈中的较高调用方无权执行所请求的操作。</span><span class="sxs-lookup"><span data-stu-id="42801-430">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-431">已通过调用 <see cref="T:System.Net.Sockets.Socket" /> 将 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 置于侦听状态，或异步操作已在进行中。</span><span class="sxs-lookup"><span data-stu-id="42801-431">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="42801-432">将委托作为回调方法进行封送</span><span class="sxs-lookup"><span data-stu-id="42801-432">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="42801-433">异步客户端套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-433">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="42801-434">异步服务器套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-434">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, requestCallback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="42801-435">远程主机的 <see cref="T:System.Net.IPAddress" />。</span><span class="sxs-lookup"><span data-stu-id="42801-435">The <see cref="T:System.Net.IPAddress" /> of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="42801-436">远程主机的端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-436">The port number of the remote host.</span></span></param>
        <param name="requestCallback"><span data-ttu-id="42801-437">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用连接操作完成时要调用的方法。</span><span class="sxs-lookup"><span data-stu-id="42801-437">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="callback"><span data-ttu-id="42801-438">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用连接操作完成时要调用的方法。</span><span class="sxs-lookup"><span data-stu-id="42801-438">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="42801-439">一个用户定义对象，其中包含连接操作的相关信息。</span><span class="sxs-lookup"><span data-stu-id="42801-439">A user-defined object that contains information about the connect operation.</span></span> <span data-ttu-id="42801-440">当操作完成时，此对象会被传递给 <paramref name="requestCallback" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="42801-440">This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="42801-441">开始一个对远程主机连接的异步请求。</span><span class="sxs-lookup"><span data-stu-id="42801-441">Begins an asynchronous request for a remote host connection.</span></span> <span data-ttu-id="42801-442">主机由 <see cref="T:System.Net.IPAddress" /> 和端口号指定。</span><span class="sxs-lookup"><span data-stu-id="42801-442">The host is specified by an <see cref="T:System.Net.IPAddress" /> and a port number.</span></span></summary>
        <returns><span data-ttu-id="42801-443">引用异步连接的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="42801-443">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-444">异步 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 操作必须通过调用 <xref:System.Net.Sockets.Socket.EndConnect%2A> 方法完成。</span><span class="sxs-lookup"><span data-stu-id="42801-444">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="42801-445">通常，方法由 `requestCallback` 委托调用。</span><span class="sxs-lookup"><span data-stu-id="42801-445">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="42801-446">在操作完成之前，此方法不会被阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-446">This method does not block until the operation is complete.</span></span> <span data-ttu-id="42801-447">若要在操作完成之前一直阻止，请使用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法重载之一，或 <xref:System.Net.Sockets.Socket.EndConnect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-447">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads, or <xref:System.Net.Sockets.Socket.EndConnect%2A>.</span></span>  
  
 <span data-ttu-id="42801-448">若要取消对 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法的挂起调用，请关闭 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-448">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-449">当异步操作正在进行时调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法时，会调用向 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法提供的回调。</span><span class="sxs-lookup"><span data-stu-id="42801-449">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="42801-450">对 <xref:System.Net.Sockets.Socket.EndConnect%2A> 方法的后续调用将引发 <xref:System.ObjectDisposedException>，以指示该操作已取消。</span><span class="sxs-lookup"><span data-stu-id="42801-450">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="42801-451">有关使用异步编程模型的详细信息，请参阅[以异步方式调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="42801-451">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-452">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-452">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-453">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-453">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-454">如果此套接字之前已断开连接，则必须在操作完成之前，将不会退出的线程上调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-454">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="42801-455">这是底层提供程序的限制。</span><span class="sxs-lookup"><span data-stu-id="42801-455">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="42801-456">使用的 <xref:System.Net.EndPoint> 也必须不同。</span><span class="sxs-lookup"><span data-stu-id="42801-456">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-457">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-457">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-458">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-458">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-459">对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。</span><span class="sxs-lookup"><span data-stu-id="42801-459">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="42801-460">第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。</span><span class="sxs-lookup"><span data-stu-id="42801-460">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-461">下面的代码示例启动异步连接尝试。</span><span class="sxs-lookup"><span data-stu-id="42801-461">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-462"><paramref name="address" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-462"><paramref name="address" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-463">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-463">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-464"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-464">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-465"><see cref="T:System.Net.Sockets.Socket" /> 不在套接字族中。</span><span class="sxs-lookup"><span data-stu-id="42801-465">The <see cref="T:System.Net.Sockets.Socket" /> is not in the socket family.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-466">端口号无效。</span><span class="sxs-lookup"><span data-stu-id="42801-466">The port number is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-467"><paramref name="address" /> 的长度为零。</span><span class="sxs-lookup"><span data-stu-id="42801-467">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-468">已通过调用 <see cref="T:System.Net.Sockets.Socket" /> 将 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 置于侦听状态，或异步操作已在进行中。</span><span class="sxs-lookup"><span data-stu-id="42801-468">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="42801-469">将委托作为回调方法进行封送</span><span class="sxs-lookup"><span data-stu-id="42801-469">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="42801-470">异步客户端套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-470">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="42801-471">异步服务器套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-471">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, requestCallback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="addresses"><span data-ttu-id="42801-472">至少一个用于指定远程主机的 <see cref="T:System.Net.IPAddress" />。</span><span class="sxs-lookup"><span data-stu-id="42801-472">At least one <see cref="T:System.Net.IPAddress" />, designating the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="42801-473">远程主机的端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-473">The port number of the remote host.</span></span></param>
        <param name="requestCallback"><span data-ttu-id="42801-474">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用连接操作完成时要调用的方法。</span><span class="sxs-lookup"><span data-stu-id="42801-474">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="callback"><span data-ttu-id="42801-475">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用连接操作完成时要调用的方法。</span><span class="sxs-lookup"><span data-stu-id="42801-475">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="42801-476">一个用户定义对象，其中包含连接操作的相关信息。</span><span class="sxs-lookup"><span data-stu-id="42801-476">A user-defined object that contains information about the connect operation.</span></span> <span data-ttu-id="42801-477">当操作完成时，此对象会被传递给 <paramref name="requestCallback" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="42801-477">This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="42801-478">开始一个对远程主机连接的异步请求。</span><span class="sxs-lookup"><span data-stu-id="42801-478">Begins an asynchronous request for a remote host connection.</span></span> <span data-ttu-id="42801-479">主机由 <see cref="T:System.Net.IPAddress" /> 数组和端口号指定。</span><span class="sxs-lookup"><span data-stu-id="42801-479">The host is specified by an <see cref="T:System.Net.IPAddress" /> array and a port number.</span></span></summary>
        <returns><span data-ttu-id="42801-480">引用异步连接的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="42801-480">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connections.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-481">异步 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 操作必须通过调用 <xref:System.Net.Sockets.Socket.EndConnect%2A> 方法完成。</span><span class="sxs-lookup"><span data-stu-id="42801-481">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="42801-482">通常，方法由 `requestCallback` 委托调用。</span><span class="sxs-lookup"><span data-stu-id="42801-482">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="42801-483">在操作完成之前，此方法不会被阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-483">This method does not block until the operation is complete.</span></span> <span data-ttu-id="42801-484">若要在操作完成之前一直阻止，请使用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法重载之一。</span><span class="sxs-lookup"><span data-stu-id="42801-484">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.</span></span>  
  
 <span data-ttu-id="42801-485">若要取消对 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法的挂起调用，请关闭 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-485">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-486">当异步操作正在进行时调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法时，会调用向 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法提供的回调。</span><span class="sxs-lookup"><span data-stu-id="42801-486">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="42801-487">对 <xref:System.Net.Sockets.Socket.EndConnect%2A> 方法的后续调用将引发 <xref:System.ObjectDisposedException>，以指示该操作已取消。</span><span class="sxs-lookup"><span data-stu-id="42801-487">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="42801-488">有关使用异步编程模型的详细信息，请参阅[以异步方式调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-488">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-489">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-489">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-490">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-490">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-491">如果此套接字之前已断开连接，则必须在操作完成之前，将不会退出的线程上调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-491">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="42801-492">这是底层提供程序的限制。</span><span class="sxs-lookup"><span data-stu-id="42801-492">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="42801-493">使用的 <xref:System.Net.EndPoint> 也必须不同。</span><span class="sxs-lookup"><span data-stu-id="42801-493">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-494">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-494">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-495">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-495">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-496">对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。</span><span class="sxs-lookup"><span data-stu-id="42801-496">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="42801-497">第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。</span><span class="sxs-lookup"><span data-stu-id="42801-497">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-498">下面的代码示例启动异步连接尝试。</span><span class="sxs-lookup"><span data-stu-id="42801-498">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-499"><paramref name="addresses" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-499"><paramref name="addresses" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-500">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-500">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-501"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-501">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-502">此方法对使用 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 的套接字有效。</span><span class="sxs-lookup"><span data-stu-id="42801-502">This method is valid for sockets that use <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-503">端口号无效。</span><span class="sxs-lookup"><span data-stu-id="42801-503">The port number is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-504"><paramref name="address" /> 的长度为零。</span><span class="sxs-lookup"><span data-stu-id="42801-504">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-505">已通过调用 <see cref="T:System.Net.Sockets.Socket" /> 将 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 置于侦听状态，或异步操作已在进行中。</span><span class="sxs-lookup"><span data-stu-id="42801-505">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="42801-506">将委托作为回调方法进行封送</span><span class="sxs-lookup"><span data-stu-id="42801-506">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="42801-507">异步客户端套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-507">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="42801-508">异步服务器套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-508">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, requestCallback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="host"><span data-ttu-id="42801-509">远程主机的名称。</span><span class="sxs-lookup"><span data-stu-id="42801-509">The name of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="42801-510">远程主机的端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-510">The port number of the remote host.</span></span></param>
        <param name="requestCallback"><span data-ttu-id="42801-511">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用连接操作完成时要调用的方法。</span><span class="sxs-lookup"><span data-stu-id="42801-511">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="callback"><span data-ttu-id="42801-512">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用连接操作完成时要调用的方法。</span><span class="sxs-lookup"><span data-stu-id="42801-512">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="42801-513">一个用户定义对象，其中包含连接操作的相关信息。</span><span class="sxs-lookup"><span data-stu-id="42801-513">A user-defined object that contains information about the connect operation.</span></span> <span data-ttu-id="42801-514">当操作完成时，此对象会被传递给 <paramref name="requestCallback" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="42801-514">This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="42801-515">开始一个对远程主机连接的异步请求。</span><span class="sxs-lookup"><span data-stu-id="42801-515">Begins an asynchronous request for a remote host connection.</span></span> <span data-ttu-id="42801-516">主机由主机名和端口号指定。</span><span class="sxs-lookup"><span data-stu-id="42801-516">The host is specified by a host name and a port number.</span></span></summary>
        <returns><span data-ttu-id="42801-517">引用异步连接的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="42801-517">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-518">异步 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 操作必须通过调用 <xref:System.Net.Sockets.Socket.EndConnect%2A> 方法完成。</span><span class="sxs-lookup"><span data-stu-id="42801-518">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="42801-519">通常，方法由 `requestCallback` 委托调用。</span><span class="sxs-lookup"><span data-stu-id="42801-519">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="42801-520">在操作完成之前，此方法不会被阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-520">This method does not block until the operation is complete.</span></span> <span data-ttu-id="42801-521">若要在操作完成之前一直阻止，请使用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法重载之一。</span><span class="sxs-lookup"><span data-stu-id="42801-521">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.</span></span>  
  
 <span data-ttu-id="42801-522">若要取消对 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法的挂起调用，请关闭 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-522">To cancel a pending call to the  <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-523">当异步操作正在进行时调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法时，会调用向 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法提供的回调。</span><span class="sxs-lookup"><span data-stu-id="42801-523">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="42801-524">对 <xref:System.Net.Sockets.Socket.EndConnect%2A> 方法的后续调用将引发 <xref:System.ObjectDisposedException>，以指示该操作已取消。</span><span class="sxs-lookup"><span data-stu-id="42801-524">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="42801-525">有关使用异步编程模型的详细信息，请参阅[以异步方式调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="42801-525">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-526">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-526">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-527">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-527">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-528">如果此套接字之前已断开连接，则必须在操作完成之前，将不会退出的线程上调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-528">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="42801-529">这是底层提供程序的限制。</span><span class="sxs-lookup"><span data-stu-id="42801-529">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="42801-530">使用的 <xref:System.Net.EndPoint> 也必须不同。</span><span class="sxs-lookup"><span data-stu-id="42801-530">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-531">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-531">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-532">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-532">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-533">对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。</span><span class="sxs-lookup"><span data-stu-id="42801-533">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="42801-534">第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。</span><span class="sxs-lookup"><span data-stu-id="42801-534">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-535">下面的代码示例启动异步连接尝试。</span><span class="sxs-lookup"><span data-stu-id="42801-535">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-536"><paramref name="host" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-536"><paramref name="host" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-537"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-537">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-538">此方法对 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列中的套接字有效。</span><span class="sxs-lookup"><span data-stu-id="42801-538">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-539">端口号无效。</span><span class="sxs-lookup"><span data-stu-id="42801-539">The port number is not valid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-540">已通过调用 <see cref="T:System.Net.Sockets.Socket" /> 将 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 置于侦听状态，或异步操作已在进行中。</span><span class="sxs-lookup"><span data-stu-id="42801-540">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="42801-541">将委托作为回调方法进行封送</span><span class="sxs-lookup"><span data-stu-id="42801-541">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="42801-542">异步客户端套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-542">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="42801-543">异步服务器套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-543">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="reuseSocket"><span data-ttu-id="42801-544">如果关闭该连接后可以重用此套接字，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-544"><see langword="true" /> if this socket can be reused after the connection is closed; otherwise, <see langword="false" />.</span></span></param>
        <param name="callback"><span data-ttu-id="42801-545"><see cref="T:System.AsyncCallback" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="42801-545">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="42801-546">包含此请求的状态信息的对象。</span><span class="sxs-lookup"><span data-stu-id="42801-546">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="42801-547">开始异步请求从远程终结点断开连接。</span><span class="sxs-lookup"><span data-stu-id="42801-547">Begins an asynchronous request to disconnect from a remote endpoint.</span></span></summary>
        <returns><span data-ttu-id="42801-548">一个 <see cref="T:System.IAsyncResult" /> 对象，它引用异步操作。</span><span class="sxs-lookup"><span data-stu-id="42801-548">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-549">如果使用面向连接的协议，则可以调用 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> 方法从远程终结点请求断开连接。</span><span class="sxs-lookup"><span data-stu-id="42801-549">If you are using a connection-oriented protocol, you can call the <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method to request a disconnect from a remote endpoint.</span></span> <span data-ttu-id="42801-550">如果 `true``reuseSocket`，则可以重复使用套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-550">If `reuseSocket` is `true`, you can reuse the socket.</span></span>  
  
 <span data-ttu-id="42801-551"><xref:System.Net.Sockets.Socket.BeginDisconnect%2A> 方法使用单独的线程来调用指定的回调方法。</span><span class="sxs-lookup"><span data-stu-id="42801-551">The <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method uses a separate thread to invoke the specified callback method.</span></span> <span data-ttu-id="42801-552">在挂起的断开连接完成之前，<xref:System.Net.Sockets.Socket.EndDisconnect%2A> 方法将会阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-552">The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the pending disconnect is complete.</span></span> <span data-ttu-id="42801-553">有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-553">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-554">如果收到 <xref:System.Net.Sockets.SocketException> 异常，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-554">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-555">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-555">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-556">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-556">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-557">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-557">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-558">下面的代码示例为异步通信创建套接字，并将一些数据发送到远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-558">The following code example creates a socket for asynchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="42801-559">发送数据后，将调用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 来停止发送和接收活动。</span><span class="sxs-lookup"><span data-stu-id="42801-559">When the data has been sent, <xref:System.Net.Sockets.Socket.Shutdown%2A> is called to stop the send and receive activity.</span></span> <span data-ttu-id="42801-560">然后调用 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> 以开始断开连接请求。</span><span class="sxs-lookup"><span data-stu-id="42801-560">Then <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> is called to begin a disconnect request.</span></span> <span data-ttu-id="42801-561">请求完成后，将查询 <xref:System.Net.Sockets.Socket.Connected%2A> 属性以测试套接字是否已断开连接。</span><span class="sxs-lookup"><span data-stu-id="42801-561">When the request completes, the <xref:System.Net.Sockets.Socket.Connected%2A> property is queried to test whether the socket is disconnected.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-562">操作系统为 Windows 2000 或更低版本，而此方法需要在 Windows XP 中使用。</span><span class="sxs-lookup"><span data-stu-id="42801-562">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-563"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-563">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-564">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-564">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42801-565">开始从连接的 <see cref="T:System.Net.Sockets.Socket" /> 中异步接收数据。</span><span class="sxs-lookup"><span data-stu-id="42801-565">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="42801-566"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</span><span class="sxs-lookup"><span data-stu-id="42801-566">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-567"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-567">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="42801-568">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用操作完成时要调用的方法。</span><span class="sxs-lookup"><span data-stu-id="42801-568">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="42801-569">一个用户定义的对象，其中包含接收操作的相关信息。</span><span class="sxs-lookup"><span data-stu-id="42801-569">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="42801-570">当操作完成时，此对象会被传递给 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="42801-570">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="42801-571">开始从连接的 <see cref="T:System.Net.Sockets.Socket" /> 中异步接收数据。</span><span class="sxs-lookup"><span data-stu-id="42801-571">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="42801-572">引用异步读的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="42801-572">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-573">异步 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 操作必须通过调用 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法完成。</span><span class="sxs-lookup"><span data-stu-id="42801-573">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="42801-574">通常，方法由 `callback` 委托调用。</span><span class="sxs-lookup"><span data-stu-id="42801-574">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="42801-575">在操作完成之前，此方法不会被阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-575">This method does not block until the operation is complete.</span></span> <span data-ttu-id="42801-576">若要在操作完成之前一直阻止，请使用 <xref:System.Net.Sockets.Socket.Receive%2A> 方法重载之一。</span><span class="sxs-lookup"><span data-stu-id="42801-576">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="42801-577">若要取消挂起的 <xref:System.Net.Sockets.Socket.BeginReceive%2A>，请调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-577">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="42801-578">有关使用异步编程模型的详细信息，请参阅[以异步方式调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-578">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-579">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-579">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-580">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-580">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-581">给定线程启动的所有 i/o 都将在该线程退出时取消。</span><span class="sxs-lookup"><span data-stu-id="42801-581">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="42801-582">如果线程在操作完成之前退出，则挂起的异步操作可能会失败。</span><span class="sxs-lookup"><span data-stu-id="42801-582">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-583">`state` 是用户定义的类的实例化。</span><span class="sxs-lookup"><span data-stu-id="42801-583">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-584">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-584">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-585">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-585">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-586">对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。</span><span class="sxs-lookup"><span data-stu-id="42801-586">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="42801-587">第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。</span><span class="sxs-lookup"><span data-stu-id="42801-587">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-588"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-588"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-589">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-589">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-590"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-590"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="42801-591">将委托作为回调方法进行封送</span><span class="sxs-lookup"><span data-stu-id="42801-591">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="42801-592">异步客户端套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-592">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="42801-593">异步服务器套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-593">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="42801-594"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</span><span class="sxs-lookup"><span data-stu-id="42801-594">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-595"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-595">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="42801-596">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</span><span class="sxs-lookup"><span data-stu-id="42801-596">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="42801-597">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用操作完成时要调用的方法。</span><span class="sxs-lookup"><span data-stu-id="42801-597">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="42801-598">一个用户定义的对象，其中包含接收操作的相关信息。</span><span class="sxs-lookup"><span data-stu-id="42801-598">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="42801-599">当操作完成时，此对象会被传递给 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="42801-599">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="42801-600">开始从连接的 <see cref="T:System.Net.Sockets.Socket" /> 中异步接收数据。</span><span class="sxs-lookup"><span data-stu-id="42801-600">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="42801-601">引用异步读的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="42801-601">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-602">异步 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 操作必须通过调用 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法完成。</span><span class="sxs-lookup"><span data-stu-id="42801-602">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="42801-603">通常，方法由 `callback` 委托调用。</span><span class="sxs-lookup"><span data-stu-id="42801-603">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="42801-604">在操作完成之前，此方法不会被阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-604">This method does not block until the operation is complete.</span></span> <span data-ttu-id="42801-605">若要在操作完成之前一直阻止，请使用 <xref:System.Net.Sockets.Socket.Receive%2A> 方法重载之一。</span><span class="sxs-lookup"><span data-stu-id="42801-605">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="42801-606">若要取消挂起的 <xref:System.Net.Sockets.Socket.BeginReceive%2A>，请调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-606">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="42801-607">有关使用异步编程模型的详细信息，请参阅[以异步方式调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-607">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-608">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-608">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-609">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-609">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-610">给定线程启动的所有 i/o 都将在该线程退出时取消。</span><span class="sxs-lookup"><span data-stu-id="42801-610">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="42801-611">如果线程在操作完成之前退出，则挂起的异步操作可能会失败。</span><span class="sxs-lookup"><span data-stu-id="42801-611">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-612">`state` 是用户定义的类的实例化。</span><span class="sxs-lookup"><span data-stu-id="42801-612">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-613">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-613">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-614">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-614">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-615">对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。</span><span class="sxs-lookup"><span data-stu-id="42801-615">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="42801-616">第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。</span><span class="sxs-lookup"><span data-stu-id="42801-616">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-617"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-617"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-618">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-618">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-619"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-619"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="42801-620">将委托作为回调方法进行封送</span><span class="sxs-lookup"><span data-stu-id="42801-620">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="42801-621">异步客户端套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-621">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="42801-622">异步服务器套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-622">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socketFlags, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-623"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</span><span class="sxs-lookup"><span data-stu-id="42801-623">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="42801-624"><paramref name="buffer" /> 参数中存储所接收数据的位置，该位置从零开始计数。</span><span class="sxs-lookup"><span data-stu-id="42801-624">The zero-based position in the <paramref name="buffer" /> parameter at which to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="42801-625">要接收的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-625">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-626"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-626">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="socket_flags"><span data-ttu-id="42801-627"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-627">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="42801-628">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用操作完成时要调用的方法。</span><span class="sxs-lookup"><span data-stu-id="42801-628">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="42801-629">一个用户定义的对象，其中包含接收操作的相关信息。</span><span class="sxs-lookup"><span data-stu-id="42801-629">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="42801-630">当操作完成时，此对象会被传递给 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="42801-630">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="42801-631">开始从连接的 <see cref="T:System.Net.Sockets.Socket" /> 中异步接收数据。</span><span class="sxs-lookup"><span data-stu-id="42801-631">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="42801-632">引用异步读的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="42801-632">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-633">异步 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 操作必须通过调用 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法完成。</span><span class="sxs-lookup"><span data-stu-id="42801-633">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="42801-634">通常，方法由 `callback` 委托调用。</span><span class="sxs-lookup"><span data-stu-id="42801-634">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="42801-635">在操作完成之前，此方法不会被阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-635">This method does not block until the operation is complete.</span></span> <span data-ttu-id="42801-636">若要在操作完成之前一直阻止，请使用 <xref:System.Net.Sockets.Socket.Receive%2A> 方法重载之一。</span><span class="sxs-lookup"><span data-stu-id="42801-636">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="42801-637">若要取消挂起的 <xref:System.Net.Sockets.Socket.BeginReceive%2A>，请调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-637">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="42801-638">有关使用异步编程模型的详细信息，请参阅[以异步方式调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-638">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-639">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-639">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-640">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-640">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-641">给定线程启动的所有 i/o 都将在该线程退出时取消。</span><span class="sxs-lookup"><span data-stu-id="42801-641">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="42801-642">如果线程在操作完成之前退出，则挂起的异步操作可能会失败。</span><span class="sxs-lookup"><span data-stu-id="42801-642">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-643">`state` 是用户定义的类的实例化。</span><span class="sxs-lookup"><span data-stu-id="42801-643">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-644">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-644">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-645">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-645">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-646">对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。</span><span class="sxs-lookup"><span data-stu-id="42801-646">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="42801-647">第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。</span><span class="sxs-lookup"><span data-stu-id="42801-647">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-648">下面的代码示例开始从连接的 <xref:System.Net.Sockets.Socket>中异步接收数据。</span><span class="sxs-lookup"><span data-stu-id="42801-648">The following code example begins to asynchronously receive data from a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-649"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-649"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-650">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-650">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-651"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-651"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-652"><paramref name="offset" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-652"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-653">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-653">-or-</span></span> 
 <span data-ttu-id="42801-654"><paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="42801-654"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="42801-655">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-655">-or-</span></span> 
 <span data-ttu-id="42801-656"><paramref name="size" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-656"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-657">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-657">-or-</span></span> 
 <span data-ttu-id="42801-658"><paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</span><span class="sxs-lookup"><span data-stu-id="42801-658"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="42801-659">将委托作为回调方法进行封送</span><span class="sxs-lookup"><span data-stu-id="42801-659">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="42801-660">异步客户端套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-660">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="42801-661">异步服务器套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-661">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socketFlags, errorCode, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-662"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</span><span class="sxs-lookup"><span data-stu-id="42801-662">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="42801-663"><paramref name="buffer" /> 中存储所接收数据的位置。</span><span class="sxs-lookup"><span data-stu-id="42801-663">The location in <paramref name="buffer" /> to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="42801-664">要接收的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-664">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-665"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-665">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="flags"><span data-ttu-id="42801-666"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-666">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="42801-667">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</span><span class="sxs-lookup"><span data-stu-id="42801-667">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="error"><span data-ttu-id="42801-668">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</span><span class="sxs-lookup"><span data-stu-id="42801-668">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="42801-669">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用操作完成时要调用的方法。</span><span class="sxs-lookup"><span data-stu-id="42801-669">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="42801-670">一个用户定义的对象，其中包含接收操作的相关信息。</span><span class="sxs-lookup"><span data-stu-id="42801-670">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="42801-671">当操作完成时，此对象会被传递给 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="42801-671">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="42801-672">开始从连接的 <see cref="T:System.Net.Sockets.Socket" /> 中异步接收数据。</span><span class="sxs-lookup"><span data-stu-id="42801-672">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="42801-673">引用异步读的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="42801-673">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-674">异步 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 操作必须通过调用 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法完成。</span><span class="sxs-lookup"><span data-stu-id="42801-674">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="42801-675">通常，方法由 `callback` 委托调用。</span><span class="sxs-lookup"><span data-stu-id="42801-675">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="42801-676">在操作完成之前，此方法不会被阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-676">This method does not block until the operation is complete.</span></span> <span data-ttu-id="42801-677">若要在操作完成之前一直阻止，请使用 <xref:System.Net.Sockets.Socket.Receive%2A> 方法重载之一。</span><span class="sxs-lookup"><span data-stu-id="42801-677">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="42801-678">若要取消挂起的 <xref:System.Net.Sockets.Socket.BeginReceive%2A>，请调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-678">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="42801-679">有关使用异步编程模型的详细信息，请参阅[以异步方式调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-679">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-680">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-680">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-681">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-681">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-682">给定线程启动的所有 i/o 都将在该线程退出时取消。</span><span class="sxs-lookup"><span data-stu-id="42801-682">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="42801-683">如果线程在操作完成之前退出，则挂起的异步操作可能会失败。</span><span class="sxs-lookup"><span data-stu-id="42801-683">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-684">`state` 是用户定义的类的实例化。</span><span class="sxs-lookup"><span data-stu-id="42801-684">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-685">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-685">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-686">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-686">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-687">对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。</span><span class="sxs-lookup"><span data-stu-id="42801-687">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="42801-688">第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。</span><span class="sxs-lookup"><span data-stu-id="42801-688">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-689"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-689"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-690">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-690">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-691"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-691"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-692"><paramref name="offset" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-692"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-693">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-693">-or-</span></span> 
 <span data-ttu-id="42801-694"><paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="42801-694"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="42801-695">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-695">-or-</span></span> 
 <span data-ttu-id="42801-696"><paramref name="size" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-696"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-697">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-697">-or-</span></span> 
 <span data-ttu-id="42801-698"><paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</span><span class="sxs-lookup"><span data-stu-id="42801-698"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="42801-699">将委托作为回调方法进行封送</span><span class="sxs-lookup"><span data-stu-id="42801-699">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="42801-700">异步客户端套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-700">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="42801-701">异步服务器套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-701">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-702"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</span><span class="sxs-lookup"><span data-stu-id="42801-702">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="42801-703"><paramref name="buffer" /> 参数中存储数据的位置，该位置从零开始计数。</span><span class="sxs-lookup"><span data-stu-id="42801-703">The zero-based position in the <paramref name="buffer" /> parameter at which to store the data.</span></span></param>
        <param name="size"><span data-ttu-id="42801-704">要接收的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-704">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-705"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-705">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="socket_flags"><span data-ttu-id="42801-706"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-706">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="42801-707">一个 <see cref="T:System.Net.EndPoint" />，它表示数据的来源。</span><span class="sxs-lookup"><span data-stu-id="42801-707">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</span></span></param>
        <param name="remote_end"><span data-ttu-id="42801-708">一个 <see cref="T:System.Net.EndPoint" />，它表示数据的来源。</span><span class="sxs-lookup"><span data-stu-id="42801-708">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</span></span></param>
        <param name="callback"><span data-ttu-id="42801-709"><see cref="T:System.AsyncCallback" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="42801-709">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="42801-710">包含此请求的状态信息的对象。</span><span class="sxs-lookup"><span data-stu-id="42801-710">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="42801-711">开始从指定网络设备中异步接收数据。</span><span class="sxs-lookup"><span data-stu-id="42801-711">Begins to asynchronously receive data from a specified network device.</span></span></summary>
        <returns><span data-ttu-id="42801-712">引用异步读的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="42801-712">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-713"><xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法从远程主机异步读取无连接的数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-713">The <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method starts asynchronously reading connectionless datagrams from a remote host.</span></span> <span data-ttu-id="42801-714">调用 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法使你能够在单独的执行线程中接收数据。</span><span class="sxs-lookup"><span data-stu-id="42801-714">Calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method gives you the ability to receive data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="42801-715">你可以创建一个实现 <xref:System.AsyncCallback> 委托的回调方法，并将其名称传递到 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-715">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="42801-716">为此，你的 `state` 参数至少必须包含用于通信的已连接或默认 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-716">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="42801-717">如果回调需要更多的信息，可以创建一个小类来容纳 <xref:System.Net.Sockets.Socket> 和其他所需的信息。</span><span class="sxs-lookup"><span data-stu-id="42801-717">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="42801-718">通过 `state` 参数将此类的实例传递给 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-718">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="42801-719">回调方法应调用 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-719">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method.</span></span> <span data-ttu-id="42801-720">当应用程序调用 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>时，系统将使用一个单独的线程来执行指定的回调方法，并且它将在 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 上阻塞，直到 <xref:System.Net.Sockets.Socket> 读取数据或引发异常。</span><span class="sxs-lookup"><span data-stu-id="42801-720">When your application calls <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, the system will use a separate thread to execute the specified callback method, and it will block on <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> until the <xref:System.Net.Sockets.Socket> reads data or throws an exception.</span></span> <span data-ttu-id="42801-721">如果希望在调用 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法后原始线程被阻止，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="42801-721">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-722">如果希望原始线程继续执行，请在回调方法中的 T:System.Threading.ManualResetEvent 上调用 Set 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-722">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="42801-723">有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-723">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-724">在调用 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>之前，必须使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法将 <xref:System.Net.Sockets.Socket> 显式绑定到本地终结点，否则 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-724">Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method, or <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="42801-725">此方法将数据读取到 `buffer` 参数，并捕获从其发送数据的远程主机终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-725">This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent.</span></span> <span data-ttu-id="42801-726">有关如何检索此终结点的信息，请参阅 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-726">For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span></span> <span data-ttu-id="42801-727">如果打算从未知主机或多台主机异步接收无连接的数据报，此方法非常有用。</span><span class="sxs-lookup"><span data-stu-id="42801-727">This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</span></span> <span data-ttu-id="42801-728">在这些情况下，<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 将读取接收到本地网络缓冲区中的第一个排队数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-728">In these cases, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="42801-729">如果接收的数据报大于 `buffer`的大小，则 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法会将尽可能多的消息填入 `buffer`，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-729">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-730">如果使用的是不可靠的协议，则过量的数据将丢失。</span><span class="sxs-lookup"><span data-stu-id="42801-730">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="42801-731">如果你使用的是可靠协议，则会将多余的数据保留在服务提供程序中，并且你可以通过使用足够大的缓冲区调用 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法来检索它。</span><span class="sxs-lookup"><span data-stu-id="42801-731">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="42801-732">为了保证始终返回远程主机终结点，应用程序应使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法将 <xref:System.Net.Sockets.Socket> 显式绑定到本地终结点，然后调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，将 `optionLevel` 参数设置为 <xref:System.Net.Sockets.SocketOptionLevel.IP> 或 <xref:System.Net.Sockets.SocketOptionLevel.IPv6>，将 `optionName` 参数设置为 <xref:System.Net.Sockets.SocketOptionName.PacketInformation>，并使用 `optionValue` 参数在调用 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法之前启用此选项。</span><span class="sxs-lookup"><span data-stu-id="42801-732">To guarantee that the remote host endpoint is always returned, an application should explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method and then call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method with the `optionLevel` parameter set to <xref:System.Net.Sockets.SocketOptionLevel.IP> or <xref:System.Net.Sockets.SocketOptionLevel.IPv6> as appropriate, the `optionName` parameter set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation>, and the `optionValue` parameter to enable this option before calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="42801-733">否则，如果在接收方已调用 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法之前，发送方发送了大量的数据报，则可能不会返回远程主机终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-733">Otherwise, it is possible for the remote host endpoint to not be returned when the sender has sent a number of datagrams before the receiver has called the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span>  
  
 <span data-ttu-id="42801-734">尽管 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 适用于无连接协议，但你也可以使用面向连接的协议。</span><span class="sxs-lookup"><span data-stu-id="42801-734">Although <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="42801-735">如果选择这样做，则必须先通过调用 <xref:System.Net.Sockets.Socket.Connect%2A> / <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法建立远程主机连接，或通过调用 <xref:System.Net.Sockets.Socket.Accept%2A> 或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法接受传入的连接请求。</span><span class="sxs-lookup"><span data-stu-id="42801-735">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> / <xref:System.Net.Sockets.Socket.BeginConnect%2A> method or accept an incoming connection request by calling the <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="42801-736">如果在建立或接受连接之前调用 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法，将获得 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-736">If you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method before establishing or accepting a connection, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-737">还可以在调用 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法之前，为无连接协议建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-737">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="42801-738">在这两种情况下，<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法将忽略 `remoteEP` 参数，并仅从已连接或默认的远程主机接收数据。</span><span class="sxs-lookup"><span data-stu-id="42801-738">In either of these cases, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="42801-739">使用面向连接的套接字时，<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 将读取尽可能多的数据，最多可达 `size` 参数指定的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-739">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter.</span></span>  
  
 <span data-ttu-id="42801-740">若要取消挂起的 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>，请调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-740">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-741">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-741">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-742">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-742">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-743">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-743">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-744">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-744">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-745">对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。</span><span class="sxs-lookup"><span data-stu-id="42801-745">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="42801-746">第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。</span><span class="sxs-lookup"><span data-stu-id="42801-746">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-747">下面的代码示例从远程主机异步接收无连接的数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-747">The following code example asynchronously receives connectionless datagrams from a remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-748"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-748"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="42801-749">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-749">-or-</span></span> 
 <span data-ttu-id="42801-750"><paramref name="remoteEP" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-750"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-751">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-751">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-752"><paramref name="offset" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-752"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-753">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-753">-or-</span></span> 
 <span data-ttu-id="42801-754"><paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="42801-754"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="42801-755">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-755">-or-</span></span> 
 <span data-ttu-id="42801-756"><paramref name="size" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-756"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-757">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-757">-or-</span></span> 
 <span data-ttu-id="42801-758"><paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</span><span class="sxs-lookup"><span data-stu-id="42801-758"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-759"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-759">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="42801-760">调用堆栈中的较高调用方无权执行所请求的操作。</span><span class="sxs-lookup"><span data-stu-id="42801-760">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="42801-761">将委托作为回调方法进行封送</span><span class="sxs-lookup"><span data-stu-id="42801-761">Marshaling a Delegate as a Callback Method</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-762"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</span><span class="sxs-lookup"><span data-stu-id="42801-762">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="42801-763"><paramref name="buffer" /> 参数中存储数据的位置，该位置从零开始计数。</span><span class="sxs-lookup"><span data-stu-id="42801-763">The zero-based position in the <paramref name="buffer" /> parameter at which to store the data.</span></span></param>
        <param name="size"><span data-ttu-id="42801-764">要接收的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-764">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-765"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-765">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="42801-766">一个 <see cref="T:System.Net.EndPoint" />，它表示数据的来源。</span><span class="sxs-lookup"><span data-stu-id="42801-766">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</span></span></param>
        <param name="callback"><span data-ttu-id="42801-767"><see cref="T:System.AsyncCallback" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="42801-767">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="42801-768">包含此请求的状态信息的对象。</span><span class="sxs-lookup"><span data-stu-id="42801-768">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="42801-769">开始使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 将指定字节数的数据异步接收到数据缓冲区的指定位置，然后存储终结点和数据包信息。</span><span class="sxs-lookup"><span data-stu-id="42801-769">Begins to asynchronously receive the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint and packet information.</span></span></summary>
        <returns><span data-ttu-id="42801-770">引用异步读的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="42801-770">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-771">异步接收操作必须通过调用 <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> 方法完成。</span><span class="sxs-lookup"><span data-stu-id="42801-771">The asynchronous receive operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> method.</span></span> <span data-ttu-id="42801-772">通常，方法由 `asyncCallback` 委托调用。</span><span class="sxs-lookup"><span data-stu-id="42801-772">Typically, the method is invoked by the `asyncCallback` delegate.</span></span>  
  
 <span data-ttu-id="42801-773">在操作完成之前，此方法不会被阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-773">This method does not block until the operation completes.</span></span> <span data-ttu-id="42801-774">若要在操作完成之前一直阻止，请使用 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-774">To block until the operation completes, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="42801-775">若要取消挂起的 <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>，请调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-775">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="42801-776">有关使用异步编程模型的详细信息，请参阅[以异步方式调用同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="42801-776">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
 <span data-ttu-id="42801-777">此方法将数据读取到 `buffer` 参数，并捕获从其发送数据的远程主机终结点以及有关已接收的数据包的信息。</span><span class="sxs-lookup"><span data-stu-id="42801-777">This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent, as well as information about the received packet.</span></span> <span data-ttu-id="42801-778">有关如何检索此终结点的信息，请参阅 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-778">For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span></span> <span data-ttu-id="42801-779">如果打算从未知主机或多台主机异步接收无连接的数据报，此方法非常有用。</span><span class="sxs-lookup"><span data-stu-id="42801-779">This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-780">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-780">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-781">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-781">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-782">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-782">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-783">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-783">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-784">对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。</span><span class="sxs-lookup"><span data-stu-id="42801-784">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="42801-785">第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。</span><span class="sxs-lookup"><span data-stu-id="42801-785">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-786"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-786"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="42801-787">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-787">-or-</span></span> 
 <span data-ttu-id="42801-788"><paramref name="remoteEP" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-788"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-789">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-789">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-790"><paramref name="offset" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-790"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-791">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-791">-or-</span></span> 
 <span data-ttu-id="42801-792"><paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="42801-792"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="42801-793">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-793">-or-</span></span> 
 <span data-ttu-id="42801-794"><paramref name="size" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-794"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-795">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-795">-or-</span></span> 
 <span data-ttu-id="42801-796"><paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</span><span class="sxs-lookup"><span data-stu-id="42801-796"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-797"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-797">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-798">操作系统为 Windows 2000 或更低版本，而此方法需要在 Windows XP 中使用。</span><span class="sxs-lookup"><span data-stu-id="42801-798">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42801-799">将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="42801-799">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="42801-800"><see cref="T:System.Byte" /> 类型的数组，它包含要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-800">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-801"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-801">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="42801-802"><see cref="T:System.AsyncCallback" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="42801-802">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="42801-803">包含此请求的状态信息的对象。</span><span class="sxs-lookup"><span data-stu-id="42801-803">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="42801-804">将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="42801-804">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="42801-805">引用异步发送的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="42801-805">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-806"><xref:System.Net.Sockets.Socket.BeginSend%2A> 方法开始异步发送操作到在 <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法中建立的远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-806">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="42801-807">如果你不首先调用 <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.BeginConnect%2A>，<xref:System.Net.Sockets.Socket.BeginSend%2A> 会引发异常。</span><span class="sxs-lookup"><span data-stu-id="42801-807"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="42801-808">调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法使你能够在单独的执行线程中发送数据。</span><span class="sxs-lookup"><span data-stu-id="42801-808">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="42801-809">你可以创建一个实现 <xref:System.AsyncCallback> 委托的回调方法，并将其名称传递到 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-809">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="42801-810">为此，你的 `state` 参数至少必须包含用于通信的已连接或默认 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-810">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="42801-811">如果回调需要更多的信息，可以创建一个小型类或结构来保存 <xref:System.Net.Sockets.Socket> 和其他所需的信息。</span><span class="sxs-lookup"><span data-stu-id="42801-811">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="42801-812">通过 `state` 参数将此类的实例传递给 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-812">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="42801-813">回调方法应调用 <xref:System.Net.Sockets.Socket.EndSend%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-813">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="42801-814">当应用程序调用 <xref:System.Net.Sockets.Socket.BeginSend%2A>时，系统将使用一个单独的线程来执行指定的回调方法，并将在 <xref:System.Net.Sockets.Socket.EndSend%2A> 上阻塞，直到 <xref:System.Net.Sockets.Socket> 发送请求的字节数或引发异常。</span><span class="sxs-lookup"><span data-stu-id="42801-814">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="42801-815">如果希望在调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法后原始线程被阻止，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-815">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="42801-816">如果希望原始线程继续执行，请在回调方法中的 T:System.Threading.ManualResetEvent 上调用 Set 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-816">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="42801-817">有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-817">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="42801-818">尽管适用于面向连接的协议，但 <xref:System.Net.Sockets.Socket.BeginSend%2A> 也适用于无连接协议，前提是你首先调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法来建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-818">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="42801-819">如果使用无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-819">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="42801-820">即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-820">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="42801-821">还可以在调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 之前更改默认远程主机，方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-821">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="42801-822">对于无连接协议，还必须确保缓冲区的大小不超过基础服务提供程序的最大数据包大小。</span><span class="sxs-lookup"><span data-stu-id="42801-822">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="42801-823">如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.BeginSend%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-823">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="42801-824">如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则将不路由要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-824">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-825">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-825">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-826">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-826">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-827">给定线程启动的所有 i/o 都将在该线程退出时取消。</span><span class="sxs-lookup"><span data-stu-id="42801-827">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="42801-828">如果线程在操作完成之前退出，则挂起的异步操作可能会失败。</span><span class="sxs-lookup"><span data-stu-id="42801-828">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-829">`state` 是用户定义的类的实例化。</span><span class="sxs-lookup"><span data-stu-id="42801-829">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-830">成功完成发送并不表示数据已成功传递。</span><span class="sxs-lookup"><span data-stu-id="42801-830">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="42801-831">如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。</span><span class="sxs-lookup"><span data-stu-id="42801-831">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-832">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-832">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-833">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-833">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-834">对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。</span><span class="sxs-lookup"><span data-stu-id="42801-834">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="42801-835">第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。</span><span class="sxs-lookup"><span data-stu-id="42801-835">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-836"><paramref name="buffers" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-836"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-837"><paramref name="buffers" /> 为空。</span><span class="sxs-lookup"><span data-stu-id="42801-837"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-838">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-838">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="42801-839">请参见下面的备注部分。</span><span class="sxs-lookup"><span data-stu-id="42801-839">See remarks section below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-840"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-840">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="42801-841">将委托作为回调方法进行封送</span><span class="sxs-lookup"><span data-stu-id="42801-841">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="42801-842">异步客户端套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-842">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="42801-843">异步服务器套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-843">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="42801-844"><see cref="T:System.Byte" /> 类型的数组，它包含要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-844">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-845"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-845">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="42801-846">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</span><span class="sxs-lookup"><span data-stu-id="42801-846">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="42801-847"><see cref="T:System.AsyncCallback" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="42801-847">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="42801-848">包含此请求的状态信息的对象。</span><span class="sxs-lookup"><span data-stu-id="42801-848">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="42801-849">将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="42801-849">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="42801-850">引用异步发送的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="42801-850">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-851"><xref:System.Net.Sockets.Socket.BeginSend%2A> 方法开始异步发送操作到在 <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法中建立的远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-851">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="42801-852">如果你不首先调用 <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.BeginConnect%2A>，<xref:System.Net.Sockets.Socket.BeginSend%2A> 会引发异常。</span><span class="sxs-lookup"><span data-stu-id="42801-852"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="42801-853">调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法使你能够在单独的执行线程中发送数据。</span><span class="sxs-lookup"><span data-stu-id="42801-853">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="42801-854">你可以创建一个实现 <xref:System.AsyncCallback> 委托的回调方法，并将其名称传递到 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-854">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="42801-855">为此，你的 `state` 参数至少必须包含用于通信的已连接或默认 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-855">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="42801-856">如果回调需要更多的信息，可以创建一个小型类或结构来保存 <xref:System.Net.Sockets.Socket> 和其他所需的信息。</span><span class="sxs-lookup"><span data-stu-id="42801-856">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="42801-857">通过 `state` 参数将此类的实例传递给 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-857">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="42801-858">回调方法应调用 <xref:System.Net.Sockets.Socket.EndSend%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-858">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="42801-859">当应用程序调用 <xref:System.Net.Sockets.Socket.BeginSend%2A>时，系统将使用一个单独的线程来执行指定的回调方法，并将在 <xref:System.Net.Sockets.Socket.EndSend%2A> 上阻塞，直到 <xref:System.Net.Sockets.Socket> 发送请求的字节数或引发异常。</span><span class="sxs-lookup"><span data-stu-id="42801-859">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="42801-860">如果希望在调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法后原始线程被阻止，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-860">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="42801-861">如果希望原始线程继续执行，请在回调方法中的 <xref:System.Threading.ManualResetEvent> 上调用 Set 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-861">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="42801-862">有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-862">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="42801-863">尽管适用于面向连接的协议，但 <xref:System.Net.Sockets.Socket.BeginSend%2A> 也适用于无连接协议，前提是你首先调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法来建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-863">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="42801-864">如果使用无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-864">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="42801-865">即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-865">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="42801-866">还可以在调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 之前更改默认远程主机，方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-866">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="42801-867">对于无连接协议，还必须确保缓冲区的大小不超过基础服务提供程序的最大数据包大小。</span><span class="sxs-lookup"><span data-stu-id="42801-867">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="42801-868">如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.BeginSend%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-868">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="42801-869">如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则将不路由要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-869">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-870">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-870">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-871">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-871">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-872">给定线程启动的所有 i/o 都将在该线程退出时取消。</span><span class="sxs-lookup"><span data-stu-id="42801-872">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="42801-873">如果线程在操作完成之前退出，则挂起的异步操作可能会失败。</span><span class="sxs-lookup"><span data-stu-id="42801-873">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-874">`state` 是用户定义的类的实例化。</span><span class="sxs-lookup"><span data-stu-id="42801-874">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-875">成功完成发送并不表示数据已成功传递。</span><span class="sxs-lookup"><span data-stu-id="42801-875">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="42801-876">如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。</span><span class="sxs-lookup"><span data-stu-id="42801-876">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-877">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-877">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-878">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-878">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-879">对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。</span><span class="sxs-lookup"><span data-stu-id="42801-879">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="42801-880">第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。</span><span class="sxs-lookup"><span data-stu-id="42801-880">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-881"><paramref name="buffers" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-881"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-882"><paramref name="buffers" /> 为空。</span><span class="sxs-lookup"><span data-stu-id="42801-882"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-883">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-883">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="42801-884">请参见下面的备注部分。</span><span class="sxs-lookup"><span data-stu-id="42801-884">See remarks section below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-885"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-885">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="42801-886">将委托作为回调方法进行封送</span><span class="sxs-lookup"><span data-stu-id="42801-886">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="42801-887">异步客户端套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-887">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="42801-888">异步服务器套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-888">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-889"><see cref="T:System.Byte" /> 类型的数组，它包含要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-889">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="offset"><span data-ttu-id="42801-890"><paramref name="buffer" /> 参数中开始发送数据的位置，该位置从零开始计数。</span><span class="sxs-lookup"><span data-stu-id="42801-890">The zero-based position in the <paramref name="buffer" /> parameter at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="42801-891">要发送的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-891">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-892"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-892">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="42801-893">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</span><span class="sxs-lookup"><span data-stu-id="42801-893">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="42801-894"><see cref="T:System.AsyncCallback" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="42801-894">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="42801-895">包含此请求的状态信息的对象。</span><span class="sxs-lookup"><span data-stu-id="42801-895">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="42801-896">将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="42801-896">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="42801-897">引用异步发送的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="42801-897">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-898"><xref:System.Net.Sockets.Socket.BeginSend%2A> 方法开始异步发送操作到在 <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法中建立的远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-898">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="42801-899">如果你不首先调用 <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.BeginConnect%2A>，<xref:System.Net.Sockets.Socket.BeginSend%2A> 会引发异常。</span><span class="sxs-lookup"><span data-stu-id="42801-899"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="42801-900">调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法使你能够在单独的执行线程中发送数据。</span><span class="sxs-lookup"><span data-stu-id="42801-900">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="42801-901">你可以创建一个实现 <xref:System.AsyncCallback> 委托的回调方法，并将其名称传递到 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-901">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="42801-902">为此，你的 `state` 参数至少必须包含用于通信的已连接或默认 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-902">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="42801-903">如果回调需要更多的信息，可以创建一个小型类或结构来保存 <xref:System.Net.Sockets.Socket> 和其他所需的信息。</span><span class="sxs-lookup"><span data-stu-id="42801-903">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="42801-904">通过 `state` 参数将此类的实例传递给 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-904">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="42801-905">回调方法应调用 <xref:System.Net.Sockets.Socket.EndSend%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-905">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="42801-906">当应用程序调用 <xref:System.Net.Sockets.Socket.BeginSend%2A>时，系统将使用一个单独的线程来执行指定的回调方法，并将在 <xref:System.Net.Sockets.Socket.EndSend%2A> 上阻塞，直到 <xref:System.Net.Sockets.Socket> 发送请求的字节数或引发异常。</span><span class="sxs-lookup"><span data-stu-id="42801-906">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="42801-907">如果希望在调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法后原始线程被阻止，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-907">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="42801-908">如果希望原始线程继续执行，请在回调方法中的 T:System.Threading.ManualResetEvent 上调用 Set 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-908">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="42801-909">有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-909">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="42801-910">尽管适用于面向连接的协议，但 <xref:System.Net.Sockets.Socket.BeginSend%2A> 也适用于无连接协议，前提是你首先调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法来建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-910">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="42801-911">如果使用无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-911">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="42801-912">即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-912">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="42801-913">还可以在调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 之前更改默认远程主机，方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-913">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="42801-914">对于无连接协议，还必须确保缓冲区的大小不超过基础服务提供程序的最大数据包大小。</span><span class="sxs-lookup"><span data-stu-id="42801-914">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="42801-915">如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.BeginSend%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-915">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="42801-916">如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则将不路由要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-916">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-917">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-917">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-918">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-918">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-919">给定线程启动的所有 i/o 都将在该线程退出时取消。</span><span class="sxs-lookup"><span data-stu-id="42801-919">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="42801-920">如果线程在操作完成之前退出，则挂起的异步操作可能会失败。</span><span class="sxs-lookup"><span data-stu-id="42801-920">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-921">`state` 是用户定义的类的实例化。</span><span class="sxs-lookup"><span data-stu-id="42801-921">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-922">成功完成发送并不表示数据已成功传递。</span><span class="sxs-lookup"><span data-stu-id="42801-922">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="42801-923">如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。</span><span class="sxs-lookup"><span data-stu-id="42801-923">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-924">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-924">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-925">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-925">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-926">对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。</span><span class="sxs-lookup"><span data-stu-id="42801-926">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="42801-927">第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。</span><span class="sxs-lookup"><span data-stu-id="42801-927">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-928"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-928"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-929">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-929">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="42801-930">请参见下面的备注部分。</span><span class="sxs-lookup"><span data-stu-id="42801-930">See remarks section below.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-931"><paramref name="offset" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-931"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-932">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-932">-or-</span></span> 
 <span data-ttu-id="42801-933"><paramref name="offset" /> 小于 <paramref name="buffer" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="42801-933"><paramref name="offset" /> is less than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="42801-934">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-934">-or-</span></span> 
 <span data-ttu-id="42801-935"><paramref name="size" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-935"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-936">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-936">-or-</span></span> 
 <span data-ttu-id="42801-937"><paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</span><span class="sxs-lookup"><span data-stu-id="42801-937"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-938"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-938">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="42801-939">将委托作为回调方法进行封送</span><span class="sxs-lookup"><span data-stu-id="42801-939">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="42801-940">异步客户端套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-940">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="42801-941">异步服务器套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-941">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-942"><see cref="T:System.Byte" /> 类型的数组，它包含要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-942">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="offset"><span data-ttu-id="42801-943"><paramref name="buffer" /> 参数中开始发送数据的位置，该位置从零开始计数。</span><span class="sxs-lookup"><span data-stu-id="42801-943">The zero-based position in the <paramref name="buffer" /> parameter at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="42801-944">要发送的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-944">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-945"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-945">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="socket_flags"><span data-ttu-id="42801-946"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-946">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="42801-947"><see cref="T:System.AsyncCallback" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="42801-947">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="42801-948">包含此请求的状态信息的对象。</span><span class="sxs-lookup"><span data-stu-id="42801-948">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="42801-949">将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="42801-949">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="42801-950">引用异步发送的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="42801-950">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-951"><xref:System.Net.Sockets.Socket.BeginSend%2A> 方法开始异步发送操作到在 <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法中建立的远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-951">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="42801-952">如果你不首先调用 <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.BeginConnect%2A>，<xref:System.Net.Sockets.Socket.BeginSend%2A> 会引发异常。</span><span class="sxs-lookup"><span data-stu-id="42801-952"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="42801-953">调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法使你能够在单独的执行线程中发送数据。</span><span class="sxs-lookup"><span data-stu-id="42801-953">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="42801-954">你可以创建一个实现 <xref:System.AsyncCallback> 委托的回调方法，并将其名称传递到 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-954">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="42801-955">为此，你的 `state` 参数至少必须包含用于通信的已连接或默认 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-955">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="42801-956">如果回调需要更多的信息，可以创建一个小型类或结构来保存 <xref:System.Net.Sockets.Socket> 和其他所需的信息。</span><span class="sxs-lookup"><span data-stu-id="42801-956">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="42801-957">通过 `state` 参数将此类的实例传递给 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-957">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="42801-958">回调方法应调用 <xref:System.Net.Sockets.Socket.EndSend%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-958">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="42801-959">当应用程序调用 <xref:System.Net.Sockets.Socket.BeginSend%2A>时，系统将使用一个单独的线程来执行指定的回调方法，并将在 <xref:System.Net.Sockets.Socket.EndSend%2A> 上阻塞，直到 <xref:System.Net.Sockets.Socket> 发送请求的字节数或引发异常。</span><span class="sxs-lookup"><span data-stu-id="42801-959">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="42801-960">如果希望在调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法后原始线程被阻止，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-960">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="42801-961">如果希望原始线程继续执行，请在回调方法中的 T:System.Threading.ManualResetEvent 上调用 Set 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-961">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="42801-962">有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-962">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="42801-963">尽管适用于面向连接的协议，但 <xref:System.Net.Sockets.Socket.BeginSend%2A> 也适用于无连接协议，前提是你首先调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法来建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-963">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="42801-964">如果使用无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-964">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="42801-965">即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-965">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="42801-966">还可以在调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 之前更改默认远程主机，方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-966">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="42801-967">对于无连接协议，还必须确保缓冲区的大小不超过基础服务提供程序的最大数据包大小。</span><span class="sxs-lookup"><span data-stu-id="42801-967">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="42801-968">如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.BeginSend%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-968">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="42801-969">如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则将不路由要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-969">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-970">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-970">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-971">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-971">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-972">给定线程启动的所有 i/o 都将在该线程退出时取消。</span><span class="sxs-lookup"><span data-stu-id="42801-972">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="42801-973">如果线程在操作完成之前退出，则挂起的异步操作可能会失败。</span><span class="sxs-lookup"><span data-stu-id="42801-973">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-974">`state` 是用户定义的类的实例化。</span><span class="sxs-lookup"><span data-stu-id="42801-974">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-975">成功完成发送并不表示数据已成功传递。</span><span class="sxs-lookup"><span data-stu-id="42801-975">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="42801-976">如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。</span><span class="sxs-lookup"><span data-stu-id="42801-976">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-977">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-977">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-978">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-978">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-979">对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。</span><span class="sxs-lookup"><span data-stu-id="42801-979">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="42801-980">第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。</span><span class="sxs-lookup"><span data-stu-id="42801-980">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-981">下面的代码示例开始将数据异步发送到远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-981">The following code example begins asynchronously sending data to a remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-982"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-982"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-983">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-983">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="42801-984">请参见下面的备注部分。</span><span class="sxs-lookup"><span data-stu-id="42801-984">See remarks section below.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-985"><paramref name="offset" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-985"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-986">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-986">-or-</span></span> 
 <span data-ttu-id="42801-987"><paramref name="offset" /> 小于 <paramref name="buffer" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="42801-987"><paramref name="offset" /> is less than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="42801-988">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-988">-or-</span></span> 
 <span data-ttu-id="42801-989"><paramref name="size" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-989"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-990">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-990">-or-</span></span> 
 <span data-ttu-id="42801-991"><paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</span><span class="sxs-lookup"><span data-stu-id="42801-991"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-992"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-992">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="42801-993">将委托作为回调方法进行封送</span><span class="sxs-lookup"><span data-stu-id="42801-993">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="42801-994">异步客户端套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-994">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="42801-995">异步服务器套接字示例</span><span class="sxs-lookup"><span data-stu-id="42801-995">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42801-996">将文件异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="42801-996">Sends a file asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="42801-997">一个字符串，它包含要发送的文件的路径和名称。</span><span class="sxs-lookup"><span data-stu-id="42801-997">A string that contains the path and name of the file to send.</span></span> <span data-ttu-id="42801-998">此参数可以为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-998">This parameter can be <see langword="null" />.</span></span></param>
        <param name="callback"><span data-ttu-id="42801-999"><see cref="T:System.AsyncCallback" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="42801-999">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="42801-1000">包含此请求的状态信息的对象。</span><span class="sxs-lookup"><span data-stu-id="42801-1000">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="42801-1001">使用 <paramref name="fileName" /> 标志，将文件 <see cref="T:System.Net.Sockets.Socket" /> 发送到连接的 <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="42801-1001">Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> flag.</span></span></summary>
        <returns><span data-ttu-id="42801-1002">一个 <see cref="T:System.IAsyncResult" /> 对象，它表示异步发送。</span><span class="sxs-lookup"><span data-stu-id="42801-1002">An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1003">此重载将文件 `fileName` 发送到连接的套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-1003">This overload sends the file `fileName` to the connected socket.</span></span> <span data-ttu-id="42801-1004">如果 `fileName` 位于本地目录中，则只能用该文件的名称进行标识;否则，必须指定文件的完整路径和名称。</span><span class="sxs-lookup"><span data-stu-id="42801-1004">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="42801-1005">通配符（".。。支持\\\myfile.txt "）和 UNC 共享名称（"\\\\\\\shared 目录\\\myfile.txt "）。</span><span class="sxs-lookup"><span data-stu-id="42801-1005">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="42801-1006">如果找不到该文件，则将引发异常 <xref:System.IO.FileNotFoundException>。</span><span class="sxs-lookup"><span data-stu-id="42801-1006">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="42801-1007">此方法使用在 Windows Socket 2 API 中找到的 `TransmitFile` 函数。</span><span class="sxs-lookup"><span data-stu-id="42801-1007">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="42801-1008">有关 `TransmitFile` 函数及其标志的详细信息，请参阅[Windows 套接字](/windows/desktop/WinSock/)文档。</span><span class="sxs-lookup"><span data-stu-id="42801-1008">For more information about the `TransmitFile` function and its flags, see the [Windows Sockets](/windows/desktop/WinSock/) documentation.</span></span>  
  
 <span data-ttu-id="42801-1009"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> 方法开始异步发送操作到在 <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法中建立的远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1009">The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods.</span></span> <span data-ttu-id="42801-1010">如果不首先调用 <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.BeginConnect%2A>，<xref:System.Net.Sockets.Socket.BeginSendFile%2A> 会引发异常。</span><span class="sxs-lookup"><span data-stu-id="42801-1010"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="42801-1011">通过调用 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 方法，您可以在单独的执行线程中发送文件。</span><span class="sxs-lookup"><span data-stu-id="42801-1011">Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method enables you to send a file within a separate execution thread.</span></span>  
  
 <span data-ttu-id="42801-1012">若要完成此操作，可以创建一个由 <xref:System.AsyncCallback> 委托参数调用的回调方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1012">To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter.</span></span> <span data-ttu-id="42801-1013">为此，至少 `state` 参数必须包含用于通信的 <xref:System.Net.Sockets.Socket> 对象。</span><span class="sxs-lookup"><span data-stu-id="42801-1013">To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication.</span></span> <span data-ttu-id="42801-1014">如果回调需要更多的信息，可以创建一个类或结构来保存 <xref:System.Net.Sockets.Socket> 和其他所需的信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1014">If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="42801-1015">通过 `state` 参数向 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 方法传递此自定义对象的实例。</span><span class="sxs-lookup"><span data-stu-id="42801-1015">Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="42801-1016">回调方法必须调用 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1016">Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method.</span></span> <span data-ttu-id="42801-1017">当应用程序调用 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>时，系统将使用一个单独的线程来执行指定的回调方法，并在 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 上阻止，直到 <xref:System.Net.Sockets.Socket> 发送整个文件或引发异常。</span><span class="sxs-lookup"><span data-stu-id="42801-1017">When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception.</span></span> <span data-ttu-id="42801-1018">有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1018">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="42801-1019">尽管适用于面向连接的协议，但 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 也适用于无连接协议，前提是你首先调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法来建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1019">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="42801-1020">在无连接协议的情况下，必须确保文件大小不超过基础服务提供程序的最大数据包大小。</span><span class="sxs-lookup"><span data-stu-id="42801-1020">With connectionless protocols, you must be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="42801-1021">如果是这样，则不发送数据报并且 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 引发 <xref:System.Net.Sockets.SocketException> 异常。</span><span class="sxs-lookup"><span data-stu-id="42801-1021">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1022">如果收到 <xref:System.Net.Sockets.SocketException> 异常，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1022">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1023">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1023">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1024">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1024">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1025">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1025">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1026">对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。</span><span class="sxs-lookup"><span data-stu-id="42801-1026">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="42801-1027">第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。</span><span class="sxs-lookup"><span data-stu-id="42801-1027">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1028">下面的代码示例创建并连接套接字以进行异步通信。</span><span class="sxs-lookup"><span data-stu-id="42801-1028">The following code example creates and connects a socket for asynchronous communication.</span></span> <span data-ttu-id="42801-1029">首先，将文件 "text .txt" 异步发送到远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1029">First, the file "text.txt" is sent asynchronously to the remote host.</span></span> <span data-ttu-id="42801-1030">回调委托调用 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 来完成传输。</span><span class="sxs-lookup"><span data-stu-id="42801-1030">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1031"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1031">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-1032">套接字未连接到远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1032">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="42801-1033">未找到文件 <paramref name="fileName" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1033">The file <paramref name="fileName" /> was not found.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1034">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1034">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="42801-1035">请参见下面的备注部分。</span><span class="sxs-lookup"><span data-stu-id="42801-1035">See remarks section below.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="42801-1036">一个字符串，它包含要发送的文件的路径和名称。</span><span class="sxs-lookup"><span data-stu-id="42801-1036">A string that contains the path and name of the file to be sent.</span></span> <span data-ttu-id="42801-1037">此参数可以为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1037">This parameter can be <see langword="null" />.</span></span></param>
        <param name="preBuffer"><span data-ttu-id="42801-1038">一个 <see cref="T:System.Byte" /> 数组，它包含发送文件前要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1038">A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent.</span></span> <span data-ttu-id="42801-1039">此参数可以为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1039">This parameter can be <see langword="null" />.</span></span></param>
        <param name="postBuffer"><span data-ttu-id="42801-1040">一个 <see cref="T:System.Byte" /> 数组，它包含发送文件后要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1040">A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent.</span></span> <span data-ttu-id="42801-1041">此参数可以为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1041">This parameter can be <see langword="null" />.</span></span></param>
        <param name="flags"><span data-ttu-id="42801-1042"><see cref="T:System.Net.Sockets.TransmitFileOptions" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-1042">A bitwise combination of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="42801-1043">一个 <see cref="T:System.AsyncCallback" /> 委托，将在此操作完成时调用它。</span><span class="sxs-lookup"><span data-stu-id="42801-1043">An <see cref="T:System.AsyncCallback" /> delegate to be invoked when this operation completes.</span></span> <span data-ttu-id="42801-1044">此参数可以为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1044">This parameter can be <see langword="null" />.</span></span></param>
        <param name="state"><span data-ttu-id="42801-1045">一个用户定义的对象，它包含此请求的状态信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1045">A user-defined object that contains state information for this request.</span></span> <span data-ttu-id="42801-1046">此参数可以为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1046">This parameter can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="42801-1047">将文件和数据缓冲区异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="42801-1047">Sends a file and buffers of data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="42801-1048">一个 <see cref="T:System.IAsyncResult" /> 对象，它表示异步操作。</span><span class="sxs-lookup"><span data-stu-id="42801-1048">An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1049">此重载要求要发送的文件的名称和 <xref:System.Net.Sockets.TransmitFileOptions> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-1049">This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values.</span></span> <span data-ttu-id="42801-1050">`preBuffer` 参数包含要置于该文件之前的所有数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1050">The `preBuffer` parameter contains any data you want to precede the file.</span></span> <span data-ttu-id="42801-1051">`postBuffer` 包含要跟踪文件的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1051">`postBuffer` contains data you want to follow the file.</span></span> <span data-ttu-id="42801-1052">如果 `fileName` 位于本地目录中，则只能用该文件的名称进行标识;否则，必须指定文件的完整路径和名称。</span><span class="sxs-lookup"><span data-stu-id="42801-1052">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="42801-1053">通配符（".。。支持\\\myfile.txt "）和 UNC 共享名称（"\\\\\\\shared 目录\\\myfile.txt "）。</span><span class="sxs-lookup"><span data-stu-id="42801-1053">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="42801-1054">如果找不到该文件，则将引发异常 <xref:System.IO.FileNotFoundException>。</span><span class="sxs-lookup"><span data-stu-id="42801-1054">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="42801-1055">`flags` 参数为窗口套接字服务提供程序提供有关文件传输的其他信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1055">The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="42801-1056">有关如何使用此参数的详细信息，请参阅 <xref:System.Net.Sockets.TransmitFileOptions>。</span><span class="sxs-lookup"><span data-stu-id="42801-1056">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="42801-1057">此方法使用在 Windows Socket 2 API 中找到的 `TransmitFile` 函数。</span><span class="sxs-lookup"><span data-stu-id="42801-1057">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="42801-1058">有关 `TransmitFile` 函数及其标志的详细信息，请参阅[Windows 套接字](/windows/desktop/WinSock/)文档。</span><span class="sxs-lookup"><span data-stu-id="42801-1058">For more information about the `TransmitFile` function and its flags, see the [Windows Sockets](/windows/desktop/WinSock/) documentation.</span></span>  
  
 <span data-ttu-id="42801-1059"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> 方法开始异步发送操作到在 <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法中建立的远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1059">The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods.</span></span> <span data-ttu-id="42801-1060">如果不首先调用 <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.BeginConnect%2A>，<xref:System.Net.Sockets.Socket.BeginSendFile%2A> 会引发异常。</span><span class="sxs-lookup"><span data-stu-id="42801-1060"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="42801-1061">调用 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 方法使你能够在单独的执行线程中发送文件。</span><span class="sxs-lookup"><span data-stu-id="42801-1061">Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method gives you the ability to send a file within a separate execution thread.</span></span>  
  
 <span data-ttu-id="42801-1062">若要完成此操作，可以创建一个由 <xref:System.AsyncCallback> 委托参数调用的回调方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1062">To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter.</span></span> <span data-ttu-id="42801-1063">为此，至少 `state` 参数必须包含用于通信的 <xref:System.Net.Sockets.Socket> 对象。</span><span class="sxs-lookup"><span data-stu-id="42801-1063">To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication.</span></span> <span data-ttu-id="42801-1064">如果回调需要更多的信息，可以创建一个类或结构来保存 <xref:System.Net.Sockets.Socket> 和其他所需的信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1064">If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="42801-1065">通过 `state` 参数向 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 方法传递此自定义对象的实例。</span><span class="sxs-lookup"><span data-stu-id="42801-1065">Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="42801-1066">回调方法必须调用 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1066">Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method.</span></span> <span data-ttu-id="42801-1067">当应用程序调用 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>时，系统将使用一个单独的线程来执行指定的回调方法，并在 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 上阻止，直到 <xref:System.Net.Sockets.Socket> 发送整个文件或引发异常。</span><span class="sxs-lookup"><span data-stu-id="42801-1067">When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception.</span></span> <span data-ttu-id="42801-1068">有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1068">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="42801-1069">尽管适用于面向连接的协议，但 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 也适用于无连接协议，前提是你首先调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法来建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1069">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="42801-1070">在无连接协议的情况下，你还必须确保文件大小不超过基础服务提供程序的最大数据包大小。</span><span class="sxs-lookup"><span data-stu-id="42801-1070">With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="42801-1071">如果是这样，则不发送数据报并且 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 引发 <xref:System.Net.Sockets.SocketException> 异常。</span><span class="sxs-lookup"><span data-stu-id="42801-1071">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1072">如果收到 <xref:System.Net.Sockets.SocketException> 异常，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1072">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1073">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1073">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1074">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1074">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1075">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1075">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1076">对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。</span><span class="sxs-lookup"><span data-stu-id="42801-1076">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="42801-1077">第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。</span><span class="sxs-lookup"><span data-stu-id="42801-1077">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1078">下面的代码示例创建并连接套接字用于异步通信，并开始将文件 "test.txt" 异步发送到远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1078">The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</span></span> <span data-ttu-id="42801-1079">在此示例中，将创建一个与文件一起发送的 `preBuffer` 和 `postBuffer` 的数据，并使用默认的 <xref:System.Net.Sockets.TransmitFileOptions> 值。</span><span class="sxs-lookup"><span data-stu-id="42801-1079">In this example, a `preBuffer` and a `postBuffer` of data is created to send with the file and the default <xref:System.Net.Sockets.TransmitFileOptions> value is used.</span></span> <span data-ttu-id="42801-1080">回调委托调用 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 来完成传输。</span><span class="sxs-lookup"><span data-stu-id="42801-1080">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1081"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1081">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1082">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1082">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="42801-1083">请参见下面的备注部分。</span><span class="sxs-lookup"><span data-stu-id="42801-1083">See remarks section below.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-1084">操作系统不是 Windows NT 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="42801-1084">The operating system is not Windows NT or later.</span></span>  
  
<span data-ttu-id="42801-1085">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-1085">-or-</span></span>
  
 <span data-ttu-id="42801-1086">套接字未连接到远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1086">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="42801-1087">未找到文件 <paramref name="fileName" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1087">The file <paramref name="fileName" /> was not found.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socketFlags, remoteEP, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-1088"><see cref="T:System.Byte" /> 类型的数组，它包含要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1088">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="offset"><span data-ttu-id="42801-1089"><paramref name="buffer" /> 中的从其开始发送数据的、从零开始编排的位置。</span><span class="sxs-lookup"><span data-stu-id="42801-1089">The zero-based position in <paramref name="buffer" /> at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="42801-1090">要发送的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-1090">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-1091"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-1091">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="socket_flags"><span data-ttu-id="42801-1092"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-1092">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="42801-1093">表示远程设备的 <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1093">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</span></span></param>
        <param name="remote_end"><span data-ttu-id="42801-1094">表示远程设备的 <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1094">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</span></span></param>
        <param name="callback"><span data-ttu-id="42801-1095"><see cref="T:System.AsyncCallback" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="42801-1095">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="42801-1096">包含此请求的状态信息的对象。</span><span class="sxs-lookup"><span data-stu-id="42801-1096">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="42801-1097">以异步方式将数据发送到特定远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1097">Sends data asynchronously to a specific remote host.</span></span></summary>
        <returns><span data-ttu-id="42801-1098">引用异步发送的 <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1098">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1099"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> 方法对 `remoteEP` 参数中指定的远程主机启动异步发送操作。</span><span class="sxs-lookup"><span data-stu-id="42801-1099">The <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method starts an asynchronous send operation to the remote host specified in the `remoteEP` parameter.</span></span> <span data-ttu-id="42801-1100">调用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 方法使你能够在单独的执行线程中发送数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1100">Calling the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method gives you the ability to send data within a separate execution thread.</span></span> <span data-ttu-id="42801-1101">尽管适用于无连接协议，但 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 适用于连接和面向连接的协议。</span><span class="sxs-lookup"><span data-stu-id="42801-1101">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> works with both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="42801-1102">你可以创建一个实现 <xref:System.AsyncCallback> 委托的回调方法，并将其名称传递到 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1102">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method.</span></span> <span data-ttu-id="42801-1103">为此，你的 `state` 参数至少必须包含用于通信的已连接或默认 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-1103">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="42801-1104">如果回调需要更多的信息，可以创建一个小类来保存 <xref:System.Net.Sockets.Socket>，并创建其他必需的信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1104">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information.</span></span> <span data-ttu-id="42801-1105">通过 `state` 参数将此类的实例传递给 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1105">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="42801-1106">回调方法应调用 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1106">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method.</span></span> <span data-ttu-id="42801-1107">当应用程序调用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>时，系统将使用一个单独的线程来执行指定的回调方法，并将在 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 上阻塞，直到 <xref:System.Net.Sockets.Socket> 发送请求的字节数或引发异常。</span><span class="sxs-lookup"><span data-stu-id="42801-1107">When your application calls <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSendTo%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="42801-1108">如果希望在调用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 方法后原始线程被阻止，请使用 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1108">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="42801-1109">如果希望原始线程继续执行，请在回调方法中的 T:System.Threading.ManualResetEvent 上调用 Set 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1109">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="42801-1110">有关编写回调方法的其他信息，请参阅将[委托作为回调方法进行封送处理](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1110">For additional information about writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="42801-1111">如果使用面向连接的协议，则必须先调用 <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法，否则 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-1111">If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, or <xref:System.Net.Sockets.Socket.BeginSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-1112"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> 将忽略 `remoteEP` 参数，并将数据发送到 <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法中建立的 <xref:System.Net.EndPoint>。</span><span class="sxs-lookup"><span data-stu-id="42801-1112"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> will ignore the `remoteEP` parameter and send data to the <xref:System.Net.EndPoint> established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="42801-1113">如果使用的是无连接协议，则在调用 <xref:System.Net.Sockets.Socket.SendTo%2A>之前，无需使用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1113">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="42801-1114">如果要调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法，只需执行此操作。</span><span class="sxs-lookup"><span data-stu-id="42801-1114">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="42801-1115">如果在调用 <xref:System.Net.Sockets.Socket.SendTo%2A>之前调用了 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法，则 `remoteEP` 参数只会重写该发送操作的指定默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1115">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="42801-1116">您也不需要调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1116">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="42801-1117">在这种情况下，基础服务提供程序将分配最适当的本地网络地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-1117">In this case, the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="42801-1118">如果希望基础服务提供商选择可用端口，请使用端口号零。</span><span class="sxs-lookup"><span data-stu-id="42801-1118">Use a port number of zero if you want the underlying service provider to select a free port.</span></span> <span data-ttu-id="42801-1119">如果需要确定分配的本地网络地址和端口号，可以在 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 方法成功完成后使用 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="42801-1119">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="42801-1120">如果要将数据发送到广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将套接字选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="42801-1120">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-1121">-还必须确保缓冲区的大小不超过基础服务提供程序的最大数据包大小。</span><span class="sxs-lookup"><span data-stu-id="42801-1121">-You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="42801-1122">如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-1122">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.EndSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="42801-1123">如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则将不路由要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1123">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1124">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1124">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1125">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1125">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1126">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1126">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1127">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1127">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1128">对异步 <xref:System.Net.Sockets.Socket> 方法缓存执行上下文（安全上下文、模拟用户和调用上下文）。</span><span class="sxs-lookup"><span data-stu-id="42801-1128">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="42801-1129">第一次使用特定上下文（特定的异步 <xref:System.Net.Sockets.Socket> 方法、特定的 <xref:System.Net.Sockets.Socket> 实例和特定回调）后，该上下文的后续使用将会提高性能。</span><span class="sxs-lookup"><span data-stu-id="42801-1129">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1130">下面的代码示例将数据异步发送到指定的远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1130">The following code example asynchronously sends data to the specified remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-1131"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1131"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="42801-1132">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-1132">-or-</span></span> 
 <span data-ttu-id="42801-1133"><paramref name="remoteEP" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1133"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1134">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1134">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-1135"><paramref name="offset" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-1135"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-1136">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-1136">-or-</span></span> 
 <span data-ttu-id="42801-1137"><paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="42801-1137"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="42801-1138">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-1138">-or-</span></span> 
 <span data-ttu-id="42801-1139"><paramref name="size" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-1139"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-1140">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-1140">-or-</span></span> 
 <span data-ttu-id="42801-1141"><paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</span><span class="sxs-lookup"><span data-stu-id="42801-1141"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1142"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1142">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="42801-1143">调用堆栈中的较高调用方无权执行所请求的操作。</span><span class="sxs-lookup"><span data-stu-id="42801-1143">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="42801-1144">将委托作为回调方法进行封送</span><span class="sxs-lookup"><span data-stu-id="42801-1144">Marshaling a Delegate as a Callback Method</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP"><span data-ttu-id="42801-1145">要与 <see cref="T:System.Net.EndPoint" /> 关联的本地 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1145">The local <see cref="T:System.Net.EndPoint" /> to associate with the <see cref="T:System.Net.Sockets.Socket" />.</span></span></param>
        <summary><span data-ttu-id="42801-1146">使 <see cref="T:System.Net.Sockets.Socket" /> 与一个本地终结点相关联。</span><span class="sxs-lookup"><span data-stu-id="42801-1146">Associates a <see cref="T:System.Net.Sockets.Socket" /> with a local endpoint.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1147">如果需要使用特定的本地终结点，请使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1147">Use the <xref:System.Net.Sockets.Socket.Bind%2A> method if you need to use a specific local endpoint.</span></span> <span data-ttu-id="42801-1148">必须先调用 <xref:System.Net.Sockets.Socket.Bind%2A>，然后才能调用 <xref:System.Net.Sockets.Socket.Listen%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1148">You must call <xref:System.Net.Sockets.Socket.Bind%2A> before you can call the <xref:System.Net.Sockets.Socket.Listen%2A> method.</span></span> <span data-ttu-id="42801-1149">除非需要使用特定的本地终结点，否则在使用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法之前无需调用 <xref:System.Net.Sockets.Socket.Bind%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-1149">You do not need to call <xref:System.Net.Sockets.Socket.Bind%2A> before using the <xref:System.Net.Sockets.Socket.Connect%2A> method unless you need to use a specific local endpoint.</span></span> <span data-ttu-id="42801-1150">可以在无连接和面向连接的协议上使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1150">You can use the <xref:System.Net.Sockets.Socket.Bind%2A> method on both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="42801-1151">在调用 <xref:System.Net.Sockets.Socket.Bind%2A>之前，必须先创建要用于与数据通信的本地 <xref:System.Net.IPEndPoint>。</span><span class="sxs-lookup"><span data-stu-id="42801-1151">Before calling <xref:System.Net.Sockets.Socket.Bind%2A>, you must first create the local <xref:System.Net.IPEndPoint> from which you intend to communicate data.</span></span> <span data-ttu-id="42801-1152">如果你不关心分配了哪个本地地址，则可以使用 <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> 作为 address 参数创建 <xref:System.Net.IPEndPoint>，基础服务提供程序将分配最适当的网络地址。</span><span class="sxs-lookup"><span data-stu-id="42801-1152">If you do not care which local address is assigned, you can create an <xref:System.Net.IPEndPoint> using <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> as the address parameter, and the underlying service provider will assign the most appropriate network address.</span></span> <span data-ttu-id="42801-1153">如果你有多个网络接口，这可能有助于简化你的应用程序。</span><span class="sxs-lookup"><span data-stu-id="42801-1153">This might help simplify your application if you have multiple network interfaces.</span></span> <span data-ttu-id="42801-1154">如果你不介意使用哪个本地端口，则可以使用0作为端口号来创建 <xref:System.Net.IPEndPoint>。</span><span class="sxs-lookup"><span data-stu-id="42801-1154">If you do not care which local port is used, you can create an <xref:System.Net.IPEndPoint> using 0 for the port number.</span></span> <span data-ttu-id="42801-1155">在这种情况下，服务提供商将分配介于1024和5000之间的可用端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-1155">In this case, the service provider will assign an available port number between 1024 and 5000.</span></span>  
  
 <span data-ttu-id="42801-1156">如果使用以上方法，则可以通过调用 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>来发现分配的本地网络地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-1156">If you use the above approach, you can discover what local network address and port number has been assigned by calling the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>.</span></span> <span data-ttu-id="42801-1157">如果你使用的是面向连接的协议，则在调用 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.EndConnect%2A> 方法之前，<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 不会返回本地分配的网络地址。</span><span class="sxs-lookup"><span data-stu-id="42801-1157">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> will not return the locally assigned network address until after you have made a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="42801-1158">如果使用的是无连接协议，则在完成发送或接收之前，将无法访问此信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1158">If you are using a connectionless protocol, you will not have access to this information until you have completed a send or receive.</span></span>  
  
 <span data-ttu-id="42801-1159">如果 UDP 套接字希望接收有关接收到的数据包的接口信息，应在调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法之后，使用套接字选项显式调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法 <xref:System.Net.Sockets.SocketOptionName.PacketInformation>。</span><span class="sxs-lookup"><span data-stu-id="42801-1159">If a UDP socket wants to receive interface information on received packets,  the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method should be explicitly called with the socket option set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation> immediately after calling the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1160">如果打算接收多播数据报，则必须使用多播端口号调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1160">If you intend to receive multicast datagrams, you must call the <xref:System.Net.Sockets.Socket.Bind%2A> method with a multicast port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1161">如果打算使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法接收无连接的数据报，则必须调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1161">You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method if you intend to receive connectionless datagrams using the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1162">如果在调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法时接收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性来获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1162">If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1163">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1163">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1164">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1164">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1165">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1165">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1166">下面的代码示例使用指定的本地终结点绑定 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-1166">The following code example binds a <xref:System.Net.Sockets.Socket> using the specified local endpoint.</span></span>  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-1167"><paramref name="localEP" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1167"><paramref name="localEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1168">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1168">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1169"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1169">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="42801-1170">调用堆栈中的较高调用方无权执行所请求的操作。</span><span class="sxs-lookup"><span data-stu-id="42801-1170">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="42801-1171">用于接受来自 <paramref name="localEP" />定义的主机的连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1171">for accepting connections from the host defined by <paramref name="localEP" />.</span></span> <span data-ttu-id="42801-1172">关联的枚举： <see cref="F:System.Net.NetworkAccess.Accept" /></span><span class="sxs-lookup"><span data-stu-id="42801-1172">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></span></span></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-1173">获取或设置一个值，该值指示 <see cref="T:System.Net.Sockets.Socket" /> 是否处于阻止模式。</span><span class="sxs-lookup"><span data-stu-id="42801-1173">Gets or sets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is in blocking mode.</span></span></summary>
        <value><span data-ttu-id="42801-1174">如果 <see langword="true" /> 将阻止，则为 <see cref="T:System.Net.Sockets.Socket" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1174"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> will block; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="42801-1175">默认值为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1175">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1176"><xref:System.Net.Sockets.Socket.Blocking%2A> 属性指示 <xref:System.Net.Sockets.Socket> 是否处于阻止模式。</span><span class="sxs-lookup"><span data-stu-id="42801-1176">The <xref:System.Net.Sockets.Socket.Blocking%2A> property indicates whether a <xref:System.Net.Sockets.Socket> is in blocking mode.</span></span>  
  
 <span data-ttu-id="42801-1177">如果你处于阻止模式，并且你进行了一个不会立即完成的方法调用，则应用程序将在请求的操作完成前阻止执行。</span><span class="sxs-lookup"><span data-stu-id="42801-1177">If you are in blocking mode, and you make a method call which does not complete immediately, your application will block execution until the requested operation completes.</span></span> <span data-ttu-id="42801-1178">如果希望在请求的操作未完成的情况下继续执行，请将 <xref:System.Net.Sockets.Socket.Blocking%2A> 属性更改为 `false`。</span><span class="sxs-lookup"><span data-stu-id="42801-1178">If you want execution to continue even though the requested operation is not complete, change the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false`.</span></span> <span data-ttu-id="42801-1179"><xref:System.Net.Sockets.Socket.Blocking%2A> 属性对异步方法不起作用。</span><span class="sxs-lookup"><span data-stu-id="42801-1179">The <xref:System.Net.Sockets.Socket.Blocking%2A> property has no effect on asynchronous methods.</span></span> <span data-ttu-id="42801-1180">如果要异步发送和接收数据，并想要阻止执行，请使用 <xref:System.Threading.ManualResetEvent> 类。</span><span class="sxs-lookup"><span data-stu-id="42801-1180">If you are sending and receiving data asynchronously and want to block execution, use the <xref:System.Threading.ManualResetEvent> class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1181">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1181">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1182">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1182">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1183">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1183">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1184">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1184">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1185">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1185">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1186"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1186">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="42801-1187"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象，该对象用于通过调用 <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> 方法之一，请求与远程主机的连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1187">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object used to request the connection to the remote host by calling one of the <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> methods.</span></span></param>
        <summary><span data-ttu-id="42801-1188">取消一个对远程主机连接的异步请求。</span><span class="sxs-lookup"><span data-stu-id="42801-1188">Cancels an asynchronous request for a remote host connection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1189"><xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> 方法取消对远程主机连接的异步请求。</span><span class="sxs-lookup"><span data-stu-id="42801-1189">The <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> method cancels an asynchronous request for a remote host connection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-1190"><paramref name="e" /> 参数不能为 null，并且 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为空。</span><span class="sxs-lookup"><span data-stu-id="42801-1190">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1191">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1191">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1192"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1192">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="42801-1193">调用堆栈中的较高调用方无权执行所请求的操作。</span><span class="sxs-lookup"><span data-stu-id="42801-1193">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42801-1194">关闭 <see cref="T:System.Net.Sockets.Socket" /> 连接并释放所有关联的资源。</span><span class="sxs-lookup"><span data-stu-id="42801-1194">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="42801-1195">关闭 <see cref="T:System.Net.Sockets.Socket" /> 连接并释放所有关联的资源。</span><span class="sxs-lookup"><span data-stu-id="42801-1195">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1196"><xref:System.Net.Sockets.Socket.Close%2A> 方法会关闭远程主机连接，并释放与 <xref:System.Net.Sockets.Socket>关联的所有托管资源和非托管资源。</span><span class="sxs-lookup"><span data-stu-id="42801-1196">The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-1197">关闭时，<xref:System.Net.Sockets.Socket.Connected%2A> 属性设置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="42801-1197">Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.</span></span>  
  
 <span data-ttu-id="42801-1198">对于面向连接的协议，建议你在调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法之前调用 <xref:System.Net.Sockets.Socket.Shutdown%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-1198">For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span> <span data-ttu-id="42801-1199">这可确保所有数据在连接的套接字关闭之前都已发送和接收。</span><span class="sxs-lookup"><span data-stu-id="42801-1199">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="42801-1200">如果需要在不首先调用 <xref:System.Net.Sockets.Socket.Shutdown%2A>的情况下调用 <xref:System.Net.Sockets.Socket.Close%2A>，则可以通过将 <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> 选项设置为 `false` 并指定非零超时间隔来确保将排队等待传出传输的数据发送。</span><span class="sxs-lookup"><span data-stu-id="42801-1200">If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specifying a non-zero time-out interval.</span></span> <span data-ttu-id="42801-1201">然后，<xref:System.Net.Sockets.Socket.Close%2A> 将被阻止，直到发送此数据或指定的超时过期。</span><span class="sxs-lookup"><span data-stu-id="42801-1201"><xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="42801-1202">如果将 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 设置为 `false` 并指定零超时间隔，<xref:System.Net.Sockets.Socket.Close%2A> 会释放连接并自动丢弃传出的排队数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1202">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1203">若要将 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 套接字选项设置为 `false`，请创建 <xref:System.Net.Sockets.LingerOption>，将 "enabled" 属性设置为 `true`，并将 "<xref:System.Net.Sockets.LingerOption.LingerTime%2A>" 属性设置为所需的超时时间。</span><span class="sxs-lookup"><span data-stu-id="42801-1203">To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time out period.</span></span> <span data-ttu-id="42801-1204">使用此 <xref:System.Net.Sockets.LingerOption> 和 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 套接字选项来调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1204">Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1205">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1205">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1206">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1206">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1207">下面的代码示例关闭 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-1207">The following code example closes a <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="42801-1208">等待最多 <paramref name="timeout" /> 秒钟后，即可发送任何剩余数据，然后关闭套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-1208">Wait up to <paramref name="timeout" /> seconds to send any remaining data, then close the socket.</span></span></param>
        <summary><span data-ttu-id="42801-1209">关闭 <see cref="T:System.Net.Sockets.Socket" /> 连接并释放所有与指定超时关联的资源，以允许要发送的数据排队。</span><span class="sxs-lookup"><span data-stu-id="42801-1209">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources with a specified timeout to allow queued data to be sent.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1210"><xref:System.Net.Sockets.Socket.Close%2A> 方法会关闭远程主机连接，并释放与 <xref:System.Net.Sockets.Socket>关联的所有托管资源和非托管资源。</span><span class="sxs-lookup"><span data-stu-id="42801-1210">The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-1211">关闭时，<xref:System.Net.Sockets.Socket.Connected%2A> 属性设置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="42801-1211">Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.</span></span>  
  
 <span data-ttu-id="42801-1212">对于面向连接的协议，建议你在调用 <xref:System.Net.Sockets.Socket.Close%2A>之前调用 <xref:System.Net.Sockets.Socket.Shutdown%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-1212">For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling <xref:System.Net.Sockets.Socket.Close%2A>.</span></span> <span data-ttu-id="42801-1213">这可确保所有数据在连接的套接字关闭之前都已发送和接收。</span><span class="sxs-lookup"><span data-stu-id="42801-1213">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="42801-1214">如果需要在不首先调用 <xref:System.Net.Sockets.Socket.Shutdown%2A>的情况下调用 <xref:System.Net.Sockets.Socket.Close%2A>，则可以通过将 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 选项设置为 `false` 并指定一个非零超时间隔来确保将排队等待传出传输的数据发送。</span><span class="sxs-lookup"><span data-stu-id="42801-1214">If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger> option to `false` and specifying a non-zero time-out interval.</span></span> <span data-ttu-id="42801-1215">然后，<xref:System.Net.Sockets.Socket.Close%2A> 将被阻止，直到发送此数据或指定的超时过期。</span><span class="sxs-lookup"><span data-stu-id="42801-1215"><xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="42801-1216">如果将 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 设置为 `false` 并指定零超时间隔，<xref:System.Net.Sockets.Socket.Close%2A> 会释放连接并自动丢弃传出的排队数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1216">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1217">若要将 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 套接字选项设置为 `false`，请创建 <xref:System.Net.Sockets.LingerOption>，将 "enabled" 属性设置为 `true`，并将 "<xref:System.Net.Sockets.LingerOption.LingerTime%2A>" 属性设置为所需的超时期限。</span><span class="sxs-lookup"><span data-stu-id="42801-1217">To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time-out period.</span></span> <span data-ttu-id="42801-1218">使用此 <xref:System.Net.Sockets.LingerOption> 和 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 套接字选项来调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1218">Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1219">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1219">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1220">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1220">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1221">下面的代码示例演示如何关闭 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-1221">The following code example demonstrates how to close a <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42801-1222">与远程主机建立连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1222">Establishes a connection to a remote host.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP"><span data-ttu-id="42801-1223">表示远程设备的 <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1223">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</span></span></param>
        <summary><span data-ttu-id="42801-1224">与远程主机建立连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1224">Establishes a connection to a remote host.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1225">如果你使用的是面向连接的协议（例如 TCP），<xref:System.Net.Sockets.Socket.Connect%2A> 方法将同步在 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 与指定的远程终结点之间建立网络连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1225">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="42801-1226">如果使用的是无连接协议，<xref:System.Net.Sockets.Socket.Connect%2A> 会建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1226">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="42801-1227">调用 <xref:System.Net.Sockets.Socket.Connect%2A>后，可以通过 <xref:System.Net.Sockets.Socket.Send%2A> 方法将数据发送到远程设备，或通过 <xref:System.Net.Sockets.Socket.Receive%2A> 方法从远程设备接收数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1227">After you call <xref:System.Net.Sockets.Socket.Connect%2A>, you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="42801-1228">如果使用的是无连接协议（如 UDP），则在发送和接收数据之前无需调用 <xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-1228">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="42801-1229">您可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 和 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 与远程主机同步通信。</span><span class="sxs-lookup"><span data-stu-id="42801-1229">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="42801-1230">如果调用 <xref:System.Net.Sockets.Socket.Connect%2A>，则从指定的默认值以外的地址到达的任何数据报都将被丢弃。</span><span class="sxs-lookup"><span data-stu-id="42801-1230">If you do call <xref:System.Net.Sockets.Socket.Connect%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="42801-1231">如果要将默认远程主机设置为广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将 socket 选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，否则 <xref:System.Net.Sockets.Socket.Connect%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-1231">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-1232">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1232">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1233">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1233">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="42801-1234">除非在调用 <xref:System.Net.Sockets.Socket.Connect%2A>之前专门将 <xref:System.Net.Sockets.Socket.Blocking%2A> 属性设置为 `false`，否则 <xref:System.Net.Sockets.Socket.Connect%2A> 方法将会阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-1234">The <xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="42801-1235">如果使用面向连接的协议（如 TCP），并禁用阻止，<xref:System.Net.Sockets.Socket.Connect%2A> 将引发 <xref:System.Net.Sockets.SocketException>，因为它需要时间来建立连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1235">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="42801-1236">无连接协议不会引发异常，因为它们只是建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1236">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="42801-1237">您可以使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1237">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="42801-1238">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1238">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="42801-1239">如果错误返回了 WSAEWOULDBLOCK，则已通过面向连接的 <xref:System.Net.Sockets.Socket>启动了远程主机连接，但尚未成功完成。</span><span class="sxs-lookup"><span data-stu-id="42801-1239">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="42801-1240">使用 <xref:System.Net.Sockets.Socket.Poll%2A> 方法可确定 <xref:System.Net.Sockets.Socket> 连接完成的时间。</span><span class="sxs-lookup"><span data-stu-id="42801-1240">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1241">如果使用面向连接的协议，且在调用 <xref:System.Net.Sockets.Socket.Connect%2A>之前未调用 <xref:System.Net.Sockets.Socket.Bind%2A>，则基础服务提供程序将分配本地网络地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-1241">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="42801-1242">如果使用的是无连接协议，则在完成发送或接收操作之前，服务提供程序将不会分配本地网络地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-1242">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="42801-1243">如果要更改默认远程主机，请再次调用 <xref:System.Net.Sockets.Socket.Connect%2A> 所需的终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-1243">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1244">如果先前已断开套接字连接，则不能使用此方法来还原连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1244">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="42801-1245">使用异步 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法之一重新连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1245">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="42801-1246">这是底层提供程序的限制。</span><span class="sxs-lookup"><span data-stu-id="42801-1246">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1247">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1247">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1248">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1248">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1249">下面的代码示例连接到远程终结点，并验证连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1249">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-1250"><paramref name="remoteEP" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1250"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1251">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1251">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1252"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1252">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="42801-1253">调用堆栈中的较高调用方无权执行所请求的操作。</span><span class="sxs-lookup"><span data-stu-id="42801-1253">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-1254">已通过调用 <see cref="T:System.Net.Sockets.Socket" /> 将 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 置于侦听状态。</span><span class="sxs-lookup"><span data-stu-id="42801-1254">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="42801-1255">用于连接到远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1255">for connecting to the remote host.</span></span> <span data-ttu-id="42801-1256">关联的枚举： <see cref="F:System.Net.NetworkAccess.Connect" /></span><span class="sxs-lookup"><span data-stu-id="42801-1256">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Connect" /></span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="42801-1257">远程主机的 IP 地址。</span><span class="sxs-lookup"><span data-stu-id="42801-1257">The IP address of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="42801-1258">远程主机的端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-1258">The port number of the remote host.</span></span></param>
        <summary><span data-ttu-id="42801-1259">与远程主机建立连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1259">Establishes a connection to a remote host.</span></span> <span data-ttu-id="42801-1260">主机由 IP 地址和端口号指定。</span><span class="sxs-lookup"><span data-stu-id="42801-1260">The host is specified by an IP address and a port number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1261">如果你使用的是面向连接的协议（例如 TCP），<xref:System.Net.Sockets.Socket.Connect%2A> 方法将同步在 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 与指定的远程终结点之间建立网络连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1261">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="42801-1262">如果使用的是无连接协议，<xref:System.Net.Sockets.Socket.Connect%2A> 会建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1262">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="42801-1263">调用 <xref:System.Net.Sockets.Socket.Connect%2A> 可以通过 <xref:System.Net.Sockets.Socket.Send%2A> 方法将数据发送到远程设备，或通过 <xref:System.Net.Sockets.Socket.Receive%2A> 方法从远程设备接收数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1263">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="42801-1264">如果使用的是无连接协议（如 UDP），则在发送和接收数据之前无需调用 <xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-1264">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="42801-1265">您可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 和 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 与远程主机同步通信。</span><span class="sxs-lookup"><span data-stu-id="42801-1265">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="42801-1266">如果确实调用 <xref:System.Net.Sockets.Socket.Connect%2A> 从指定的默认值以外的地址到达的任何数据报都将被丢弃。</span><span class="sxs-lookup"><span data-stu-id="42801-1266">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="42801-1267">如果要将默认远程主机设置为广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将 socket 选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，否则 <xref:System.Net.Sockets.Socket.Connect%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-1267">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-1268">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1268">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1269">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1269">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="42801-1270"><xref:System.Net.Sockets.Socket.Connect%2A> 方法将会阻止，除非在调用 <xref:System.Net.Sockets.Socket.Connect%2A>之前专门将 <xref:System.Net.Sockets.Socket.Blocking%2A> 属性设置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="42801-1270"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="42801-1271">如果使用面向连接的协议（如 TCP），并禁用阻止，<xref:System.Net.Sockets.Socket.Connect%2A> 将引发 <xref:System.Net.Sockets.SocketException>，因为它需要时间来建立连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1271">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="42801-1272">无连接协议不会引发异常，因为它们只是建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1272">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="42801-1273">您可以使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1273">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="42801-1274">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1274">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="42801-1275">如果错误返回了 WSAEWOULDBLOCK，则已通过面向连接的 <xref:System.Net.Sockets.Socket>启动了远程主机连接，但尚未成功完成。</span><span class="sxs-lookup"><span data-stu-id="42801-1275">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="42801-1276">使用 <xref:System.Net.Sockets.Socket.Poll%2A> 方法可确定 <xref:System.Net.Sockets.Socket> 连接完成的时间。</span><span class="sxs-lookup"><span data-stu-id="42801-1276">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1277">如果使用面向连接的协议，且在调用 <xref:System.Net.Sockets.Socket.Connect%2A>之前未调用 <xref:System.Net.Sockets.Socket.Bind%2A>，则基础服务提供程序将分配本地网络地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-1277">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="42801-1278">如果使用的是无连接协议，则在完成发送或接收操作之前，服务提供程序将不会分配本地网络地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-1278">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="42801-1279">如果要更改默认远程主机，请再次调用 <xref:System.Net.Sockets.Socket.Connect%2A> 所需的终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-1279">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1280">如果先前已断开套接字连接，则不能使用此方法来还原连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1280">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="42801-1281">使用异步 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法之一重新连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1281">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="42801-1282">这是底层提供程序的限制。</span><span class="sxs-lookup"><span data-stu-id="42801-1282">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1283">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1283">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1284">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1284">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1285">下面的代码示例连接到远程终结点，并验证连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1285">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-1286"><paramref name="address" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1286"><paramref name="address" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-1287">端口号无效。</span><span class="sxs-lookup"><span data-stu-id="42801-1287">The port number is not valid.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1288">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1288">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1289"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1289">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-1290">此方法对 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列中的套接字有效。</span><span class="sxs-lookup"><span data-stu-id="42801-1290">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-1291"><paramref name="address" /> 的长度为零。</span><span class="sxs-lookup"><span data-stu-id="42801-1291">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-1292">已通过调用 <see cref="T:System.Net.Sockets.Socket" /> 将 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 置于侦听状态。</span><span class="sxs-lookup"><span data-stu-id="42801-1292">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="addresses"><span data-ttu-id="42801-1293">远程主机的 IP 地址。</span><span class="sxs-lookup"><span data-stu-id="42801-1293">The IP addresses of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="42801-1294">远程主机的端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-1294">The port number of the remote host.</span></span></param>
        <summary><span data-ttu-id="42801-1295">与远程主机建立连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1295">Establishes a connection to a remote host.</span></span> <span data-ttu-id="42801-1296">主机由 IP 地址数组和端口号指定。</span><span class="sxs-lookup"><span data-stu-id="42801-1296">The host is specified by an array of IP addresses and a port number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1297">此方法通常在调用 <xref:System.Net.Dns.GetHostAddresses%2A>后立即使用，这可能会为单个主机返回多个 IP 地址。</span><span class="sxs-lookup"><span data-stu-id="42801-1297">This method is typically used immediately after a call to <xref:System.Net.Dns.GetHostAddresses%2A>, which can return multiple IP addresses for a single host.</span></span> <span data-ttu-id="42801-1298">如果你使用的是面向连接的协议（例如 TCP），<xref:System.Net.Sockets.Socket.Connect%2A> 方法将同步在 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 与指定的远程终结点之间建立网络连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1298">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="42801-1299">如果使用的是无连接协议，<xref:System.Net.Sockets.Socket.Connect%2A> 会建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1299">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="42801-1300">调用 <xref:System.Net.Sockets.Socket.Connect%2A> 可以通过 <xref:System.Net.Sockets.Socket.Send%2A> 方法将数据发送到远程设备，或通过 <xref:System.Net.Sockets.Socket.Receive%2A> 方法从远程设备接收数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1300">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="42801-1301">如果使用的是无连接协议（如 UDP），则在发送和接收数据之前无需调用 <xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-1301">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="42801-1302">您可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 和 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 与远程主机同步通信。</span><span class="sxs-lookup"><span data-stu-id="42801-1302">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="42801-1303">如果确实调用 <xref:System.Net.Sockets.Socket.Connect%2A> 从指定的默认值以外的地址到达的任何数据报都将被丢弃。</span><span class="sxs-lookup"><span data-stu-id="42801-1303">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="42801-1304">如果要将默认远程主机设置为广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将 socket 选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，否则 <xref:System.Net.Sockets.Socket.Connect%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-1304">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-1305">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1305">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1306">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1306">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="42801-1307"><xref:System.Net.Sockets.Socket.Connect%2A> 方法将会阻止，除非在调用 <xref:System.Net.Sockets.Socket.Connect%2A>之前专门将 <xref:System.Net.Sockets.Socket.Blocking%2A> 属性设置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="42801-1307"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="42801-1308">如果使用面向连接的协议（如 TCP），并禁用阻止，<xref:System.Net.Sockets.Socket.Connect%2A> 将引发 <xref:System.Net.Sockets.SocketException>，因为它需要时间来建立连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1308">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="42801-1309">无连接协议不会引发异常，因为它们只是建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1309">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="42801-1310">您可以使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1310">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="42801-1311">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1311">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="42801-1312">如果错误返回了 WSAEWOULDBLOCK，则已通过面向连接的 <xref:System.Net.Sockets.Socket>启动了远程主机连接，但尚未成功完成。</span><span class="sxs-lookup"><span data-stu-id="42801-1312">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="42801-1313">使用 <xref:System.Net.Sockets.Socket.Poll%2A> 方法可确定 <xref:System.Net.Sockets.Socket> 连接完成的时间。</span><span class="sxs-lookup"><span data-stu-id="42801-1313">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1314">如果使用面向连接的协议，且在调用 <xref:System.Net.Sockets.Socket.Connect%2A>之前未调用 <xref:System.Net.Sockets.Socket.Bind%2A>，则基础服务提供程序将分配本地网络地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-1314">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="42801-1315">如果使用的是无连接协议，则在完成发送或接收操作之前，服务提供程序将不会分配本地网络地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-1315">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="42801-1316">如果要更改默认远程主机，请再次调用 <xref:System.Net.Sockets.Socket.Connect%2A> 所需的终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-1316">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1317">如果先前已断开套接字连接，则不能使用此方法来还原连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1317">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="42801-1318">使用异步 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法之一重新连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1318">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="42801-1319">这是底层提供程序的限制。</span><span class="sxs-lookup"><span data-stu-id="42801-1319">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1320">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1320">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1321">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1321">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1322">下面的代码示例连接到远程终结点，并验证连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1322">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-1323"><paramref name="addresses" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1323"><paramref name="addresses" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-1324">端口号无效。</span><span class="sxs-lookup"><span data-stu-id="42801-1324">The port number is not valid.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1325">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1325">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1326"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1326">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-1327">此方法对 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列中的套接字有效。</span><span class="sxs-lookup"><span data-stu-id="42801-1327">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-1328"><paramref name="address" /> 的长度为零。</span><span class="sxs-lookup"><span data-stu-id="42801-1328">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-1329">已通过调用 <see cref="T:System.Net.Sockets.Socket" /> 将 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 置于侦听状态。</span><span class="sxs-lookup"><span data-stu-id="42801-1329">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="host"><span data-ttu-id="42801-1330">远程主机的名称。</span><span class="sxs-lookup"><span data-stu-id="42801-1330">The name of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="42801-1331">远程主机的端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-1331">The port number of the remote host.</span></span></param>
        <summary><span data-ttu-id="42801-1332">与远程主机建立连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1332">Establishes a connection to a remote host.</span></span> <span data-ttu-id="42801-1333">主机由主机名和端口号指定。</span><span class="sxs-lookup"><span data-stu-id="42801-1333">The host is specified by a host name and a port number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1334">如果使用面向连接的协议（例如 TCP），则 <xref:System.Net.Sockets.Socket.Connect%2A> 方法会在 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 与指定的远程主机之间同步建立网络连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1334">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote host.</span></span> <span data-ttu-id="42801-1335">如果使用的是无连接协议，<xref:System.Net.Sockets.Socket.Connect%2A> 会建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1335">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="42801-1336">调用 <xref:System.Net.Sockets.Socket.Connect%2A> 可以通过 <xref:System.Net.Sockets.Socket.Send%2A> 方法将数据发送到远程设备，或通过 <xref:System.Net.Sockets.Socket.Receive%2A> 方法从远程设备接收数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1336">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="42801-1337">如果使用的是无连接协议（如 UDP），则在发送和接收数据之前无需调用 <xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-1337">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="42801-1338">您可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 和 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 与远程主机同步通信。</span><span class="sxs-lookup"><span data-stu-id="42801-1338">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="42801-1339">如果确实调用 <xref:System.Net.Sockets.Socket.Connect%2A> 从指定的默认值以外的地址到达的任何数据报都将被丢弃。</span><span class="sxs-lookup"><span data-stu-id="42801-1339">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="42801-1340">如果要将默认远程主机设置为广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将 socket 选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，否则 <xref:System.Net.Sockets.Socket.Connect%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-1340">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-1341">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1341">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1342">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1342">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="42801-1343"><xref:System.Net.Sockets.Socket.Connect%2A> 方法将会阻止，除非在调用 <xref:System.Net.Sockets.Socket.Connect%2A>之前专门将 <xref:System.Net.Sockets.Socket.Blocking%2A> 属性设置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="42801-1343"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="42801-1344">如果使用面向连接的协议（如 TCP），并禁用阻止，<xref:System.Net.Sockets.Socket.Connect%2A> 将引发 <xref:System.Net.Sockets.SocketException>，因为它需要时间来建立连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1344">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="42801-1345">无连接协议不会引发异常，因为它们只是建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1345">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="42801-1346">您可以使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1346">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="42801-1347">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1347">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="42801-1348">如果错误返回了 WSAEWOULDBLOCK，则已通过面向连接的 <xref:System.Net.Sockets.Socket>启动了远程主机连接，但尚未成功完成。</span><span class="sxs-lookup"><span data-stu-id="42801-1348">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="42801-1349">使用 <xref:System.Net.Sockets.Socket.Poll%2A> 方法可确定 <xref:System.Net.Sockets.Socket> 连接完成的时间。</span><span class="sxs-lookup"><span data-stu-id="42801-1349">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
 <span data-ttu-id="42801-1350">如果启用了 IPv6，并且调用 <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> 方法连接到解析 IPv6 和 IPv4 地址的主机，则在 IPv4 地址之前将首先尝试连接到 IPv6 地址。</span><span class="sxs-lookup"><span data-stu-id="42801-1350">If IPv6 is enabled and the <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address.</span></span> <span data-ttu-id="42801-1351">如果主机未侦听 IPv6 地址，则这可能会延迟建立连接的时间。</span><span class="sxs-lookup"><span data-stu-id="42801-1351">This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1352">如果使用面向连接的协议，且在调用 <xref:System.Net.Sockets.Socket.Connect%2A>之前未调用 <xref:System.Net.Sockets.Socket.Bind%2A>，则基础服务提供程序将分配本地网络地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-1352">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="42801-1353">如果使用的是无连接协议，则在完成发送或接收操作之前，服务提供程序将不会分配本地网络地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-1353">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="42801-1354">如果要更改默认远程主机，请再次调用 <xref:System.Net.Sockets.Socket.Connect%2A> 所需的终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-1354">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1355">如果先前已断开套接字连接，则不能使用此方法来还原连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1355">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="42801-1356">使用异步 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法之一重新连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1356">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="42801-1357">这是底层提供程序的限制。</span><span class="sxs-lookup"><span data-stu-id="42801-1357">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1358">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1358">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1359">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1359">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1360">下面的代码示例连接到远程终结点，并验证连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1360">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-1361"><paramref name="host" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1361"><paramref name="host" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-1362">端口号无效。</span><span class="sxs-lookup"><span data-stu-id="42801-1362">The port number is not valid.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1363">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1363">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1364"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1364">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-1365">此方法对 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列中的套接字有效。</span><span class="sxs-lookup"><span data-stu-id="42801-1365">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-1366">已通过调用 <see cref="T:System.Net.Sockets.Socket" /> 将 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 置于侦听状态。</span><span class="sxs-lookup"><span data-stu-id="42801-1366">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42801-1367">开始一个对远程主机连接的异步请求。</span><span class="sxs-lookup"><span data-stu-id="42801-1367">Begins an asynchronous request for a connection to a remote host.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="42801-1368">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="42801-1368">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="42801-1369">开始一个对远程主机连接的异步请求。</span><span class="sxs-lookup"><span data-stu-id="42801-1369">Begins an asynchronous request for a connection to a remote host.</span></span></summary>
        <returns><span data-ttu-id="42801-1370">如果 I/O 操作挂起，则为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1370"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="42801-1371">操作完成时，将引发 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 参数的 <paramref name="e" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="42801-1371">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="42801-1372">如果 I/O 操作同步完成，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1372"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="42801-1373">在这种情况下，将不会引发 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 参数的 <paramref name="e" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</span><span class="sxs-lookup"><span data-stu-id="42801-1373">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1374">如果使用面向连接的协议，则 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法会启动到远程主机的连接的异步请求。</span><span class="sxs-lookup"><span data-stu-id="42801-1374">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method starts an asynchronous request for a connection to the remote host.</span></span> <span data-ttu-id="42801-1375">如果使用的是无连接协议，<xref:System.Net.Sockets.Socket.ConnectAsync%2A> 会建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1375">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host.</span></span>  
  
 <span data-ttu-id="42801-1376">若要在完成时收到通知，您必须创建一个回调方法，用于实现 EventHandler\<SocketAsyncEventArgs > 委托并将回调附加到 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 事件。</span><span class="sxs-lookup"><span data-stu-id="42801-1376">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="42801-1377">调用方必须将 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 属性设置为要连接到的远程主机的 <xref:System.Net.IPEndPoint>。</span><span class="sxs-lookup"><span data-stu-id="42801-1377">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.</span></span>  
  
 <span data-ttu-id="42801-1378">调用方可以在调用 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法之前将 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 属性设置为所需的任何用户状态对象，以便可以在回调方法中检索信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1378">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="42801-1379">如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。</span><span class="sxs-lookup"><span data-stu-id="42801-1379">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="42801-1380">如果使用的是无连接协议（如 UDP），则在发送和接收数据之前无需调用 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-1380">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data.</span></span> <span data-ttu-id="42801-1381">您可以使用 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 和 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> 与远程主机通信。</span><span class="sxs-lookup"><span data-stu-id="42801-1381">You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host.</span></span> <span data-ttu-id="42801-1382">如果调用 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>，则从指定的默认值以外的地址到达的任何数据报都将被丢弃。</span><span class="sxs-lookup"><span data-stu-id="42801-1382">If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="42801-1383">如果要更改默认远程主机，请通过所需的终结点再次调用 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1383">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="42801-1384">如果要将默认远程主机设置为广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 并将广播设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="42801-1384">If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="42801-1385">如果未执行此操作，<xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-1385">If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="42801-1386">需要 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 对象上的下列属性和事件：</span><span class="sxs-lookup"><span data-stu-id="42801-1386">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="42801-1387">（可选）可以提供缓冲区，在 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法成功后，将以原子方式将其发送到套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-1387">Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="42801-1388">在这种情况下，需要将 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 属性设置为包含要发送的数据的缓冲区，并且 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 属性需要设置为要从缓冲区发送的数据的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-1388">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the number of bytes of data to send from the buffer.</span></span> <span data-ttu-id="42801-1389">建立连接后，将发送此数据缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-1389">Once a connection is established, this buffer of data is sent.</span></span>  
  
 <span data-ttu-id="42801-1390">如果使用面向连接的协议，且在调用 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>之前未调用 <xref:System.Net.Sockets.Socket.Bind%2A>，则基础服务提供程序将分配最适当的本地网络地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-1390">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span>  
  
 <span data-ttu-id="42801-1391">如果使用的是无连接协议，则在调用 <xref:System.Net.Sockets.Socket.SendAsync%2A> 或 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> 方法之前，服务提供程序将不会分配本地网络 IP 地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-1391">If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.</span></span>  
  
 <span data-ttu-id="42801-1392">如果 <xref:System.Net.Sockets.Socket> 和 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 的地址系列不是同一地址族，则 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法会引发 <xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="42801-1392">The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> are not the same address family.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1393">如果在调用此方法时接收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1393">If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1394">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1394">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-1395">自变量无效。</span><span class="sxs-lookup"><span data-stu-id="42801-1395">An argument is not valid.</span></span> <span data-ttu-id="42801-1396">如果指定了多个缓冲区，即 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 属性不为 null，将会发生此异常。</span><span class="sxs-lookup"><span data-stu-id="42801-1396">This exception occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-1397"><paramref name="e" /> 参数不能为 null，并且 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为空。</span><span class="sxs-lookup"><span data-stu-id="42801-1397">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-1398"><see cref="T:System.Net.Sockets.Socket" /> 正在侦听或已经在使用 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 参数中指定的 <paramref name="e" /> 对象执行套接字操作。</span><span class="sxs-lookup"><span data-stu-id="42801-1398">The <see cref="T:System.Net.Sockets.Socket" /> is listening or a socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1399">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1399">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-1400">此方法需要 Windows XP 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="42801-1400">Windows XP or later is required for this method.</span></span> <span data-ttu-id="42801-1401">如果本地终结点和 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不是相同的地址族，也会发生此异常。</span><span class="sxs-lookup"><span data-stu-id="42801-1401">This exception also occurs if the local endpoint and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> are not the same address family.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1402"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1402">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="42801-1403">调用堆栈中的较高调用方无权执行所请求的操作。</span><span class="sxs-lookup"><span data-stu-id="42801-1403">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType"><span data-ttu-id="42801-1404"><see cref="T:System.Net.Sockets.SocketType" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-1404">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></param>
        <param name="protocolType"><span data-ttu-id="42801-1405"><see cref="T:System.Net.Sockets.ProtocolType" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-1405">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></param>
        <param name="e"><span data-ttu-id="42801-1406">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="42801-1406">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="42801-1407">开始一个对远程主机连接的异步请求。</span><span class="sxs-lookup"><span data-stu-id="42801-1407">Begins an asynchronous request for a connection to a remote host.</span></span></summary>
        <returns><span data-ttu-id="42801-1408">如果 I/O 操作挂起，则为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1408"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="42801-1409">操作完成时，将引发 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 参数的 <paramref name="e" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="42801-1409">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="42801-1410">如果 I/O 操作同步完成，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1410"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="42801-1411">在这种情况下，将不会引发 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 参数的 <paramref name="e" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</span><span class="sxs-lookup"><span data-stu-id="42801-1411">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1412">如果你使用的是面向连接的协议，则 M:System.Net.Sockets.Socket.ConnectAsync （SocketType，，系统 .net. ProtocolType，SocketAsyncEventArgs）方法会启动对的异步请求。与远程主机的连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1412">If you are using a connection-oriented protocol, the M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) method starts an asynchronous request for a connection to the remote host.</span></span> <span data-ttu-id="42801-1413">如果使用的是无连接协议，<xref:System.Net.Sockets.Socket.ConnectAsync%2A> 将建立由 `socketType` 和 `protocolType` 参数指定的默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1413">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host specified by the `socketType` and `protocolType` parameters.</span></span>  
  
 <span data-ttu-id="42801-1414">若要在完成时收到通知，您必须创建一个回调方法，用于实现 EventHandler\<SocketAsyncEventArgs > 委托并将回调附加到 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 事件。</span><span class="sxs-lookup"><span data-stu-id="42801-1414">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="42801-1415">调用方必须将 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 属性设置为要连接到的远程主机的 <xref:System.Net.IPEndPoint>。</span><span class="sxs-lookup"><span data-stu-id="42801-1415">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.</span></span>  
  
 <span data-ttu-id="42801-1416">调用方可以在调用 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法之前将 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 属性设置为所需的任何用户状态对象，以便可以在回调方法中检索信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1416">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="42801-1417">如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。</span><span class="sxs-lookup"><span data-stu-id="42801-1417">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="42801-1418">如果使用的是无连接协议（如 UDP），则在发送和接收数据之前无需调用 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-1418">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data.</span></span> <span data-ttu-id="42801-1419">您可以使用 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 和 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> 与远程主机通信。</span><span class="sxs-lookup"><span data-stu-id="42801-1419">You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host.</span></span> <span data-ttu-id="42801-1420">如果调用 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>，则从指定的默认值以外的地址到达的任何数据报都将被丢弃。</span><span class="sxs-lookup"><span data-stu-id="42801-1420">If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="42801-1421">如果要更改默认远程主机，请通过所需的终结点再次调用 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1421">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="42801-1422">如果要将默认远程主机设置为广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 并将广播设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="42801-1422">If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="42801-1423">如果未执行此操作，<xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-1423">If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="42801-1424">需要 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 对象上的下列属性和事件：</span><span class="sxs-lookup"><span data-stu-id="42801-1424">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="42801-1425">（可选）可以提供缓冲区，在 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法成功后，将以原子方式将其发送到套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-1425">Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="42801-1426">在这种情况下，需要将 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 属性设置为包含要发送的数据的缓冲区，并且 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 属性需要设置为要从缓冲区发送的数据的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-1426">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the number of bytes of data to send from the buffer.</span></span> <span data-ttu-id="42801-1427">建立连接后，将发送此数据缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-1427">Once a connection is established, this buffer of data is sent.</span></span>  
  
 <span data-ttu-id="42801-1428">如果使用面向连接的协议，且在调用 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>之前未调用 <xref:System.Net.Sockets.Socket.Bind%2A>，则基础服务提供程序将分配最适当的本地网络地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-1428">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span>  
  
 <span data-ttu-id="42801-1429">如果使用的是无连接协议，则在调用 <xref:System.Net.Sockets.Socket.SendAsync%2A> 或 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> 方法之前，服务提供程序将不会分配本地网络 IP 地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-1429">If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.</span></span>  
  
 <span data-ttu-id="42801-1430">如果 <xref:System.Net.Sockets.Socket> 和 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 的地址系列不是同一地址族，则 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法会引发 <xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="42801-1430">The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> are not the same address family.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1431">如果在调用此方法时接收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1431">If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1432">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1432">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-1433">自变量无效。</span><span class="sxs-lookup"><span data-stu-id="42801-1433">An argument is not valid.</span></span> <span data-ttu-id="42801-1434">如果指定了多个缓冲区，即 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 属性不为 null，将会发生此异常。</span><span class="sxs-lookup"><span data-stu-id="42801-1434">This exception occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-1435"><paramref name="e" /> 参数不能为 null，并且 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为空。</span><span class="sxs-lookup"><span data-stu-id="42801-1435">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-1436"><see cref="T:System.Net.Sockets.Socket" /> 正在侦听或已经在使用 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 参数中指定的 <paramref name="e" /> 对象执行套接字操作。</span><span class="sxs-lookup"><span data-stu-id="42801-1436">The <see cref="T:System.Net.Sockets.Socket" /> is listening or a socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1437">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1437">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-1438">此方法需要 Windows XP 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="42801-1438">Windows XP or later is required for this method.</span></span> <span data-ttu-id="42801-1439">如果本地终结点和 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不是相同的地址族，也会发生此异常。</span><span class="sxs-lookup"><span data-stu-id="42801-1439">This exception also occurs if the local endpoint and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> are not the same address family.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1440"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1440">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="42801-1441">调用堆栈中的较高调用方无权执行所请求的操作。</span><span class="sxs-lookup"><span data-stu-id="42801-1441">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-1442">获取一个值，该值指示 <see cref="T:System.Net.Sockets.Socket" /> 是在上次 <see cref="Overload:System.Net.Sockets.Socket.Send" /> 还是 <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 操作时连接到远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1442">Gets a value that indicates whether a <see cref="T:System.Net.Sockets.Socket" /> is connected to a remote host as of the last <see cref="Overload:System.Net.Sockets.Socket.Send" /> or <see cref="Overload:System.Net.Sockets.Socket.Receive" /> operation.</span></span></summary>
        <value><span data-ttu-id="42801-1443">如果 <see langword="true" /> 在最近操作时连接到远程资源，则为 <see cref="T:System.Net.Sockets.Socket" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1443"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> was connected to a remote resource as of the most recent operation; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1444">`Connected` 属性获取自上次 i/o 操作到 <xref:System.Net.Sockets.Socket> 的连接状态。</span><span class="sxs-lookup"><span data-stu-id="42801-1444">The `Connected` property gets the connection state of the <xref:System.Net.Sockets.Socket> as of the last I/O operation.</span></span> <span data-ttu-id="42801-1445">如果它返回 `false`，则 <xref:System.Net.Sockets.Socket> 永远不会连接，或不再处于连接状态。</span><span class="sxs-lookup"><span data-stu-id="42801-1445">When it returns `false`, the <xref:System.Net.Sockets.Socket> was either never connected, or is no longer connected.</span></span>  
  
 <span data-ttu-id="42801-1446"><xref:System.Net.Sockets.Socket.Connected%2A> 属性的值反映了最近操作的连接状态。</span><span class="sxs-lookup"><span data-stu-id="42801-1446">The value of the <xref:System.Net.Sockets.Socket.Connected%2A> property reflects the state of the connection as of the most recent operation.</span></span> <span data-ttu-id="42801-1447">如果需要确定连接的当前状态，请发出非阻止的零字节发送调用。</span><span class="sxs-lookup"><span data-stu-id="42801-1447">If you need to determine the current state of the connection, make a nonblocking, zero-byte Send call.</span></span> <span data-ttu-id="42801-1448">如果调用成功返回或引发 WAEWOULDBLOCK 错误代码（10035），则套接字仍处于连接状态;否则，将不再连接套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-1448">If the call returns successfully or throws a WAEWOULDBLOCK error code (10035), then the socket is still connected; otherwise, the socket is no longer connected.</span></span>  
  
 <span data-ttu-id="42801-1449">如果对用户数据报协议（UDP）套接字调用 <xref:System.Net.Sockets.Socket.Connect%2A>，则 <xref:System.Net.Sockets.Socket.Connected%2A> 属性始终返回 `true`;但是，此操作不会更改 UDP 的固有无连接特性。</span><span class="sxs-lookup"><span data-stu-id="42801-1449">If you call <xref:System.Net.Sockets.Socket.Connect%2A> on a User Datagram Protocol (UDP) socket, the <xref:System.Net.Sockets.Socket.Connected%2A> property always returns `true`; however, this action does not change the inherent connectionless nature of UDP.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1450">下面的代码示例连接到远程终结点，检查 <xref:System.Net.Sockets.Socket.Connected%2A> 属性，并检查连接的当前状态。</span><span class="sxs-lookup"><span data-stu-id="42801-1450">The following code example connects to a remote endpoint, checks the <xref:System.Net.Sockets.Socket.Connected%2A> property, and checks the current state of the connection.</span></span>  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="reuseSocket"><span data-ttu-id="42801-1451">如果关闭当前连接后可以重用此套接字，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1451"><see langword="true" /> if this socket can be reused after the current connection is closed; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="42801-1452">关闭套接字连接并允许重用套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-1452">Closes the socket connection and allows reuse of the socket.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1453">如果使用面向连接的协议，则可以使用此方法关闭套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-1453">If you are using a connection-oriented protocol, you can use this method to close the socket.</span></span> <span data-ttu-id="42801-1454">此方法结束连接，并将 <xref:System.Net.Sockets.Socket.Connected%2A> 属性设置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="42801-1454">This method ends the connection and sets the <xref:System.Net.Sockets.Socket.Connected%2A> property to `false`.</span></span> <span data-ttu-id="42801-1455">但是，如果 `true``reuseSocket`，则可以重复使用套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-1455">However, if `reuseSocket` is `true`, you can reuse the socket.</span></span>  
  
 <span data-ttu-id="42801-1456">若要确保在关闭套接字之前发送和接收所有数据，应在调用 <xref:System.Net.Sockets.Socket.Disconnect%2A> 方法之前调用 <xref:System.Net.Sockets.Socket.Shutdown%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-1456">To ensure that all data is sent and received before the socket is closed, you should call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Disconnect%2A> method.</span></span>  
  
 <span data-ttu-id="42801-1457">如果需要在不首先调用 <xref:System.Net.Sockets.Socket.Shutdown%2A>的情况下调用 <xref:System.Net.Sockets.Socket.Disconnect%2A>，则可以将 <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> 选项设置为 `false`，并指定非零超时间隔以确保发送排队等待传出传输的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1457">If you need to call <xref:System.Net.Sockets.Socket.Disconnect%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can set the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specify a nonzero time-out interval to ensure that data queued for outgoing transmission is sent.</span></span> <span data-ttu-id="42801-1458">然后，<xref:System.Net.Sockets.Socket.Disconnect%2A> 会一直阻止到发送数据或直到指定的超时过期。</span><span class="sxs-lookup"><span data-stu-id="42801-1458"><xref:System.Net.Sockets.Socket.Disconnect%2A> then blocks until the data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="42801-1459">如果将 <xref:System.Net.Sockets.SocketOptionName.DontLinger> 设置为 `false` 并指定零超时间隔，<xref:System.Net.Sockets.Socket.Close%2A> 会释放连接并自动丢弃传出的排队数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1459">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1460">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1460">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1461">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1461">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1462">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1462">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1463">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1463">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1464">下面的代码示例为同步通信创建套接字，并将一些数据发送到远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1464">The following code example creates a socket for synchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="42801-1465">然后，它调用 <xref:System.Net.Sockets.Socket.Shutdown%2A>，停止发送和接收活动，并 <xref:System.Net.Sockets.Socket.Disconnect%2A>关闭套接字连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1465">It then calls <xref:System.Net.Sockets.Socket.Shutdown%2A>, to stop the send and receive activity, and <xref:System.Net.Sockets.Socket.Disconnect%2A>, to close the socket connection.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="42801-1466">此方法需要 Windows 2000 或更低版本，否则将引发异常。</span><span class="sxs-lookup"><span data-stu-id="42801-1466">This method requires Windows 2000 or earlier, or the exception will be thrown.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1467"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1467">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1468">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1468">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="42801-1469">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="42801-1469">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="42801-1470">开始异步请求从远程终结点断开连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1470">Begins an asynchronous request to disconnect from a remote endpoint.</span></span></summary>
        <returns><span data-ttu-id="42801-1471">如果 I/O 操作挂起，则为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1471"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="42801-1472">操作完成时，将引发 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 参数的 <paramref name="e" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="42801-1472">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="42801-1473">如果 I/O 操作同步完成，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1473"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="42801-1474">在这种情况下，将不会引发 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 参数的 <paramref name="e" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</span><span class="sxs-lookup"><span data-stu-id="42801-1474">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1475">使用面向连接的协议时，调用 <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> 方法会从远程终结点请求断开连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1475">When using a connection-oriented protocol, calling the <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> method requests a disconnect from a remote endpoint.</span></span> <span data-ttu-id="42801-1476">如果将 <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> 设置为在 `e` 参数中 `true`，则可以重复使用套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-1476">If you set <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> to `true` in the `e` parameter, the socket can be reused.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-1477"><paramref name="e" /> 参数不能为 null。</span><span class="sxs-lookup"><span data-stu-id="42801-1477">The <paramref name="e" /> parameter cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-1478">已经在使用 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 参数中指定的 <paramref name="e" /> 对象执行套接字操作。</span><span class="sxs-lookup"><span data-stu-id="42801-1478">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-1479">此方法需要 Windows XP 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="42801-1479">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1480"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1480">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1481">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1481">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42801-1482">释放 <see cref="T:System.Net.Sockets.Socket" /> 类的当前实例所使用的所有资源。</span><span class="sxs-lookup"><span data-stu-id="42801-1482">Releases all resources used by the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="42801-1483">释放 <see cref="T:System.Net.Sockets.Socket" /> 类的当前实例所使用的所有资源。</span><span class="sxs-lookup"><span data-stu-id="42801-1483">Releases all resources used by the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1484">在完成使用 `Dispose` 后，应调用 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-1484">Call `Dispose` when you are finished using the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-1485">`Dispose` 方法使 <xref:System.Net.Sockets.Socket> 处于不可用状态。</span><span class="sxs-lookup"><span data-stu-id="42801-1485">The `Dispose` method leaves the <xref:System.Net.Sockets.Socket> in an unusable state.</span></span> <span data-ttu-id="42801-1486">调用 `Dispose`后，必须释放对 <xref:System.Net.Sockets.Socket> 的所有引用，以便垃圾回收器可以回收 <xref:System.Net.Sockets.Socket> 占用的内存。</span><span class="sxs-lookup"><span data-stu-id="42801-1486">After calling `Dispose`, you must release all references to the <xref:System.Net.Sockets.Socket> so the garbage collector can reclaim the memory that the <xref:System.Net.Sockets.Socket> was occupying.</span></span>  
  
 <span data-ttu-id="42801-1487">有关详细信息，请参阅[清理非托管资源](~/docs/standard/garbage-collection/unmanaged.md)和[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1487">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1488">每次释放对 `Dispose` 的最后一个引用前，均应调用 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-1488">Always call `Dispose` before you release your last reference to the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-1489">否则，在垃圾回收器调用 <xref:System.Net.Sockets.Socket> 对象的 `Finalize` 方法之前，该对象正在使用的资源不会被释放。</span><span class="sxs-lookup"><span data-stu-id="42801-1489">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Net.Sockets.Socket> object's `Finalize` method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="42801-1490">如果释放托管资源和非托管资源，则为 <see langword="true" />；如果仅释放非托管资源，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1490"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to releases only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="42801-1491">释放由 <see cref="T:System.Net.Sockets.Socket" /> 使用的非托管资源，并可根据需要释放托管资源。</span><span class="sxs-lookup"><span data-stu-id="42801-1491">Releases the unmanaged resources used by the <see cref="T:System.Net.Sockets.Socket" />, and optionally disposes of the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1492">此方法由 public `Dispose()` 方法和 <xref:System.Object.Finalize%2A> 方法调用。</span><span class="sxs-lookup"><span data-stu-id="42801-1492">This method is called by the public `Dispose()` method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="42801-1493">`Dispose()` 调用受保护的 `Dispose(Boolean)` 方法，并将 `disposing` 参数设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="42801-1493">`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="42801-1494"><xref:System.Object.Finalize%2A> 调用 `disposing` 设置为 `false`的 `Dispose`。</span><span class="sxs-lookup"><span data-stu-id="42801-1494"><xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="42801-1495">当 `disposing` 参数为 `true` 时，此方法释放该 <xref:System.Net.Sockets.Socket> 引用的、由任何托管对象持有的全部资源。</span><span class="sxs-lookup"><span data-stu-id="42801-1495">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Net.Sockets.Socket> references.</span></span> <span data-ttu-id="42801-1496">此方法调用每个引用对象的 `Dispose()` 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1496">This method invokes the `Dispose()` method of each referenced object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1497">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1497">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1498">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1498">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="42801-1499">
            <see langword="Dispose" /> 可以由其他对象多次调用。</span><span class="sxs-lookup"><span data-stu-id="42801-1499">
            <see langword="Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="42801-1500">重写 <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /> 时，请注意不要引用在以前调用 <see langword="Dispose" /> 时已释放的对象。</span><span class="sxs-lookup"><span data-stu-id="42801-1500">When overriding <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see langword="Dispose" />.</span></span> <span data-ttu-id="42801-1501">有关如何实现 <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />的详细信息，请参阅[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1501">For more information about how to implement <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
<span data-ttu-id="42801-1502">有关 <see langword="Dispose" /> 和 <see cref="M:System.Object.Finalize" />的详细信息，请参阅[清理非托管资源](~/docs/standard/garbage-collection/unmanaged.md)和[重写 Finalize 方法](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="42801-1502">For more information about <see langword="Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-1503">获取或设置 <see cref="T:System.Boolean" /> 值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 是否允许将 Internet 协议 (IP) 数据报分段。</span><span class="sxs-lookup"><span data-stu-id="42801-1503">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows Internet Protocol (IP) datagrams to be fragmented.</span></span></summary>
        <value><span data-ttu-id="42801-1504">如果 <see langword="true" /> 允许数据报分段，则为 <see cref="T:System.Net.Sockets.Socket" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1504"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows datagram fragmentation; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="42801-1505">默认值为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1505">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1506">如果数据报的大小超过传输介质的最大传输单位（MTU），则需要进行碎片整理。</span><span class="sxs-lookup"><span data-stu-id="42801-1506">Datagrams require fragmentation when their size exceeds the Maximum Transfer Unit (MTU) of the transmission medium.</span></span> <span data-ttu-id="42801-1507">数据报可以通过发送主机（所有 Internet 协议版本）或中间路由器（仅限 Internet 协议版本4）进行分段。</span><span class="sxs-lookup"><span data-stu-id="42801-1507">Datagrams may be fragmented by the sending host (all Internet Protocol versions) or an intermediate router (Internet Protocol Version 4 only).</span></span> <span data-ttu-id="42801-1508">如果必须将数据报分段，并设置 <xref:System.Net.Sockets.Socket.DontFragment%2A> 选项，则会丢弃数据报，并将 Internet 控制消息协议（ICMP）错误消息发回到数据报的发件人。</span><span class="sxs-lookup"><span data-stu-id="42801-1508">If a datagram must be fragmented, and the <xref:System.Net.Sockets.Socket.DontFragment%2A> option is set, the datagram is discarded, and an Internet Control Message Protocol (ICMP) error message is sent back to the sender of the datagram.</span></span>  
  
 <span data-ttu-id="42801-1509">对传输控制协议（TCP）套接字设置此属性将不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="42801-1509">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1510">下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket.DontFragment%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="42801-1510">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.DontFragment%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-1511">只有对于在 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 族中的套接字，才可以设置此属性。</span><span class="sxs-lookup"><span data-stu-id="42801-1511">This property can be set only for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1512">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1512">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1513"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1513">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-1514">获取或设置一个 <see cref="T:System.Boolean" /> 值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 是否是用于 IPv4 和 IPv6 的双模式套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-1514">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> is a dual-mode socket used for both IPv4 and IPv6.</span></span></summary>
        <value><span data-ttu-id="42801-1515">如果 <see langword="true" /> 是双模式套接字，则为 <see cref="T:System.Net.Sockets.Socket" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1515"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> is a  dual-mode socket; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="42801-1516">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1516">The default is <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="targetProcessId"><span data-ttu-id="42801-1517">从中创建重复套接字引用的目标进程的 ID。</span><span class="sxs-lookup"><span data-stu-id="42801-1517">The ID of the target process where a duplicate of the socket reference is created.</span></span></param>
        <summary><span data-ttu-id="42801-1518">重复目标进程的套接字引用，并关闭此进程的套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-1518">Duplicates the socket reference for the target process, and closes the socket for this process.</span></span></summary>
        <returns><span data-ttu-id="42801-1519">要传递到目标进程的套接字引用。</span><span class="sxs-lookup"><span data-stu-id="42801-1519">The socket reference to be passed to the target process.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1520">目标进程应使用 <xref:System.Net.Sockets.Socket.%23ctor%2A> 来创建重复的套接字实例。</span><span class="sxs-lookup"><span data-stu-id="42801-1520">The target process should use <xref:System.Net.Sockets.Socket.%23ctor%2A> to create the duplicate socket instance.</span></span>  
  
 <span data-ttu-id="42801-1521">如果多次调用 <xref:System.Net.Sockets.Socket.%23ctor%2A> 构造函数并将同一字节数组作为每次调用的参数，则将创建具有相同基础套接字的多个托管 <xref:System.Net.Sockets.Socket> 实例。</span><span class="sxs-lookup"><span data-stu-id="42801-1521">If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket> instances with the same underlying socket.</span></span> <span data-ttu-id="42801-1522">强烈建议您不要这样做。</span><span class="sxs-lookup"><span data-stu-id="42801-1522">This practice is strongly discouraged.</span></span>  
  
 <span data-ttu-id="42801-1523">如果创建套接字的进程使用异步方法（<xref:System.Net.Sockets.Socket.BeginReceive%2A> 或 <xref:System.Net.Sockets.Socket.BeginSend%2A>），则进程必须首先将 <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> 属性设置为 true;否则，套接字绑定到创建进程的完成端口，这可能导致在目标进程中引发 <xref:System.ArgumentNullException>。</span><span class="sxs-lookup"><span data-stu-id="42801-1523">If the process creating the socket uses asynchronous methods (<xref:System.Net.Sockets.Socket.BeginReceive%2A> or <xref:System.Net.Sockets.Socket.BeginSend%2A>), the process must first set the <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> property to true; otherwise, the socket is bound to the completion port of the creating process, which may cause an <xref:System.ArgumentNullException> to be thrown on the target process.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1524"><paramref name="targetProcessID" /> 不是有效的进程 ID。</span><span class="sxs-lookup"><span data-stu-id="42801-1524"><paramref name="targetProcessID" /> is not a valid process id.</span></span> 
<span data-ttu-id="42801-1525">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-1525">-or-</span></span> 
<span data-ttu-id="42801-1526">套接字引用的复制失败。</span><span class="sxs-lookup"><span data-stu-id="42801-1526">Duplication of the socket reference failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-1527">获取或设置一个 <see cref="T:System.Boolean" /> 值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 是否可以发送或接收广播数据包。</span><span class="sxs-lookup"><span data-stu-id="42801-1527">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> can send or receive broadcast packets.</span></span></summary>
        <value><span data-ttu-id="42801-1528">如果 <see langword="true" /> 允许广播数据包，则为 <see cref="T:System.Net.Sockets.Socket" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1528"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows broadcast packets; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="42801-1529">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1529">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1530">广播限制为特定的子网，并且必须使用用户数据报协议（UDP）。对于 Internet 协议版本4，可以通过将数据包发送到255.255.255.255 来广播到本地子网;或者，你可以使用定向广播地址，该地址是 Internet 协议（IP）地址的网络部分，其中的所有位均设置为主机部分。</span><span class="sxs-lookup"><span data-stu-id="42801-1530">Broadcasting is limited to a specific subnet, and must use User Datagram Protocol (UDP.) For Internet Protocol version 4, you can broadcast to your local subnet by sending a packet to 255.255.255.255; or you can use the directed broadcast address, which is the network portion of an Internet Protocol (IP) address with all bits set in the host portion.</span></span> <span data-ttu-id="42801-1531">例如，如果 IP 地址为192.168.1.40 （a 类 C 地址，子网掩码为255.255.255.0，网络部分为前三个八位字节，主机部分为最后一个八进制数），则定向广播地址为192.168.1.255。</span><span class="sxs-lookup"><span data-stu-id="42801-1531">For example, if your IP address is 192.168.1.40 (a Class C address, with a netmask of 255.255.255.0 -- the network portion is the first three octets, and the host portion is the last octet), your directed broadcast address is 192.168.1.255.</span></span>  
  
 <span data-ttu-id="42801-1532">对传输控制协议（TCP）套接字设置此属性将不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="42801-1532">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1533">下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="42801-1533">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1534">此选项仅对数据报套接字有效。</span><span class="sxs-lookup"><span data-stu-id="42801-1534">This option is valid for a datagram socket only.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1535"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1535">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42801-1536">异步接受传入的连接尝试。</span><span class="sxs-lookup"><span data-stu-id="42801-1536">Asynchronously accepts an incoming connection attempt.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept : Byte[] * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-1537">包含所传输字节的类型 <see cref="T:System.Byte" /> 的数组。</span><span class="sxs-lookup"><span data-stu-id="42801-1537">An array of type <see cref="T:System.Byte" /> that contains the bytes transferred.</span></span></param>
        <param name="asyncResult"><span data-ttu-id="42801-1538"><see cref="T:System.IAsyncResult" /> 对象，它存储此异步操作的状态信息以及任何用户定义数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1538">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <summary><span data-ttu-id="42801-1539">异步接受传入的连接尝试，并创建新的 <see cref="T:System.Net.Sockets.Socket" /> 对象来处理远程主机通信。</span><span class="sxs-lookup"><span data-stu-id="42801-1539">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> object to handle remote host communication.</span></span> <span data-ttu-id="42801-1540">此方法返回包含所传输的初始数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-1540">This method returns a buffer that contains the initial data transferred.</span></span></summary>
        <returns><span data-ttu-id="42801-1541">一个 <see cref="T:System.Net.Sockets.Socket" /> 对象，它处理与远程主机的通信。</span><span class="sxs-lookup"><span data-stu-id="42801-1541">A <see cref="T:System.Net.Sockets.Socket" /> object to handle communication with the remote host.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1542"><xref:System.Net.Sockets.Socket.EndAccept%2A> 完成对 <xref:System.Net.Sockets.Socket.BeginAccept%2A>的调用。</span><span class="sxs-lookup"><span data-stu-id="42801-1542"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="42801-1543">在调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A>之前，需要创建由 <xref:System.AsyncCallback> 委托调用的回调方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1543">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="42801-1544">此回调方法在单独的线程中执行，并在 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法返回后由系统调用。</span><span class="sxs-lookup"><span data-stu-id="42801-1544">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span>  
  
 <span data-ttu-id="42801-1545">在回调方法中，调用 `asyncResult` 参数的 <xref:System.IAsyncResult.AsyncState%2A> 方法，以获取在其上进行连接尝试的 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-1545">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="42801-1546">获取 <xref:System.Net.Sockets.Socket>后，可以调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法成功完成连接尝试。</span><span class="sxs-lookup"><span data-stu-id="42801-1546">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span> <span data-ttu-id="42801-1547">此重载的 `buffer` 参数包含调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 时收到的数据，`bytesTransferred` 参数包含在调用中传输的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-1547">The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.</span></span>  
  
 <span data-ttu-id="42801-1548">在传入连接队列中等待连接之前，<xref:System.Net.Sockets.Socket.EndAccept%2A> 方法将会阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-1548">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="42801-1549"><xref:System.Net.Sockets.Socket.EndAccept%2A> 方法接受传入连接，并返回可用于向远程主机发送数据并从远程主机接收数据的新 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-1549">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1550">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1550">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1551">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1551">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1552">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1552">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1553">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1553">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1554">下面的代码示例使用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 创建并连接套接字，并接受前10个字节的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1554">The following code example uses <xref:System.Net.Sockets.Socket.BeginAccept%2A> to create and connect a socket and accept the initial 10 bytes of data.</span></span> <span data-ttu-id="42801-1555">回调委托调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 以结束异步请求。</span><span class="sxs-lookup"><span data-stu-id="42801-1555">The callback delegate calls <xref:System.Net.Sockets.Socket.EndAccept%2A> to end the asynchronous request.</span></span> <span data-ttu-id="42801-1556">传输的字节数和数据将在此方法的 `buffer` 和 `bytesTransferred` 参数中返回，并显示在控制台上。</span><span class="sxs-lookup"><span data-stu-id="42801-1556">The number of bytes transmitted and the data are returned in the `buffer` and `bytesTransferred` parameters of this method and are displayed on the console.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-1557">此方法需要 Windows NT。</span><span class="sxs-lookup"><span data-stu-id="42801-1557">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1558"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1558">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-1559"><paramref name="asyncResult" /> 为空。</span><span class="sxs-lookup"><span data-stu-id="42801-1559"><paramref name="asyncResult" /> is empty.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-1560"><paramref name="asyncResult" /> 并不是通过对 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> 的调用创建的。</span><span class="sxs-lookup"><span data-stu-id="42801-1560"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-1561"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 方法以前被调用过。</span><span class="sxs-lookup"><span data-stu-id="42801-1561"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1562">尝试访问 <see cref="T:System.Net.Sockets.Socket" /> 时出错</span><span class="sxs-lookup"><span data-stu-id="42801-1562">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" /></span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="42801-1563"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及任何用户定义数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1563">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <param name="result"><span data-ttu-id="42801-1564"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及任何用户定义数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1564">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <summary><span data-ttu-id="42801-1565">异步接受传入的连接尝试，并创建新的 <see cref="T:System.Net.Sockets.Socket" /> 来处理远程主机通信。</span><span class="sxs-lookup"><span data-stu-id="42801-1565">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> to handle remote host communication.</span></span></summary>
        <returns><span data-ttu-id="42801-1566">一个 <see cref="T:System.Net.Sockets.Socket" />，它处理与远程主机的通信。</span><span class="sxs-lookup"><span data-stu-id="42801-1566">A <see cref="T:System.Net.Sockets.Socket" /> to handle communication with the remote host.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1567"><xref:System.Net.Sockets.Socket.EndAccept%2A> 完成对 <xref:System.Net.Sockets.Socket.BeginAccept%2A>的调用。</span><span class="sxs-lookup"><span data-stu-id="42801-1567"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="42801-1568">在调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A>之前，需要创建实现 <xref:System.AsyncCallback> 委托的回调方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1568">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="42801-1569">此回调方法在单独的线程中执行，并在 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法返回后由系统调用。</span><span class="sxs-lookup"><span data-stu-id="42801-1569">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span> <span data-ttu-id="42801-1570">它必须接受从 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法返回的 `asyncResult` 参数。</span><span class="sxs-lookup"><span data-stu-id="42801-1570">It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="42801-1571">在回调方法中，调用 `asyncResult` 参数的 <xref:System.IAsyncResult.AsyncState%2A> 方法，以获取在其上进行连接尝试的 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-1571">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="42801-1572">获取 <xref:System.Net.Sockets.Socket>后，可以调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法成功完成连接尝试。</span><span class="sxs-lookup"><span data-stu-id="42801-1572">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span>  
  
 <span data-ttu-id="42801-1573">在传入连接队列中等待连接之前，<xref:System.Net.Sockets.Socket.EndAccept%2A> 方法将会阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-1573">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="42801-1574"><xref:System.Net.Sockets.Socket.EndAccept%2A> 方法接受传入连接，并返回可用于向远程主机发送数据并从远程主机接收数据的新 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-1574">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1575">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1575">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1576">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1576">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1577">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1577">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1578">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1578">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1579">下面的代码示例结束异步请求，并创建新的 <xref:System.Net.Sockets.Socket> 以接受传入的连接请求。</span><span class="sxs-lookup"><span data-stu-id="42801-1579">The following code example ends an asynchronous request and creates a new <xref:System.Net.Sockets.Socket> to accept an incoming connection request.</span></span> <span data-ttu-id="42801-1580">有关演示与套接字的异步通信的完整示例，请参阅[套接字代码示例](~/docs/framework/network-programming/socket-code-examples.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1580">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-1581"><paramref name="asyncResult" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1581"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-1582"><paramref name="asyncResult" /> 并不是通过对 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> 的调用创建的。</span><span class="sxs-lookup"><span data-stu-id="42801-1582"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1583">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1583">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="42801-1584">有关详细信息，请参阅“备注”部分。</span><span class="sxs-lookup"><span data-stu-id="42801-1584">See the Remarks section for more information.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1585"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1585">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-1586"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 方法以前被调用过。</span><span class="sxs-lookup"><span data-stu-id="42801-1586"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-1587">此方法需要 Windows NT。</span><span class="sxs-lookup"><span data-stu-id="42801-1587">Windows NT is required for this method.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept : Byte[] * int * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="bytesTransferred" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-1588">包含所传输字节的类型 <see cref="T:System.Byte" /> 的数组。</span><span class="sxs-lookup"><span data-stu-id="42801-1588">An array of type <see cref="T:System.Byte" /> that contains the bytes transferred.</span></span></param>
        <param name="bytesTransferred"><span data-ttu-id="42801-1589">传输的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-1589">The number of bytes transferred.</span></span></param>
        <param name="asyncResult"><span data-ttu-id="42801-1590"><see cref="T:System.IAsyncResult" /> 对象，它存储此异步操作的状态信息以及任何用户定义数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1590">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <summary><span data-ttu-id="42801-1591">异步接受传入的连接尝试，并创建新的 <see cref="T:System.Net.Sockets.Socket" /> 对象来处理远程主机通信。</span><span class="sxs-lookup"><span data-stu-id="42801-1591">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> object to handle remote host communication.</span></span> <span data-ttu-id="42801-1592">此方法返回一个缓冲区，其中包含初始数据和传输的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-1592">This method returns a buffer that contains the initial data and the number of bytes transferred.</span></span></summary>
        <returns><span data-ttu-id="42801-1593">一个 <see cref="T:System.Net.Sockets.Socket" /> 对象，它处理与远程主机的通信。</span><span class="sxs-lookup"><span data-stu-id="42801-1593">A <see cref="T:System.Net.Sockets.Socket" /> object to handle communication with the remote host.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1594"><xref:System.Net.Sockets.Socket.EndAccept%2A> 完成对 <xref:System.Net.Sockets.Socket.BeginAccept%2A>的调用。</span><span class="sxs-lookup"><span data-stu-id="42801-1594"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="42801-1595">在调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A>之前，需要创建由 <xref:System.AsyncCallback> 委托调用的回调方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1595">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="42801-1596">此回调方法在单独的线程中执行，并在 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法返回后由系统调用。</span><span class="sxs-lookup"><span data-stu-id="42801-1596">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span> <span data-ttu-id="42801-1597">它必须接受从 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 方法返回的 `asyncResult` 参数。</span><span class="sxs-lookup"><span data-stu-id="42801-1597">It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="42801-1598">在回调方法中，调用 `asyncResult` 参数的 <xref:System.IAsyncResult.AsyncState%2A> 方法，以获取在其上进行连接尝试的 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-1598">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="42801-1599">获取 <xref:System.Net.Sockets.Socket>后，可以调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 方法成功完成连接尝试。</span><span class="sxs-lookup"><span data-stu-id="42801-1599">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span> <span data-ttu-id="42801-1600">此重载的 `buffer` 参数包含调用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 时收到的数据，`bytesTransferred` 参数包含在调用中传输的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-1600">The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.</span></span>  
  
 <span data-ttu-id="42801-1601">在传入连接队列中等待连接之前，<xref:System.Net.Sockets.Socket.EndAccept%2A> 方法将会阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-1601">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="42801-1602"><xref:System.Net.Sockets.Socket.EndAccept%2A> 方法接受传入连接，并返回可用于向远程主机发送数据并从远程主机接收数据的新 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-1602">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1603">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1603">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1604">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1604">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1605">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1605">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1606">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1606">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1607">下面的代码示例使用 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 创建并连接套接字，并接受前10个字节的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1607">The following code example uses <xref:System.Net.Sockets.Socket.BeginAccept%2A> to create and connect a socket and accept the initial 10 bytes of data.</span></span> <span data-ttu-id="42801-1608">回调委托调用 <xref:System.Net.Sockets.Socket.EndAccept%2A> 以结束异步请求。</span><span class="sxs-lookup"><span data-stu-id="42801-1608">The callback delegate calls <xref:System.Net.Sockets.Socket.EndAccept%2A> to end the asynchronous request.</span></span> <span data-ttu-id="42801-1609">传输的字节数和数据将在此方法的 `buffer` 和 `bytesTransferred` 参数中返回，并显示在控制台上。</span><span class="sxs-lookup"><span data-stu-id="42801-1609">The number of bytes transmitted and the data are returned in the `buffer` and `bytesTransferred` parameters of this method and are displayed on the console.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-1610">此方法需要 Windows NT。</span><span class="sxs-lookup"><span data-stu-id="42801-1610">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1611"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1611">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-1612"><paramref name="asyncResult" /> 为空。</span><span class="sxs-lookup"><span data-stu-id="42801-1612"><paramref name="asyncResult" /> is empty.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-1613"><paramref name="asyncResult" /> 并不是通过对 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> 的调用创建的。</span><span class="sxs-lookup"><span data-stu-id="42801-1613"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-1614"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 方法以前被调用过。</span><span class="sxs-lookup"><span data-stu-id="42801-1614"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1615">尝试访问 <see cref="T:System.Net.Sockets.Socket" /> 时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1615">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="42801-1616"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1616">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="result"><span data-ttu-id="42801-1617"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1617">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="42801-1618">结束挂起的异步连接请求。</span><span class="sxs-lookup"><span data-stu-id="42801-1618">Ends a pending asynchronous connection request.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1619"><xref:System.Net.Sockets.Socket.EndConnect%2A> 是一种阻止方法，用于完成在 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法中启动的异步远程主机连接请求。</span><span class="sxs-lookup"><span data-stu-id="42801-1619"><xref:System.Net.Sockets.Socket.EndConnect%2A> is a blocking method that completes the asynchronous remote host connection request started in the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method.</span></span>  
  
 <span data-ttu-id="42801-1620">在调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A>之前，需要创建实现 <xref:System.AsyncCallback> 委托的回调方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1620">Before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="42801-1621">此回调方法在单独的线程中执行，并在 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 返回后由系统调用。</span><span class="sxs-lookup"><span data-stu-id="42801-1621">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginConnect%2A> returns.</span></span> <span data-ttu-id="42801-1622">回调方法必须接受 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 方法作为参数返回的 <xref:System.IAsyncResult>。</span><span class="sxs-lookup"><span data-stu-id="42801-1622">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="42801-1623">在回调方法中，调用 <xref:System.IAsyncResult> 参数的 <xref:System.IAsyncResult.AsyncState%2A> 方法，以获取在其上进行连接尝试的 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-1623">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="42801-1624">获取 <xref:System.Net.Sockets.Socket>后，可以调用 <xref:System.Net.Sockets.Socket.EndConnect%2A> 方法成功完成连接尝试。</span><span class="sxs-lookup"><span data-stu-id="42801-1624">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndConnect%2A> method to successfully complete the connection attempt.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1625">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1625">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1626">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1626">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1627">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1627">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1628">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1628">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1629">下面的代码示例结束了异步连接尝试。</span><span class="sxs-lookup"><span data-stu-id="42801-1629">The following code example ends the asynchronous connection attempt.</span></span> <span data-ttu-id="42801-1630">有关演示与套接字的异步通信的完整示例，请参阅[套接字代码示例](~/docs/framework/network-programming/socket-code-examples.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1630">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-1631"><paramref name="asyncResult" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1631"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-1632">对 <paramref name="asyncResult" /> 方法的调用未返回 <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1632"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-1633">先前曾为异步连接调用过 <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1633"><see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> was previously called for the asynchronous connection.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1634">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1634">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1635"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1635">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="42801-1636"><see cref="T:System.IAsyncResult" /> 对象，它存储此异步操作的状态信息以及所有用户定义数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1636">An <see cref="T:System.IAsyncResult" /> object that stores state information and any user-defined data for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="42801-1637">结束挂起的异步断开连接请求。</span><span class="sxs-lookup"><span data-stu-id="42801-1637">Ends a pending asynchronous disconnect request.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1638"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> 完成对 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>的调用。</span><span class="sxs-lookup"><span data-stu-id="42801-1638"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>.</span></span> <span data-ttu-id="42801-1639">直到断开连接完成后，才会阻止 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1639">The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the disconnect completes.</span></span> <span data-ttu-id="42801-1640">有关异步操作的详细信息，请参阅 MSDN library 中的异步编程概述主题。</span><span class="sxs-lookup"><span data-stu-id="42801-1640">For information about asynchronous operations, see the Asynchronous Programming Overview topic in the MSDN library.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1641">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1641">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1642">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1642">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1643">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1643">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1644">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1644">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1645">下面的代码示例为异步通信创建套接字，并将一些数据发送到远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1645">The following code example creates a socket for asynchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="42801-1646">发送数据后，将调用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 来停止发送和接收活动。</span><span class="sxs-lookup"><span data-stu-id="42801-1646">When the data has been sent, <xref:System.Net.Sockets.Socket.Shutdown%2A> is called to stop the send and receive activity.</span></span> <span data-ttu-id="42801-1647">然后调用 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> 以开始断开连接请求。</span><span class="sxs-lookup"><span data-stu-id="42801-1647">Then <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> is called to begin a disconnect request.</span></span> <span data-ttu-id="42801-1648">回调委托调用 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> 以结束异步请求。</span><span class="sxs-lookup"><span data-stu-id="42801-1648">The callback delegate calls <xref:System.Net.Sockets.Socket.EndDisconnect%2A> to end the asynchronous request.</span></span> <span data-ttu-id="42801-1649">请求完成后，将查询 <xref:System.Net.Sockets.Socket.Connected%2A> 属性以测试套接字是否已断开连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1649">When the request completes, the <xref:System.Net.Sockets.Socket.Connected%2A> property is queried to test whether the socket is disconnected.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-1650">操作系统为 Windows 2000 或更低版本，而此方法需要在 Windows XP 中使用。</span><span class="sxs-lookup"><span data-stu-id="42801-1650">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1651"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1651">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-1652"><paramref name="asyncResult" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1652"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-1653">对 <paramref name="asyncResult" /> 方法的调用未返回 <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1653"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-1654">先前曾为异步连接调用过 <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1654"><see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> was previously called for the asynchronous connection.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1655">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1655">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.Net.WebException"><span data-ttu-id="42801-1656">断开连接请求已超时。</span><span class="sxs-lookup"><span data-stu-id="42801-1656">The disconnect request has timed out.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42801-1657">结束挂起的异步读取。</span><span class="sxs-lookup"><span data-stu-id="42801-1657">Ends a pending asynchronous read.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="42801-1658"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1658">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="result"><span data-ttu-id="42801-1659"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1659">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="42801-1660">结束挂起的异步读取。</span><span class="sxs-lookup"><span data-stu-id="42801-1660">Ends a pending asynchronous read.</span></span></summary>
        <returns><span data-ttu-id="42801-1661">收到的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-1661">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1662"><xref:System.Net.Sockets.Socket.EndReceive%2A> 方法完成 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 方法中启动的异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="42801-1662">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span>  
  
 <span data-ttu-id="42801-1663">在调用 <xref:System.Net.Sockets.Socket.BeginReceive%2A>之前，需要创建实现 <xref:System.AsyncCallback> 委托的回调方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1663">Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="42801-1664">此回调方法在单独的线程中执行，并在 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 返回后由系统调用。</span><span class="sxs-lookup"><span data-stu-id="42801-1664">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="42801-1665">回调方法必须接受 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 方法作为参数返回的 <xref:System.IAsyncResult>。</span><span class="sxs-lookup"><span data-stu-id="42801-1665">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="42801-1666">在回调方法中，调用 <xref:System.IAsyncResult> 的 <xref:System.IAsyncResult.AsyncState%2A> 方法，以获取传递给 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 方法的状态对象。</span><span class="sxs-lookup"><span data-stu-id="42801-1666">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="42801-1667">从此状态对象中提取接收 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-1667">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="42801-1668">获取 <xref:System.Net.Sockets.Socket>后，可以调用 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法成功完成读取操作并返回所读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-1668">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="42801-1669">在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1669">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available.</span></span> <span data-ttu-id="42801-1670">如果使用的是无连接协议，<xref:System.Net.Sockets.Socket.EndReceive%2A> 将读取传入网络缓冲区中的第一个排队数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-1670">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="42801-1671">如果使用面向连接的协议，<xref:System.Net.Sockets.Socket.EndReceive%2A> 方法将读取尽可能多的数据，最多可达在 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 方法的 `size` 参数中指定的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-1671">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="42801-1672">如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法会立即完成并返回零字节。</span><span class="sxs-lookup"><span data-stu-id="42801-1672">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="42801-1673">若要获取收到的数据，请调用 <xref:System.IAsyncResult>的 <xref:System.IAsyncResult.AsyncState%2A> 方法，然后提取所产生状态对象中包含的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-1673">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.</span></span>  
  
 <span data-ttu-id="42801-1674">若要取消挂起的 <xref:System.Net.Sockets.Socket.BeginReceive%2A>，请调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1674">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1675">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1675">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1676">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1676">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1677">给定线程启动的所有 i/o 都将在该线程退出时取消。</span><span class="sxs-lookup"><span data-stu-id="42801-1677">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="42801-1678">如果线程在操作完成之前退出，则挂起的异步操作可能会失败。</span><span class="sxs-lookup"><span data-stu-id="42801-1678">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1679">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1679">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1680">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1680">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1681">下面的代码示例结束挂起的异步读取。</span><span class="sxs-lookup"><span data-stu-id="42801-1681">The following code example ends a pending asynchronous read.</span></span> <span data-ttu-id="42801-1682">有关演示与套接字的异步通信的完整示例，请参阅[套接字代码示例](~/docs/framework/network-programming/socket-code-examples.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1682">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-1683"><paramref name="asyncResult" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1683"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-1684">对 <paramref name="asyncResult" /> 方法的调用未返回 <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1684"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-1685">先前曾为异步读取调用过 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1685"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1686">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1686">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1687"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1687">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult * SocketError -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="42801-1688"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1688">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="errorCode"><span data-ttu-id="42801-1689">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</span><span class="sxs-lookup"><span data-stu-id="42801-1689">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="42801-1690">结束挂起的异步读取。</span><span class="sxs-lookup"><span data-stu-id="42801-1690">Ends a pending asynchronous read.</span></span></summary>
        <returns><span data-ttu-id="42801-1691">收到的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-1691">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1692"><xref:System.Net.Sockets.Socket.EndReceive%2A> 方法完成 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 方法中启动的异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="42801-1692">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span>  
  
 <span data-ttu-id="42801-1693">在调用 <xref:System.Net.Sockets.Socket.BeginReceive%2A>之前，需要创建实现 <xref:System.AsyncCallback> 委托的回调方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1693">Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="42801-1694">此回调方法在单独的线程中执行，并在 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 返回后由系统调用。</span><span class="sxs-lookup"><span data-stu-id="42801-1694">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="42801-1695">回调方法必须接受 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 方法作为参数返回的 <xref:System.IAsyncResult>。</span><span class="sxs-lookup"><span data-stu-id="42801-1695">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="42801-1696">在回调方法中，调用 <xref:System.IAsyncResult> 的 <xref:System.IAsyncResult.AsyncState%2A> 方法，以获取传递给 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 方法的状态对象。</span><span class="sxs-lookup"><span data-stu-id="42801-1696">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="42801-1697">从此状态对象中提取接收 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-1697">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="42801-1698">获取 <xref:System.Net.Sockets.Socket>后，可以调用 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法成功完成读取操作并返回所读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-1698">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="42801-1699">在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1699">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available.</span></span> <span data-ttu-id="42801-1700">如果使用的是无连接协议，<xref:System.Net.Sockets.Socket.EndReceive%2A> 将读取传入网络缓冲区中的第一个排队数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-1700">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="42801-1701">如果使用面向连接的协议，<xref:System.Net.Sockets.Socket.EndReceive%2A> 方法将读取尽可能多的数据，最多可达在 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 方法的 `size` 参数中指定的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-1701">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="42801-1702">如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.EndReceive%2A> 方法会立即完成并返回零字节。</span><span class="sxs-lookup"><span data-stu-id="42801-1702">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="42801-1703">若要获取收到的数据，请调用 <xref:System.IAsyncResult>的 <xref:System.IAsyncResult.AsyncState%2A> 方法，然后提取所产生状态对象中包含的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-1703">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1704">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1704">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1705">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1705">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1706">给定线程启动的所有 i/o 都将在该线程退出时取消。</span><span class="sxs-lookup"><span data-stu-id="42801-1706">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="42801-1707">如果线程在操作完成之前退出，则挂起的异步操作可能会失败。</span><span class="sxs-lookup"><span data-stu-id="42801-1707">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1708">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1708">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1709">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1709">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-1710"><paramref name="asyncResult" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1710"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-1711">对 <paramref name="asyncResult" /> 方法的调用未返回 <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1711"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-1712">先前曾为异步读取调用过 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1712"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1713">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1713">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1714"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1714">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult * EndPoint -&gt; int" Usage="socket.EndReceiveFrom (asyncResult, endPoint)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult * EndPoint -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="42801-1715"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1715">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="result"><span data-ttu-id="42801-1716"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1716">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="endPoint"><span data-ttu-id="42801-1717">源 <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1717">The source <see cref="T:System.Net.EndPoint" />.</span></span></param>
        <param name="end_point"><span data-ttu-id="42801-1718">源 <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1718">The source <see cref="T:System.Net.EndPoint" />.</span></span></param>
        <summary><span data-ttu-id="42801-1719">结束挂起的、从特定终结点进行异步读取。</span><span class="sxs-lookup"><span data-stu-id="42801-1719">Ends a pending asynchronous read from a specific endpoint.</span></span></summary>
        <returns><span data-ttu-id="42801-1720">如果成功，则返回已接收的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-1720">If successful, the number of bytes received.</span></span> <span data-ttu-id="42801-1721">如果不成功，则返回 0。</span><span class="sxs-lookup"><span data-stu-id="42801-1721">If unsuccessful, returns 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1722"><xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 方法完成 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法中启动的异步读取操作。</span><span class="sxs-lookup"><span data-stu-id="42801-1722">The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span>  
  
 <span data-ttu-id="42801-1723">在调用 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>之前，需要创建实现 <xref:System.AsyncCallback> 委托的回调方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1723">Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="42801-1724">此回调方法在单独的线程中执行，并在 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 返回后由系统调用。</span><span class="sxs-lookup"><span data-stu-id="42801-1724">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> returns.</span></span> <span data-ttu-id="42801-1725">回调方法必须接受 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法作为参数返回的 <xref:System.IAsyncResult>。</span><span class="sxs-lookup"><span data-stu-id="42801-1725">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="42801-1726">在回调方法中，调用 <xref:System.IAsyncResult> 的 <xref:System.IAsyncResult.AsyncState%2A> 方法，以获取传递给 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法的状态对象。</span><span class="sxs-lookup"><span data-stu-id="42801-1726">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="42801-1727">从此状态对象中提取接收 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-1727">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="42801-1728">获取 <xref:System.Net.Sockets.Socket>后，可以调用 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 方法成功完成读取操作并返回所读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-1728">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="42801-1729">在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1729">The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="42801-1730">如果使用的是无连接协议，<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 将读取传入网络缓冲区中的第一个排队数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-1730">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="42801-1731">如果使用面向连接的协议，<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 方法将读取尽可能多的数据，最多可达在 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 方法的 `size` 参数中指定的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-1731">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="42801-1732">如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> 方法会立即完成并返回零字节。</span><span class="sxs-lookup"><span data-stu-id="42801-1732">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span> <span data-ttu-id="42801-1733">若要获取收到的数据，请调用 <xref:System.IAsyncResult> 对象的 <xref:System.IAsyncResult.AsyncState%2A> 方法，然后提取所产生状态对象中包含的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-1733">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> object, and extract the buffer contained in the resulting state object.</span></span> <span data-ttu-id="42801-1734">若要标识源主机，请提取 <xref:System.Net.EndPoint> 并将其转换为 <xref:System.Net.IPEndPoint>。</span><span class="sxs-lookup"><span data-stu-id="42801-1734">To identify the originating host, extract the <xref:System.Net.EndPoint> and cast it to an <xref:System.Net.IPEndPoint>.</span></span> <span data-ttu-id="42801-1735">使用 <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> 方法来获取 IP 地址和 <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> 方法以获取端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-1735">Use the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to obtain the IP address and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to obtain the port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1736">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1736">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1737">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1737">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1738">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1738">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1739">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1739">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1740">下面的代码示例结束了从特定 <xref:System.Net.EndPoint>进行的挂起的异步读取。</span><span class="sxs-lookup"><span data-stu-id="42801-1740">The following code example ends a pending asynchronous read from a specific <xref:System.Net.EndPoint>.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-1741"><paramref name="asyncResult" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1741"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-1742">对 <paramref name="asyncResult" /> 方法的调用未返回 <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1742"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-1743">先前曾为异步读取调用过 <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1743"><see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1744">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1744">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1745"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1745">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult * SocketFlags * EndPoint * IPPacketInformation -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="42801-1746"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1746">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-1747">所接收数据包的 <see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-1747">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values for the received packet.</span></span></param>
        <param name="endPoint"><span data-ttu-id="42801-1748">源 <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1748">The source <see cref="T:System.Net.EndPoint" />.</span></span></param>
        <param name="ipPacketInformation"><span data-ttu-id="42801-1749">所接收数据包的 <see cref="T:System.Net.IPAddress" /> 和接口。</span><span class="sxs-lookup"><span data-stu-id="42801-1749">The <see cref="T:System.Net.IPAddress" /> and interface of the received packet.</span></span></param>
        <summary><span data-ttu-id="42801-1750">结束挂起的、从特定终结点进行异步读取。</span><span class="sxs-lookup"><span data-stu-id="42801-1750">Ends a pending asynchronous read from a specific endpoint.</span></span> <span data-ttu-id="42801-1751">此方法还显示有关数据包而不是 <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> 的更多信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1751">This method also reveals more information about the packet than <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</span></span></summary>
        <returns><span data-ttu-id="42801-1752">如果成功，则返回已接收的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-1752">If successful, the number of bytes received.</span></span> <span data-ttu-id="42801-1753">如果不成功，则返回 0。</span><span class="sxs-lookup"><span data-stu-id="42801-1753">If unsuccessful, returns 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1754">如果操作尚未完成，则此方法将一直阻止到该操作。</span><span class="sxs-lookup"><span data-stu-id="42801-1754">If the operation has not completed, this method blocks until it does.</span></span>  
  
 <span data-ttu-id="42801-1755">若要同步执行此操作，请使用 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1755">To perform this operation synchronously, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="42801-1756">如果需要知道是否使用单播、多播或广播地址发送了数据报，请检查 `ipPacketInformation`。</span><span class="sxs-lookup"><span data-stu-id="42801-1756">Examine `ipPacketInformation` if you need to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-1757"><paramref name="asyncResult" /> 为 <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="42801-1757"><paramref name="asyncResult" /> is <see langword="null" /></span></span>  
  
<span data-ttu-id="42801-1758">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-1758">-or-</span></span> 
 <span data-ttu-id="42801-1759"><paramref name="endPoint" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1759"><paramref name="endPoint" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-1760">对 <paramref name="asyncResult" /> 方法的调用未返回 <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1760"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-1761">先前曾为异步读取调用过 <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1761"><see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1762">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1762">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1763"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1763">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42801-1764">结束挂起的异步发送。</span><span class="sxs-lookup"><span data-stu-id="42801-1764">Ends a pending asynchronous send.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="42801-1765"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1765">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</span></span></param>
        <param name="result"><span data-ttu-id="42801-1766"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1766">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="42801-1767">结束挂起的异步发送。</span><span class="sxs-lookup"><span data-stu-id="42801-1767">Ends a pending asynchronous send.</span></span></summary>
        <returns><span data-ttu-id="42801-1768">如果成功，则将返回向 <see cref="T:System.Net.Sockets.Socket" /> 发送的字节数；否则会返回无效 <see cref="T:System.Net.Sockets.Socket" /> 错误。</span><span class="sxs-lookup"><span data-stu-id="42801-1768">If successful, the number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1769"><xref:System.Net.Sockets.Socket.EndSend%2A> 完成 <xref:System.Net.Sockets.Socket.BeginSend%2A>中启动的异步发送操作。</span><span class="sxs-lookup"><span data-stu-id="42801-1769"><xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span></span>  
  
 <span data-ttu-id="42801-1770">在调用 <xref:System.Net.Sockets.Socket.BeginSend%2A>之前，需要创建实现 <xref:System.AsyncCallback> 委托的回调方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1770">Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="42801-1771">此回调方法在单独的线程中执行，并在 <xref:System.Net.Sockets.Socket.BeginSend%2A> 返回后由系统调用。</span><span class="sxs-lookup"><span data-stu-id="42801-1771">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns.</span></span> <span data-ttu-id="42801-1772">回调方法必须接受 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法作为参数返回的 <xref:System.IAsyncResult>。</span><span class="sxs-lookup"><span data-stu-id="42801-1772">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="42801-1773">在回调方法中，调用 <xref:System.IAsyncResult> 参数的 <xref:System.IAsyncResult.AsyncState%2A> 方法以获取发送 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-1773">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-1774">获取 <xref:System.Net.Sockets.Socket>后，可以调用 <xref:System.Net.Sockets.Socket.EndSend%2A> 方法成功完成发送操作，并返回发送的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-1774">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="42801-1775">如果你使用的是无连接协议，则在发送数据报之前，<xref:System.Net.Sockets.Socket.EndSend%2A> 将会阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-1775">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="42801-1776">如果你使用的是面向连接的协议，<xref:System.Net.Sockets.Socket.EndSend%2A> 会一直阻止，直到发送了某些缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-1776">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent.</span></span> <span data-ttu-id="42801-1777">如果 <xref:System.Net.Sockets.Socket.EndSend%2A> 的返回值指示未完全发送缓冲区，请再次调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法，同时修改缓冲区以保存未发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1777">If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.</span></span>  
  
 <span data-ttu-id="42801-1778">不能保证发送的数据会立即显示在网络上。</span><span class="sxs-lookup"><span data-stu-id="42801-1778">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="42801-1779">为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1779">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="42801-1780">成功完成 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1780">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1781">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1781">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1782">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1782">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1783">给定线程启动的所有 i/o 都将在该线程退出时取消。</span><span class="sxs-lookup"><span data-stu-id="42801-1783">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="42801-1784">如果线程在操作完成之前退出，则挂起的异步操作可能会失败。</span><span class="sxs-lookup"><span data-stu-id="42801-1784">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1785">成功完成发送并不表示数据已成功传递。</span><span class="sxs-lookup"><span data-stu-id="42801-1785">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="42801-1786">如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。</span><span class="sxs-lookup"><span data-stu-id="42801-1786">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1787">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1787">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1788">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1788">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1789">下面的代码示例结束挂起的异步发送。</span><span class="sxs-lookup"><span data-stu-id="42801-1789">The following code example ends a pending asynchronous send.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-1790"><paramref name="asyncResult" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1790"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-1791">对 <paramref name="asyncResult" /> 方法的调用未返回 <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1791"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-1792">先前为异步发送已调用过 <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1792"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> was previously called for the asynchronous send.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1793">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1793">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1794"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1794">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult * SocketError -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="42801-1795"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1795">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</span></span></param>
        <param name="errorCode"><span data-ttu-id="42801-1796">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</span><span class="sxs-lookup"><span data-stu-id="42801-1796">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="42801-1797">结束挂起的异步发送。</span><span class="sxs-lookup"><span data-stu-id="42801-1797">Ends a pending asynchronous send.</span></span></summary>
        <returns><span data-ttu-id="42801-1798">如果成功，则将返回向 <see cref="T:System.Net.Sockets.Socket" /> 发送的字节数；否则会返回无效 <see cref="T:System.Net.Sockets.Socket" /> 错误。</span><span class="sxs-lookup"><span data-stu-id="42801-1798">If successful, the number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1799"><xref:System.Net.Sockets.Socket.EndSend%2A> 完成 <xref:System.Net.Sockets.Socket.BeginSend%2A>中启动的异步发送操作。</span><span class="sxs-lookup"><span data-stu-id="42801-1799"><xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span></span>  
  
 <span data-ttu-id="42801-1800">在调用 <xref:System.Net.Sockets.Socket.BeginSend%2A>之前，需要创建实现 <xref:System.AsyncCallback> 委托的回调方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1800">Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="42801-1801">此回调方法在单独的线程中执行，并在 <xref:System.Net.Sockets.Socket.BeginSend%2A> 返回后由系统调用。</span><span class="sxs-lookup"><span data-stu-id="42801-1801">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns.</span></span> <span data-ttu-id="42801-1802">回调方法必须接受 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法作为参数返回的 <xref:System.IAsyncResult>。</span><span class="sxs-lookup"><span data-stu-id="42801-1802">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="42801-1803">在回调方法中，调用 <xref:System.IAsyncResult> 参数的 <xref:System.IAsyncResult.AsyncState%2A> 方法以获取发送 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-1803">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-1804">获取 <xref:System.Net.Sockets.Socket>后，可以调用 <xref:System.Net.Sockets.Socket.EndSend%2A> 方法成功完成发送操作，并返回发送的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-1804">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="42801-1805">如果你使用的是无连接协议，则在发送数据报之前，<xref:System.Net.Sockets.Socket.EndSend%2A> 将会阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-1805">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="42801-1806">如果你使用的是面向连接的协议，<xref:System.Net.Sockets.Socket.EndSend%2A> 会一直阻止，直到发送了某些缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-1806">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent.</span></span> <span data-ttu-id="42801-1807">如果 <xref:System.Net.Sockets.Socket.EndSend%2A> 的返回值指示未完全发送缓冲区，请再次调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法，同时修改缓冲区以保存未发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1807">If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.</span></span>  
  
 <span data-ttu-id="42801-1808">不能保证发送的数据会立即显示在网络上。</span><span class="sxs-lookup"><span data-stu-id="42801-1808">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="42801-1809">为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1809">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="42801-1810">成功完成 <xref:System.Net.Sockets.Socket.BeginSend%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1810">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1811">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1811">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1812">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1812">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1813">给定线程启动的所有 i/o 都将在该线程退出时取消。</span><span class="sxs-lookup"><span data-stu-id="42801-1813">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="42801-1814">如果线程在操作完成之前退出，则挂起的异步操作可能会失败。</span><span class="sxs-lookup"><span data-stu-id="42801-1814">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1815">成功完成发送并不表示数据已成功传递。</span><span class="sxs-lookup"><span data-stu-id="42801-1815">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="42801-1816">如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。</span><span class="sxs-lookup"><span data-stu-id="42801-1816">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1817">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1817">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1818">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1818">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-1819"><paramref name="asyncResult" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1819"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-1820">对 <paramref name="asyncResult" /> 方法的调用未返回 <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1820"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-1821">先前为异步发送已调用过 <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1821"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> was previously called for the asynchronous send.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1822">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1822">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1823"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1823">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="42801-1824"><see cref="T:System.IAsyncResult" /> 对象，它存储此异步操作的状态信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1824">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="42801-1825">结束文件的挂起异步发送。</span><span class="sxs-lookup"><span data-stu-id="42801-1825">Ends a pending asynchronous send of a file.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1826"><xref:System.Net.Sockets.Socket.EndSendFile%2A> 完成 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>中启动的异步发送操作。</span><span class="sxs-lookup"><span data-stu-id="42801-1826"><xref:System.Net.Sockets.Socket.EndSendFile%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.</span></span>  
  
 <span data-ttu-id="42801-1827">在调用 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>之前，必须创建实现 <xref:System.AsyncCallback> 委托的回调方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1827">Before calling <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, you must create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="42801-1828">此回调方法在单独的线程中执行，并在 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 返回后由系统调用。</span><span class="sxs-lookup"><span data-stu-id="42801-1828">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSendFile%2A> returns.</span></span> <span data-ttu-id="42801-1829">回调方法必须接受 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 方法返回的 <xref:System.IAsyncResult> 对象作为参数。</span><span class="sxs-lookup"><span data-stu-id="42801-1829">The callback method must accept the <xref:System.IAsyncResult> object returned by the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="42801-1830">在回调方法中，调用 <xref:System.IAsyncResult> 参数的 <xref:System.IAsyncResult.AsyncState%2A> 方法以获取发送 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-1830">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-1831">获取 <xref:System.Net.Sockets.Socket>后，可以调用 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 方法成功完成发送操作。</span><span class="sxs-lookup"><span data-stu-id="42801-1831">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method to successfully complete the send operation.</span></span>  
  
 <span data-ttu-id="42801-1832">如果使用的是无连接协议，则在发送数据报之前 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-1832">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the datagram is sent.</span></span> <span data-ttu-id="42801-1833">如果使用面向连接的协议，则在发送整个文件之前 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 会阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-1833">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the entire file is sent.</span></span> <span data-ttu-id="42801-1834">不能保证发送的数据会立即显示在网络上。</span><span class="sxs-lookup"><span data-stu-id="42801-1834">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="42801-1835">为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1835">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="42801-1836">成功完成 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1836">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1837">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1837">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1838">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1838">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1839">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1839">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1840">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1840">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1841">下面的代码示例创建并连接套接字用于异步通信，并开始将文件 "test.txt" 异步发送到远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-1841">The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</span></span> <span data-ttu-id="42801-1842">回调委托调用 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 来完成传输。</span><span class="sxs-lookup"><span data-stu-id="42801-1842">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-1843">此方法需要 Windows NT。</span><span class="sxs-lookup"><span data-stu-id="42801-1843">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1844"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1844">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-1845"><paramref name="asyncResult" /> 为空。</span><span class="sxs-lookup"><span data-stu-id="42801-1845"><paramref name="asyncResult" /> is empty.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-1846">对 <paramref name="asyncResult" /> 方法的调用未返回 <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1846"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-1847">先前曾为异步 <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> 调用过 <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1847"><see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> was previously called for the asynchronous <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1848">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1848">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="42801-1849">请参见下面的备注部分。</span><span class="sxs-lookup"><span data-stu-id="42801-1849">See remarks section below.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="42801-1850"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1850">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="result"><span data-ttu-id="42801-1851"><see cref="T:System.IAsyncResult" />，它存储此异步操作的状态信息以及所有用户定义的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1851">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="42801-1852">结束挂起的、向指定位置进行的异步发送。</span><span class="sxs-lookup"><span data-stu-id="42801-1852">Ends a pending asynchronous send to a specific location.</span></span></summary>
        <returns><span data-ttu-id="42801-1853">如果成功，则返回已发送的字节数；否则会返回无效 <see cref="T:System.Net.Sockets.Socket" /> 错误。</span><span class="sxs-lookup"><span data-stu-id="42801-1853">If successful, the number of bytes sent; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1854"><xref:System.Net.Sockets.Socket.EndSendTo%2A> 完成 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>中启动的异步发送操作。</span><span class="sxs-lookup"><span data-stu-id="42801-1854"><xref:System.Net.Sockets.Socket.EndSendTo%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span>  
  
 <span data-ttu-id="42801-1855">在调用 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>之前，需要创建实现 <xref:System.AsyncCallback> 委托的回调方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1855">Before calling <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="42801-1856">此回调方法在单独的线程中执行，并在 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 返回后由系统调用。</span><span class="sxs-lookup"><span data-stu-id="42801-1856">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="42801-1857">回调方法必须接受 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 方法作为参数返回的 <xref:System.IAsyncResult>。</span><span class="sxs-lookup"><span data-stu-id="42801-1857">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="42801-1858">在回调方法中，调用 <xref:System.IAsyncResult> 参数的 <xref:System.IAsyncResult.AsyncState%2A> 方法以获取发送 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-1858">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-1859">获取 <xref:System.Net.Sockets.Socket>后，可以调用 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 方法成功完成发送操作，并返回发送的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-1859">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="42801-1860">如果你使用的是无连接协议，则在发送数据报之前，<xref:System.Net.Sockets.Socket.EndSendTo%2A> 将会阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-1860">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="42801-1861">如果使用面向连接的协议，则在发送请求的字节数之前，将阻止 <xref:System.Net.Sockets.Socket.EndSendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-1861">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="42801-1862">不能保证发送的数据会立即显示在网络上。</span><span class="sxs-lookup"><span data-stu-id="42801-1862">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="42801-1863">为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1863">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="42801-1864">成功完成 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1864">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1865">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1865">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1866">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1866">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1867">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1867">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1868">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1868">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1869">下面的代码示例结束了到特定位置的异步发送。</span><span class="sxs-lookup"><span data-stu-id="42801-1869">The following code example ends an asynchronous send to a specific location.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-1870"><paramref name="asyncResult" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1870"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-1871">对 <paramref name="asyncResult" /> 方法的调用未返回 <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1871"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-1872">先前为异步发送已调用过 <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1872"><see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> was previously called for the asynchronous send.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1873">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1873">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1874"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1874">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-1875">获取或设置 <see cref="T:System.Boolean" /> 值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 是否仅允许一个进程绑定到端口。</span><span class="sxs-lookup"><span data-stu-id="42801-1875">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows only one process to bind to a port.</span></span></summary>
        <value><span data-ttu-id="42801-1876">如果 <see langword="true" /> 仅允许一个套接字绑定到特定端口，则为 <see cref="T:System.Net.Sockets.Socket" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1876"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows only one socket to bind to a specific port; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="42801-1877">对于 Windows Server 2003 和 Windows XP Service Pack 2，默认值为 <see langword="true" />，对于所有其他版本，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1877">The default is <see langword="true" /> for Windows Server 2003 and Windows XP Service Pack 2, and <see langword="false" /> for all other versions.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1878">如果 `false`<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>，则多个套接字可以使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法绑定到特定端口;但只有一个套接字可以对发送到端口的网络流量执行操作。</span><span class="sxs-lookup"><span data-stu-id="42801-1878">If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `false`, multiple sockets can use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a specific port; however only one of the sockets can perform operations on the network traffic sent to the port.</span></span> <span data-ttu-id="42801-1879">如果有多个套接字尝试使用 <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> 方法绑定到特定端口，则具有更具体的 IP 地址的套接字将处理发送到该端口的网络流量。</span><span class="sxs-lookup"><span data-stu-id="42801-1879">If more than one socket attempts to use the <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> method to bind to a particular port, then the one with the more specific IP address will handle the network traffic sent to that port.</span></span>  
  
 <span data-ttu-id="42801-1880">如果 `true`<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>，则第一次使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法尝试绑定到特定端口，而不管 Internet 协议（IP）地址如何，都将成功;在销毁原始绑定套接字之前，所有后续使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法尝试绑定到该端口都将失败。</span><span class="sxs-lookup"><span data-stu-id="42801-1880">If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `true`, the first use of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to a particular port, regardless of Internet Protocol (IP) address, will succeed; all subsequent uses of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to that port will fail until the original bound socket is destroyed.</span></span>  
  
 <span data-ttu-id="42801-1881">必须先设置此属性，然后才能调用 <xref:System.Net.Sockets.Socket.Bind%2A>;否则，将引发 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="42801-1881">This property must be set before <xref:System.Net.Sockets.Socket.Bind%2A> is called; otherwise an <xref:System.InvalidOperationException> will be thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1882">下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="42801-1882">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1883">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1883">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1884"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1884">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-1885">已为此 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 调用了 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1885"><see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> has been called for this <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="42801-1886">释放 <see cref="T:System.Net.Sockets.Socket" /> 类使用的资源。</span><span class="sxs-lookup"><span data-stu-id="42801-1886">Frees resources used by the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1887"><xref:System.Net.Sockets.Socket> 类终结器调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法来关闭与 <xref:System.Net.Sockets.Socket>关联的 <xref:System.Net.Sockets.Socket> 和释放资源。</span><span class="sxs-lookup"><span data-stu-id="42801-1887">The <xref:System.Net.Sockets.Socket> class finalizer calls the <xref:System.Net.Sockets.Socket.Close%2A> method to close the <xref:System.Net.Sockets.Socket> and free resources associated with the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="socket.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="42801-1888">返回 <see cref="T:System.Net.Sockets.Socket" /> 实例的哈希值。</span><span class="sxs-lookup"><span data-stu-id="42801-1888">Returns a hash value for a <see cref="T:System.Net.Sockets.Socket" /> instance.</span></span></summary>
        <returns><span data-ttu-id="42801-1889">整数哈希值。</span><span class="sxs-lookup"><span data-stu-id="42801-1889">An integer hash value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="42801-1890">GetHashCode 方法返回此实例的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1890">The GetHashCode method returns a hash code of this instance.</span></span> <span data-ttu-id="42801-1891">此值可用作哈希表中的键。</span><span class="sxs-lookup"><span data-stu-id="42801-1891">This value can be used as a key in hash tables.</span></span>

]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42801-1892">返回 <see cref="T:System.Net.Sockets.Socket" /> 选项的值。</span><span class="sxs-lookup"><span data-stu-id="42801-1892">Returns the value of a <see cref="T:System.Net.Sockets.Socket" /> option.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="42801-1893"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-1893">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="42801-1894"><see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-1894">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <summary><span data-ttu-id="42801-1895">返回指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项的值，表示为一个对象。</span><span class="sxs-lookup"><span data-stu-id="42801-1895">Returns the value of a specified <see cref="T:System.Net.Sockets.Socket" /> option, represented as an object.</span></span></summary>
        <returns><span data-ttu-id="42801-1896">一个对象，表示选项的值。</span><span class="sxs-lookup"><span data-stu-id="42801-1896">An object that represents the value of the option.</span></span> <span data-ttu-id="42801-1897">当将 <paramref name="optionName" /> 参数设置为 <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> 时，返回值为 <see cref="T:System.Net.Sockets.LingerOption" /> 类的一个实例。</span><span class="sxs-lookup"><span data-stu-id="42801-1897">When the <paramref name="optionName" /> parameter is set to <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> the return value is an instance of the <see cref="T:System.Net.Sockets.LingerOption" /> class.</span></span> <span data-ttu-id="42801-1898">当将 <paramref name="optionName" /> 设置为 <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> 或 <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /> 时，返回值为 <see cref="T:System.Net.Sockets.MulticastOption" /> 类的一个实例。</span><span class="sxs-lookup"><span data-stu-id="42801-1898">When <paramref name="optionName" /> is set to <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> or <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, the return value is an instance of the <see cref="T:System.Net.Sockets.MulticastOption" /> class.</span></span> <span data-ttu-id="42801-1899">当 <paramref name="optionName" /> 为其他任何值时，返回值为整数。</span><span class="sxs-lookup"><span data-stu-id="42801-1899">When <paramref name="optionName" /> is any other value, the return value is an integer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1900"><xref:System.Net.Sockets.Socket> 选项确定当前 <xref:System.Net.Sockets.Socket>的行为。</span><span class="sxs-lookup"><span data-stu-id="42801-1900"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-1901">使用此重载获取 <xref:System.Net.Sockets.SocketOptionName.Linger>、<xref:System.Net.Sockets.SocketOptionName.AddMembership>和 <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> 选项。</span><span class="sxs-lookup"><span data-stu-id="42801-1901">Use this overload to get the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options.</span></span> <span data-ttu-id="42801-1902">对于 <xref:System.Net.Sockets.SocketOptionName.Linger> 选项，请对 `optionLevel` 参数使用 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-1902">For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter.</span></span> <span data-ttu-id="42801-1903">对于 <xref:System.Net.Sockets.SocketOptionName.AddMembership> 和 <xref:System.Net.Sockets.SocketOptionName.DropMembership>，请使用 <xref:System.Net.Sockets.SocketOptionLevel.IP>。</span><span class="sxs-lookup"><span data-stu-id="42801-1903">For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span></span> <span data-ttu-id="42801-1904">如果要设置上面列出的任何选项的值，请使用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-1904">If you want to set the value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1905">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1905">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1906">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1906">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1907">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1907">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1908">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1908">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1909">下面的代码示例检索 <xref:System.Net.Sockets.LingerOption> 和 <xref:System.Net.Sockets.Socket.Send%2A> 超时值，并将其显示在控制台中。</span><span class="sxs-lookup"><span data-stu-id="42801-1909">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1910">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1910">An error occurred when attempting to access the socket.</span></span>  
  
<span data-ttu-id="42801-1911">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-1911">-or-</span></span> 
 <span data-ttu-id="42801-1912"><paramref name="optionName" /> 设置为不支持的值 <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1912"><paramref name="optionName" /> was set to the unsupported value <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1913"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1913">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="42801-1914"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-1914">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="42801-1915"><see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-1915">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="42801-1916"><see cref="T:System.Byte" /> 类型的数组，用于接收选项设置。</span><span class="sxs-lookup"><span data-stu-id="42801-1916">An array of type <see cref="T:System.Byte" /> that is to receive the option setting.</span></span></param>
        <summary><span data-ttu-id="42801-1917">返回指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项设置，表示为字节数组。</span><span class="sxs-lookup"><span data-stu-id="42801-1917">Returns the specified <see cref="T:System.Net.Sockets.Socket" /> option setting, represented as a byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1918"><xref:System.Net.Sockets.Socket> 选项确定当前 <xref:System.Net.Sockets.Socket>的行为。</span><span class="sxs-lookup"><span data-stu-id="42801-1918"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-1919">此方法成功完成后，`optionValue` 参数指定的数组包含指定 <xref:System.Net.Sockets.Socket> 选项的值。</span><span class="sxs-lookup"><span data-stu-id="42801-1919">Upon successful completion of this method, the array specified by the `optionValue` parameter contains the value of the specified <xref:System.Net.Sockets.Socket> option.</span></span>  
  
 <span data-ttu-id="42801-1920">如果 `optionValue` 数组的长度小于存储指定的 <xref:System.Net.Sockets.Socket> 选项的值所需的字节数，<xref:System.Net.Sockets.Socket.GetSocketOption%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-1920">When the length of the `optionValue` array is smaller than the number of bytes required to store the value of the specified <xref:System.Net.Sockets.Socket> option, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-1921">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1921">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1922">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1922">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="42801-1923">将此重载用于由布尔值或整数表示的任何套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-1923">Use this overload for any sockets that are represented by Boolean values or integers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1924">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1924">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1925">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1925">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1926">下面的代码示例检索 <xref:System.Net.Sockets.LingerOption> 和 <xref:System.Net.Sockets.Socket.Send%2A> 超时值，并将其显示在控制台中。</span><span class="sxs-lookup"><span data-stu-id="42801-1926">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1927">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1927">An error occurred when attempting to access the socket.</span></span>  
  
<span data-ttu-id="42801-1928">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-1928">-or-</span></span> 
<span data-ttu-id="42801-1929">在 .NET Compact Framework 应用程序中，Windows CE 默认缓冲区的空间被设置为 32768 字节。</span><span class="sxs-lookup"><span data-stu-id="42801-1929">In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</span></span> <span data-ttu-id="42801-1930">通过调用 <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />，可以更改每个套接字缓冲区的空间。</span><span class="sxs-lookup"><span data-stu-id="42801-1930">You can change the per socket buffer space by calling <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1931"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1931">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionLength" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="42801-1932"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-1932">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="42801-1933"><see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-1933">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionLength"><span data-ttu-id="42801-1934">所需返回值的长度（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="42801-1934">The length, in bytes, of the expected return value.</span></span></param>
        <summary><span data-ttu-id="42801-1935">返回数组中指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项的值。</span><span class="sxs-lookup"><span data-stu-id="42801-1935">Returns the value of the specified <see cref="T:System.Net.Sockets.Socket" /> option in an array.</span></span></summary>
        <returns><span data-ttu-id="42801-1936"><see cref="T:System.Byte" /> 类型的数组，它包含套接字选项的值。</span><span class="sxs-lookup"><span data-stu-id="42801-1936">An array of type <see cref="T:System.Byte" /> that contains the value of the socket option.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1937">`optionLength` 参数设置返回的字节数组的最大大小。</span><span class="sxs-lookup"><span data-stu-id="42801-1937">The `optionLength` parameter sets the maximum size of the returned byte array.</span></span> <span data-ttu-id="42801-1938">如果选项值需要较少的字节，则数组只包含很多字节。</span><span class="sxs-lookup"><span data-stu-id="42801-1938">If the option value requires fewer bytes, the array will contain only that many bytes.</span></span> <span data-ttu-id="42801-1939">如果选项值需要更多字节，<xref:System.Net.Sockets.Socket.GetSocketOption%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-1939">If the option value requires more bytes, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-1940">将此重载用于由布尔值或整数表示的任何套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-1940">Use this overload for any sockets that are represented by Boolean values or integers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1941">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1941">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1942">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1942">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1943">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1943">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1944">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1944">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1945">下面的代码示例检索 <xref:System.Net.Sockets.LingerOption> 和 <xref:System.Net.Sockets.Socket.Send%2A> 超时值，并将其显示在控制台中。</span><span class="sxs-lookup"><span data-stu-id="42801-1945">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1946">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1946">An error occurred when attempting to access the socket.</span></span>  
  
<span data-ttu-id="42801-1947">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-1947">-or-</span></span> 
<span data-ttu-id="42801-1948">在 .NET Compact Framework 应用程序中，Windows CE 默认缓冲区的空间被设置为 32768 字节。</span><span class="sxs-lookup"><span data-stu-id="42801-1948">In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</span></span> <span data-ttu-id="42801-1949">通过调用 <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />，可以更改每个套接字缓冲区的空间。</span><span class="sxs-lookup"><span data-stu-id="42801-1949">You can change the per socket buffer space by calling <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1950"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1950">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-1951">获取 <see cref="T:System.Net.Sockets.Socket" /> 的操作系统句柄。</span><span class="sxs-lookup"><span data-stu-id="42801-1951">Gets the operating system handle for the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="42801-1952">一个 <see cref="T:System.IntPtr" />，它表示 <see cref="T:System.Net.Sockets.Socket" /> 的操作系统句柄。</span><span class="sxs-lookup"><span data-stu-id="42801-1952">An <see cref="T:System.IntPtr" /> that represents the operating system handle for the <see cref="T:System.Net.Sockets.Socket" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42801-1953">为 <see cref="T:System.Net.Sockets.Socket" /> 设置低级别操作模式。</span><span class="sxs-lookup"><span data-stu-id="42801-1953">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="ioControlCode"><span data-ttu-id="42801-1954">一个 <see cref="T:System.Int32" /> 值，该值指定要执行的操作的控制代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1954">An <see cref="T:System.Int32" /> value that specifies the control code of the operation to perform.</span></span></param>
        <param name="optionInValue"><span data-ttu-id="42801-1955">一个 <see cref="T:System.Byte" /> 数组，它包含操作需要的输入数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1955">A <see cref="T:System.Byte" /> array that contains the input data required by the operation.</span></span></param>
        <param name="optionOutValue"><span data-ttu-id="42801-1956">一个 <see cref="T:System.Byte" /> 数组，它包含操作返回的输出数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1956">A <see cref="T:System.Byte" /> array that contains the output data returned by the operation.</span></span></param>
        <summary><span data-ttu-id="42801-1957">使用数字控制代码，为 <see cref="T:System.Net.Sockets.Socket" /> 设置低级操作模式。</span><span class="sxs-lookup"><span data-stu-id="42801-1957">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using numerical control codes.</span></span></summary>
        <returns><span data-ttu-id="42801-1958"><paramref name="optionOutValue" /> 参数中的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-1958">The number of bytes in the <paramref name="optionOutValue" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1959"><xref:System.Net.Sockets.Socket.IOControl%2A> 方法提供对 <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket> 类的当前实例所基于的操作系统的低级访问。</span><span class="sxs-lookup"><span data-stu-id="42801-1959">The <xref:System.Net.Sockets.Socket.IOControl%2A> method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class.</span></span> <span data-ttu-id="42801-1960">有关详细信息，请参阅[WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl)文档。</span><span class="sxs-lookup"><span data-stu-id="42801-1960">For more information, see the [WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) documentation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1961">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1961">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1962">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1962">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1963">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1963">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1964">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1964">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1965">下面的代码示例将 FIONREAD 和可用属性的结果进行比较。</span><span class="sxs-lookup"><span data-stu-id="42801-1965">The following code example compares the results of FIONREAD and the Available property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1966">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1966">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1967"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1967">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-1968">尝试不使用 <see cref="P:System.Net.Sockets.Socket.Blocking" /> 属性更改阻止模式。</span><span class="sxs-lookup"><span data-stu-id="42801-1968">An attempt was made to change the blocking mode without using the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="42801-1969">调用堆栈中的调用方没有所需的权限。</span><span class="sxs-lookup"><span data-stu-id="42801-1969">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="42801-1970">执行非托管代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1970">to execute unmanaged code.</span></span> <span data-ttu-id="42801-1971">关联的枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1971">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="ioControlCode"><span data-ttu-id="42801-1972">一个 <see cref="T:System.Net.Sockets.IOControlCode" /> 值，它指定要执行的操作的控制代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1972">A <see cref="T:System.Net.Sockets.IOControlCode" /> value that specifies the control code of the operation to perform.</span></span></param>
        <param name="optionInValue"><span data-ttu-id="42801-1973"><see cref="T:System.Byte" /> 类型的数组，包含操作要求的输入数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1973">An array of type <see cref="T:System.Byte" /> that contains the input data required by the operation.</span></span></param>
        <param name="optionOutValue"><span data-ttu-id="42801-1974"><see cref="T:System.Byte" /> 类型的数组，包含由操作返回的输出数据。</span><span class="sxs-lookup"><span data-stu-id="42801-1974">An array of type <see cref="T:System.Byte" /> that contains the output data returned by the operation.</span></span></param>
        <summary><span data-ttu-id="42801-1975">使用 <see cref="T:System.Net.Sockets.Socket" /> 枚举指定控制代码，为 <see cref="T:System.Net.Sockets.IOControlCode" /> 设置低级操作模式。</span><span class="sxs-lookup"><span data-stu-id="42801-1975">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using the <see cref="T:System.Net.Sockets.IOControlCode" /> enumeration to specify control codes.</span></span></summary>
        <returns><span data-ttu-id="42801-1976"><paramref name="optionOutValue" /> 参数中的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-1976">The number of bytes in the <paramref name="optionOutValue" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1977">此方法提供对 <xref:System.Net.Sockets.Socket> 类的当前实例 <xref:System.Net.Sockets.Socket> 基础的操作系统的低级访问。</span><span class="sxs-lookup"><span data-stu-id="42801-1977">This method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class.</span></span> <span data-ttu-id="42801-1978">有关详细信息，请参阅[WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl)文档。</span><span class="sxs-lookup"><span data-stu-id="42801-1978">For more, see the [WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) documentation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1979">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1979">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-1980">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-1980">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-1981">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-1981">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-1982">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-1982">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1983">下面的代码示例将调用 <xref:System.Net.Sockets.Socket.IOControl%2A> 的结果与 <xref:System.Net.Sockets.IOControlCode.DataToRead> 和 <xref:System.Net.Sockets.Socket.Available%2A> 属性进行比较。</span><span class="sxs-lookup"><span data-stu-id="42801-1983">The following code example compares the results of calling <xref:System.Net.Sockets.Socket.IOControl%2A> with <xref:System.Net.Sockets.IOControlCode.DataToRead> and the <xref:System.Net.Sockets.Socket.Available%2A> property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-1984">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-1984">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-1985"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-1985">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-1986">尝试不使用 <see cref="P:System.Net.Sockets.Socket.Blocking" /> 属性更改阻止模式。</span><span class="sxs-lookup"><span data-stu-id="42801-1986">An attempt was made to change the blocking mode without using the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="42801-1987">执行非托管代码。</span><span class="sxs-lookup"><span data-stu-id="42801-1987">to execute unmanaged code.</span></span> <span data-ttu-id="42801-1988">关联的枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1988">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-1989">获取一个值，该值指示 <see cref="T:System.Net.Sockets.Socket" /> 是否绑定到特定本地端口。</span><span class="sxs-lookup"><span data-stu-id="42801-1989">Gets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is bound to a specific local port.</span></span></summary>
        <value><span data-ttu-id="42801-1990">如果 <see langword="true" /> 绑定到本地端口，则为 <see cref="T:System.Net.Sockets.Socket" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-1990"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> is bound to a local port; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1991">如果套接字是通过调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法显式绑定的，或者通过调用 <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.SendTo%2A>或 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>的成员（如操作系统选择的免费端口大于1024），则将套接字视为绑定到本地端口。服务器使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法绑定到众所周知的端口，以便客户端可以连接到它们。</span><span class="sxs-lookup"><span data-stu-id="42801-1991">A socket is considered bound to a local port if it is explicitly bound by calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, or implicitly bound by calling members like <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, which use an ephemeral local port (a free port greater than 1024, selected by the operating system.) Servers use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a well-known port so that clients may connect to them.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-1992">下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket.IsBound%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="42801-1992">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.IsBound%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-1993">获取或设置一个值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 在尝试发送所有挂起数据时是否延迟关闭套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-1993">Gets or sets a value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> will delay closing a socket in an attempt to send all pending data.</span></span></summary>
        <value><span data-ttu-id="42801-1994">一个 <see cref="T:System.Net.Sockets.LingerOption" />，它指定关闭套接字时如何逗留。</span><span class="sxs-lookup"><span data-stu-id="42801-1994">A <see cref="T:System.Net.Sockets.LingerOption" /> that specifies how to linger while closing a socket.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-1995"><xref:System.Net.Sockets.Socket.LingerState%2A> 属性更改 <xref:System.Net.Sockets.Socket.Close%2A> 方法行为的方式。</span><span class="sxs-lookup"><span data-stu-id="42801-1995">The <xref:System.Net.Sockets.Socket.LingerState%2A> property changes the way <xref:System.Net.Sockets.Socket.Close%2A> method behaves.</span></span> <span data-ttu-id="42801-1996">设置此属性时，此属性修改 Winsock 可以重置连接时的条件。</span><span class="sxs-lookup"><span data-stu-id="42801-1996">This property when set modifies the conditions under which the connection can be reset by Winsock.</span></span> <span data-ttu-id="42801-1997">仍然可以基于 IP 协议行为重置连接。</span><span class="sxs-lookup"><span data-stu-id="42801-1997">Connection resets can still occur based on the IP protocol behavior.</span></span>  
  
 <span data-ttu-id="42801-1998">此属性控制在数据保留时，连接到 <xref:System.Net.Sockets.Socket.Close%2A> 后，面向连接的连接将保持打开状态的时间长度。</span><span class="sxs-lookup"><span data-stu-id="42801-1998">This property controls the length of time that a connection-oriented connection will remain open after a call to <xref:System.Net.Sockets.Socket.Close%2A> when data remains to be sent.</span></span>  
  
 <span data-ttu-id="42801-1999">调用方法将数据发送到对等节点时，此数据将被置于传出网络缓冲区中。</span><span class="sxs-lookup"><span data-stu-id="42801-1999">When you call methods to send data to a peer, this data is placed in the outgoing network buffer.</span></span> <span data-ttu-id="42801-2000">此属性可用于确保在 <xref:System.Net.Sockets.TcpClient.Close%2A> 方法断开连接之前，将此数据发送到远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-2000">This property can be used to ensure that this data is sent to the remote host before the <xref:System.Net.Sockets.TcpClient.Close%2A> method drops the connection.</span></span>  
  
 <span data-ttu-id="42801-2001">若要启用延迟，请创建包含所需值的 <xref:System.Net.Sockets.LingerOption> 实例，并将 <xref:System.Net.Sockets.Socket.LingerState%2A> 属性设置为此实例。</span><span class="sxs-lookup"><span data-stu-id="42801-2001">To enable lingering, create a <xref:System.Net.Sockets.LingerOption> instance containing the desired values, and set the <xref:System.Net.Sockets.Socket.LingerState%2A> property to this instance.</span></span>  
  
 <span data-ttu-id="42801-2002">下表描述了 <xref:System.Net.Sockets.LingerOption.Enabled%2A> 属性的可能值和 <xref:System.Net.Sockets.Socket.LingerState%2A> 属性中存储的 <xref:System.Net.Sockets.LingerOption.LingerTime%2A> 属性的 <xref:System.Net.Sockets.Socket.Close%2A> 方法的行为。</span><span class="sxs-lookup"><span data-stu-id="42801-2002">The following table describes the behavior of the <xref:System.Net.Sockets.Socket.Close%2A> method for the possible values of the <xref:System.Net.Sockets.LingerOption.Enabled%2A> property and the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property.</span></span>  
  
|<span data-ttu-id="42801-2003">LingerState.Enabled</span><span class="sxs-lookup"><span data-stu-id="42801-2003">LingerState.Enabled</span></span>|<span data-ttu-id="42801-2004">LingerState.LingerTime</span><span class="sxs-lookup"><span data-stu-id="42801-2004">LingerState.LingerTime</span></span>|<span data-ttu-id="42801-2005">行为</span><span class="sxs-lookup"><span data-stu-id="42801-2005">Behavior</span></span>|  
|-------------------------|----------------------------|--------------|  
|<span data-ttu-id="42801-2006">`false` （已禁用），默认值为</span><span class="sxs-lookup"><span data-stu-id="42801-2006">`false` (disabled), the default value</span></span>|<span data-ttu-id="42801-2007">超时不适用，（默认值）。</span><span class="sxs-lookup"><span data-stu-id="42801-2007">The time-out is not applicable, (default).</span></span>|<span data-ttu-id="42801-2008">在默认 IP 协议超时过期之前，尝试发送挂起的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2008">Attempts to send pending data until the default IP protocol time-out expires.</span></span>|  
|<span data-ttu-id="42801-2009">`true` （已启用）</span><span class="sxs-lookup"><span data-stu-id="42801-2009">`true` (enabled)</span></span>|<span data-ttu-id="42801-2010">非零超时</span><span class="sxs-lookup"><span data-stu-id="42801-2010">A nonzero time-out</span></span>|<span data-ttu-id="42801-2011">尝试发送挂起的数据直到指定的超时过期，如果尝试失败，Winsock 将重置连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2011">Attempts to send pending data until the specified time-out expires, and if the attempt fails, then Winsock resets the connection.</span></span>|  
|<span data-ttu-id="42801-2012">`true` （已启用）</span><span class="sxs-lookup"><span data-stu-id="42801-2012">`true` (enabled)</span></span>|<span data-ttu-id="42801-2013">零超时。</span><span class="sxs-lookup"><span data-stu-id="42801-2013">A zero timeout.</span></span>|<span data-ttu-id="42801-2014">丢弃所有挂起的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2014">Discards any pending data.</span></span> <span data-ttu-id="42801-2015">对于面向连接的套接字（例如 TCP），Winsock 重置连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2015">For connection-oriented socket (TCP, for example), Winsock resets the connection.</span></span>|  
  
 <span data-ttu-id="42801-2016">IP 堆栈根据连接的往返时间来计算要使用的默认 IP 协议超时期限。</span><span class="sxs-lookup"><span data-stu-id="42801-2016">The IP stack computes the default IP protocol time-out period to use based on the round trip time of the connection.</span></span> <span data-ttu-id="42801-2017">在大多数情况下，堆栈计算出的超时比应用程序定义的超时更密切。</span><span class="sxs-lookup"><span data-stu-id="42801-2017">In most cases, the time-out computed by the stack is more relevant than one defined by an application.</span></span> <span data-ttu-id="42801-2018">这是未设置 <xref:System.Net.Sockets.Socket.LingerState%2A> 属性时套接字的默认行为。</span><span class="sxs-lookup"><span data-stu-id="42801-2018">This is the default behavior for a socket when the <xref:System.Net.Sockets.Socket.LingerState%2A> property is not set.</span></span>  
  
 <span data-ttu-id="42801-2019">如果在 <xref:System.Net.Sockets.Socket.LingerState%2A> 属性中存储的 <xref:System.Net.Sockets.LingerOption.LingerTime%2A> 属性设置为大于默认 IP 协议超时值，则默认的 IP 协议超时将仍适用并将替代。</span><span class="sxs-lookup"><span data-stu-id="42801-2019">When the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property is set greater than the default IP protocol time-out, the default IP protocol time-out will still apply and override.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-2020">下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket.LingerState%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="42801-2020">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.LingerState%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2021">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2021">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2022"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2022">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog"><span data-ttu-id="42801-2023">挂起连接队列的最大长度。</span><span class="sxs-lookup"><span data-stu-id="42801-2023">The maximum length of the pending connections queue.</span></span></param>
        <summary><span data-ttu-id="42801-2024">将 <see cref="T:System.Net.Sockets.Socket" /> 置于侦听状态。</span><span class="sxs-lookup"><span data-stu-id="42801-2024">Places a <see cref="T:System.Net.Sockets.Socket" /> in a listening state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2025"><xref:System.Net.Sockets.Socket.Listen%2A> 会导致面向连接的 <xref:System.Net.Sockets.Socket> 侦听传入的连接尝试。</span><span class="sxs-lookup"><span data-stu-id="42801-2025"><xref:System.Net.Sockets.Socket.Listen%2A> causes a connection-oriented <xref:System.Net.Sockets.Socket> to listen for incoming connection attempts.</span></span> <span data-ttu-id="42801-2026">`backlog` 参数指定可以排队等待接受的传入连接的数量。</span><span class="sxs-lookup"><span data-stu-id="42801-2026">The `backlog` parameter specifies the number of incoming connections that can be queued for acceptance.</span></span> <span data-ttu-id="42801-2027">若要确定可以指定的最大连接数，请检索 <xref:System.Net.Sockets.SocketOptionName.MaxConnections> 值。</span><span class="sxs-lookup"><span data-stu-id="42801-2027">To determine the maximum number of connections you can specify, retrieve the <xref:System.Net.Sockets.SocketOptionName.MaxConnections> value.</span></span> <span data-ttu-id="42801-2028"><xref:System.Net.Sockets.Socket.Listen%2A> 不会阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-2028"><xref:System.Net.Sockets.Socket.Listen%2A> does not block.</span></span>  
  
 <span data-ttu-id="42801-2029">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-2029">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-2030">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-2030">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="42801-2031">使用 <xref:System.Net.Sockets.Socket.Accept%2A> 或 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 接受队列中的连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2031">Use <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> to accept a connection from the queue.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2032">必须先调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法，然后才能调用 <xref:System.Net.Sockets.Socket.Listen%2A>或 <xref:System.Net.Sockets.Socket.Listen%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2032">You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method before calling <xref:System.Net.Sockets.Socket.Listen%2A>, or <xref:System.Net.Sockets.Socket.Listen%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2033">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2033">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-2034">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-2034">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2035">积压工作（backlog）参数限制为不同的值，具体取决于操作系统。</span><span class="sxs-lookup"><span data-stu-id="42801-2035">The backlog parameter is limited to different values depending on the Operating System.</span></span> <span data-ttu-id="42801-2036">您可以指定较大的值，但积压工作（backlog）将基于操作系统进行限制。</span><span class="sxs-lookup"><span data-stu-id="42801-2036">You may specify a higher value, but the backlog will be limited based on the Operating System.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-2037">下面的代码示例使用 <xref:System.Net.Sockets.Socket> 侦听传入连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2037">The following code example uses <xref:System.Net.Sockets.Socket> to listen for incoming connections.</span></span>  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2038">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2038">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2039"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2039">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-2040">获取本地终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-2040">Gets the local endpoint.</span></span></summary>
        <value><span data-ttu-id="42801-2041"><see cref="T:System.Net.EndPoint" /> 当前用以进行通信的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2041">The <see cref="T:System.Net.EndPoint" /> that the <see cref="T:System.Net.Sockets.Socket" /> is using for communications.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2042"><xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 属性获取一个 <xref:System.Net.EndPoint>，其中包含 <xref:System.Net.Sockets.Socket> 绑定到的本地 IP 地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-2042">The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property gets an <xref:System.Net.EndPoint> that contains the local IP address and port number to which your <xref:System.Net.Sockets.Socket> is bound.</span></span> <span data-ttu-id="42801-2043">在检索任何信息之前，必须将此 <xref:System.Net.EndPoint> 强制转换为 <xref:System.Net.IPEndPoint>。</span><span class="sxs-lookup"><span data-stu-id="42801-2043">You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information.</span></span> <span data-ttu-id="42801-2044">然后，可以调用 <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> 方法检索本地 <xref:System.Net.IPAddress>，并调用 <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> 方法来检索本地端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-2044">You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to retrieve the local <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to retrieve the local port number.</span></span>  
  
 <span data-ttu-id="42801-2045"><xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 属性通常是在调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法之后设置的。</span><span class="sxs-lookup"><span data-stu-id="42801-2045">The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property is usually set after you make a call to the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="42801-2046">如果允许系统分配套接字的本地 IP 地址和端口号，则在第一次 i/o 操作之后将设置 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="42801-2046">If you allow the system to assign your socket's local IP address and port number, the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property will be set after the first I/O operation.</span></span> <span data-ttu-id="42801-2047">对于面向连接的协议，第一个 i/o 操作将是对 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法的调用。</span><span class="sxs-lookup"><span data-stu-id="42801-2047">For connection-oriented protocols, the first I/O operation would be a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="42801-2048">对于无连接协议，第一个 i/o 操作将是任何发送或接收调用。</span><span class="sxs-lookup"><span data-stu-id="42801-2048">For connectionless protocols, the first I/O operation would be any of the send or receive calls.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2049">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-2049">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-2050">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-2050">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2051">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2051">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-2052">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-2052">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-2053">下面的代码示例检索并显示本地和远程终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-2053">The following code example retrieves and displays the local and remote endpoints.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2054">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2054">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2055"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2055">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-2056">获取或设置一个值，该值指定传出的多路广播数据包是否传递到发送应用程序。</span><span class="sxs-lookup"><span data-stu-id="42801-2056">Gets or sets a value that specifies whether outgoing multicast packets are delivered to the sending application.</span></span></summary>
        <value><span data-ttu-id="42801-2057">如果 <see langword="true" /> 接收传出的多路广播数据包，则为 <see cref="T:System.Net.Sockets.Socket" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2057"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> receives outgoing multicast packets; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2058">多播是 Internet 上多对多通信的可扩展方法。</span><span class="sxs-lookup"><span data-stu-id="42801-2058">Multicast is a scalable method for many-to-many communication on the Internet.</span></span> <span data-ttu-id="42801-2059">进程订阅多路广播地址;然后，由订阅的进程发送的任何数据包都由订阅了多播地址的每个其他进程接收。</span><span class="sxs-lookup"><span data-stu-id="42801-2059">A process subscribes to a multicast address; then, any packets sent by a subscribed process are received by every other process subscribed to the multicast address.</span></span>  
  
 <span data-ttu-id="42801-2060">对传输控制协议（TCP）套接字设置此属性将不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="42801-2060">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-2061">下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="42801-2061">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2062">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2062">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2063"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2063">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-2064">获取或设置 <see cref="T:System.Boolean" /> 值，该值指定流 <see cref="T:System.Net.Sockets.Socket" /> 是否正在使用 Nagle 算法。</span><span class="sxs-lookup"><span data-stu-id="42801-2064">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the stream <see cref="T:System.Net.Sockets.Socket" /> is using the Nagle algorithm.</span></span></summary>
        <value><span data-ttu-id="42801-2065">如果 <see langword="false" /> 使用 Nagle 算法，则为 <see cref="T:System.Net.Sockets.Socket" />；否则为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2065"><see langword="false" /> if the <see cref="T:System.Net.Sockets.Socket" /> uses the Nagle algorithm; otherwise, <see langword="true" />.</span></span> <span data-ttu-id="42801-2066">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2066">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2067">Nagle 算法旨在通过使套接字缓冲小数据包，然后在特定情况下将它们合并并发送到一个数据包，从而减少网络流量。</span><span class="sxs-lookup"><span data-stu-id="42801-2067">The Nagle algorithm is designed to reduce network traffic by causing the socket to buffer small packets and then combine and send them in one packet under certain circumstances.</span></span> <span data-ttu-id="42801-2068">TCP 数据包包含40字节的标头以及要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2068">A TCP packet consists of 40 bytes of header plus the data being sent.</span></span> <span data-ttu-id="42801-2069">当使用 TCP 发送小型数据包时，TCP 标头产生的开销可能会成为网络流量的重要部分。</span><span class="sxs-lookup"><span data-stu-id="42801-2069">When small packets of data are sent with TCP, the overhead resulting from the TCP header can become a significant part of the network traffic.</span></span> <span data-ttu-id="42801-2070">在负载较重的网络上，由于这种开销导致的拥塞会导致丢失数据报和重新传输，以及拥塞导致的传播时间过大。</span><span class="sxs-lookup"><span data-stu-id="42801-2070">On heavily loaded networks, the congestion resulting from this overhead can result in lost datagrams and retransmissions, as well as excessive propagation time caused by congestion.</span></span> <span data-ttu-id="42801-2071">如果在连接上以前传输的数据保持未确认的情况，则 Nagle 算法将禁止发送新的 TCP 段。</span><span class="sxs-lookup"><span data-stu-id="42801-2071">The Nagle algorithm inhibits the sending of new TCP segments when new outgoing data arrives from the user if any previously transmitted data on the connection remains unacknowledged.</span></span>  
  
 <span data-ttu-id="42801-2072">大多数网络应用程序都应使用 Nagle 算法。</span><span class="sxs-lookup"><span data-stu-id="42801-2072">The majority of network applications should use the Nagle algorithm.</span></span>  
  
 <span data-ttu-id="42801-2073">在用户数据报协议（UDP）套接字上设置此属性将不起作用。</span><span class="sxs-lookup"><span data-stu-id="42801-2073">Setting this property on a User Datagram Protocol (UDP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-2074">下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket.NoDelay%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="42801-2074">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.NoDelay%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2075">尝试访问 <see cref="T:System.Net.Sockets.Socket" /> 时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2075">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2076"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2076">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-2077">指示基础操作系统和网络适配器是否支持 Internet 协议第 4 版 (IPv4)。</span><span class="sxs-lookup"><span data-stu-id="42801-2077">Indicates whether the underlying operating system and network adaptors support Internet Protocol version 4 (IPv4).</span></span></summary>
        <value><span data-ttu-id="42801-2078">如果操作系统和网络适配器支持 IPv4 协议，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2078"><see langword="true" /> if the operating system and network adaptors support the IPv4 protocol; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2079">操作系统可能支持 IPv4 和 IPv6 协议。</span><span class="sxs-lookup"><span data-stu-id="42801-2079">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-2080">指示基础操作系统和网络适配器是否支持 Internet 协议第 6 版 (IPv6)。</span><span class="sxs-lookup"><span data-stu-id="42801-2080">Indicates whether the underlying operating system and network adaptors support Internet Protocol version 6 (IPv6).</span></span></summary>
        <value><span data-ttu-id="42801-2081">如果操作系统和网络适配器支持 IPv6 协议，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2081"><see langword="true" /> if the operating system and network adaptors support the IPv6 protocol; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2082">操作系统可能支持 IPv4 和 IPv6 协议。</span><span class="sxs-lookup"><span data-stu-id="42801-2082">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="microSeconds"><span data-ttu-id="42801-2083">等待响应的时间（以微秒为单位）。</span><span class="sxs-lookup"><span data-stu-id="42801-2083">The time to wait for a response, in microseconds.</span></span></param>
        <param name="mode"><span data-ttu-id="42801-2084"><see cref="T:System.Net.Sockets.SelectMode" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-2084">One of the <see cref="T:System.Net.Sockets.SelectMode" /> values.</span></span></param>
        <summary><span data-ttu-id="42801-2085">确定 <see cref="T:System.Net.Sockets.Socket" /> 的状态。</span><span class="sxs-lookup"><span data-stu-id="42801-2085">Determines the status of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="42801-2086">基于 <see cref="T:System.Net.Sockets.Socket" /> 参数中传递的轮询模式值的 <paramref name="mode" /> 的状态。</span><span class="sxs-lookup"><span data-stu-id="42801-2086">The status of the <see cref="T:System.Net.Sockets.Socket" /> based on the polling mode value passed in the <paramref name="mode" /> parameter.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="42801-2087">模式</span><span class="sxs-lookup"><span data-stu-id="42801-2087">Mode</span></span> 
 </term><description> <span data-ttu-id="42801-2088">返回值</span><span class="sxs-lookup"><span data-stu-id="42801-2088">Return Value</span></span> 
 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><span data-ttu-id="42801-2089">如果已调用 <see langword="true" /> 并且有挂起的连接，则为 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2089"><see langword="true" /> if <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> has been called and a connection is pending;</span></span> 
<span data-ttu-id="42801-2090">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2090">-or-</span></span> 
 <span data-ttu-id="42801-2091">如果有数据可供读取，则为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2091"><see langword="true" /> if data is available for reading;</span></span> 
<span data-ttu-id="42801-2092">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2092">-or-</span></span> 
 <span data-ttu-id="42801-2093">如果连接已关闭、重置或终止，则返回 <see langword="true" />；</span><span class="sxs-lookup"><span data-stu-id="42801-2093"><see langword="true" /> if the connection has been closed, reset, or terminated;</span></span> 
<span data-ttu-id="42801-2094">否则，返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2094">otherwise, returns <see langword="false" />.</span></span>  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><span data-ttu-id="42801-2095">如果正在处理 <see langword="true" /> 并且连接已成功，则为 <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />；</span><span class="sxs-lookup"><span data-stu-id="42801-2095"><see langword="true" />, if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, and the connection has succeeded;</span></span> 
<span data-ttu-id="42801-2096">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2096">-or-</span></span> 
 <span data-ttu-id="42801-2097">如果可以发送数据，则返回 <see langword="true" />；</span><span class="sxs-lookup"><span data-stu-id="42801-2097"><see langword="true" /> if data can be sent;</span></span> 
<span data-ttu-id="42801-2098">否则，返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2098">otherwise, returns <see langword="false" />.</span></span>  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description><span data-ttu-id="42801-2099">如果正在处理不阻止的 <see langword="true" />，并且连接已失败，则为 <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />；</span><span class="sxs-lookup"><span data-stu-id="42801-2099"><see langword="true" /> if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> that does not block, and the connection has failed;</span></span> 
<span data-ttu-id="42801-2100">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2100">-or-</span></span> 
 <span data-ttu-id="42801-2101">如果 <see langword="true" /> 未设置，并且带外数据可用，则为 <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" />；</span><span class="sxs-lookup"><span data-stu-id="42801-2101"><see langword="true" /> if <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> is not set and out-of-band data is available;</span></span> 
<span data-ttu-id="42801-2102">否则，返回 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2102">otherwise, returns <see langword="false" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2103"><xref:System.Net.Sockets.Socket.Poll%2A> 方法将检查 <xref:System.Net.Sockets.Socket>的状态。</span><span class="sxs-lookup"><span data-stu-id="42801-2103">The <xref:System.Net.Sockets.Socket.Poll%2A> method will check the state of the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-2104">指定 `selectMode` 参数 <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType>，以确定 <xref:System.Net.Sockets.Socket> 是否可读。</span><span class="sxs-lookup"><span data-stu-id="42801-2104">Specify <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> for the `selectMode` parameter to determine if the <xref:System.Net.Sockets.Socket> is readable.</span></span> <span data-ttu-id="42801-2105">指定 <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> 确定 <xref:System.Net.Sockets.Socket> 是否可写。</span><span class="sxs-lookup"><span data-stu-id="42801-2105">Specify <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> to determine if the <xref:System.Net.Sockets.Socket> is writable.</span></span> <span data-ttu-id="42801-2106">使用 <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> 检测错误条件。</span><span class="sxs-lookup"><span data-stu-id="42801-2106">Use <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> to detect an error condition.</span></span> <span data-ttu-id="42801-2107"><xref:System.Net.Sockets.Socket.Poll%2A> 将阻止执行到指定时间段（以 `microseconds`为单位）。</span><span class="sxs-lookup"><span data-stu-id="42801-2107"><xref:System.Net.Sockets.Socket.Poll%2A> will block execution until the specified time period, measured in `microseconds`, elapses.</span></span> <span data-ttu-id="42801-2108">如果要无限期等待响应，请将 `microSeconds` 参数设置为负整数。</span><span class="sxs-lookup"><span data-stu-id="42801-2108">Set the `microSeconds` parameter to a negative integer if you would like to wait indefinitely for a response.</span></span> <span data-ttu-id="42801-2109">如果要检查多个套接字的状态，可能更倾向于使用 <xref:System.Net.Sockets.Socket.Select%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-2109">If you want to check the status of multiple sockets, you might prefer to use the <xref:System.Net.Sockets.Socket.Select%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2110">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-2110">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-2111">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-2111">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2112">此方法无法检测某些类型的连接问题，例如网络电缆损坏或远程主机已关闭意外。</span><span class="sxs-lookup"><span data-stu-id="42801-2112">This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</span></span> <span data-ttu-id="42801-2113">您必须尝试发送或接收数据，以检测这些类型的错误。</span><span class="sxs-lookup"><span data-stu-id="42801-2113">You must attempt to send or receive data to detect these kinds of errors.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2114">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2114">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-2115">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-2115">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-2116">下面的代码示例创建套接字，连接到服务器，并使用 <xref:System.Net.Sockets.Socket.Poll%2A> 来检查套接字的状态。</span><span class="sxs-lookup"><span data-stu-id="42801-2116">The following code example creates a socket, connects to a server, and uses <xref:System.Net.Sockets.Socket.Poll%2A> to check the status of the socket.</span></span>  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-2117"><paramref name="mode" /> 参数不是一个 <see cref="T:System.Net.Sockets.SelectMode" /> 值。</span><span class="sxs-lookup"><span data-stu-id="42801-2117">The <paramref name="mode" /> parameter is not one of the <see cref="T:System.Net.Sockets.SelectMode" /> values.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2118">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2118">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="42801-2119">请参阅下面的备注。</span><span class="sxs-lookup"><span data-stu-id="42801-2119">See remarks below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2120"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2120">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-2121">获取 <see cref="T:System.Net.Sockets.Socket" /> 的协议类型。</span><span class="sxs-lookup"><span data-stu-id="42801-2121">Gets the protocol type of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="42801-2122"><see cref="T:System.Net.Sockets.ProtocolType" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-2122">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2123"><xref:System.Net.Sockets.Socket.ProtocolType%2A> 属性在创建 <xref:System.Net.Sockets.Socket> 时设置，并指定该 <xref:System.Net.Sockets.Socket>所使用的协议。</span><span class="sxs-lookup"><span data-stu-id="42801-2123">The <xref:System.Net.Sockets.Socket.ProtocolType%2A> property is set when the <xref:System.Net.Sockets.Socket> is created, and specifies the protocol used by that <xref:System.Net.Sockets.Socket>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-2124">下面的代码示例显示控制台 <xref:System.Net.Sockets.AddressFamily>、<xref:System.Net.Sockets.SocketType>和 <xref:System.Net.Sockets.ProtocolType>。</span><span class="sxs-lookup"><span data-stu-id="42801-2124">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42801-2125">接收来自绑定的 <see cref="T:System.Net.Sockets.Socket" /> 的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2125">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-2126"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</span><span class="sxs-lookup"><span data-stu-id="42801-2126">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <summary><span data-ttu-id="42801-2127">从绑定的 <see cref="T:System.Net.Sockets.Socket" /> 套接字接收数据，将数据存入接收缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-2127">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer.</span></span></summary>
        <returns><span data-ttu-id="42801-2128">收到的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2128">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2129"><xref:System.Net.Sockets.Socket.Receive%2A> 方法将数据读入 buffer 参数，并返回成功读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2129">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="42801-2130">可从面向连接的套接字和无连接套接字调用 <xref:System.Net.Sockets.Socket.Receive%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-2130">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="42801-2131">此重载只要求你提供接收缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-2131">This overload only requires you to provide a receive buffer.</span></span> <span data-ttu-id="42801-2132">缓冲区偏移量默认为0，大小默认为 buffer 参数的长度，<xref:System.Net.Sockets.SocketFlags> 值默认为 <xref:System.Net.Sockets.SocketFlags.None>。</span><span class="sxs-lookup"><span data-stu-id="42801-2132">The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="42801-2133">如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在调用 <xref:System.Net.Sockets.Socket.Receive%2A>之前 <xref:System.Net.Sockets.Socket.Accept%2A> 接受传入连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2133">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="42801-2134"><xref:System.Net.Sockets.Socket.Receive%2A> 方法将只读取从在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机到达的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2134">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="42801-2135">如果使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-2135">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="42801-2136"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 允许接收来自任何主机的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2136"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="42801-2137">如果没有可供读取的数据，则在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.Receive%2A> 方法，除非使用 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>设置了超时值。</span><span class="sxs-lookup"><span data-stu-id="42801-2137">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-2138">如果超过超时值，则 <xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2138">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2139">如果处于非阻止模式，并且协议堆栈缓冲区中没有可用的数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2139">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2140">您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。</span><span class="sxs-lookup"><span data-stu-id="42801-2140">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="42801-2141">如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。</span><span class="sxs-lookup"><span data-stu-id="42801-2141">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="42801-2142">如果使用面向连接的 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直到达到缓冲区的大小。</span><span class="sxs-lookup"><span data-stu-id="42801-2142">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="42801-2143">如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法会立即完成并返回零字节。</span><span class="sxs-lookup"><span data-stu-id="42801-2143">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="42801-2144">如果你使用的是无连接 <xref:System.Net.Sockets.Socket>，则 <xref:System.Net.Sockets.Socket.Receive%2A> 将从你在 <xref:System.Net.Sockets.Socket.Connect%2A> 方法中指定的目标地址读取第一个排队的数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-2144">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="42801-2145">如果接收的数据报大于 `buffer` 参数的大小，则 `buffer` 会填充消息的第一部分，超过的数据将会丢失，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2145">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2146">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-2146">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-2147">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-2147">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2148">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2148">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-2149">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-2149">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-2150">下面的代码示例接收已连接 <xref:System.Net.Sockets.Socket>上的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2150">The following code example receives data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-2151"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2151"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2152">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2152">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2153"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2153">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="42801-2154">调用堆栈中的调用方没有所需的权限。</span><span class="sxs-lookup"><span data-stu-id="42801-2154">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="42801-2155">用于接受来自网络的连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2155">for accepting connections from the network.</span></span> <span data-ttu-id="42801-2156">关联的枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2156">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="42801-2157"><see cref="T:System.ArraySegment`1" /> 类型的一个 <see cref="T:System.Byte" /> 列表，包含接收的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2157">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span></span></param>
        <summary><span data-ttu-id="42801-2158">从绑定的 <see cref="T:System.Net.Sockets.Socket" /> 接收数据，将数据存入接收缓冲区列表中。</span><span class="sxs-lookup"><span data-stu-id="42801-2158">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers.</span></span></summary>
        <returns><span data-ttu-id="42801-2159">收到的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2159">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2160">此方法将数据读取到缓冲区参数，并返回成功读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2160">This method reads data into the buffers parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="42801-2161">可从面向连接的套接字和无连接套接字调用。</span><span class="sxs-lookup"><span data-stu-id="42801-2161">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="42801-2162">此重载要求提供一个或多个接收缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-2162">This overload requires you to provide one or more receive buffers.</span></span>  
  
 <span data-ttu-id="42801-2163">如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在调用 <xref:System.Net.Sockets.Socket.Receive%2A>之前 <xref:System.Net.Sockets.Socket.Accept%2A> 接受传入连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2163">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="42801-2164"><xref:System.Net.Sockets.Socket.Receive%2A> 方法将只读取从在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机连接到达的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2164">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="42801-2165">如果使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-2165">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="42801-2166"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 允许接收来自任何主机的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2166"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="42801-2167">如果没有可供读取的数据，则在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.Receive%2A> 方法，除非使用 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>设置了超时值。</span><span class="sxs-lookup"><span data-stu-id="42801-2167">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-2168">如果超过超时值，则 <xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2168">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2169">如果处于非阻止模式，并且协议堆栈缓冲区中没有可用的数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2169">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2170">您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。</span><span class="sxs-lookup"><span data-stu-id="42801-2170">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="42801-2171">如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。</span><span class="sxs-lookup"><span data-stu-id="42801-2171">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="42801-2172">如果使用面向连接的 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直到达到缓冲区的大小。</span><span class="sxs-lookup"><span data-stu-id="42801-2172">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="42801-2173">如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法会立即完成并返回零字节。</span><span class="sxs-lookup"><span data-stu-id="42801-2173">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="42801-2174">如果你使用的是无连接 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 将从你在 <xref:System.Net.Sockets.Socket.Connect%2A> 方法中指定的目标地址读取第一个排队的数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-2174">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="42801-2175">如果接收的数据报大于 `buffers` 参数的大小，则 `buffers` 会填充消息的第一部分，超过的数据将会丢失，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2175">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2176">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-2176">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-2177">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-2177">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="42801-2178">**注意**当你在应用程序中启用网络跟踪时，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2178">**Note** This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-2179">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-2179">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-2180"><paramref name="buffer" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2180">The <paramref name="buffer" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2181">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2181">An error occurred while attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2182"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2182">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-2183">一个字节范围，它是所接收的数据的存储位置。</span><span class="sxs-lookup"><span data-stu-id="42801-2183">A span of bytes that is the storage location for the received data.</span></span></param>
        <summary><span data-ttu-id="42801-2184">从绑定的 <see cref="T:System.Net.Sockets.Socket" /> 套接字接收数据，将数据存入接收缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-2184">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer.</span></span></summary>
        <returns><span data-ttu-id="42801-2185">收到的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2185">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="42801-2186"><xref:System.Net.Sockets.Socket.Receive%2A> 方法将数据读入 buffer 参数，并返回成功读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2186">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="42801-2187">可从面向连接的套接字和无连接套接字调用 <xref:System.Net.Sockets.Socket.Receive%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-2187">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>

<span data-ttu-id="42801-2188">此重载只要求你提供接收缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-2188">This overload only requires you to provide a receive buffer.</span></span> <span data-ttu-id="42801-2189">缓冲区偏移量默认为0，大小默认为 buffer 参数的长度，<xref:System.Net.Sockets.SocketFlags> 值默认为 <xref:System.Net.Sockets.SocketFlags.None>。</span><span class="sxs-lookup"><span data-stu-id="42801-2189">The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>

<span data-ttu-id="42801-2190">如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在调用 <xref:System.Net.Sockets.Socket.Receive%2A>之前 <xref:System.Net.Sockets.Socket.Accept%2A> 接受传入连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2190">If you're using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection before calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="42801-2191"><xref:System.Net.Sockets.Socket.Receive%2A> 方法将只读取从在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机到达的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2191">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="42801-2192">如果使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-2192">If you're using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="42801-2193"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 允许接收来自任何主机的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2193"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>

<span data-ttu-id="42801-2194">如果没有可供读取的数据，则在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.Receive%2A> 方法，除非使用 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>设置了超时值。</span><span class="sxs-lookup"><span data-stu-id="42801-2194">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-2195">超过超时值时，<xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2195">When the time-out value is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2196">如果处于非阻止模式，并且协议堆栈缓冲区中没有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2196">If you're in non-blocking mode, and there's no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2197">您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。</span><span class="sxs-lookup"><span data-stu-id="42801-2197">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="42801-2198">如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。</span><span class="sxs-lookup"><span data-stu-id="42801-2198">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>

<span data-ttu-id="42801-2199">如果使用面向连接的 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直到达到缓冲区的大小。</span><span class="sxs-lookup"><span data-stu-id="42801-2199">If you're using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="42801-2200">如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法会立即完成并返回零字节。</span><span class="sxs-lookup"><span data-stu-id="42801-2200">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>

<span data-ttu-id="42801-2201">如果你使用的是无连接 <xref:System.Net.Sockets.Socket>，则 <xref:System.Net.Sockets.Socket.Receive%2A> 将从你在 <xref:System.Net.Sockets.Socket.Connect%2A> 方法中指定的目标地址读取第一个排队的数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-2201">If you're using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="42801-2202">如果接收的数据报大于 `buffer` 参数的大小，则 `buffer` 会填充消息的第一部分，超过的数据将会丢失，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2202">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost, and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>

> [!NOTE]
> <span data-ttu-id="42801-2203">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-2203">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-2204">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-2204">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>

<span data-ttu-id="42801-2205">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2205">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-2206">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-2206">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2207">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2207">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2208"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2208">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="42801-2209">调用堆栈中的调用方没有所需的权限。</span><span class="sxs-lookup"><span data-stu-id="42801-2209">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="42801-2210">接受来自网络的连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2210">Accepting connections from the network.</span></span> <span data-ttu-id="42801-2211">关联的枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2211">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-2212"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</span><span class="sxs-lookup"><span data-stu-id="42801-2212">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-2213"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-2213">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="42801-2214">使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-2214">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="42801-2215">收到的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2215">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2216"><xref:System.Net.Sockets.Socket.Receive%2A> 方法将数据读入 buffer 参数，并返回成功读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2216">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="42801-2217">可从面向连接的套接字和无连接套接字调用 <xref:System.Net.Sockets.Socket.Receive%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-2217">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="42801-2218">此重载只要求你提供接收缓冲区和必要的 <xref:System.Net.Sockets.SocketFlags>。</span><span class="sxs-lookup"><span data-stu-id="42801-2218">This overload only requires you to provide a receive buffer and the necessary <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="42801-2219">缓冲区偏移量默认为0，大小默认为 byte 参数的长度。</span><span class="sxs-lookup"><span data-stu-id="42801-2219">The buffer offset defaults to 0, and the size defaults to the length of the byte parameter.</span></span>  
  
 <span data-ttu-id="42801-2220">如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在调用 <xref:System.Net.Sockets.Socket.Receive%2A>之前 <xref:System.Net.Sockets.Socket.Accept%2A> 接受传入连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2220">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="42801-2221"><xref:System.Net.Sockets.Socket.Receive%2A> 方法将只读取从在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机到达的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2221">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="42801-2222">如果使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-2222">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="42801-2223"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 允许接收来自任何主机的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2223"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="42801-2224">如果没有可供读取的数据，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将被阻止，直到数据可用。</span><span class="sxs-lookup"><span data-stu-id="42801-2224">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available.</span></span> <span data-ttu-id="42801-2225">如果处于非阻止模式，并且协议堆栈缓冲区中没有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2225">If you are in non-blocking mode, and there is no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2226">您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。</span><span class="sxs-lookup"><span data-stu-id="42801-2226">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="42801-2227">如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，请重试接收操作。</span><span class="sxs-lookup"><span data-stu-id="42801-2227">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.</span></span>  
  
 <span data-ttu-id="42801-2228">如果使用面向连接的 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直到缓冲区大小可用。</span><span class="sxs-lookup"><span data-stu-id="42801-2228">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available up to the size of the buffer.</span></span> <span data-ttu-id="42801-2229">如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法会立即完成并返回零字节。</span><span class="sxs-lookup"><span data-stu-id="42801-2229">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="42801-2230">如果你使用的是无连接 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 将从你在 <xref:System.Net.Sockets.Socket.Connect%2A> 方法中指定的目标地址读取第一个排队的数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-2230">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="42801-2231">如果接收的数据报大于 `buffer` 参数的大小，则 `buffer` 会填充消息的第一部分，超过的数据将会丢失，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2231">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2232">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-2232">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-2233">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-2233">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2234">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2234">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-2235">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-2235">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-2236">下面的代码示例指定了一个数据缓冲区，并 <xref:System.Net.Sockets.SocketFlags> 用于接收连接 <xref:System.Net.Sockets.Socket>上的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2236">The following code example specifies a data buffer, and <xref:System.Net.Sockets.SocketFlags> for receiving data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-2237"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2237"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2238">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2238">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2239"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2239">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="42801-2240">调用堆栈中的调用方没有所需的权限。</span><span class="sxs-lookup"><span data-stu-id="42801-2240">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="42801-2241">接受来自网络的连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2241">Accepting connections from the network.</span></span> <span data-ttu-id="42801-2242">关联的枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2242">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="42801-2243"><see cref="T:System.ArraySegment`1" /> 类型的一个 <see cref="T:System.Byte" /> 列表，包含接收的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2243">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-2244"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-2244">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="42801-2245">使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区列表中。</span><span class="sxs-lookup"><span data-stu-id="42801-2245">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="42801-2246">收到的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2246">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2247">此方法将数据读取到 `buffers` 参数并返回成功读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2247">This method reads data into the `buffers` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="42801-2248">可从面向连接的套接字和无连接套接字调用。</span><span class="sxs-lookup"><span data-stu-id="42801-2248">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="42801-2249">此重载要求提供一个或多个接收缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-2249">This overload requires you to provide one or more receive buffers.</span></span> <span data-ttu-id="42801-2250"><xref:System.Net.Sockets.SocketFlags> 值默认为 <xref:System.Net.Sockets.SocketFlags.None>。</span><span class="sxs-lookup"><span data-stu-id="42801-2250">The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="42801-2251">如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在调用 <xref:System.Net.Sockets.Socket.Receive%2A>之前 <xref:System.Net.Sockets.Socket.Accept%2A> 接受传入连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2251">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="42801-2252"><xref:System.Net.Sockets.Socket.Receive%2A> 方法将只读取从在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机连接到达的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2252">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="42801-2253">如果使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-2253">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="42801-2254"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 允许接收来自任何主机的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2254"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="42801-2255">如果没有可供读取的数据，则在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.Receive%2A> 方法，除非使用 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>设置了超时值。</span><span class="sxs-lookup"><span data-stu-id="42801-2255">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-2256">如果超过超时值，则 <xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2256">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2257">如果处于非阻止模式，并且协议堆栈缓冲区中没有可用的数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2257">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2258">您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。</span><span class="sxs-lookup"><span data-stu-id="42801-2258">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="42801-2259">如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。</span><span class="sxs-lookup"><span data-stu-id="42801-2259">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="42801-2260">如果使用面向连接的 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直到达到缓冲区的大小。</span><span class="sxs-lookup"><span data-stu-id="42801-2260">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="42801-2261">如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法会立即完成并返回零字节。</span><span class="sxs-lookup"><span data-stu-id="42801-2261">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="42801-2262">如果你使用的是无连接 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 将从你在 <xref:System.Net.Sockets.Socket.Connect%2A> 方法中指定的目标地址读取第一个排队的数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-2262">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="42801-2263">如果接收的数据报大于 `buffers` 参数的大小，则 `buffers` 会填充消息的第一部分，超过的数据将会丢失，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2263">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2264">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-2264">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-2265">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-2265">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2266">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2266">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-2267">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-2267">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-2268">下面的代码示例演示如何在连接的 <xref:System.Net.Sockets.Socket>上接收数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2268">The following code example demonstrates how to receive data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-2269"><paramref name="buffers" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2269"><paramref name="buffers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="42801-2270">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2270">-or-</span></span> 
 <span data-ttu-id="42801-2271"><paramref name="buffers" />.Count 是零。</span><span class="sxs-lookup"><span data-stu-id="42801-2271"><paramref name="buffers" />.Count is zero.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2272">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2272">An error occurred while attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2273"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2273">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="42801-2274">用于接受来自网络的连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2274">for accepting connections from the network.</span></span> <span data-ttu-id="42801-2275">关联的枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2275">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-2276">一个字节范围，它是所接收的数据的存储位置。</span><span class="sxs-lookup"><span data-stu-id="42801-2276">A span of bytes that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-2277">枚举值的按位组合，它用于指定发送和接收行为。</span><span class="sxs-lookup"><span data-stu-id="42801-2277">A bitwise combination of the enumeration values that specifies send and receive behaviors.</span></span></param>
        <summary><span data-ttu-id="42801-2278">使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-2278">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="42801-2279">收到的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2279">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks

<span data-ttu-id="42801-2280"><xref:System.Net.Sockets.Socket.Receive%2A> 方法将数据读入 buffer 参数，并返回成功读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2280">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="42801-2281">可从面向连接的套接字和无连接套接字调用 <xref:System.Net.Sockets.Socket.Receive%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-2281">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>

<span data-ttu-id="42801-2282">此重载只要求你提供接收缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-2282">This overload only requires you to provide a receive buffer.</span></span> <span data-ttu-id="42801-2283">缓冲区偏移量默认为0，大小默认为 buffer 参数的长度，<xref:System.Net.Sockets.SocketFlags> 值默认为 <xref:System.Net.Sockets.SocketFlags.None>。</span><span class="sxs-lookup"><span data-stu-id="42801-2283">The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>

<span data-ttu-id="42801-2284">如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在调用 <xref:System.Net.Sockets.Socket.Receive%2A>之前 <xref:System.Net.Sockets.Socket.Accept%2A> 接受传入连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2284">If you're using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="42801-2285"><xref:System.Net.Sockets.Socket.Receive%2A> 方法将只读取从在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机到达的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2285">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="42801-2286">如果使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-2286">If you're using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="42801-2287"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 允许接收来自任何主机的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2287"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>

<span data-ttu-id="42801-2288">如果没有可供读取的数据，则在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.Receive%2A> 方法，除非使用 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>设置了超时值。</span><span class="sxs-lookup"><span data-stu-id="42801-2288">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-2289">超过超时值时，<xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2289">When the time-out value is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2290">如果处于非阻止模式，并且协议堆栈缓冲区中没有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2290">If you're in non-blocking mode, and there is no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2291">您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。</span><span class="sxs-lookup"><span data-stu-id="42801-2291">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="42801-2292">如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。</span><span class="sxs-lookup"><span data-stu-id="42801-2292">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>

<span data-ttu-id="42801-2293">如果使用面向连接的 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直到达到缓冲区的大小。</span><span class="sxs-lookup"><span data-stu-id="42801-2293">If you're using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="42801-2294">如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法会立即完成并返回零字节。</span><span class="sxs-lookup"><span data-stu-id="42801-2294">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>

<span data-ttu-id="42801-2295">如果你使用的是无连接 <xref:System.Net.Sockets.Socket>，则 <xref:System.Net.Sockets.Socket.Receive%2A> 将从你在 <xref:System.Net.Sockets.Socket.Connect%2A> 方法中指定的目标地址读取第一个排队的数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-2295">If you're using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="42801-2296">如果接收的数据报大于 `buffer` 参数的大小，则 `buffer` 会填充消息的第一部分，超过的数据将会丢失，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2296">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost, and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>

> [!NOTE]
> <span data-ttu-id="42801-2297">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-2297">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-2298">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-2298">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>

<span data-ttu-id="42801-2299">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2299">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-2300">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-2300">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2301">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2301">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2302"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2302">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="42801-2303">调用堆栈中的调用方没有所需的权限。</span><span class="sxs-lookup"><span data-stu-id="42801-2303">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="42801-2304">用于接受来自网络的连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2304">for accepting connections from the network.</span></span> <span data-ttu-id="42801-2305">关联的枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2305">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-2306"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</span><span class="sxs-lookup"><span data-stu-id="42801-2306">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="size"><span data-ttu-id="42801-2307">要接收的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2307">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-2308"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-2308">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="42801-2309">使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收指定字节数的数据，并将数据存入接收缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-2309">Receives the specified number of bytes of data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="42801-2310">收到的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2310">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2311"><xref:System.Net.Sockets.Socket.Receive%2A> 方法将数据读入 `buffer` 参数，并返回成功读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2311">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the `buffer` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="42801-2312">可从面向连接的套接字和无连接套接字调用 <xref:System.Net.Sockets.Socket.Receive%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-2312">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="42801-2313">此重载只要求你提供接收缓冲区、要接收的字节数以及必需的 <xref:System.Net.Sockets.SocketFlags>。</span><span class="sxs-lookup"><span data-stu-id="42801-2313">This overload only requires you to provide a receive buffer, the number of bytes you want to receive, and the necessary <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 <span data-ttu-id="42801-2314">如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在调用 <xref:System.Net.Sockets.Socket.Receive%2A>之前 <xref:System.Net.Sockets.Socket.Accept%2A> 接受传入连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2314">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="42801-2315"><xref:System.Net.Sockets.Socket.Receive%2A> 方法将只读取从在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机到达的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2315">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="42801-2316">如果使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-2316">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="42801-2317"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 允许接收来自任何主机的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2317"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="42801-2318">如果没有可供读取的数据，则在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.Receive%2A> 方法，除非使用 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>设置了超时值。</span><span class="sxs-lookup"><span data-stu-id="42801-2318">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-2319">如果超过超时值，则 <xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2319">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2320">如果处于非阻止模式，并且协议堆栈缓冲区中没有可用的数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2320">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, The <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2321">您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。</span><span class="sxs-lookup"><span data-stu-id="42801-2321">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="42801-2322">如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，请重试接收操作。</span><span class="sxs-lookup"><span data-stu-id="42801-2322">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.</span></span>  
  
 <span data-ttu-id="42801-2323">如果使用面向连接的 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直至 `size` 参数指定的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2323">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="42801-2324">如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法会立即完成并返回零字节。</span><span class="sxs-lookup"><span data-stu-id="42801-2324">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="42801-2325">如果你使用的是无连接 <xref:System.Net.Sockets.Socket>，则 <xref:System.Net.Sockets.Socket.Receive%2A> 将从你在 <xref:System.Net.Sockets.Socket.Connect%2A> 方法中指定的目标地址读取第一个排队的数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-2325">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="42801-2326">如果接收的数据报大于 `buffer` 参数的大小，则 `buffer` 会填充消息的第一部分，超过的数据将会丢失，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2326">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2327">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-2327">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-2328">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-2328">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2329">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2329">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-2330">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-2330">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-2331">下面的将接收到 `buffer`中找到的数据，并指定 <xref:System.Net.Sockets.SocketFlags><xref:System.Net.Sockets.SocketFlags.None>。</span><span class="sxs-lookup"><span data-stu-id="42801-2331">The following receives the data found into `buffer`, and specifies <xref:System.Net.Sockets.SocketFlags.None> for <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 [!code-cpp[Socket_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-2332"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2332"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-2333"><paramref name="size" /> 超出了 <paramref name="buffer" /> 的大小。</span><span class="sxs-lookup"><span data-stu-id="42801-2333"><paramref name="size" /> exceeds the size of <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2334">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2334">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2335"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2335">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="42801-2336">调用堆栈中的调用方没有所需的权限。</span><span class="sxs-lookup"><span data-stu-id="42801-2336">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="42801-2337">用于接受来自网络的连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2337">for accepting connections from the network.</span></span> <span data-ttu-id="42801-2338">关联的枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2338">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="42801-2339"><see cref="T:System.ArraySegment`1" /> 类型的一个 <see cref="T:System.Byte" /> 列表，包含接收的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2339">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-2340"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-2340">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="42801-2341">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</span><span class="sxs-lookup"><span data-stu-id="42801-2341">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="42801-2342">使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区列表中。</span><span class="sxs-lookup"><span data-stu-id="42801-2342">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="42801-2343">收到的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2343">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2344">此方法将数据读取到 `buffers` 参数并返回成功读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2344">This method reads data into the `buffers` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="42801-2345">可从面向连接的套接字和无连接套接字调用。</span><span class="sxs-lookup"><span data-stu-id="42801-2345">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="42801-2346">此重载要求提供一个或多个接收缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-2346">This overload requires you to provide one or more receive buffers.</span></span> <span data-ttu-id="42801-2347"><xref:System.Net.Sockets.SocketFlags> 值默认为 <xref:System.Net.Sockets.SocketFlags.None>。</span><span class="sxs-lookup"><span data-stu-id="42801-2347">The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="42801-2348">如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在调用 <xref:System.Net.Sockets.Socket.Receive%2A>之前 <xref:System.Net.Sockets.Socket.Accept%2A> 接受传入连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2348">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="42801-2349"><xref:System.Net.Sockets.Socket.Receive%2A> 方法将只读取从在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机连接到达的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2349">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="42801-2350">如果使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-2350">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="42801-2351"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 允许接收来自任何主机的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2351"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="42801-2352">如果没有可供读取的数据，则在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.Receive%2A> 方法，除非使用 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>设置了超时值。</span><span class="sxs-lookup"><span data-stu-id="42801-2352">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-2353">如果超过超时值，则 <xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2353">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2354">如果处于非阻止模式，并且协议堆栈缓冲区中没有可用的数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2354">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2355">您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。</span><span class="sxs-lookup"><span data-stu-id="42801-2355">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="42801-2356">如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。</span><span class="sxs-lookup"><span data-stu-id="42801-2356">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="42801-2357">如果使用面向连接的 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直到达到缓冲区的大小。</span><span class="sxs-lookup"><span data-stu-id="42801-2357">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="42801-2358">如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法会立即完成并返回零字节。</span><span class="sxs-lookup"><span data-stu-id="42801-2358">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="42801-2359">如果你使用的是无连接 <xref:System.Net.Sockets.Socket>，则<xref:System.Net.Sockets.Socket.Receive%2A> 将从你在 <xref:System.Net.Sockets.Socket.Connect%2A> 方法中指定的目标地址读取第一个排队的数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-2359">If you are using a connectionless <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="42801-2360">如果接收的数据报大于 `buffers` 参数的大小，则 `buffers` 会填充消息的第一部分，超过的数据将会丢失，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2360">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2361">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-2361">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-2362">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-2362">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2363">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2363">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-2364">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-2364">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-2365"><paramref name="buffers" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2365"><paramref name="buffers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="42801-2366">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2366">-or-</span></span> 
 <span data-ttu-id="42801-2367"><paramref name="buffers" />.Count 是零。</span><span class="sxs-lookup"><span data-stu-id="42801-2367"><paramref name="buffers" />.Count is zero.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2368">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2368">An error occurred while attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2369"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2369">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="42801-2370">用于接受来自网络的连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2370">for accepting connections from the network.</span></span> <span data-ttu-id="42801-2371">关联的枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2371">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-2372">一个字节范围，它是所接收的数据的存储位置。</span><span class="sxs-lookup"><span data-stu-id="42801-2372">A span of bytes that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-2373">枚举值的按位组合，它用于指定发送和接收行为。</span><span class="sxs-lookup"><span data-stu-id="42801-2373">A bitwise combination of the enumeration values that specifies send and receive behaviors.</span></span></param>
        <param name="errorCode"><span data-ttu-id="42801-2374">当此方法返回时，将包含定义套接字错误代码的枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-2374">When this method returns, contains one of the enumeration values that defines error codes for the socket.</span></span></param>
        <summary><span data-ttu-id="42801-2375">使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-2375">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="42801-2376">收到的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2376">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<span data-ttu-id="42801-2377"><xref:System.Net.Sockets.Socket.Receive%2A> 方法将数据读入 buffer 参数，并返回成功读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2377">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="42801-2378">可从面向连接的套接字和无连接套接字调用 <xref:System.Net.Sockets.Socket.Receive%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-2378">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  

<span data-ttu-id="42801-2379">此重载只要求你提供接收缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-2379">This overload only requires you to provide a receive buffer.</span></span> <span data-ttu-id="42801-2380">缓冲区偏移量默认为0，大小默认为 buffer 参数的长度，<xref:System.Net.Sockets.SocketFlags> 值默认为 <xref:System.Net.Sockets.SocketFlags.None>。</span><span class="sxs-lookup"><span data-stu-id="42801-2380">The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  

<span data-ttu-id="42801-2381">如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在调用 <xref:System.Net.Sockets.Socket.Receive%2A>之前 <xref:System.Net.Sockets.Socket.Accept%2A> 接受传入连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2381">If you're using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="42801-2382"><xref:System.Net.Sockets.Socket.Receive%2A> 方法将只读取从在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机到达的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2382">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="42801-2383">如果使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-2383">If you're using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="42801-2384"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 允许接收来自任何主机的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2384"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  

<span data-ttu-id="42801-2385">如果没有可供读取的数据，则在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.Receive%2A> 方法，除非使用 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>设置了超时值。</span><span class="sxs-lookup"><span data-stu-id="42801-2385">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-2386">超过超时值时，<xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2386">When the time-out value is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2387">如果处于非阻止模式，并且协议堆栈缓冲区中没有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2387">If you're in non-blocking mode, and there's no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2388">您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。</span><span class="sxs-lookup"><span data-stu-id="42801-2388">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="42801-2389">如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。</span><span class="sxs-lookup"><span data-stu-id="42801-2389">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  

<span data-ttu-id="42801-2390">如果使用面向连接的 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，直到达到缓冲区的大小。</span><span class="sxs-lookup"><span data-stu-id="42801-2390">If you're using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="42801-2391">如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法会立即完成并返回零字节。</span><span class="sxs-lookup"><span data-stu-id="42801-2391">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  

<span data-ttu-id="42801-2392">如果你使用的是无连接 <xref:System.Net.Sockets.Socket>，则 <xref:System.Net.Sockets.Socket.Receive%2A> 将从你在 <xref:System.Net.Sockets.Socket.Connect%2A> 方法中指定的目标地址读取第一个排队的数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-2392">If you're using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="42801-2393">如果接收的数据报大于 `buffer` 参数的大小，则 `buffer` 会填充消息的第一部分，超过的数据将会丢失，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2393">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  

> [!NOTE]
>  <span data-ttu-id="42801-2394">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-2394">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-2395">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-2395">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  

> [!NOTE]
>  <span data-ttu-id="42801-2396">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2396">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-2397">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-2397">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2398">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2398">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2399"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2399">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="42801-2400">调用堆栈中的调用方没有所需的权限。</span><span class="sxs-lookup"><span data-stu-id="42801-2400">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="42801-2401">用于接受来自网络的连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2401">for accepting connections from the network.</span></span> <span data-ttu-id="42801-2402">关联的枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2402">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-2403">类型 <see cref="T:System.Byte" /> 的数组，它是所接受的数据的存储位置。</span><span class="sxs-lookup"><span data-stu-id="42801-2403">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="offset"><span data-ttu-id="42801-2404"><paramref name="buffer" /> 中存储所接收数据的位置。</span><span class="sxs-lookup"><span data-stu-id="42801-2404">The location in <paramref name="buffer" /> to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="42801-2405">要接收的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2405">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-2406"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-2406">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="42801-2407">使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收指定的字节数，存入接收缓冲区的指定偏移量位置。</span><span class="sxs-lookup"><span data-stu-id="42801-2407">Receives the specified number of bytes from a bound <see cref="T:System.Net.Sockets.Socket" /> into the specified offset position of the receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="42801-2408">收到的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2408">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2409"><xref:System.Net.Sockets.Socket.Receive%2A> 方法将数据读入 buffer 参数，并返回成功读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2409">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="42801-2410">可从面向连接的套接字和无连接套接字调用 <xref:System.Net.Sockets.Socket.Receive%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-2410">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="42801-2411">如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在调用 <xref:System.Net.Sockets.Socket.Receive%2A>之前 <xref:System.Net.Sockets.Socket.Accept%2A> 接受传入连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2411">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="42801-2412"><xref:System.Net.Sockets.Socket.Receive%2A> 方法将只读取从在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机到达的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2412">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="42801-2413">如果使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-2413">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="42801-2414"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 允许接收来自任何主机的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2414"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="42801-2415">如果没有可供读取的数据，则在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.Receive%2A> 方法，除非使用 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>设置了超时值。</span><span class="sxs-lookup"><span data-stu-id="42801-2415">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-2416">如果超过超时值，则 <xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2416">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2417">如果处于非阻止模式，并且协议堆栈缓冲区中没有可用的数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2417">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2418">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2418">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="42801-2419">请参阅下面的备注。</span><span class="sxs-lookup"><span data-stu-id="42801-2419">See Remarks below.</span></span> <span data-ttu-id="42801-2420">您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。</span><span class="sxs-lookup"><span data-stu-id="42801-2420">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="42801-2421">如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。</span><span class="sxs-lookup"><span data-stu-id="42801-2421">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="42801-2422">如果使用面向连接的 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，最多可达 size 参数指定的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2422">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter.</span></span> <span data-ttu-id="42801-2423">如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法会立即完成并返回零字节。</span><span class="sxs-lookup"><span data-stu-id="42801-2423">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="42801-2424">如果你使用的是无连接 <xref:System.Net.Sockets.Socket>，则 <xref:System.Net.Sockets.Socket.Receive%2A> 将从你在 <xref:System.Net.Sockets.Socket.Connect%2A> 方法中指定的目标地址读取第一个排队的数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-2424">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="42801-2425">如果接收的数据报大于 `buffer` 参数的大小，则 `buffer` 会填充消息的第一部分，超过的数据将会丢失，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2425">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2426">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-2426">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-2427">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-2427">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2428">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2428">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-2429">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-2429">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-2430">下面的代码示例在连接 <xref:System.Net.Sockets.Socket>上接收数据之前，指定数据缓冲区、偏移量、大小和套接字标志。</span><span class="sxs-lookup"><span data-stu-id="42801-2430">The following code example specifies a data buffer, an offset, a size, and a socket flag before receiving data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-2431"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2431"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-2432"><paramref name="offset" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-2432"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-2433">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2433">-or-</span></span> 
 <span data-ttu-id="42801-2434"><paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="42801-2434"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="42801-2435">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2435">-or-</span></span> 
 <span data-ttu-id="42801-2436"><paramref name="size" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-2436"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-2437">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2437">-or-</span></span> 
 <span data-ttu-id="42801-2438"><paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</span><span class="sxs-lookup"><span data-stu-id="42801-2438"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2439"><paramref name="socketFlags" /> 不是有效的值组合。</span><span class="sxs-lookup"><span data-stu-id="42801-2439"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="42801-2440">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2440">-or-</span></span> 
<span data-ttu-id="42801-2441">未设置 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="42801-2441">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
<span data-ttu-id="42801-2442">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2442">-or-</span></span> 
<span data-ttu-id="42801-2443">访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</span><span class="sxs-lookup"><span data-stu-id="42801-2443">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2444"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2444">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="42801-2445">调用堆栈中的调用方没有所需的权限。</span><span class="sxs-lookup"><span data-stu-id="42801-2445">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="42801-2446">用于接受来自网络的连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2446">for accepting connections from the network.</span></span> <span data-ttu-id="42801-2447">关联的枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2447">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-2448"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</span><span class="sxs-lookup"><span data-stu-id="42801-2448">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="42801-2449"><paramref name="buffer" /> 参数中的位置，用于存储所接收的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2449">The position in the <paramref name="buffer" /> parameter to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="42801-2450">要接收的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2450">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-2451"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-2451">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="42801-2452">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</span><span class="sxs-lookup"><span data-stu-id="42801-2452">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="42801-2453">使用指定的 <see cref="T:System.Net.Sockets.Socket" />，从绑定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收数据，将数据存入接收缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-2453">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="42801-2454">收到的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2454">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2455"><xref:System.Net.Sockets.Socket.Receive%2A> 方法将数据读入 buffer 参数，并返回成功读取的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2455">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="42801-2456">可从面向连接的套接字和无连接套接字调用 <xref:System.Net.Sockets.Socket.Receive%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-2456">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="42801-2457">如果使用面向连接的协议，则必须调用 <xref:System.Net.Sockets.Socket.Connect%2A> 以建立远程主机连接，或在调用 <xref:System.Net.Sockets.Socket.Receive%2A>之前 <xref:System.Net.Sockets.Socket.Accept%2A> 接受传入连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2457">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="42801-2458"><xref:System.Net.Sockets.Socket.Receive%2A> 方法将只读取从在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机到达的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2458">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="42801-2459">如果使用的是无连接协议，则还可以使用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-2459">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="42801-2460"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 允许接收来自任何主机的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2460"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="42801-2461">如果没有可供读取的数据，则在数据可用之前，将阻止 <xref:System.Net.Sockets.Socket.Receive%2A> 方法，除非使用 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>设置了超时值。</span><span class="sxs-lookup"><span data-stu-id="42801-2461">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-2462">如果超过超时值，则 <xref:System.Net.Sockets.Socket.Receive%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2462">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2463">如果处于非阻止模式，并且协议堆栈缓冲区中没有可用的数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2463">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2464">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2464">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="42801-2465">请参阅下面的备注。</span><span class="sxs-lookup"><span data-stu-id="42801-2465">See Remarks below.</span></span> <span data-ttu-id="42801-2466">您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。</span><span class="sxs-lookup"><span data-stu-id="42801-2466">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="42801-2467">如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。</span><span class="sxs-lookup"><span data-stu-id="42801-2467">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="42801-2468">如果使用面向连接的 <xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将读取尽可能多的数据，最多可达 size 参数指定的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2468">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter.</span></span> <span data-ttu-id="42801-2469">如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.Receive%2A> 方法会立即完成并返回零字节。</span><span class="sxs-lookup"><span data-stu-id="42801-2469">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="42801-2470">如果你使用的是无连接 <xref:System.Net.Sockets.Socket>，则 <xref:System.Net.Sockets.Socket.Receive%2A> 将从你在 <xref:System.Net.Sockets.Socket.Connect%2A> 方法中指定的目标地址读取第一个排队的数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-2470">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="42801-2471">如果接收的数据报大于 `buffer` 参数的大小，则 `buffer` 会填充消息的第一部分，超过的数据将会丢失，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2471">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2472">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-2472">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-2473">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-2473">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2474">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2474">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-2475">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-2475">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-2476"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2476"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-2477"><paramref name="offset" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-2477"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-2478">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2478">-or-</span></span> 
 <span data-ttu-id="42801-2479"><paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="42801-2479"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="42801-2480">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2480">-or-</span></span> 
 <span data-ttu-id="42801-2481"><paramref name="size" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-2481"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-2482">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2482">-or-</span></span> 
 <span data-ttu-id="42801-2483"><paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</span><span class="sxs-lookup"><span data-stu-id="42801-2483"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2484"><paramref name="socketFlags" /> 不是有效的值组合。</span><span class="sxs-lookup"><span data-stu-id="42801-2484"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="42801-2485">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2485">-or-</span></span> 
<span data-ttu-id="42801-2486">未设置 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="42801-2486">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property is not set.</span></span>  
  
<span data-ttu-id="42801-2487">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2487">-or-</span></span> 
<span data-ttu-id="42801-2488">访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</span><span class="sxs-lookup"><span data-stu-id="42801-2488">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2489"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2489">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="42801-2490">调用堆栈中的调用方没有所需的权限。</span><span class="sxs-lookup"><span data-stu-id="42801-2490">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="42801-2491">用于接受来自网络的连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2491">for accepting connections from the network.</span></span> <span data-ttu-id="42801-2492">关联的枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2492">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="42801-2493">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="42801-2493">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="42801-2494">开始一个异步请求以便从连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象中接收数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2494">Begins an asynchronous request to receive data from a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="42801-2495">如果 I/O 操作挂起，则为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2495"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="42801-2496">操作完成时，将引发 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 参数的 <paramref name="e" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="42801-2496">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="42801-2497">如果 I/O 操作同步完成，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2497"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="42801-2498">在这种情况下，将不会引发 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 参数的 <paramref name="e" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</span><span class="sxs-lookup"><span data-stu-id="42801-2498">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2499"><xref:System.Net.Sockets.Socket.ReceiveAsync%2A> 方法用于连接的套接字或绑定的无连接套接字，并用于读取传入的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2499">The <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method is used on connected sockets or bound connectionless sockets and is used to read incoming data.</span></span> <span data-ttu-id="42801-2500">套接字的本地地址必须是已知的。</span><span class="sxs-lookup"><span data-stu-id="42801-2500">The socket's local address must be known.</span></span>  
  
 <span data-ttu-id="42801-2501">对于绑定的无连接套接字，此函数限制接受接收的消息的地址。</span><span class="sxs-lookup"><span data-stu-id="42801-2501">For bound connectionless sockets, this function restricts the addresses from which received messages are accepted.</span></span> <span data-ttu-id="42801-2502">函数只从连接中指定的远程地址返回消息。</span><span class="sxs-lookup"><span data-stu-id="42801-2502">The function only returns messages from the remote address specified in the connection.</span></span> <span data-ttu-id="42801-2503">来自其他地址的消息将悄悄地丢弃。</span><span class="sxs-lookup"><span data-stu-id="42801-2503">Messages from other addresses are silently discarded.</span></span>  
  
 <span data-ttu-id="42801-2504">`e` 参数的 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> 属性为窗口套接字服务提供程序提供有关读取请求的其他信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2504">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request.</span></span> <span data-ttu-id="42801-2505">有关如何使用此参数的详细信息，请参阅 <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="42801-2505">For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="42801-2506">若要成功调用此方法，需要 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 对象上的下列属性和事件：</span><span class="sxs-lookup"><span data-stu-id="42801-2506">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <span data-ttu-id="42801-2507"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 或 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="42801-2507"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span></span>  
  
-   <span data-ttu-id="42801-2508">如果设置 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>，则 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="42801-2508"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <span data-ttu-id="42801-2509">如果设置 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>，则 <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="42801-2509"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="42801-2510">调用方可以在调用 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> 方法之前将 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 属性设置为所需的任何用户状态对象，以便可以在回调方法中检索信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2510">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="42801-2511">如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。</span><span class="sxs-lookup"><span data-stu-id="42801-2511">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="42801-2512">对于字节流样式的套接字，传入的数据将被放入缓冲区中，直到缓冲区填充完毕、连接关闭或内部缓冲的数据被耗尽。</span><span class="sxs-lookup"><span data-stu-id="42801-2512">For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</span></span>  
  
 <span data-ttu-id="42801-2513">对于面向消息的套接字，会将传入消息放入缓冲区中，直到与 `e` 参数相关联的缓冲区的总大小。</span><span class="sxs-lookup"><span data-stu-id="42801-2513">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer associated with the `e` parameter.</span></span> <span data-ttu-id="42801-2514">如果消息大于缓冲区，则缓冲区将用消息的第一部分进行填充。</span><span class="sxs-lookup"><span data-stu-id="42801-2514">If the message is larger than the buffer, the buffer is filled with the first part of the message.</span></span>  
  
 <span data-ttu-id="42801-2515">对于面向连接的套接字，<xref:System.Net.Sockets.Socket.ReceiveAsync%2A> 方法可以通过以下两种方式之一指示虚拟线路的正常终止方式：取决于套接字是字节流还是面向消息。</span><span class="sxs-lookup"><span data-stu-id="42801-2515">For connection-oriented sockets, the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented.</span></span> <span data-ttu-id="42801-2516">对于字节流，已读取的零字节表示正常关闭，不会再读取更多的字节。</span><span class="sxs-lookup"><span data-stu-id="42801-2516">For byte streams, zero bytes having been read indicates graceful closure and that no more bytes will ever be read.</span></span> <span data-ttu-id="42801-2517">对于面向消息的套接字（通常允许使用零字节消息），将使用 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> 设置为本机 Winsock WSAEDISCON 错误代码（10101）的 <xref:System.Net.Sockets.SocketException> 来指示正常关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2517">For message-oriented sockets, where a zero byte message is often allowable, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAEDISCON error code (10101) is used to indicate graceful closure.</span></span> <span data-ttu-id="42801-2518">在任何情况下，将 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> 设置为本机 Winsock WSAECONNRESET 错误代码（10054）的 <xref:System.Net.Sockets.SocketException> 表明发生了异常 close。</span><span class="sxs-lookup"><span data-stu-id="42801-2518">In any case, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAECONNRESET error code (10054) indicates an abortive close has occurred.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-2519">参数无效。</span><span class="sxs-lookup"><span data-stu-id="42801-2519">An argument was invalid.</span></span> <span data-ttu-id="42801-2520"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 参数的 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 或 <paramref name="e" /> 属性必须引用有效的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-2520">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> properties on the <paramref name="e" /> parameter must reference valid buffers.</span></span> <span data-ttu-id="42801-2521">可以设置这两个属性中的某一个，但不能同时设置这两个属性。</span><span class="sxs-lookup"><span data-stu-id="42801-2521">One or the other of these properties may be set, but not both at the same time.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-2522">已经在使用 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 参数中指定的 <paramref name="e" /> 对象执行套接字操作。</span><span class="sxs-lookup"><span data-stu-id="42801-2522">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-2523">此方法需要 Windows XP 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="42801-2523">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2524"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2524">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2525">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2525">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-2526">获取或设置一个值，它指定 <see cref="T:System.Net.Sockets.Socket" /> 接收缓冲区的大小。</span><span class="sxs-lookup"><span data-stu-id="42801-2526">Gets or sets a value that specifies the size of the receive buffer of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="42801-2527"><see cref="T:System.Int32" />，它包含接收缓冲区的大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="42801-2527">An <see cref="T:System.Int32" /> that contains the size, in bytes, of the receive buffer.</span></span> <span data-ttu-id="42801-2528">默认值为 8192。</span><span class="sxs-lookup"><span data-stu-id="42801-2528">The default is 8192.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2529">较大的缓冲区大小可能会减少空确认（没有数据部分的 TCP 数据包）的数目，但也可能会延迟连接问题的识别。</span><span class="sxs-lookup"><span data-stu-id="42801-2529">A larger buffer size potentially reduces the number of empty acknowledgements (TCP packets with no data portion), but might also delay the recognition of connection difficulties.</span></span> <span data-ttu-id="42801-2530">如果正在传输大文件，或者使用的是高带宽、高延迟连接（如卫星宽带提供程序），请考虑增加缓冲区大小。</span><span class="sxs-lookup"><span data-stu-id="42801-2530">Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-2531">下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="42801-2531">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2532">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2532">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2533"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2533">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-2534">为设置操作指定的值小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-2534">The value specified for a set operation is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42801-2535">接收数据报并存储源终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-2535">Receives a datagram and stores the source endpoint.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-2536">类型 <see cref="T:System.Byte" /> 的数组，它是所接受的数据的存储位置。</span><span class="sxs-lookup"><span data-stu-id="42801-2536">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="42801-2537">通过引用传递的 <see cref="T:System.Net.EndPoint" />，表示远程服务器。</span><span class="sxs-lookup"><span data-stu-id="42801-2537">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="42801-2538">将数据报接收到数据缓冲区并存储终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-2538">Receives a datagram into the data buffer and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="42801-2539">收到的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2539">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2540"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将数据读入 `buffer` 参数，返回成功读取的字节数，并捕获从其发送数据的远程主机终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-2540">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="42801-2541">如果打算从未知主机或多台主机接收无连接的数据报，此方法非常有用。</span><span class="sxs-lookup"><span data-stu-id="42801-2541">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="42801-2542">此重载只要求你提供接收 `buffer`和表示远程主机的 <xref:System.Net.EndPoint>。</span><span class="sxs-lookup"><span data-stu-id="42801-2542">This overload only requires you to provide a receive `buffer`, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="42801-2543">缓冲区偏移量默认为0。</span><span class="sxs-lookup"><span data-stu-id="42801-2543">The buffer offset defaults to 0.</span></span> <span data-ttu-id="42801-2544">大小默认为 `buffer` 参数的长度，`socketFlags` 值默认为 <xref:System.Net.Sockets.SocketFlags.None>。</span><span class="sxs-lookup"><span data-stu-id="42801-2544">The size defaults to the length of the `buffer` parameter and the `socketFlags` value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2545">在调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>之前，必须使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法将 <xref:System.Net.Sockets.Socket> 显式绑定到本地终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-2545">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="42801-2546">否则，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2546">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="42801-2547">对于无连接协议，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将读取接收到本地网络缓冲区中的第一个排队数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-2547">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="42801-2548">如果接收的数据报大于 `buffer`的大小，则 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法会将尽可能多的消息填入 `buffer`，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2548">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2549">如果使用的是不可靠的协议，则过量的数据将丢失。</span><span class="sxs-lookup"><span data-stu-id="42801-2549">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="42801-2550">如果你使用的是可靠协议，则会将多余的数据保留在服务提供程序中，并且你可以通过使用足够大的缓冲区调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法来检索它。</span><span class="sxs-lookup"><span data-stu-id="42801-2550">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="42801-2551">如果没有可供读取的数据，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将被阻止，直到数据可用。</span><span class="sxs-lookup"><span data-stu-id="42801-2551">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="42801-2552">如果处于非阻止模式，并且协议堆栈缓冲区中没有可用的数据，则 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2552">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2553">您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。</span><span class="sxs-lookup"><span data-stu-id="42801-2553">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="42801-2554">如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。</span><span class="sxs-lookup"><span data-stu-id="42801-2554">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="42801-2555">尽管 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 适用于无连接协议，但你也可以使用面向连接的协议。</span><span class="sxs-lookup"><span data-stu-id="42801-2555">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="42801-2556">如果选择这样做，则必须先通过调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法建立远程主机连接，或通过调用 <xref:System.Net.Sockets.Socket.Accept%2A> 方法接受传入的远程主机连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2556">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="42801-2557">如果在调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法之前未建立或接受连接，则将获得一个 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2557">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2558">还可以在调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法之前，为无连接协议建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-2558">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="42801-2559">在这两种情况下，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将忽略 `remoteEP` 参数，并仅从已连接或默认的远程主机接收数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2559">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="42801-2560">使用面向连接的套接字时，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将读取尽可能多的数据，直到 `buffer`的大小。</span><span class="sxs-lookup"><span data-stu-id="42801-2560">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`.</span></span> <span data-ttu-id="42801-2561">如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法会立即完成并返回零字节。</span><span class="sxs-lookup"><span data-stu-id="42801-2561">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2562">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-2562">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-2563">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-2563">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2564"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 中使用的 <xref:System.Net.EndPoint> 的 <xref:System.Net.Sockets.AddressFamily> 需要与 <xref:System.Net.EndPoint> 中使用的 <xref:System.Net.Sockets.Socket.SendTo%2A>的 <xref:System.Net.Sockets.AddressFamily> 匹配。</span><span class="sxs-lookup"><span data-stu-id="42801-2564">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2565">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2565">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-2566">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-2566">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-2567">下面的代码示例从远程主机接收无连接的数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-2567">The following code example receives a connectionless datagram from a remote host.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-2568"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2568"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="42801-2569">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2569">-or-</span></span> 
 <span data-ttu-id="42801-2570"><paramref name="remoteEP" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2570"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2571">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2571">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2572"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2572">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="42801-2573">调用堆栈中的调用方没有所需的权限。</span><span class="sxs-lookup"><span data-stu-id="42801-2573">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="42801-2574">用于接受来自网络的连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2574">for accepting connections from the network.</span></span> <span data-ttu-id="42801-2575">关联的枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2575">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-2576"><see cref="T:System.Byte" /> 类型的数组，它是存储接收到的数据的位置。</span><span class="sxs-lookup"><span data-stu-id="42801-2576">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-2577"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-2577">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="42801-2578">通过引用传递的 <see cref="T:System.Net.EndPoint" />，表示远程服务器。</span><span class="sxs-lookup"><span data-stu-id="42801-2578">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="42801-2579">使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 将数据报接收到数据缓冲区并存储终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-2579">Receives a datagram into the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="42801-2580">收到的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2580">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2581"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将数据读入 `buffer` 参数，返回成功读取的字节数，并捕获从其发送数据的远程主机终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-2581">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="42801-2582">如果打算从未知主机或多台主机接收无连接的数据报，此方法非常有用。</span><span class="sxs-lookup"><span data-stu-id="42801-2582">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="42801-2583">此重载只要求你提供接收缓冲区、必需的 <xref:System.Net.Sockets.SocketFlags>以及表示远程主机的 <xref:System.Net.EndPoint>。</span><span class="sxs-lookup"><span data-stu-id="42801-2583">This overload only requires you to provide a receive buffer, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="42801-2584">偏移量默认为0，大小默认为 buffer 参数的长度。</span><span class="sxs-lookup"><span data-stu-id="42801-2584">The offset defaults to 0 and the size defaults to the length of the buffer parameter.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2585">在调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>之前，必须使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法将 <xref:System.Net.Sockets.Socket> 显式绑定到本地终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-2585">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="42801-2586">否则，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2586">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="42801-2587">对于无连接协议，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将读取接收到本地网络缓冲区中的第一个排队数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-2587">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="42801-2588">如果接收的数据报大于 `buffer`的大小，则 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法会将尽可能多的消息填入 `buffer`，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2588">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2589">如果使用的是不可靠的协议，则过量的数据将丢失。</span><span class="sxs-lookup"><span data-stu-id="42801-2589">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="42801-2590">如果你使用的是可靠协议，则会将多余的数据保留在服务提供程序中，并且你可以通过使用足够大的缓冲区调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法来检索它。</span><span class="sxs-lookup"><span data-stu-id="42801-2590">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="42801-2591">如果没有可供读取的数据，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将被阻止，直到数据可用。</span><span class="sxs-lookup"><span data-stu-id="42801-2591">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="42801-2592">如果处于非阻止模式，并且协议堆栈缓冲区中没有可用的数据，则 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2592">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2593">您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。</span><span class="sxs-lookup"><span data-stu-id="42801-2593">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="42801-2594">如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。</span><span class="sxs-lookup"><span data-stu-id="42801-2594">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="42801-2595">尽管 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 适用于无连接协议，但你也可以使用面向连接的协议。</span><span class="sxs-lookup"><span data-stu-id="42801-2595">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="42801-2596">如果选择这样做，则必须先通过调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法建立远程主机连接，或通过调用 <xref:System.Net.Sockets.Socket.Accept%2A> 方法接受传入的远程主机连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2596">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="42801-2597">如果在调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法之前未建立或接受连接，则将获得一个 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2597">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2598">还可以在调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法之前，为无连接协议建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-2598">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="42801-2599">在这两种情况下，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将忽略 `remoteEP` 参数，并仅从已连接或默认的远程主机接收数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2599">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="42801-2600">使用面向连接的套接字时，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将读取尽可能多的数据，直到 `buffer`的大小。</span><span class="sxs-lookup"><span data-stu-id="42801-2600">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`.</span></span> <span data-ttu-id="42801-2601">如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法会立即完成并返回零字节。</span><span class="sxs-lookup"><span data-stu-id="42801-2601">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2602">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-2602">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-2603">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-2603">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2604"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 中使用的 <xref:System.Net.EndPoint> 的 <xref:System.Net.Sockets.AddressFamily> 需要与 <xref:System.Net.EndPoint> 中使用的 <xref:System.Net.Sockets.Socket.SendTo%2A>的 <xref:System.Net.Sockets.AddressFamily> 匹配。</span><span class="sxs-lookup"><span data-stu-id="42801-2604">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2605">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2605">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-2606">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-2606">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-2607">下面的代码示例从远程主机接收无连接的数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-2607">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="42801-2608"><xref:System.Net.Sockets.SocketFlags> 传递到 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-2608"><xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-2609"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2609"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="42801-2610">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2610">-or-</span></span> 
 <span data-ttu-id="42801-2611"><paramref name="remoteEP" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2611"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2612">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2612">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2613"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2613">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="42801-2614">调用堆栈中的调用方没有所需的权限。</span><span class="sxs-lookup"><span data-stu-id="42801-2614">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="42801-2615">用于接受来自网络的连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2615">for accepting connections from the network.</span></span> <span data-ttu-id="42801-2616">关联的枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2616">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-2617">类型 <see cref="T:System.Byte" /> 的数组，它是所接受的数据的存储位置。</span><span class="sxs-lookup"><span data-stu-id="42801-2617">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="size"><span data-ttu-id="42801-2618">要接收的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2618">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-2619"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-2619">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="42801-2620">通过引用传递的 <see cref="T:System.Net.EndPoint" />，表示远程服务器。</span><span class="sxs-lookup"><span data-stu-id="42801-2620">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="42801-2621">使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 将指定的字节数接收到数据缓冲区并存储终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-2621">Receives the specified number of bytes into the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="42801-2622">收到的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2622">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2623"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将数据读入 `buffer` 参数，返回成功读取的字节数，并捕获从其发送数据的远程主机终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-2623">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="42801-2624">如果打算从未知主机或多台主机接收无连接的数据报，此方法非常有用。</span><span class="sxs-lookup"><span data-stu-id="42801-2624">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="42801-2625">此重载只要求你提供接收缓冲区、要接收的字节数、必需的 <xref:System.Net.Sockets.SocketFlags>以及表示远程主机的 <xref:System.Net.EndPoint>。</span><span class="sxs-lookup"><span data-stu-id="42801-2625">This overload only requires you to provide a receive buffer, the number of bytes you want to receive, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="42801-2626">缓冲区偏移量默认为0。</span><span class="sxs-lookup"><span data-stu-id="42801-2626">The buffer offset defaults to 0.</span></span>  
  
 <span data-ttu-id="42801-2627">对于无连接协议，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将读取接收到本地网络缓冲区中的第一个排队数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-2627">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="42801-2628">如果接收的数据报大于 `buffer`的大小，则 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法会将尽可能多的消息填入 `buffer`，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2628">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2629">如果使用的是不可靠的协议，则过量的数据将丢失。</span><span class="sxs-lookup"><span data-stu-id="42801-2629">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="42801-2630">如果你使用的是可靠协议，则会将多余的数据保留在服务提供程序中，并且你可以通过使用足够大的缓冲区调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法来检索它。</span><span class="sxs-lookup"><span data-stu-id="42801-2630">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="42801-2631">如果没有可供读取的数据，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将被阻止，直到数据可用。</span><span class="sxs-lookup"><span data-stu-id="42801-2631">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="42801-2632">如果处于非阻止模式，并且协议堆栈缓冲区中没有可用的数据，则 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2632">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2633">您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。</span><span class="sxs-lookup"><span data-stu-id="42801-2633">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="42801-2634">如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。</span><span class="sxs-lookup"><span data-stu-id="42801-2634">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="42801-2635">尽管 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 适用于无连接协议，但你也可以使用面向连接的协议。</span><span class="sxs-lookup"><span data-stu-id="42801-2635">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="42801-2636">如果选择这样做，则必须先通过调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法建立远程主机连接，或通过调用 <xref:System.Net.Sockets.Socket.Accept%2A> 方法接受传入的远程主机连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2636">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="42801-2637">如果在调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法之前未建立或接受连接，则将获得一个 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2637">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2638">还可以在调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法之前，为无连接协议建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-2638">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="42801-2639">在这两种情况下，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将忽略 `remoteEP` 参数，并仅从已连接或默认的远程主机接收数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2639">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="42801-2640">使用面向连接的套接字时，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将读取尽可能多的数据，最多可达 `size` 参数指定的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2640">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="42801-2641">如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法会立即完成并返回零字节。</span><span class="sxs-lookup"><span data-stu-id="42801-2641">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2642">在调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>之前，必须使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法将 <xref:System.Net.Sockets.Socket> 显式绑定到本地终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-2642">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="42801-2643">否则，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2643">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2644">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-2644">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-2645">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-2645">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2646"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 中使用的 <xref:System.Net.EndPoint> 的 <xref:System.Net.Sockets.AddressFamily> 需要与 <xref:System.Net.EndPoint> 中使用的 <xref:System.Net.Sockets.Socket.SendTo%2A>的 <xref:System.Net.Sockets.AddressFamily> 匹配。</span><span class="sxs-lookup"><span data-stu-id="42801-2646">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2647">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2647">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-2648">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-2648">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-2649">下面的代码示例从远程主机接收无连接的数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-2649">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="42801-2650">缓冲区大小和 <xref:System.Net.Sockets.SocketFlags> 会传递到 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-2650">The buffer size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-2651"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2651"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="42801-2652">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2652">-or-</span></span> 
 <span data-ttu-id="42801-2653"><paramref name="remoteEP" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2653"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-2654"><paramref name="size" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-2654"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-2655">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2655">-or-</span></span> 
 <span data-ttu-id="42801-2656"><paramref name="size" /> 大于 <paramref name="buffer" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="42801-2656"><paramref name="size" /> is greater than the length of <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2657"><paramref name="socketFlags" /> 不是有效的值组合。</span><span class="sxs-lookup"><span data-stu-id="42801-2657"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="42801-2658">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2658">-or-</span></span> 
<span data-ttu-id="42801-2659">未设置 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="42801-2659">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
<span data-ttu-id="42801-2660">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2660">-or-</span></span> 
<span data-ttu-id="42801-2661">访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</span><span class="sxs-lookup"><span data-stu-id="42801-2661">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2662"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2662">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="42801-2663">调用堆栈中的调用方没有所需的权限。</span><span class="sxs-lookup"><span data-stu-id="42801-2663">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="42801-2664">用于接受来自网络的连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2664">for accepting connections from the network.</span></span> <span data-ttu-id="42801-2665">关联的枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2665">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-2666">类型 <see cref="T:System.Byte" /> 的数组，它是所接受的数据的存储位置。</span><span class="sxs-lookup"><span data-stu-id="42801-2666">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="offset"><span data-ttu-id="42801-2667"><paramref name="buffer" /> 参数中的位置，用于存储所接收的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2667">The position in the <paramref name="buffer" /> parameter to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="42801-2668">要接收的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2668">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-2669"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-2669">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="42801-2670">通过引用传递的 <see cref="T:System.Net.EndPoint" />，表示远程服务器。</span><span class="sxs-lookup"><span data-stu-id="42801-2670">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="42801-2671">使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 将指定的数据字节数接收到数据缓冲区的指定位置，并存储终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-2671">Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="42801-2672">收到的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2672">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2673"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将数据读入 `buffer` 参数，返回成功读取的字节数，并捕获从其发送数据的远程主机终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-2673">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="42801-2674">如果打算从未知主机或多台主机接收无连接的数据报，此方法非常有用。</span><span class="sxs-lookup"><span data-stu-id="42801-2674">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="42801-2675">对于无连接协议，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将读取接收到本地网络缓冲区中的第一个排队数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-2675">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="42801-2676">如果接收的数据报大于 `buffer`的大小，则 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法会将尽可能多的消息填入 `buffer`，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2676">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2677">如果使用的是不可靠的协议，则过量的数据将丢失。</span><span class="sxs-lookup"><span data-stu-id="42801-2677">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="42801-2678">如果你使用的是可靠协议，则会将多余的数据保留在服务提供程序中，并且你可以通过使用足够大的缓冲区调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法来检索它。</span><span class="sxs-lookup"><span data-stu-id="42801-2678">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="42801-2679">如果没有可供读取的数据，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将被阻止，直到数据可用。</span><span class="sxs-lookup"><span data-stu-id="42801-2679">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="42801-2680">如果处于非阻止模式，并且协议堆栈缓冲区中没有可用的数据，则 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将立即完成，并引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2680">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2681">您可以使用 <xref:System.Net.Sockets.Socket.Available%2A> 属性来确定数据是否可用于读取。</span><span class="sxs-lookup"><span data-stu-id="42801-2681">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="42801-2682">如果 <xref:System.Net.Sockets.Socket.Available%2A> 非零，则重试接收操作。</span><span class="sxs-lookup"><span data-stu-id="42801-2682">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="42801-2683">尽管 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 适用于无连接协议，但你也可以使用面向连接的协议。</span><span class="sxs-lookup"><span data-stu-id="42801-2683">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="42801-2684">如果选择这样做，则必须先通过调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法建立远程主机连接，或通过调用 <xref:System.Net.Sockets.Socket.Accept%2A> 方法接受传入的远程主机连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2684">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="42801-2685">如果在调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法之前未建立或接受连接，则将获得一个 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2685">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2686">还可以在调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法之前，为无连接协议建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-2686">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="42801-2687">在这两种情况下，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法将忽略 `remoteEP` 参数，并仅从已连接或默认的远程主机接收数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2687">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="42801-2688">使用面向连接的套接字时，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将读取尽可能多的数据，直到 `size` 参数指定的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2688">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the amount of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="42801-2689">如果远程主机使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法关闭 <xref:System.Net.Sockets.Socket> 连接，并且收到所有可用数据，则 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法会立即完成并返回零字节。</span><span class="sxs-lookup"><span data-stu-id="42801-2689">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2690">在调用 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>之前，必须使用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法将 <xref:System.Net.Sockets.Socket> 显式绑定到本地终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-2690">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="42801-2691">否则，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2691">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2692">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-2692">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-2693">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-2693">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2694"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 中使用的 <xref:System.Net.EndPoint> 的 <xref:System.Net.Sockets.AddressFamily> 需要与 <xref:System.Net.EndPoint> 中使用的 <xref:System.Net.Sockets.Socket.SendTo%2A>的 <xref:System.Net.Sockets.AddressFamily> 匹配。</span><span class="sxs-lookup"><span data-stu-id="42801-2694">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2695">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2695">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-2696">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-2696">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-2697">下面的代码示例从远程主机接收无连接的数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-2697">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="42801-2698">偏移量、缓冲区大小和 <xref:System.Net.Sockets.SocketFlags> 会传递到 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-2698">The offset, buffer size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-2699"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2699"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="42801-2700">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2700">-or-</span></span> 
 <span data-ttu-id="42801-2701"><paramref name="remoteEP" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2701"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-2702"><paramref name="offset" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-2702"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-2703">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2703">-or-</span></span> 
 <span data-ttu-id="42801-2704"><paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="42801-2704"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="42801-2705">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2705">-or-</span></span> 
 <span data-ttu-id="42801-2706"><paramref name="size" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-2706"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-2707">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2707">-or-</span></span> 
 <span data-ttu-id="42801-2708"><paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去偏移量参数的值。</span><span class="sxs-lookup"><span data-stu-id="42801-2708"><paramref name="size" /> is greater than the length of the <paramref name="buffer" /> minus the value of the offset parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2709"><paramref name="socketFlags" /> 不是有效的值组合。</span><span class="sxs-lookup"><span data-stu-id="42801-2709"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="42801-2710">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2710">-or-</span></span> 
<span data-ttu-id="42801-2711">未设置 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="42801-2711">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
<span data-ttu-id="42801-2712">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2712">-or-</span></span> 
<span data-ttu-id="42801-2713">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2713">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2714"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2714">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="42801-2715">用于接受来自网络的连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2715">for accepting connections from the network.</span></span> <span data-ttu-id="42801-2716">关联的枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2716">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="42801-2717">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="42801-2717">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="42801-2718">开始从指定网络设备中异步接收数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2718">Begins to asynchronously receive data from a specified network device.</span></span></summary>
        <returns><span data-ttu-id="42801-2719">如果 I/O 操作挂起，则为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2719"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="42801-2720">操作完成时，将引发 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 参数的 <paramref name="e" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="42801-2720">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="42801-2721">如果 I/O 操作同步完成，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2721"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="42801-2722">在这种情况下，将不会引发 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 参数的 <paramref name="e" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</span><span class="sxs-lookup"><span data-stu-id="42801-2722">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2723"><xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> 方法主要用于接收无连接套接字上的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2723">The <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method is used primarily to receive data on a connectionless socket.</span></span> <span data-ttu-id="42801-2724">套接字的本地地址必须是已知的。</span><span class="sxs-lookup"><span data-stu-id="42801-2724">The socket's local address must be known.</span></span>  
  
 <span data-ttu-id="42801-2725">调用方必须将 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 属性设置为从中接收数据的远程主机的 <xref:System.Net.IPEndPoint>。</span><span class="sxs-lookup"><span data-stu-id="42801-2725">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.</span></span>  
  
 <span data-ttu-id="42801-2726">`e` 参数的 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> 属性为窗口套接字服务提供程序提供有关读取请求的其他信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2726">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request.</span></span> <span data-ttu-id="42801-2727">有关如何使用此参数的详细信息，请参阅 <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="42801-2727">For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="42801-2728">若要成功调用此方法，需要 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 对象上的下列属性和事件：</span><span class="sxs-lookup"><span data-stu-id="42801-2728">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="42801-2729">调用方可以在调用 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> 方法之前将 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 属性设置为所需的任何用户状态对象，以便可以在回调方法中检索信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2729">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="42801-2730">如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。</span><span class="sxs-lookup"><span data-stu-id="42801-2730">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="42801-2731">对于面向消息的套接字，传入消息会放入缓冲区中，直到缓冲区的总大小。</span><span class="sxs-lookup"><span data-stu-id="42801-2731">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</span></span> <span data-ttu-id="42801-2732">"<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>" 和 "<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 属性" 确定数据放置到缓冲区中的位置以及数据量。</span><span class="sxs-lookup"><span data-stu-id="42801-2732">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 <span data-ttu-id="42801-2733">对于字节流样式的套接字，传入的数据将被放入缓冲区中，直到缓冲区填充完毕、连接关闭或内部缓冲的数据被耗尽。</span><span class="sxs-lookup"><span data-stu-id="42801-2733">For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</span></span> <span data-ttu-id="42801-2734">"<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>" 和 "<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 属性" 确定数据放置到缓冲区中的位置以及数据量。</span><span class="sxs-lookup"><span data-stu-id="42801-2734">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-2735"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为 null。</span><span class="sxs-lookup"><span data-stu-id="42801-2735">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-2736">已经在使用 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 参数中指定的 <paramref name="e" /> 对象执行套接字操作。</span><span class="sxs-lookup"><span data-stu-id="42801-2736">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-2737">此方法需要 Windows XP 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="42801-2737">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2738"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2738">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2739">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2739">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int * SocketFlags * EndPoint * IPPacketInformation -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-2740">类型 <see cref="T:System.Byte" /> 的数组，它是所接受的数据的存储位置。</span><span class="sxs-lookup"><span data-stu-id="42801-2740">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="offset"><span data-ttu-id="42801-2741"><paramref name="buffer" /> 参数中的位置，用于存储所接收的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2741">The position in the <paramref name="buffer" /> parameter to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="42801-2742">要接收的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2742">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-2743"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-2743">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="42801-2744">通过引用传递的 <see cref="T:System.Net.EndPoint" />，表示远程服务器。</span><span class="sxs-lookup"><span data-stu-id="42801-2744">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <param name="ipPacketInformation"><span data-ttu-id="42801-2745">保存地址和接口信息的 <see cref="T:System.Net.Sockets.IPPacketInformation" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2745">An <see cref="T:System.Net.Sockets.IPPacketInformation" /> holding address and interface information.</span></span></param>
        <summary><span data-ttu-id="42801-2746">使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" /> 将指定字节数的数据接收到指定的数据缓冲区位置，并存储终结点和数据包信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2746">Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint and packet information.</span></span></summary>
        <returns><span data-ttu-id="42801-2747">收到的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2747">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2748"><xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 方法将数据读入 `buffer` 参数，返回成功读取的字节数，并捕获从其发送数据的远程主机终结点以及有关已接收数据包的信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2748">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent, as well as information about the received packet.</span></span>  
  
 <span data-ttu-id="42801-2749"><xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 方法主要用于接收无连接套接字上的消息数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2749">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method is used primarily to receive message data on a connectionless socket.</span></span> <span data-ttu-id="42801-2750">套接字的本地地址必须是已知的。</span><span class="sxs-lookup"><span data-stu-id="42801-2750">The socket's local address must be known.</span></span> <span data-ttu-id="42801-2751">此方法只能用于数据报和原始套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-2751">This method can only be used with datagram and raw sockets.</span></span> <span data-ttu-id="42801-2752">在调用此方法之前，必须用设置为 <xref:System.Net.Sockets.SocketType.Dgram> 或 <xref:System.Net.Sockets.SocketType.Raw> 的套接字类型来初始化套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-2752">The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method.</span></span> <span data-ttu-id="42801-2753">当使用 <xref:System.Net.Sockets.Socket.%23ctor%2A>构造套接字时，可以执行此操作。</span><span class="sxs-lookup"><span data-stu-id="42801-2753">This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span></span>  
  
 <span data-ttu-id="42801-2754">对于面向消息的套接字，会将传入消息放入 `buffer` 参数，直到 `size` 参数中指定的总大小。</span><span class="sxs-lookup"><span data-stu-id="42801-2754">For message-oriented sockets, an incoming message is placed into the `buffer` parameter up to the total size specified in the `size` parameter.</span></span> <span data-ttu-id="42801-2755">`offset` 参数确定放置数据的 `buffer` 位置。</span><span class="sxs-lookup"><span data-stu-id="42801-2755">The `offset` parameter determines where in the `buffer` the data is placed.</span></span> <span data-ttu-id="42801-2756">放入 `buffer` 的实际数据量由 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 方法返回。</span><span class="sxs-lookup"><span data-stu-id="42801-2756">The actual amount of data placed into the `buffer` is returned by the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="42801-2757"><xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 方法自动方法将 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> 套接字选项设置为第一次为给定 <xref:System.Net.Sockets.Socket>调用时 `true`。</span><span class="sxs-lookup"><span data-stu-id="42801-2757">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method automatically method sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-2758">但是，返回的 <xref:System.Net.Sockets.IPPacketInformation> 对象将仅对在设置套接字选项后到达本地计算机的数据包有效。</span><span class="sxs-lookup"><span data-stu-id="42801-2758">However, the returned <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set.</span></span> <span data-ttu-id="42801-2759">如果套接字在绑定到本地终结点（显式由 <xref:System.Net.Sockets.Socket.Bind%2A> 方法或由 <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>、<xref:System.Net.Sockets.Socket.SendTo%2A>或 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 方法之一隐式的情况下）和第一次调用 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 方法时发送，则对 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> 方法的调用将为这些数据包返回无效 <xref:System.Net.Sockets.IPPacketInformation> 对象。</span><span class="sxs-lookup"><span data-stu-id="42801-2759">If a socket is sent packets between when it is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and its first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method will return invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.</span></span>  
  
 <span data-ttu-id="42801-2760">若要确保所有 <xref:System.Net.Sockets.IPPacketInformation> 对象都有效，应用程序应该先将 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> 套接字选项设置为 `true`，然后再使用 <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> 方法将其绑定到本地终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-2760">To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.</span></span>  
  
 <span data-ttu-id="42801-2761">如果应用程序需要知道是否使用单播、多播或广播地址发送了数据报，则该应用程序可以检查 `ipPacketInformation` 参数。</span><span class="sxs-lookup"><span data-stu-id="42801-2761">An application can examine the `ipPacketInformation` parameter if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2762"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 中使用的 <xref:System.Net.EndPoint> 的 <xref:System.Net.Sockets.AddressFamily> 需要与 <xref:System.Net.EndPoint> 中使用的 <xref:System.Net.Sockets.Socket.SendTo%2A>的 <xref:System.Net.Sockets.AddressFamily> 匹配。</span><span class="sxs-lookup"><span data-stu-id="42801-2762">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2763">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2763">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-2764">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-2764">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-2765"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2765"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="42801-2766">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2766">-or-</span></span> 
 <span data-ttu-id="42801-2767"><paramref name="remoteEP" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2767"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-2768"><paramref name="offset" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-2768"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-2769">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2769">-or-</span></span> 
 <span data-ttu-id="42801-2770"><paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="42801-2770"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="42801-2771">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2771">-or-</span></span> 
 <span data-ttu-id="42801-2772"><paramref name="size" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-2772"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-2773">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2773">-or-</span></span> 
 <span data-ttu-id="42801-2774"><paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去偏移量参数的值。</span><span class="sxs-lookup"><span data-stu-id="42801-2774"><paramref name="size" /> is greater than the length of the <paramref name="buffer" /> minus the value of the offset parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2775"><paramref name="socketFlags" /> 不是有效的值组合。</span><span class="sxs-lookup"><span data-stu-id="42801-2775"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="42801-2776">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2776">-or-</span></span> 
<span data-ttu-id="42801-2777">未设置 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="42801-2777">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
<span data-ttu-id="42801-2778">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2778">-or-</span></span> 
<span data-ttu-id="42801-2779">.NET Framework 运行在 AMD 64 位处理器上。</span><span class="sxs-lookup"><span data-stu-id="42801-2779">The .NET Framework is running on an AMD 64-bit processor.</span></span>  
  
<span data-ttu-id="42801-2780">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-2780">-or-</span></span> 
<span data-ttu-id="42801-2781">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2781">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2782"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2782">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-2783">操作系统为 Windows 2000 或更低版本，而此方法需要在 Windows XP 中使用。</span><span class="sxs-lookup"><span data-stu-id="42801-2783">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="42801-2784">用于接受来自网络的连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2784">for accepting connections from the network.</span></span> <span data-ttu-id="42801-2785">关联的枚举：<see cref="F:System.Net.NetworkAccess.Accept" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2785">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="42801-2786">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="42801-2786">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="42801-2787">开始使用指定的 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /> 将指定字节数的数据异步接收到数据缓冲区的指定位置，并存储终结点和数据包信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2787">Begins to asynchronously receive the specified number of bytes of data into the specified location in the data buffer, using the specified <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />, and stores the endpoint and packet information.</span></span></summary>
        <returns><span data-ttu-id="42801-2788">如果 I/O 操作挂起，则为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2788"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="42801-2789">操作完成时，将引发 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 参数的 <paramref name="e" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="42801-2789">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="42801-2790">如果 I/O 操作同步完成，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2790"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="42801-2791">在这种情况下，将不会引发 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 参数的 <paramref name="e" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</span><span class="sxs-lookup"><span data-stu-id="42801-2791">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2792"><xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> 方法主要用于接收无连接套接字上的消息数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2792">The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method is used primarily to receive message data on a connectionless socket.</span></span> <span data-ttu-id="42801-2793">套接字的本地地址必须是已知的。</span><span class="sxs-lookup"><span data-stu-id="42801-2793">The socket's local address must be known.</span></span> <span data-ttu-id="42801-2794">此方法只能用于数据报和原始套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-2794">This method can only be used with datagram and raw sockets.</span></span> <span data-ttu-id="42801-2795">在调用此方法之前，必须用设置为 <xref:System.Net.Sockets.SocketType.Dgram> 或 <xref:System.Net.Sockets.SocketType.Raw> 的套接字类型来初始化套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-2795">The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method.</span></span> <span data-ttu-id="42801-2796">当使用 <xref:System.Net.Sockets.Socket.%23ctor%2A>构造套接字时，可以执行此操作。</span><span class="sxs-lookup"><span data-stu-id="42801-2796">This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span></span>  
  
 <span data-ttu-id="42801-2797">调用方必须将 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 属性设置为从中接收数据的远程主机的 <xref:System.Net.IPEndPoint>。</span><span class="sxs-lookup"><span data-stu-id="42801-2797">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.</span></span>  
  
 <span data-ttu-id="42801-2798">若要成功调用此方法，需要 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 对象上的下列属性和事件：</span><span class="sxs-lookup"><span data-stu-id="42801-2798">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="42801-2799">调用方可以在调用 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> 方法之前将 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 属性设置为所需的任何用户状态对象，以便可以在回调方法中检索信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2799">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="42801-2800">如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。</span><span class="sxs-lookup"><span data-stu-id="42801-2800">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="42801-2801">对于面向消息的套接字，传入消息会放入缓冲区中，直到缓冲区的总大小。</span><span class="sxs-lookup"><span data-stu-id="42801-2801">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</span></span> <span data-ttu-id="42801-2802">"<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>" 和 "<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 属性" 确定数据放置到缓冲区中的位置以及数据量。</span><span class="sxs-lookup"><span data-stu-id="42801-2802">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 <span data-ttu-id="42801-2803"><xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> 方法自动将 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> 套接字选项设置为第一次为给定 <xref:System.Net.Sockets.Socket>调用时 `true`。</span><span class="sxs-lookup"><span data-stu-id="42801-2803">The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method automatically sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-2804">但是，在设置套接字选项后，<xref:System.Net.Sockets.IPPacketInformation> 对象将仅对到达本地计算机的数据包有效。</span><span class="sxs-lookup"><span data-stu-id="42801-2804">However, the <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set.</span></span> <span data-ttu-id="42801-2805">如果套接字在将套接字绑定到本地终结点（由 <xref:System.Net.Sockets.Socket.Bind%2A> 方法显式调用，或由 <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>、<xref:System.Net.Sockets.Socket.SendTo%2A>或 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 方法之一隐式或由第一次调用 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> 方法）之间发送数据包，则对 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> 方法的调用将导致这些包的 <xref:System.Net.Sockets.IPPacketInformation> 对象无效。</span><span class="sxs-lookup"><span data-stu-id="42801-2805">If a socket is sent packets between when the socket is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and the first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method will result in invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.</span></span>  
  
 <span data-ttu-id="42801-2806">若要确保所有 <xref:System.Net.Sockets.IPPacketInformation> 对象都有效，应用程序应该先将 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> 套接字选项设置为`true`，然后再使用 <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> 方法将其绑定到本地终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-2806">To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to`true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.</span></span>  
  
 <span data-ttu-id="42801-2807">如果应用程序需要知道是否使用单播、多播或广播地址发送了数据报，则该应用程序可以检查生成的 <xref:System.Net.Sockets.IPPacketInformation> 对象。</span><span class="sxs-lookup"><span data-stu-id="42801-2807">An application can examine the resulting <xref:System.Net.Sockets.IPPacketInformation> objects if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-2808"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为 null。</span><span class="sxs-lookup"><span data-stu-id="42801-2808">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-2809">此方法需要 Windows XP 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="42801-2809">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2810"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2810">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2811">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2811">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-2812">获取或设置一个值，该值指定之后同步 <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 调用将超时的时间长度。</span><span class="sxs-lookup"><span data-stu-id="42801-2812">Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Receive" /> call will time out.</span></span></summary>
        <value><span data-ttu-id="42801-2813">超时值（以毫秒为单位）。</span><span class="sxs-lookup"><span data-stu-id="42801-2813">The time-out value, in milliseconds.</span></span> <span data-ttu-id="42801-2814">默认值为 0，指示超时期限无限大。</span><span class="sxs-lookup"><span data-stu-id="42801-2814">The default value is 0, which indicates an infinite time-out period.</span></span> <span data-ttu-id="42801-2815">指定 -1 还会指示超时期限无限大。</span><span class="sxs-lookup"><span data-stu-id="42801-2815">Specifying -1 also indicates an infinite time-out period.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2816">此选项仅适用于同步 <xref:System.Net.Sockets.Socket.Receive%2A> 调用。</span><span class="sxs-lookup"><span data-stu-id="42801-2816">This option applies to synchronous <xref:System.Net.Sockets.Socket.Receive%2A> calls only.</span></span> <span data-ttu-id="42801-2817">如果超过超时期限，<xref:System.Net.Sockets.Socket.Receive%2A> 方法将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2817">If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-2818">下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="42801-2818">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2819">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2819">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2820"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2820">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-2821">为设置操作指定的值小于 1。</span><span class="sxs-lookup"><span data-stu-id="42801-2821">The value specified for a set operation is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-2822">获取远程终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-2822">Gets the remote endpoint.</span></span></summary>
        <value><span data-ttu-id="42801-2823">当前和 <see cref="T:System.Net.EndPoint" /> 通信的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2823">The <see cref="T:System.Net.EndPoint" /> with which the <see cref="T:System.Net.Sockets.Socket" /> is communicating.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2824">如果使用面向连接的协议，则 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 属性将获取 <xref:System.Net.EndPoint>，其中包含 <xref:System.Net.Sockets.Socket> 连接到的远程 IP 地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-2824">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property gets the <xref:System.Net.EndPoint> that contains the remote IP address and port number to which the <xref:System.Net.Sockets.Socket> is connected.</span></span> <span data-ttu-id="42801-2825">如果使用的是无连接协议，<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 将包含 <xref:System.Net.Sockets.Socket> 将与之通信的默认远程 IP 地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-2825">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> contains the default remote IP address and port number with which the <xref:System.Net.Sockets.Socket> will communicate.</span></span> <span data-ttu-id="42801-2826">在检索任何信息之前，必须将此 <xref:System.Net.EndPoint> 强制转换为 <xref:System.Net.IPEndPoint>。</span><span class="sxs-lookup"><span data-stu-id="42801-2826">You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information.</span></span> <span data-ttu-id="42801-2827">然后，可以调用 <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> 方法检索远程 <xref:System.Net.IPAddress>，并调用 <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> 方法来检索远程端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-2827">You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to retrieve the remote <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to retrieve the remote port number.</span></span>  
  
 <span data-ttu-id="42801-2828"><xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 在调用 <xref:System.Net.Sockets.Socket.Accept%2A> 或 <xref:System.Net.Sockets.Socket.Connect%2A>后设置。</span><span class="sxs-lookup"><span data-stu-id="42801-2828">The <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> is set after a call to either <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="42801-2829">如果你之前尝试访问此属性，<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2829">If you try to access this property earlier, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2830">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-2830">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-2831">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-2831">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2832">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2832">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-2833">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-2833">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-2834">下面的代码示例检索并显示本地和远程终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-2834">The following code example retrieves and displays the local and remote endpoints.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2835">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2835">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2836"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2836">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SafeSocketHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.SafeSocketHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeSocketHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SafeSocketHandle ^ SafeHandle { System::Net::Sockets::SafeSocketHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : System.Net.Sockets.SafeSocketHandle" Usage="System.Net.Sockets.Socket.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SafeSocketHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-2837">获取一个 <see cref="T:System.Net.Sockets.SafeSocketHandle" />，它表示当前 <see cref="T:System.Net.Sockets.Socket" /> 对象封装的套接字句柄。</span><span class="sxs-lookup"><span data-stu-id="42801-2837">Gets a <see cref="T:System.Net.Sockets.SafeSocketHandle" /> that represents the socket handle that the current <see cref="T:System.Net.Sockets.Socket" /> object encapsulates.</span></span></summary>
        <value><span data-ttu-id="42801-2838">以安全方式公开当前 <see cref="T:System.Net.Sockets.Socket" /> 对象封装的套接字的套接字句柄。</span><span class="sxs-lookup"><span data-stu-id="42801-2838">A socket handle exposed in a safe manner for the socket that the current <see cref="T:System.Net.Sockets.Socket" /> object encapsulates.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

> [!IMPORTANT]
> <span data-ttu-id="42801-2839">使用 <xref:System.Net.Sockets.SafeSocketHandle> 直接对套接字进行操作可能会导致未记录状态。</span><span class="sxs-lookup"><span data-stu-id="42801-2839">Using the <xref:System.Net.Sockets.SafeSocketHandle> to operate on the socket directly may result in an undocumented state.</span></span> 

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="checkError" Type="System.Collections.IList" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="microSeconds" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="checkRead"><span data-ttu-id="42801-2840">用于检查可读性的 <see cref="T:System.Collections.IList" /> 实例的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2840">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for readability.</span></span></param>
        <param name="checkWrite"><span data-ttu-id="42801-2841">用于检查可写性的 <see cref="T:System.Collections.IList" /> 实例的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2841">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for writability.</span></span></param>
        <param name="checkError"><span data-ttu-id="42801-2842">用于检查错误的 <see cref="T:System.Collections.IList" /> 实例的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2842">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for errors.</span></span></param>
        <param name="microSeconds"><span data-ttu-id="42801-2843">超时值（以微秒为单位）。</span><span class="sxs-lookup"><span data-stu-id="42801-2843">The time-out value, in microseconds.</span></span> <span data-ttu-id="42801-2844">值 -1 指示无限超时。</span><span class="sxs-lookup"><span data-stu-id="42801-2844">A -1 value indicates an infinite time-out.</span></span></param>
        <summary><span data-ttu-id="42801-2845">确定一个或多个套接字的状态。</span><span class="sxs-lookup"><span data-stu-id="42801-2845">Determines the status of one or more sockets.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2846"><xref:System.Net.Sockets.Socket.Select%2A> 是一种静态方法，用于确定一个或多个 <xref:System.Net.Sockets.Socket> 实例的状态。</span><span class="sxs-lookup"><span data-stu-id="42801-2846"><xref:System.Net.Sockets.Socket.Select%2A> is a static method that determines the status of one or more <xref:System.Net.Sockets.Socket> instances.</span></span> <span data-ttu-id="42801-2847">必须将一个或多个套接字置于 <xref:System.Collections.IList>，然后才能使用 <xref:System.Net.Sockets.Socket.Select%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-2847">You must place one or more sockets into an <xref:System.Collections.IList> before you can use the <xref:System.Net.Sockets.Socket.Select%2A> method.</span></span> <span data-ttu-id="42801-2848">通过使用 <xref:System.Collections.IList> 作为 `checkRead` 参数调用 <xref:System.Net.Sockets.Socket.Select%2A> 来检查是否有可读性。</span><span class="sxs-lookup"><span data-stu-id="42801-2848">Check for readability by calling <xref:System.Net.Sockets.Socket.Select%2A> with the <xref:System.Collections.IList> as the `checkRead` parameter.</span></span> <span data-ttu-id="42801-2849">若要检查套接字是否可写性，请使用 `checkWrite` 参数。</span><span class="sxs-lookup"><span data-stu-id="42801-2849">To check your sockets for writability, use the `checkWrite` parameter.</span></span> <span data-ttu-id="42801-2850">对于检测错误条件，请使用 `checkError`。</span><span class="sxs-lookup"><span data-stu-id="42801-2850">For detecting error conditions, use `checkError`.</span></span> <span data-ttu-id="42801-2851">调用 <xref:System.Net.Sockets.Socket.Select%2A>后，<xref:System.Collections.IList> 将只填充满足条件的那些套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-2851">After calling <xref:System.Net.Sockets.Socket.Select%2A>, the <xref:System.Collections.IList> will be filled with only those sockets that satisfy the conditions.</span></span>  
  
 <span data-ttu-id="42801-2852">如果处于侦听状态，则可读性意味着对 <xref:System.Net.Sockets.Socket.Accept%2A> 的调用将成功，而不会受到阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-2852">If you are in a listening state, readability means that a call to <xref:System.Net.Sockets.Socket.Accept%2A> will succeed without blocking.</span></span> <span data-ttu-id="42801-2853">如果已接受连接，则可读性意味着数据可用于读取。</span><span class="sxs-lookup"><span data-stu-id="42801-2853">If you have already accepted the connection, readability means that data is available for reading.</span></span> <span data-ttu-id="42801-2854">在这些情况下，所有接收操作都将成功，但不会被阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-2854">In these cases, all receive operations will succeed without blocking.</span></span> <span data-ttu-id="42801-2855">可读性还可以指示远程 <xref:System.Net.Sockets.Socket> 是否已关闭连接;在这种情况下，对 <xref:System.Net.Sockets.Socket.Receive%2A> 的调用将立即返回，返回零个字节。</span><span class="sxs-lookup"><span data-stu-id="42801-2855">Readability can also indicate whether the remote <xref:System.Net.Sockets.Socket> has shut down the connection; in that case a call to <xref:System.Net.Sockets.Socket.Receive%2A> will return immediately, with zero bytes returned.</span></span>  
  
 <span data-ttu-id="42801-2856">如果至少有一个感兴趣的套接字（`checkRead`、`checkWrite`和 `checkError` 列表中的套接字）满足指定的条件，或者超过了 `microSeconds` 参数（以第一个为准），<xref:System.Net.Sockets.Socket.Select%2A> 将返回。</span><span class="sxs-lookup"><span data-stu-id="42801-2856"><xref:System.Net.Sockets.Socket.Select%2A> returns when at least one of the sockets of interest (the sockets in the `checkRead`, `checkWrite`, and `checkError` lists) meets its specified criteria, or the `microSeconds` parameter is exceeded, whichever comes first.</span></span> <span data-ttu-id="42801-2857">将 `microSeconds` 设置为-1 表示无限期超时。</span><span class="sxs-lookup"><span data-stu-id="42801-2857">Setting `microSeconds` to -1 specifies an infinite time-out.</span></span>  
  
 <span data-ttu-id="42801-2858">如果对 <xref:System.Net.Sockets.Socket.Connect%2A>进行非阻止调用，则可写性表示已成功连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2858">If you make a nonblocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, writability means that you have connected successfully.</span></span> <span data-ttu-id="42801-2859">如果已建立连接，可写性意味着所有发送操作都将成功，且不会阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-2859">If you already have a connection established, writability means that all send operations will succeed without blocking.</span></span>  
  
 <span data-ttu-id="42801-2860">如果对 <xref:System.Net.Sockets.Socket.Connect%2A>进行了非阻塞调用，则 `checkerror` 参数将标识未成功连接的套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-2860">If you have made a non-blocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, the `checkerror` parameter identifies sockets that have not connected successfully.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2861">如果只想确定单个 <xref:System.Net.Sockets.Socket>的状态，请使用 <xref:System.Net.Sockets.Socket.Poll%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-2861">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method if you only want to determine the status of a single <xref:System.Net.Sockets.Socket>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2862">此方法无法检测某些类型的连接问题，例如网络电缆损坏或远程主机已关闭意外。</span><span class="sxs-lookup"><span data-stu-id="42801-2862">This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</span></span> <span data-ttu-id="42801-2863">您必须尝试发送或接收数据，以检测这些类型的错误。</span><span class="sxs-lookup"><span data-stu-id="42801-2863">You must attempt to send or receive data to detect these kinds of errors.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2864">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-2864">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-2865">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-2865">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-2866">下面的代码示例使用 <xref:System.Net.Sockets.Socket.Select%2A> 来确定哪些侦听套接字具有连接请求。</span><span class="sxs-lookup"><span data-stu-id="42801-2866">The following code example uses <xref:System.Net.Sockets.Socket.Select%2A> to determine which listening sockets have a connection request.</span></span>  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-2867"><paramref name="checkRead" /> 参数为 <see langword="null" /> 或为空。</span><span class="sxs-lookup"><span data-stu-id="42801-2867">The <paramref name="checkRead" /> parameter is <see langword="null" /> or empty.</span></span>  
  
<span data-ttu-id="42801-2868">和</span><span class="sxs-lookup"><span data-stu-id="42801-2868">-and-</span></span> 
<span data-ttu-id="42801-2869"><paramref name="checkWrite" /> 参数为 <see langword="null" /> 或为空</span><span class="sxs-lookup"><span data-stu-id="42801-2869">The <paramref name="checkWrite" /> parameter is <see langword="null" /> or empty</span></span> 
<span data-ttu-id="42801-2870">和</span><span class="sxs-lookup"><span data-stu-id="42801-2870">-and-</span></span> 
<span data-ttu-id="42801-2871"><paramref name="checkError" /> 参数为 <see langword="null" /> 或为空。</span><span class="sxs-lookup"><span data-stu-id="42801-2871">The <paramref name="checkError" /> parameter is <see langword="null" /> or empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2872">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2872">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42801-2873">将数据发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2873">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-2874">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2874">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <summary><span data-ttu-id="42801-2875">将数据发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2875">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="42801-2876">发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2876">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2877"><xref:System.Net.Sockets.Socket.Send%2A> 将数据同步发送到 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中指定的远程主机，并返回成功发送的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2877"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="42801-2878"><xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的协议和无连接的协议。</span><span class="sxs-lookup"><span data-stu-id="42801-2878"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="42801-2879">此重载需要包含要发送的数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-2879">This overload requires a buffer that contains the data you want to send.</span></span> <span data-ttu-id="42801-2880"><xref:System.Net.Sockets.SocketFlags> 值默认为0，缓冲区偏移量默认为0，要发送的字节数默认为缓冲区的大小。</span><span class="sxs-lookup"><span data-stu-id="42801-2880">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span>  
  
 <span data-ttu-id="42801-2881">如果使用的是无连接协议，则必须在调用此方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2881">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2882">如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2882">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="42801-2883">如果使用无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-2883">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="42801-2884">如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法，则必须在每次调用 <xref:System.Net.Sockets.Socket.Send%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-2884">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="42801-2885">即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-2885">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="42801-2886">还可以在调用 <xref:System.Net.Sockets.Socket.Send%2A> 之前更改默认远程主机，方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-2886">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="42801-2887">如果使用面向连接的协议，则在发送缓冲区中的所有字节之前，<xref:System.Net.Sockets.Socket.Send%2A> 会一直阻止，除非使用 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>设置了超时。</span><span class="sxs-lookup"><span data-stu-id="42801-2887">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-2888">如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2888">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2889">在非阻止模式下，即使发送的字节数小于缓冲区中的字节数，<xref:System.Net.Sockets.Socket.Send%2A> 也可能成功完成。</span><span class="sxs-lookup"><span data-stu-id="42801-2889">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="42801-2890">应用程序负责跟踪发送的字节数，并在应用程序发送缓冲区中的字节之前重试该操作。</span><span class="sxs-lookup"><span data-stu-id="42801-2890">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="42801-2891">还不能保证发送的数据会立即显示在网络上。</span><span class="sxs-lookup"><span data-stu-id="42801-2891">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="42801-2892">为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2892">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="42801-2893">成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2893">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2894">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-2894">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-2895">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-2895">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2896">成功完成发送并不表示数据已成功传递。</span><span class="sxs-lookup"><span data-stu-id="42801-2896">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="42801-2897">如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。</span><span class="sxs-lookup"><span data-stu-id="42801-2897">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2898">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2898">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-2899">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-2899">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-2900">下面的代码示例演示如何在连接的 <xref:System.Net.Sockets.Socket>上发送数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2900">The following code example demonstrates sending data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-2901"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2901"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2902">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2902">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2903"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2903">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="42801-2904"><see cref="T:System.ArraySegment`1" /> 类型的 <see cref="T:System.Byte" /> 的列表，它包含要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2904">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <summary><span data-ttu-id="42801-2905">将列表中的一组缓冲区发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2905">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="42801-2906">发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2906">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2907"><xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的协议和无连接的协议。</span><span class="sxs-lookup"><span data-stu-id="42801-2907"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="42801-2908">此重载至少需要一个包含要发送的数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-2908">This overload requires at least one buffer that contains the data you want to send.</span></span>  
  
 <span data-ttu-id="42801-2909">如果使用的是无连接协议，则必须在调用此方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2909">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2910">如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2910">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="42801-2911">如果使用无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-2911">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="42801-2912">如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法，则必须在每次调用 <xref:System.Net.Sockets.Socket.Send%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-2912">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="42801-2913">即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-2913">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="42801-2914">还可以在调用 <xref:System.Net.Sockets.Socket.Send%2A> 之前更改默认远程主机，方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-2914">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="42801-2915">如果使用面向连接的协议，则在发送缓冲区中的所有字节之前，<xref:System.Net.Sockets.Socket.Send%2A> 会一直阻止，除非使用 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>设置了超时。</span><span class="sxs-lookup"><span data-stu-id="42801-2915">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-2916">如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2916">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2917">在非阻止模式下，即使发送的字节数小于缓冲区中的字节数，<xref:System.Net.Sockets.Socket.Send%2A> 也可能成功完成。</span><span class="sxs-lookup"><span data-stu-id="42801-2917">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="42801-2918">应用程序负责跟踪发送的字节数，并在应用程序发送缓冲区中的字节之前重试该操作。</span><span class="sxs-lookup"><span data-stu-id="42801-2918">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="42801-2919">还不能保证发送的数据会立即显示在网络上。</span><span class="sxs-lookup"><span data-stu-id="42801-2919">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="42801-2920">为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2920">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="42801-2921">成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2921">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2922">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-2922">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-2923">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-2923">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2924">成功完成发送并不表示数据已成功传递。</span><span class="sxs-lookup"><span data-stu-id="42801-2924">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="42801-2925">如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。</span><span class="sxs-lookup"><span data-stu-id="42801-2925">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2926">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2926">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-2927">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-2927">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-2928"><paramref name="buffers" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2928"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-2929"><paramref name="buffers" /> 为空。</span><span class="sxs-lookup"><span data-stu-id="42801-2929"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2930">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2930">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="42801-2931">请参见下面的备注部分。</span><span class="sxs-lookup"><span data-stu-id="42801-2931">See remarks section below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2932"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2932">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-2933">一个字符范围，其中包含要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2933">A span of bytes that contains the data to be sent.</span></span></param>
        <summary><span data-ttu-id="42801-2934">将数据发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2934">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="42801-2935">发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2935">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="42801-2936"><xref:System.Net.Sockets.Socket.Send%2A> 将数据同步发送到 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中指定的远程主机，并返回成功发送的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2936"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="42801-2937"><xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的协议和无连接的协议。</span><span class="sxs-lookup"><span data-stu-id="42801-2937"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>

<span data-ttu-id="42801-2938">此重载需要包含要发送的数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-2938">This overload requires a buffer that contains the data you want to send.</span></span> <span data-ttu-id="42801-2939"><xref:System.Net.Sockets.SocketFlags> 值默认为0，缓冲区偏移量默认为0，要发送的字节数默认为缓冲区的大小。</span><span class="sxs-lookup"><span data-stu-id="42801-2939">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span>

<span data-ttu-id="42801-2940">如果使用的是无连接协议，则必须在调用此方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2940">If you're using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2941">如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2941">If you're using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>

<span data-ttu-id="42801-2942">如果使用的是无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-2942">If you're using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="42801-2943">如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法，则必须在每次调用 <xref:System.Net.Sockets.Socket.Send%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-2943">If you don't use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you'll have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="42801-2944">即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-2944">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="42801-2945">还可以通过对 <xref:System.Net.Sockets.Socket.Connect%2A>进行另一次调用来更改默认远程主机，然后再调用 <xref:System.Net.Sockets.Socket.Send%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-2945">You can also change the default remote host before calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>

<span data-ttu-id="42801-2946">如果使用面向连接的协议，则在发送缓冲区中的所有字节之前，<xref:System.Net.Sockets.Socket.Send%2A> 会一直阻止，除非使用 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>设置了超时。</span><span class="sxs-lookup"><span data-stu-id="42801-2946">If you're using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-2947">如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2947">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2948">在非阻止模式下，即使发送的字节数小于缓冲区中的字节数，<xref:System.Net.Sockets.Socket.Send%2A> 也可能成功完成。</span><span class="sxs-lookup"><span data-stu-id="42801-2948">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="42801-2949">应用程序负责跟踪发送的字节数，并在应用程序发送缓冲区中的字节之前重试该操作。</span><span class="sxs-lookup"><span data-stu-id="42801-2949">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="42801-2950">还不能保证发送的数据会立即显示在网络上。</span><span class="sxs-lookup"><span data-stu-id="42801-2950">There's also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="42801-2951">为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2951">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="42801-2952">成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2952">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>

> [!NOTE]
><span data-ttu-id="42801-2953">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-2953">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-2954">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-2954">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>

<span data-ttu-id="42801-2955">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2955">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-2956">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-2956">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>

> [!IMPORTANT]
><span data-ttu-id="42801-2957">成功完成发送并不表示数据已成功传递。</span><span class="sxs-lookup"><span data-stu-id="42801-2957">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="42801-2958">如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。</span><span class="sxs-lookup"><span data-stu-id="42801-2958">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2959">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2959">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2960"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2960">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-2961">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2961">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-2962"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-2962">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="42801-2963">使用指定的 <see cref="T:System.Net.Sockets.Socket" /> 将数据发送到连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2963">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" /> using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="42801-2964">发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2964">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2965"><xref:System.Net.Sockets.Socket.Send%2A> 将数据同步发送到在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机，并返回成功发送的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2965"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="42801-2966"><xref:System.Net.Sockets.Socket.Send%2A> 方法可用于面向连接的协议和无连接的协议。</span><span class="sxs-lookup"><span data-stu-id="42801-2966">The <xref:System.Net.Sockets.Socket.Send%2A> method can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="42801-2967">此重载需要包含要发送的数据的缓冲区和 <xref:System.Net.Sockets.SocketFlags>的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-2967">This overload requires a buffer that contains the data you want to send and a bitwise combination of <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="42801-2968">缓冲区偏移量默认为0，要发送的字节数默认为缓冲区的大小。</span><span class="sxs-lookup"><span data-stu-id="42801-2968">The buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span> <span data-ttu-id="42801-2969">如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数值，则将不路由要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2969">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter value, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="42801-2970">如果使用的是无连接协议，则必须在调用此方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2970">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2971">如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。</span><span class="sxs-lookup"><span data-stu-id="42801-2971">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="42801-2972">如果使用无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-2972">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="42801-2973">如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法，则必须在每次调用 <xref:System.Net.Sockets.Socket.Send%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-2973">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="42801-2974">即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-2974">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="42801-2975">还可以在调用 <xref:System.Net.Sockets.Socket.Send%2A> 之前更改默认远程主机，方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-2975">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="42801-2976">如果使用面向连接的协议，则在发送缓冲区中的所有字节之前，<xref:System.Net.Sockets.Socket.Send%2A> 会一直阻止，除非使用 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>设置了超时。</span><span class="sxs-lookup"><span data-stu-id="42801-2976">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-2977">如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2977">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2978">在非阻止模式下，即使发送的字节数小于缓冲区中的字节数，<xref:System.Net.Sockets.Socket.Send%2A> 也可能成功完成。</span><span class="sxs-lookup"><span data-stu-id="42801-2978">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="42801-2979">应用程序负责跟踪发送的字节数，并重试操作，直到应用程序发送请求的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2979">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="42801-2980">还不能保证发送的数据会立即显示在网络上。</span><span class="sxs-lookup"><span data-stu-id="42801-2980">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="42801-2981">为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2981">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="42801-2982">成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2982">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2983">必须确保缓冲区的大小不超过基础服务提供程序的最大数据包大小。</span><span class="sxs-lookup"><span data-stu-id="42801-2983">You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="42801-2984">如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-2984">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-2985">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-2985">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-2986">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-2986">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2987">成功完成发送并不表示数据已成功传递。</span><span class="sxs-lookup"><span data-stu-id="42801-2987">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="42801-2988">如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。</span><span class="sxs-lookup"><span data-stu-id="42801-2988">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-2989">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-2989">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-2990">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-2990">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-2991">下面的代码示例演示如何在连接的 <xref:System.Net.Sockets.Socket>上发送数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2991">The following code example demonstrates sending data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-2992"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2992"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-2993">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-2993">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-2994"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-2994">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="42801-2995"><see cref="T:System.ArraySegment`1" /> 类型的 <see cref="T:System.Byte" /> 的列表，它包含要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-2995">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-2996"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-2996">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="42801-2997">使用指定的 <see cref="T:System.Net.Sockets.Socket" />，将列表中的一组缓冲区发送到连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</span><span class="sxs-lookup"><span data-stu-id="42801-2997">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="42801-2998">发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-2998">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-2999">此重载至少需要一个包含要发送的数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-2999">This overload requires at least one buffer that contains the data you want to send.</span></span> <span data-ttu-id="42801-3000"><xref:System.Net.Sockets.SocketFlags> 值默认为0。</span><span class="sxs-lookup"><span data-stu-id="42801-3000">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span> <span data-ttu-id="42801-3001">如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketFlags` 参数，则将不路由要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3001">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="42801-3002">如果使用的是无连接协议，则必须在调用此方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3002">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-3003">如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。</span><span class="sxs-lookup"><span data-stu-id="42801-3003">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="42801-3004">如果使用无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-3004">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="42801-3005">如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法，则必须在每次调用 <xref:System.Net.Sockets.Socket.Send%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-3005">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="42801-3006">即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-3006">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="42801-3007">还可以在调用 <xref:System.Net.Sockets.Socket.Send%2A> 之前更改默认远程主机，方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-3007">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="42801-3008">如果使用面向连接的协议，则在发送缓冲区中的所有字节之前，<xref:System.Net.Sockets.Socket.Send%2A> 会一直阻止，除非使用 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>设置了超时。</span><span class="sxs-lookup"><span data-stu-id="42801-3008">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-3009">如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3009">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-3010">在非阻止模式下，即使发送的字节数小于缓冲区中的字节数，<xref:System.Net.Sockets.Socket.Send%2A> 也可能成功完成。</span><span class="sxs-lookup"><span data-stu-id="42801-3010">In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="42801-3011">应用程序负责跟踪发送的字节数，并在应用程序发送缓冲区中的字节之前重试该操作。</span><span class="sxs-lookup"><span data-stu-id="42801-3011">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="42801-3012">还不能保证发送的数据会立即显示在网络上。</span><span class="sxs-lookup"><span data-stu-id="42801-3012">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="42801-3013">为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3013">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="42801-3014">成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3014">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3015">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-3015">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-3016">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-3016">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3017">成功完成发送并不表示数据已成功传递。</span><span class="sxs-lookup"><span data-stu-id="42801-3017">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="42801-3018">如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。</span><span class="sxs-lookup"><span data-stu-id="42801-3018">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3019">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-3019">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-3020">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-3020">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-3021"><paramref name="buffers" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3021"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-3022"><paramref name="buffers" /> 为空。</span><span class="sxs-lookup"><span data-stu-id="42801-3022"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-3023">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-3023">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-3024"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-3024">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-3025">一个字符范围，其中包含要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3025">A span of bytes that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-3026">枚举值的按位组合，它用于指定发送和接收行为。</span><span class="sxs-lookup"><span data-stu-id="42801-3026">A bitwise combination of the enumeration values that specifies send and receive behaviors.</span></span></param>
        <summary><span data-ttu-id="42801-3027">使用指定的 <see cref="T:System.Net.Sockets.Socket" /> 将数据发送到连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3027">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" /> using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="42801-3028">发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3028">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  

  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-3029">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-3029">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-3030"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-3030">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-3031">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3031">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="size"><span data-ttu-id="42801-3032">要发送的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3032">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-3033"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-3033">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="42801-3034">使用指定的 <see cref="T:System.Net.Sockets.Socket" />，将指定字节数的数据发送到已连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3034">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="42801-3035">发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3035">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<span data-ttu-id="42801-3036"><xref:System.Net.Sockets.Socket.Send%2A> 将数据同步发送到在 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中建立的远程主机，并返回成功发送的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3036"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="42801-3037"><xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的协议和无连接的协议。</span><span class="sxs-lookup"><span data-stu-id="42801-3037"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>

<span data-ttu-id="42801-3038">此重载需要包含要发送的数据的缓冲区、要发送的字节数以及任何 <xref:System.Net.Sockets.SocketFlags>的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-3038">This overload requires a buffer that contains the data you want to send, the number of bytes you want to send, and a bitwise combination of any <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="42801-3039">如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则不会路由正在发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3039">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you're sending won't be routed.</span></span>

<span data-ttu-id="42801-3040">如果使用的是无连接协议，则必须在调用此方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3040">If you're using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-3041">如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。</span><span class="sxs-lookup"><span data-stu-id="42801-3041">If you're using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>

<span data-ttu-id="42801-3042">如果使用的是无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-3042">If you're using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="42801-3043">如果 don'tuse <xref:System.Net.Sockets.Socket.SendTo%2A> 方法，则必须在每次调用 <xref:System.Net.Sockets.Socket.Send%2A> 方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-3043">If you don'tuse the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you'll have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="42801-3044">即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-3044">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you've established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="42801-3045">还可以通过对 <xref:System.Net.Sockets.Socket.Connect%2A>进行另一次调用来更改默认远程主机，然后再调用 <xref:System.Net.Sockets.Socket.Send%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-3045">You can also change the default remote host before calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>

<span data-ttu-id="42801-3046">使用面向连接的协议时，除非使用 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>设置了超时，否则 <xref:System.Net.Sockets.Socket.Send%2A> 会一直阻止到发送请求的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3046">With a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-3047">如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3047">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-3048">在非阻止模式下，即使发送的字节数少于你请求的字节数，<xref:System.Net.Sockets.Socket.Send%2A> 也可能成功完成。</span><span class="sxs-lookup"><span data-stu-id="42801-3048">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="42801-3049">应用程序负责跟踪发送的字节数，并重试操作，直到应用程序发送请求的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3049">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="42801-3050">还不能保证发送的数据会立即显示在网络上。</span><span class="sxs-lookup"><span data-stu-id="42801-3050">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="42801-3051">为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3051">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="42801-3052">成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3052">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>

> [!NOTE]
> <span data-ttu-id="42801-3053">必须确保大小不超过基础服务提供程序的最大数据包大小。</span><span class="sxs-lookup"><span data-stu-id="42801-3053">You must ensure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="42801-3054">如果是这样，则不会发送数据报并且 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3054">If it does, the datagram won't be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-3055">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-3055">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-3056">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-3056">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>

<span data-ttu-id="42801-3057">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-3057">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-3058">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-3058">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>

> [!IMPORTANT]
><span data-ttu-id="42801-3059">成功完成发送并不表示数据已成功传递。</span><span class="sxs-lookup"><span data-stu-id="42801-3059">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="42801-3060">如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。</span><span class="sxs-lookup"><span data-stu-id="42801-3060">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>

## Examples

<span data-ttu-id="42801-3061">下面的代码示例发送缓冲区中找到的数据，并为 <xref:System.Net.Sockets.SocketFlags>指定 <xref:System.Net.Sockets.SocketFlags.None>。</span><span class="sxs-lookup"><span data-stu-id="42801-3061">The following code example sends the data found in buffer, and specifies <xref:System.Net.Sockets.SocketFlags.None> for <xref:System.Net.Sockets.SocketFlags>.</span></span>

[!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
[!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
[!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-3062"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3062"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-3063"><paramref name="size" /> 小于 0 或超过缓冲区的大小。</span><span class="sxs-lookup"><span data-stu-id="42801-3063"><paramref name="size" /> is less than 0 or exceeds the size of the buffer.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-3064"><paramref name="socketFlags" /> 不是有效的值组合。</span><span class="sxs-lookup"><span data-stu-id="42801-3064"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="42801-3065">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-3065">-or-</span></span> 
<span data-ttu-id="42801-3066">访问套接字时发生操作系统错误。</span><span class="sxs-lookup"><span data-stu-id="42801-3066">An operating system error occurs while accessing the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-3067"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-3067">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="42801-3068"><see cref="T:System.ArraySegment`1" /> 类型的 <see cref="T:System.Byte" /> 的列表，它包含要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3068">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-3069"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-3069">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="42801-3070">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</span><span class="sxs-lookup"><span data-stu-id="42801-3070">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="42801-3071">使用指定的 <see cref="T:System.Net.Sockets.Socket" />，将列表中的一组缓冲区发送到连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3071">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="42801-3072">发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3072">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-3073">此重载至少需要一个包含要发送的数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-3073">This overload requires at least one buffer that contains the data you want to send.</span></span> <span data-ttu-id="42801-3074"><xref:System.Net.Sockets.SocketFlags> 值默认为0。</span><span class="sxs-lookup"><span data-stu-id="42801-3074">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span> <span data-ttu-id="42801-3075">如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketFlags` 参数，则将不路由要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3075">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="42801-3076">如果使用的是无连接协议，则必须在调用此方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3076">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-3077">如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。</span><span class="sxs-lookup"><span data-stu-id="42801-3077">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="42801-3078">如果使用无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-3078">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="42801-3079">如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法，则必须在每次调用 <xref:System.Net.Sockets.Socket.Send%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-3079">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="42801-3080">即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-3080">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="42801-3081">还可以在调用 <xref:System.Net.Sockets.Socket.Send%2A> 之前更改默认远程主机，方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-3081">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="42801-3082">如果使用面向连接的协议，则在发送缓冲区中的所有字节之前，<xref:System.Net.Sockets.Socket.Send%2A> 会一直阻止，除非使用 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>设置了超时。</span><span class="sxs-lookup"><span data-stu-id="42801-3082">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-3083">如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3083">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-3084">在非阻止模式下，即使发送的字节数小于缓冲区中的字节数，<xref:System.Net.Sockets.Socket.Send%2A> 也可能成功完成。</span><span class="sxs-lookup"><span data-stu-id="42801-3084">In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="42801-3085">应用程序负责跟踪发送的字节数，并在应用程序发送缓冲区中的字节之前重试该操作。</span><span class="sxs-lookup"><span data-stu-id="42801-3085">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="42801-3086">还不能保证发送的数据会立即显示在网络上。</span><span class="sxs-lookup"><span data-stu-id="42801-3086">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="42801-3087">为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3087">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="42801-3088">成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3088">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3089">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-3089">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-3090">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-3090">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3091">成功完成发送并不表示数据已成功传递。</span><span class="sxs-lookup"><span data-stu-id="42801-3091">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="42801-3092">如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。</span><span class="sxs-lookup"><span data-stu-id="42801-3092">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3093">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-3093">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-3094">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-3094">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-3095"><paramref name="buffers" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3095"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-3096"><paramref name="buffers" /> 为空。</span><span class="sxs-lookup"><span data-stu-id="42801-3096"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-3097">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-3097">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-3098"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-3098">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-3099">一个字符范围，其中包含要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3099">A span of bytes that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-3100">枚举值的按位组合，它用于指定发送和接收行为。</span><span class="sxs-lookup"><span data-stu-id="42801-3100">A bitwise combination of the enumeration values that specifies send and receive behaviors.</span></span></param>
        <param name="errorCode"><span data-ttu-id="42801-3101">当此方法返回时，将包含定义套接字错误代码的枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-3101">When this method returns, contains one of the enumeration values that defines error codes for the socket.</span></span></param>
        <summary><span data-ttu-id="42801-3102">使用指定的 <see cref="T:System.Net.Sockets.Socket" /> 将数据发送到连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3102">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" /> using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="42801-3103">发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3103">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<span data-ttu-id="42801-3104"><xref:System.Net.Sockets.Socket.Send%2A> 将数据同步发送到 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中指定的远程主机，并返回成功发送的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3104"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="42801-3105"><xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的协议和无连接的协议。</span><span class="sxs-lookup"><span data-stu-id="42801-3105"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>

<span data-ttu-id="42801-3106">此重载需要包含要发送的数据的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-3106">This overload requires a buffer that contains the data you want to send.</span></span> <span data-ttu-id="42801-3107"><xref:System.Net.Sockets.SocketFlags> 值默认为0，缓冲区偏移量默认为0，要发送的字节数默认为缓冲区的大小。</span><span class="sxs-lookup"><span data-stu-id="42801-3107">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span>

<span data-ttu-id="42801-3108">如果使用的是无连接协议，则必须在调用此方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3108">If you're using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-3109">如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。</span><span class="sxs-lookup"><span data-stu-id="42801-3109">If you're using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>

<span data-ttu-id="42801-3110">如果使用的是无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-3110">If you're using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="42801-3111">如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法，则必须在每次调用 <xref:System.Net.Sockets.Socket.Send%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-3111">If you don't use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you'll have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="42801-3112">即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-3112">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you've established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="42801-3113">还可以通过对 <xref:System.Net.Sockets.Socket.Connect%2A>进行另一次调用来更改默认远程主机，然后再调用 <xref:System.Net.Sockets.Socket.Send%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-3113">You can also change the default remote host before calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>

<span data-ttu-id="42801-3114">如果使用面向连接的协议，则在发送缓冲区中的所有字节之前，<xref:System.Net.Sockets.Socket.Send%2A> 会一直阻止，除非使用 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>设置了超时。</span><span class="sxs-lookup"><span data-stu-id="42801-3114">If you're using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-3115">如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3115">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-3116">在非阻止模式下，即使发送的字节数小于缓冲区中的字节数，<xref:System.Net.Sockets.Socket.Send%2A> 也可能成功完成。</span><span class="sxs-lookup"><span data-stu-id="42801-3116">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="42801-3117">应用程序负责跟踪发送的字节数，并在应用程序发送缓冲区中的字节之前重试该操作。</span><span class="sxs-lookup"><span data-stu-id="42801-3117">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="42801-3118">还不能保证发送的数据会立即显示在网络上。</span><span class="sxs-lookup"><span data-stu-id="42801-3118">There's also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="42801-3119">为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3119">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="42801-3120">成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3120">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>

> [!NOTE]
><span data-ttu-id="42801-3121">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-3121">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-3122">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-3122">After you've obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>

<span data-ttu-id="42801-3123">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-3123">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-3124">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-3124">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>

> [!IMPORTANT]
><span data-ttu-id="42801-3125">成功完成发送并不表示数据已成功传递。</span><span class="sxs-lookup"><span data-stu-id="42801-3125">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="42801-3126">如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。</span><span class="sxs-lookup"><span data-stu-id="42801-3126">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-3127">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-3127">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-3128"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-3128">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-3129">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3129">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="offset"><span data-ttu-id="42801-3130">开始发送数据的缓冲区中的位置。</span><span class="sxs-lookup"><span data-stu-id="42801-3130">The position in the data buffer at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="42801-3131">要发送的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3131">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-3132"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-3132">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="42801-3133">从指定偏移量开始，使用指定 <see cref="T:System.Net.Sockets.Socket" />，将指定的数据字节数发送到已连接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3133">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, starting at the specified offset, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="42801-3134">发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3134">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-3135"><xref:System.Net.Sockets.Socket.Send%2A> 将数据同步发送到 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中指定的远程主机，并返回成功发送的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3135"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="42801-3136"><xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的协议和无连接的协议。</span><span class="sxs-lookup"><span data-stu-id="42801-3136"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="42801-3137">在此重载中，如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则将不会路由你要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3137">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="42801-3138">如果使用的是无连接协议，则必须在调用此方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3138">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-3139">如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。</span><span class="sxs-lookup"><span data-stu-id="42801-3139">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="42801-3140">如果使用无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-3140">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="42801-3141">如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A>，则必须在每次调用 <xref:System.Net.Sockets.Socket.Send%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-3141">If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="42801-3142">即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-3142">It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="42801-3143">还可以在调用 <xref:System.Net.Sockets.Socket.Send%2A> 之前更改默认远程主机，方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-3143">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="42801-3144">您还必须确保大小不超过基础服务提供程序的最大数据包大小。</span><span class="sxs-lookup"><span data-stu-id="42801-3144">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="42801-3145">如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3145">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="42801-3146">如果你使用的是面向连接的协议，除非使用 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>设置了超时值，否则 <xref:System.Net.Sockets.Socket.Send%2A> 会一直阻止到发送请求的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3146">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-3147">如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3147">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-3148">在非阻止模式下，即使发送的字节数少于你请求的字节数，<xref:System.Net.Sockets.Socket.Send%2A> 也可能成功完成。</span><span class="sxs-lookup"><span data-stu-id="42801-3148">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="42801-3149">应用程序负责跟踪发送的字节数，并重试操作，直到应用程序发送请求的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3149">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="42801-3150">还不能保证发送的数据会立即显示在网络上。</span><span class="sxs-lookup"><span data-stu-id="42801-3150">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="42801-3151">为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3151">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="42801-3152">成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3152">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3153">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-3153">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-3154">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-3154">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3155">成功完成发送并不表示数据已成功传递。</span><span class="sxs-lookup"><span data-stu-id="42801-3155">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="42801-3156">如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。</span><span class="sxs-lookup"><span data-stu-id="42801-3156">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3157">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-3157">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-3158">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-3158">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-3159">下面的代码示例指定了用于将数据发送到连接的 <xref:System.Net.Sockets.Socket>的数据缓冲区、偏移量、大小和 <xref:System.Net.Sockets.SocketFlags>。</span><span class="sxs-lookup"><span data-stu-id="42801-3159">The following code example specifies the data buffer, an offset, a size, and <xref:System.Net.Sockets.SocketFlags> for sending data to a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-3160"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3160"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-3161"><paramref name="offset" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-3161"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-3162">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-3162">-or-</span></span> 
 <span data-ttu-id="42801-3163"><paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="42801-3163"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="42801-3164">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-3164">-or-</span></span> 
 <span data-ttu-id="42801-3165"><paramref name="size" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-3165"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-3166">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-3166">-or-</span></span> 
 <span data-ttu-id="42801-3167"><paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</span><span class="sxs-lookup"><span data-stu-id="42801-3167"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-3168"><paramref name="socketFlags" /> 不是有效的值组合。</span><span class="sxs-lookup"><span data-stu-id="42801-3168"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="42801-3169">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-3169">-or-</span></span> 
<span data-ttu-id="42801-3170">访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</span><span class="sxs-lookup"><span data-stu-id="42801-3170">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-3171"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-3171">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-3172">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3172">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="offset"><span data-ttu-id="42801-3173">开始发送数据的缓冲区中的位置。</span><span class="sxs-lookup"><span data-stu-id="42801-3173">The position in the data buffer at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="42801-3174">要发送的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3174">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-3175"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-3175">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="42801-3176">一个 <see cref="T:System.Net.Sockets.SocketError" /> 对象，它存储套接字错误。</span><span class="sxs-lookup"><span data-stu-id="42801-3176">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="42801-3177">从指定偏移量开始，使用指定 <see cref="T:System.Net.Sockets.Socket" />，将指定的数据字节数发送到已连接的 <see cref="T:System.Net.Sockets.SocketFlags" /></span><span class="sxs-lookup"><span data-stu-id="42801-3177">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, starting at the specified offset, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" /></span></span></summary>
        <returns><span data-ttu-id="42801-3178">发送到 <see cref="T:System.Net.Sockets.Socket" /> 的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3178">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-3179"><xref:System.Net.Sockets.Socket.Send%2A> 将数据同步发送到 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中指定的远程主机，并返回成功发送的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3179"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="42801-3180"><xref:System.Net.Sockets.Socket.Send%2A> 可用于面向连接的协议和无连接的协议。</span><span class="sxs-lookup"><span data-stu-id="42801-3180"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="42801-3181">在此重载中，如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则将不会路由你要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3181">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="42801-3182">如果使用的是无连接协议，则必须在调用此方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>，否则 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3182">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-3183">如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。</span><span class="sxs-lookup"><span data-stu-id="42801-3183">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="42801-3184">如果使用无连接协议并计划将数据发送到多个不同的主机，则应使用 <xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-3184">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="42801-3185">如果不使用 <xref:System.Net.Sockets.Socket.SendTo%2A>，则必须在每次调用 <xref:System.Net.Sockets.Socket.Send%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-3185">If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="42801-3186">即使已使用 <xref:System.Net.Sockets.Socket.Connect%2A>建立默认远程主机，也可以使用 <xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-3186">It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="42801-3187">还可以在调用 <xref:System.Net.Sockets.Socket.Send%2A> 之前更改默认远程主机，方法是调用 <xref:System.Net.Sockets.Socket.Connect%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-3187">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="42801-3188">您还必须确保大小不超过基础服务提供程序的最大数据包大小。</span><span class="sxs-lookup"><span data-stu-id="42801-3188">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="42801-3189">如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.Send%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3189">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="42801-3190">如果你使用的是面向连接的协议，除非使用 <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>设置了超时值，否则 <xref:System.Net.Sockets.Socket.Send%2A> 会一直阻止到发送请求的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3190">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-3191">如果超过超时值，则 <xref:System.Net.Sockets.Socket.Send%2A> 调用将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3191">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-3192">在非阻止模式下，即使发送的字节数少于你请求的字节数，<xref:System.Net.Sockets.Socket.Send%2A> 也可能成功完成。</span><span class="sxs-lookup"><span data-stu-id="42801-3192">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="42801-3193">应用程序负责跟踪发送的字节数，并重试操作，直到应用程序发送请求的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3193">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="42801-3194">还不能保证发送的数据会立即显示在网络上。</span><span class="sxs-lookup"><span data-stu-id="42801-3194">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="42801-3195">为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3195">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="42801-3196">成功完成 <xref:System.Net.Sockets.Socket.Send%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3196">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3197">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-3197">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-3198">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-3198">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3199">成功完成发送并不表示数据已成功传递。</span><span class="sxs-lookup"><span data-stu-id="42801-3199">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="42801-3200">如果传输系统中没有可用于保存要传输的数据的缓冲区空间，则发送将会阻止，除非已将套接字置于非阻止模式。</span><span class="sxs-lookup"><span data-stu-id="42801-3200">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3201">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-3201">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-3202">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-3202">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-3203">下面的代码示例指定了用于将数据发送到连接的 <xref:System.Net.Sockets.Socket>的数据缓冲区、偏移量、大小和 <xref:System.Net.Sockets.SocketFlags>。</span><span class="sxs-lookup"><span data-stu-id="42801-3203">The following code example specifies the data buffer, an offset, a size, and <xref:System.Net.Sockets.SocketFlags> for sending data to a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-3204"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3204"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-3205"><paramref name="offset" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-3205"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-3206">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-3206">-or-</span></span> 
 <span data-ttu-id="42801-3207"><paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="42801-3207"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="42801-3208">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-3208">-or-</span></span> 
 <span data-ttu-id="42801-3209"><paramref name="size" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-3209"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-3210">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-3210">-or-</span></span> 
 <span data-ttu-id="42801-3211"><paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</span><span class="sxs-lookup"><span data-stu-id="42801-3211"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-3212"><paramref name="socketFlags" /> 不是有效的值组合。</span><span class="sxs-lookup"><span data-stu-id="42801-3212"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="42801-3213">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-3213">-or-</span></span> 
<span data-ttu-id="42801-3214">访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</span><span class="sxs-lookup"><span data-stu-id="42801-3214">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-3215"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-3215">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="42801-3216">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="42801-3216">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="42801-3217">将数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="42801-3217">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="42801-3218">如果 I/O 操作挂起，则为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3218"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="42801-3219">操作完成时，将引发 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 参数的 <paramref name="e" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="42801-3219">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="42801-3220">如果 I/O 操作同步完成，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3220"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="42801-3221">在这种情况下，将不会引发 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 参数的 <paramref name="e" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</span><span class="sxs-lookup"><span data-stu-id="42801-3221">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-3222"><xref:System.Net.Sockets.Socket.SendAsync%2A> 方法用于从面向连接的套接字上的一个或多个缓冲区写入传出数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3222">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method is used to write outgoing data from one or more buffers on a connection-oriented socket.</span></span> <span data-ttu-id="42801-3223">但是，也可以在连接操作上已指定远程主机的无连接套接字上使用此方法。</span><span class="sxs-lookup"><span data-stu-id="42801-3223">This method can also be used, however, on connectionless sockets that have specified a remote host on a connect operation.</span></span>  
  
 <span data-ttu-id="42801-3224"><xref:System.Net.Sockets.Socket.SendAsync%2A> 方法开始异步发送操作到 <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法中建立的远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3224">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span>  
  
 <span data-ttu-id="42801-3225">若要成功调用此方法，需要 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 对象上的下列属性和事件：</span><span class="sxs-lookup"><span data-stu-id="42801-3225">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <span data-ttu-id="42801-3226"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 或 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="42801-3226"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span></span>  
  
-   <span data-ttu-id="42801-3227">如果设置 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>，则 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="42801-3227"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <span data-ttu-id="42801-3228">如果设置 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>，则 <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="42801-3228"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="42801-3229">调用方可以在调用 <xref:System.Net.Sockets.Socket.SendAsync%2A> 方法之前将 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 属性设置为所需的任何用户状态对象，以便可以在回调方法中检索信息。</span><span class="sxs-lookup"><span data-stu-id="42801-3229">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="42801-3230">如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。</span><span class="sxs-lookup"><span data-stu-id="42801-3230">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="42801-3231">如果你不首先调用 <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A><xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>，则 <xref:System.Net.Sockets.Socket.SendAsync%2A> 方法将引发异常。</span><span class="sxs-lookup"><span data-stu-id="42801-3231">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A><xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.</span></span>  
  
 <span data-ttu-id="42801-3232">调用 <xref:System.Net.Sockets.Socket.SendAsync%2A> 方法使你能够在单独的执行线程中发送数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3232">Calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="42801-3233">对于面向消息的套接字，不要超过底层 Windows 套接字服务提供程序的最大消息大小。</span><span class="sxs-lookup"><span data-stu-id="42801-3233">For message-oriented sockets, do not exceed the maximum message size of the underlying Windows sockets service provider.</span></span> <span data-ttu-id="42801-3234">如果数据太长，无法通过基础服务提供程序以原子方式传递，则不会传输任何数据，并且 <xref:System.Net.Sockets.Socket.SendAsync%2A> 方法将引发 <xref:System.Net.Sockets.SocketException> 并将 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> 设置为本机 Winsock WSAEMSGSIZE 错误代码（10040）。</span><span class="sxs-lookup"><span data-stu-id="42801-3234">If the data is too long to pass atomically through the underlying service provider, no data is transmitted and the <xref:System.Net.Sockets.Socket.SendAsync%2A> method throws a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAEMSGSIZE error code (10040).</span></span>  
  
 <span data-ttu-id="42801-3235">请注意，<xref:System.Net.Sockets.Socket.SendAsync%2A> 方法的成功完成并不表示数据已成功传递。</span><span class="sxs-lookup"><span data-stu-id="42801-3235">Note that the successful completion of the <xref:System.Net.Sockets.Socket.SendAsync%2A> method does not indicate that the data was successfully delivered.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-3236"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 参数的 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 或 <paramref name="e" /> 属性必须引用有效的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-3236">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> properties on the <paramref name="e" /> parameter must reference valid buffers.</span></span> <span data-ttu-id="42801-3237">可以设置这两个属性中的某一个，但不能同时设置这两个属性。</span><span class="sxs-lookup"><span data-stu-id="42801-3237">One or the other of these properties may be set, but not both at the same time.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-3238">已经在使用 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 参数中指定的 <paramref name="e" /> 对象执行套接字操作。</span><span class="sxs-lookup"><span data-stu-id="42801-3238">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-3239">此方法需要 Windows XP 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="42801-3239">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-3240"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-3240">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-3241"><see cref="T:System.Net.Sockets.Socket" /> 尚未连接或者尚未通过 <see cref="M:System.Net.Sockets.Socket.Accept" />、<see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> 或 <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /> 方法获得。</span><span class="sxs-lookup"><span data-stu-id="42801-3241">The <see cref="T:System.Net.Sockets.Socket" /> is not yet connected or was not obtained via an <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />,or <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />, method.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-3242">获取或设置一个值，该值指定 <see cref="T:System.Net.Sockets.Socket" /> 发送缓冲区的大小。</span><span class="sxs-lookup"><span data-stu-id="42801-3242">Gets or sets a value that specifies the size of the send buffer of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="42801-3243"><see cref="T:System.Int32" />，它包含发送缓冲区的大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="42801-3243">An <see cref="T:System.Int32" /> that contains the size, in bytes, of the send buffer.</span></span> <span data-ttu-id="42801-3244">默认值为 8192。</span><span class="sxs-lookup"><span data-stu-id="42801-3244">The default is 8192.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-3245">缓冲区大小越大，可能会延迟连接的识别问题。</span><span class="sxs-lookup"><span data-stu-id="42801-3245">A larger buffer size might delay the recognition of connection difficulties.</span></span> <span data-ttu-id="42801-3246">如果正在传输大文件，或者使用的是高带宽、高延迟连接（如卫星宽带提供程序），请考虑增加缓冲区大小。</span><span class="sxs-lookup"><span data-stu-id="42801-3246">Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-3247">下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket.SendBufferSize%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="42801-3247">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.SendBufferSize%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-3248">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-3248">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-3249"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-3249">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-3250">为设置操作指定的值小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-3250">The value specified for a set operation is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42801-3251">将文件和可选数据异步发送到连接的 <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3251">Sends a file and optional data synchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="42801-3252">一个 <see cref="T:System.String" />，它包含要发送的文件的路径和名称。</span><span class="sxs-lookup"><span data-stu-id="42801-3252">A <see cref="T:System.String" /> that contains the path and name of the file to be sent.</span></span> <span data-ttu-id="42801-3253">此参数可以为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3253">This parameter can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="42801-3254">使用 <paramref name="fileName" /> 传输标志，将文件 <see cref="T:System.Net.Sockets.Socket" /> 发送到连接的 <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="42801-3254">Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object with the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> transmit flag.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-3255">此重载将文件 `fileName` 发送到连接的套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-3255">This overload sends the file `fileName` to the connected socket.</span></span> <span data-ttu-id="42801-3256">`flags` 参数默认为 <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> （0），`preBuffer` 和 `postBuffer` 参数默认为 `null`。</span><span class="sxs-lookup"><span data-stu-id="42801-3256">The `flags` parameter defaults to <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0), and the `preBuffer` and `postBuffer` parameters default to `null`.</span></span> <span data-ttu-id="42801-3257">如果 `fileName` 位于本地目录中，则只能用该文件的名称进行标识;否则，必须指定文件的完整路径和名称。</span><span class="sxs-lookup"><span data-stu-id="42801-3257">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="42801-3258">通配符（".。。支持\\\myfile.txt "）和 UNC 共享名称（"\\\\\\\shared 目录\\\myfile.txt "）。</span><span class="sxs-lookup"><span data-stu-id="42801-3258">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="42801-3259">如果找不到该文件，则将引发异常 <xref:System.IO.FileNotFoundException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3259">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="42801-3260">此方法使用在 Windows Socket 2 API 中找到的 `TransmitFile` 函数。</span><span class="sxs-lookup"><span data-stu-id="42801-3260">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="42801-3261">有关 `TransmitFile` 函数及其标志的详细信息，请参阅[Windows 套接字](/windows/desktop/WinSock/)文档。</span><span class="sxs-lookup"><span data-stu-id="42801-3261">For more information about the `TransmitFile` function and its flags, see the [Windows Sockets](/windows/desktop/WinSock/) documentation.</span></span>  
  
 <span data-ttu-id="42801-3262"><xref:System.Net.Sockets.Socket.SendFile%2A> 将文件同步发送到 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中指定的远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3262"><xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="42801-3263"><xref:System.Net.Sockets.Socket.SendFile%2A> 可用于面向连接的协议和无连接协议。</span><span class="sxs-lookup"><span data-stu-id="42801-3263"><xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.</span></span>  
  
 <span data-ttu-id="42801-3264">如果使用的是无连接协议，则必须在调用此方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>，否则 <xref:System.Net.Sockets.Socket.SendFile%2A> 会引发 <xref:System.Net.Sockets.SocketException> 异常。</span><span class="sxs-lookup"><span data-stu-id="42801-3264">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span> <span data-ttu-id="42801-3265">如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 来建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。</span><span class="sxs-lookup"><span data-stu-id="42801-3265">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="42801-3266">如果使用面向连接的协议，则在发送文件之前 <xref:System.Net.Sockets.Socket.SendFile%2A> 阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-3266">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the file is sent.</span></span> <span data-ttu-id="42801-3267">在非阻止模式下，在发送整个文件之前，<xref:System.Net.Sockets.Socket.SendFile%2A> 可能会成功完成。</span><span class="sxs-lookup"><span data-stu-id="42801-3267">In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent.</span></span> <span data-ttu-id="42801-3268">不能保证发送的数据会立即显示在网络上。</span><span class="sxs-lookup"><span data-stu-id="42801-3268">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="42801-3269">为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3269">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="42801-3270">成功完成 <xref:System.Net.Sockets.Socket.SendFile%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3270">A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3271">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-3271">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-3272">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-3272">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3273">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-3273">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-3274">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-3274">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-3275">下面的代码示例创建并连接套接字，然后将文件发送到远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3275">The following code example creates and connects a socket and then sends a file to the remote host.</span></span> <span data-ttu-id="42801-3276">文件 "test.txt" 位于本地计算机的根目录中。</span><span class="sxs-lookup"><span data-stu-id="42801-3276">The file "test.txt" is located in the root directory of the local machine.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-3277">套接字未连接到远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3277">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-3278"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-3278">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-3279"><see cref="T:System.Net.Sockets.Socket" /> 对象未处于阻止模式，无法接受此同步调用。</span><span class="sxs-lookup"><span data-stu-id="42801-3279">The <see cref="T:System.Net.Sockets.Socket" /> object is not in blocking mode and cannot accept this synchronous call.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="42801-3280">未找到文件 <paramref name="fileName" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3280">The file <paramref name="fileName" /> was not found.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-3281">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-3281">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="42801-3282">一个 <see cref="T:System.String" />，它包含要发送的文件的路径和名称。</span><span class="sxs-lookup"><span data-stu-id="42801-3282">A <see cref="T:System.String" /> that contains the path and name of the file to be sent.</span></span> <span data-ttu-id="42801-3283">此参数可以为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3283">This parameter can be <see langword="null" />.</span></span></param>
        <param name="preBuffer"><span data-ttu-id="42801-3284">一个 <see cref="T:System.Byte" /> 数组，它包含发送文件前要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3284">A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent.</span></span> <span data-ttu-id="42801-3285">此参数可以为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3285">This parameter can be <see langword="null" />.</span></span></param>
        <param name="postBuffer"><span data-ttu-id="42801-3286">一个 <see cref="T:System.Byte" /> 数组，它包含发送文件后要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3286">A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent.</span></span> <span data-ttu-id="42801-3287">此参数可以为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3287">This parameter can be <see langword="null" />.</span></span></param>
        <param name="flags"><span data-ttu-id="42801-3288">一个或多个 <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 值。</span><span class="sxs-lookup"><span data-stu-id="42801-3288">One or more of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values.</span></span></param>
        <summary><span data-ttu-id="42801-3289">通过指定的 <paramref name="fileName" /> 值，将文件 <see cref="T:System.Net.Sockets.Socket" /> 和数据缓冲区发送到连接的 <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="42801-3289">Sends the file <paramref name="fileName" /> and buffers of data to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the specified <see cref="T:System.Net.Sockets.TransmitFileOptions" /> value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-3290">此重载要求要发送的文件的名称和 <xref:System.Net.Sockets.TransmitFileOptions> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-3290">This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values.</span></span> <span data-ttu-id="42801-3291">`preBuffer` 参数包含要置于该文件之前的所有数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3291">The `preBuffer` parameter contains any data you want to precede the file.</span></span> <span data-ttu-id="42801-3292">`postBuffer` 包含要跟踪文件的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3292">`postBuffer` contains data you want to follow the file.</span></span> <span data-ttu-id="42801-3293">如果 `fileName` 在当前工作目录中，则可以只使用文件的名称进行标识;否则，必须指定文件的完整路径和名称。</span><span class="sxs-lookup"><span data-stu-id="42801-3293">If `fileName` is in the current working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="42801-3294">通配符（".。。支持\\\myfile.txt "）和 UNC 共享名称（"\\\\\\\shared 目录\\\myfile.txt "）。</span><span class="sxs-lookup"><span data-stu-id="42801-3294">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span>  
  
 <span data-ttu-id="42801-3295">`flags` 参数为窗口套接字服务提供程序提供有关文件传输的其他信息。</span><span class="sxs-lookup"><span data-stu-id="42801-3295">The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="42801-3296">有关如何使用此参数的详细信息，请参阅 <xref:System.Net.Sockets.TransmitFileOptions>。</span><span class="sxs-lookup"><span data-stu-id="42801-3296">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="42801-3297">此方法使用在 Windows Socket 2 API 中找到的 `TransmitFile` 函数。</span><span class="sxs-lookup"><span data-stu-id="42801-3297">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="42801-3298">有关 `TransmitFile` 函数及其标志的详细信息，请参阅[Windows 套接字](/windows/desktop/WinSock/)文档。</span><span class="sxs-lookup"><span data-stu-id="42801-3298">For more information about the `TransmitFile` function and its flags, see the [Windows Sockets](/windows/desktop/WinSock/) documentation.</span></span>  
  
 <span data-ttu-id="42801-3299"><xref:System.Net.Sockets.Socket.SendFile%2A> 将文件同步发送到 <xref:System.Net.Sockets.Socket.Connect%2A> 或 <xref:System.Net.Sockets.Socket.Accept%2A> 方法中指定的远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3299"><xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="42801-3300"><xref:System.Net.Sockets.Socket.SendFile%2A> 可用于面向连接的协议和无连接协议。</span><span class="sxs-lookup"><span data-stu-id="42801-3300"><xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.</span></span>  
  
 <span data-ttu-id="42801-3301">如果使用的是无连接协议，则必须在调用此方法之前调用 <xref:System.Net.Sockets.Socket.Connect%2A>;否则 <xref:System.Net.Sockets.Socket.SendFile%2A> 会引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3301">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method; otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-3302">如果使用面向连接的协议，则必须使用 <xref:System.Net.Sockets.Socket.Connect%2A> 建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 来接受传入连接。</span><span class="sxs-lookup"><span data-stu-id="42801-3302">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="42801-3303">如果使用面向连接的协议，则在发送整个文件之前 <xref:System.Net.Sockets.Socket.SendFile%2A> 会阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-3303">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the entire file is sent.</span></span> <span data-ttu-id="42801-3304">在非阻止模式下，在发送整个文件之前，<xref:System.Net.Sockets.Socket.SendFile%2A> 可能会成功完成。</span><span class="sxs-lookup"><span data-stu-id="42801-3304">In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent.</span></span> <span data-ttu-id="42801-3305">不能保证发送的数据会立即显示在网络上。</span><span class="sxs-lookup"><span data-stu-id="42801-3305">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="42801-3306">为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3306">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="42801-3307">成功完成 <xref:System.Net.Sockets.Socket.SendFile%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3307">A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3308">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-3308">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-3309">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-3309">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3310">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-3310">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-3311">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-3311">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-3312">下面的代码示例创建并连接套接字。</span><span class="sxs-lookup"><span data-stu-id="42801-3312">The following code example creates and connects a socket.</span></span> <span data-ttu-id="42801-3313">文件 "test.txt" 位于本地计算机的根目录中。</span><span class="sxs-lookup"><span data-stu-id="42801-3313">The file "test.txt" is located in the root directory of the local machine.</span></span> <span data-ttu-id="42801-3314">在此示例中，我们将创建 prebuffer 和以增大 postbuffer 数据，并使用该文件将其发送到远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3314">In this example, we create a prebuffer and postbuffer of data and send them to the remote host with the file.</span></span> <span data-ttu-id="42801-3315">使用默认 <xref:System.Net.Sockets.TransmitFileOptions>。</span><span class="sxs-lookup"><span data-stu-id="42801-3315">The default <xref:System.Net.Sockets.TransmitFileOptions> are used.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-3316">操作系统不是 Windows NT 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="42801-3316">The operating system is not Windows NT or later.</span></span>  
  
<span data-ttu-id="42801-3317">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-3317">-or-</span></span>
  
 <span data-ttu-id="42801-3318">套接字未连接到远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3318">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-3319"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-3319">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-3320"><see cref="T:System.Net.Sockets.Socket" /> 对象未处于阻止模式，无法接受此同步调用。</span><span class="sxs-lookup"><span data-stu-id="42801-3320">The <see cref="T:System.Net.Sockets.Socket" /> object is not in blocking mode and cannot accept this synchronous call.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="42801-3321">未找到文件 <paramref name="fileName" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3321">The file <paramref name="fileName" /> was not found.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-3322">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-3322">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="42801-3323">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="42801-3323">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="42801-3324">将文件集合或者内存中的数据缓冲区以异步方法发送给连接的 <see cref="T:System.Net.Sockets.Socket" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="42801-3324">Sends a collection of files or in memory data buffers asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="42801-3325">如果 I/O 操作挂起，则为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3325"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="42801-3326">操作完成时，将引发 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 参数的 <paramref name="e" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="42801-3326">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="42801-3327">如果 I/O 操作同步完成，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3327"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="42801-3328">在这种情况下，将不会引发 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 参数的 <paramref name="e" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</span><span class="sxs-lookup"><span data-stu-id="42801-3328">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-3329"><xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 方法用于向远程主机发送一组文件或内存中的数据缓冲区。</span><span class="sxs-lookup"><span data-stu-id="42801-3329">The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is used to send a collection of files or in memory data buffers to remote host.</span></span> <span data-ttu-id="42801-3330"><xref:System.Net.Sockets.Socket> 必须已连接到远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3330">The <xref:System.Net.Sockets.Socket> must already be connected to the remote host.</span></span>  
  
 <span data-ttu-id="42801-3331">如果 <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> 引用工作目录中的文件，则可以只使用文件的名称标识该文件;否则，必须指定文件的完整路径和名称。</span><span class="sxs-lookup"><span data-stu-id="42801-3331">If a <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> references a file in the working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="42801-3332">支持通配符和 UNC 共享名。</span><span class="sxs-lookup"><span data-stu-id="42801-3332">Wildcards and UNC share names are supported.</span></span> <span data-ttu-id="42801-3333">如果找不到该文件，则会引发 <xref:System.IO.FileNotFoundException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3333">If the file is not found, <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="42801-3334">若要在完成时收到通知，您必须创建一个回调方法，用于实现 EventHandler\<SocketAsyncEventArgs > 委托并将回调附加到 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 事件。</span><span class="sxs-lookup"><span data-stu-id="42801-3334">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="42801-3335">`e` 参数的 <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> 属性为窗口套接字服务提供程序提供有关文件传输的其他信息。</span><span class="sxs-lookup"><span data-stu-id="42801-3335">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="42801-3336">有关如何使用此参数的详细信息，请参阅 <xref:System.Net.Sockets.TransmitFileOptions>。</span><span class="sxs-lookup"><span data-stu-id="42801-3336">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="42801-3337">若要成功调用此方法，需要 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 对象上的下列属性和事件：</span><span class="sxs-lookup"><span data-stu-id="42801-3337">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="42801-3338">调用方可以在调用 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 方法之前将 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 属性设置为所需的任何用户状态对象，以便可以在回调方法中检索信息。</span><span class="sxs-lookup"><span data-stu-id="42801-3338">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="42801-3339">如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。</span><span class="sxs-lookup"><span data-stu-id="42801-3339">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="42801-3340">此方法使用在 Windows Socket 2 API 中找到的 TransmitPackets 函数。</span><span class="sxs-lookup"><span data-stu-id="42801-3340">This method uses the TransmitPackets function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="42801-3341">有关 TransmitPackets 函数及其标志的详细信息，请参阅[Windows 套接字](/windows/desktop/WinSock/)文档。</span><span class="sxs-lookup"><span data-stu-id="42801-3341">For more information about the TransmitPackets function and its flags, see the [Windows Sockets](/windows/desktop/WinSock/) documentation.</span></span>  
  
 <span data-ttu-id="42801-3342">尽管适用于面向连接的协议，但 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 方法也适用于无连接协议，前提是你首先调用 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法来建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3342">Although intended for connection-oriented protocols, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method to establish a default remote host.</span></span> <span data-ttu-id="42801-3343">在无连接协议的情况下，你还必须确保文件大小不超过基础服务提供程序的最大数据包大小。</span><span class="sxs-lookup"><span data-stu-id="42801-3343">With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="42801-3344">如果是这样，则不发送数据报并且 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 引发 <xref:System.Net.Sockets.SocketException> 异常。</span><span class="sxs-lookup"><span data-stu-id="42801-3344">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
 <span data-ttu-id="42801-3345"><xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 方法根据使用它的操作系统进行了优化。</span><span class="sxs-lookup"><span data-stu-id="42801-3345">The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized according to the operating system on which it is used.</span></span> <span data-ttu-id="42801-3346">在 Windows server 版本上，<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 方法针对高性能进行了优化。</span><span class="sxs-lookup"><span data-stu-id="42801-3346">On Windows server editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for high performance.</span></span>  
  
 <span data-ttu-id="42801-3347">在 Windows 客户端版本上，<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 方法针对最小内存和资源利用率进行了优化。</span><span class="sxs-lookup"><span data-stu-id="42801-3347">On Windows client editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for minimum memory and resource utilization.</span></span>  
  
 <span data-ttu-id="42801-3348">在 `e` 参数的 <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> 属性中使用 <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> 标志可以提供显著的性能优势。</span><span class="sxs-lookup"><span data-stu-id="42801-3348">Use of the <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> property on the `e` parameter can deliver significant performance benefits.</span></span> <span data-ttu-id="42801-3349">如果发起 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 方法调用的线程用于繁重计算，则可能会阻止 Apc 启动，但这种情况很可能无法启动。</span><span class="sxs-lookup"><span data-stu-id="42801-3349">If the thread initiating the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method call is being used for heavy computations, it is possible, though unlikely, that APCs could be prevented from launching.</span></span> <span data-ttu-id="42801-3350">请注意，内核模式和用户模式 Apc 之间存在差异。</span><span class="sxs-lookup"><span data-stu-id="42801-3350">Note that there is a difference between kernel and user-mode APCs.</span></span> <span data-ttu-id="42801-3351">当线程处于等待状态时，内核 Apc 启动。</span><span class="sxs-lookup"><span data-stu-id="42801-3351">Kernel APCs launch when a thread is in a wait state.</span></span> <span data-ttu-id="42801-3352">当线程处于可报警等待状态时，用户模式 Apc 启动</span><span class="sxs-lookup"><span data-stu-id="42801-3352">User-mode APCs launch when a thread is in an alertable wait state</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="42801-3353">未找到在 <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> 属性中指定的文件。</span><span class="sxs-lookup"><span data-stu-id="42801-3353">The file specified in the <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> property was not found.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-3354">已经在使用 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 参数中指定的 <paramref name="e" /> 对象执行套接字操作。</span><span class="sxs-lookup"><span data-stu-id="42801-3354">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-3355">此方法需要 Windows XP 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="42801-3355">Windows XP or later is required for this method.</span></span> <span data-ttu-id="42801-3356">如果 <see cref="T:System.Net.Sockets.Socket" /> 未连接到远程主机，也会发生此异常。</span><span class="sxs-lookup"><span data-stu-id="42801-3356">This exception also occurs if the <see cref="T:System.Net.Sockets.Socket" /> is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-3357"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-3357">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-3358">使用的是无连接 <see cref="T:System.Net.Sockets.Socket" />，并且所发送的文件超过了基础传输的最大数据包大小。</span><span class="sxs-lookup"><span data-stu-id="42801-3358">A connectionless <see cref="T:System.Net.Sockets.Socket" /> is being used and the file being sent exceeds the maximum packet size of the underlying transport.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-3359">获取或设置一个值，该值指定之后同步 <see cref="Overload:System.Net.Sockets.Socket.Send" /> 调用将超时的时间长度。</span><span class="sxs-lookup"><span data-stu-id="42801-3359">Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Send" /> call will time out.</span></span></summary>
        <value><span data-ttu-id="42801-3360">超时值（以毫秒为单位）。</span><span class="sxs-lookup"><span data-stu-id="42801-3360">The time-out value, in milliseconds.</span></span> <span data-ttu-id="42801-3361">如果将该属性设置为 1 到 499 之间的值，该值将被更改为 500。</span><span class="sxs-lookup"><span data-stu-id="42801-3361">If you set the property with a value between 1 and 499, the value will be changed to 500.</span></span> <span data-ttu-id="42801-3362">默认值为 0，指示超时期限无限大。</span><span class="sxs-lookup"><span data-stu-id="42801-3362">The default value is 0, which indicates an infinite time-out period.</span></span> <span data-ttu-id="42801-3363">指定 -1 还会指示超时期限无限大。</span><span class="sxs-lookup"><span data-stu-id="42801-3363">Specifying -1 also indicates an infinite time-out period.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-3364">此选项仅适用于同步 <xref:System.Net.Sockets.Socket.Send%2A> 调用。</span><span class="sxs-lookup"><span data-stu-id="42801-3364">This option applies to synchronous <xref:System.Net.Sockets.Socket.Send%2A> calls only.</span></span> <span data-ttu-id="42801-3365">如果超过超时期限，<xref:System.Net.Sockets.Socket.Send%2A> 方法将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3365">If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-3366">下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket.SendTimeout%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="42801-3366">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.SendTimeout%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-3367">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-3367">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-3368"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-3368">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-3369">为设置操作指定的值小于 1。</span><span class="sxs-lookup"><span data-stu-id="42801-3369">The value specified for a set operation is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42801-3370">将数据发送到特定终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-3370">Sends data to a specific endpoint.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-3371">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3371">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="42801-3372"><see cref="T:System.Net.EndPoint" />，它表示数据的目标位置。</span><span class="sxs-lookup"><span data-stu-id="42801-3372">The <see cref="T:System.Net.EndPoint" /> that represents the destination for the data.</span></span></param>
        <summary><span data-ttu-id="42801-3373">将数据发送到指定的终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-3373">Sends data to the specified endpoint.</span></span></summary>
        <returns><span data-ttu-id="42801-3374">已发送的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3374">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-3375">在此重载中，缓冲区偏移量默认为0，发送的字节数默认为 `buffer` 参数的大小，<xref:System.Net.Sockets.SocketFlags> 值默认为0。</span><span class="sxs-lookup"><span data-stu-id="42801-3375">In this overload, the buffer offset defaults to 0, the number of bytes to send defaults to the size of the `buffer` parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span>  
  
 <span data-ttu-id="42801-3376">如果使用的是无连接协议，则在调用 <xref:System.Net.Sockets.Socket.SendTo%2A>之前，无需使用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3376">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="42801-3377">如果要调用 <xref:System.Net.Sockets.Socket.Send%2A> 方法，只需执行此操作。</span><span class="sxs-lookup"><span data-stu-id="42801-3377">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="42801-3378">如果在调用 <xref:System.Net.Sockets.Socket.SendTo%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法，`remoteEP` 参数将重写该发送操作的指定默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3378">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="42801-3379">你还不需要调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法，因为基础服务提供程序将分配最适当的本地网络地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-3379">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="42801-3380">如果需要确定分配的本地网络地址和端口号，可以在 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法成功完成后使用 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="42801-3380">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="42801-3381">尽管适用于无连接协议，但 <xref:System.Net.Sockets.Socket.SendTo%2A> 也适用于面向连接的协议。</span><span class="sxs-lookup"><span data-stu-id="42801-3381">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="42801-3382">如果使用面向连接的协议，则必须先通过调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法来建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 方法接受传入的连接请求。</span><span class="sxs-lookup"><span data-stu-id="42801-3382">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="42801-3383">如果未建立或接受远程主机连接，<xref:System.Net.Sockets.Socket.SendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3383">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-3384">还可以在调用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法之前，为无连接协议建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3384">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="42801-3385">在这两种情况下，<xref:System.Net.Sockets.Socket.SendTo%2A> 将忽略 `remoteEP` 参数，只将数据发送到已连接或默认的远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3385">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="42801-3386">在发送缓冲区中的所有字节之前，阻止套接字将会阻止。</span><span class="sxs-lookup"><span data-stu-id="42801-3386">Blocking sockets will block until the all of the bytes in the buffer are sent.</span></span> <span data-ttu-id="42801-3387">由于非阻止 <xref:System.Net.Sockets.Socket> 会立即完成，因此它可能不会发送 `buffer`中的所有字节。</span><span class="sxs-lookup"><span data-stu-id="42801-3387">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`.</span></span> <span data-ttu-id="42801-3388">应用程序负责跟踪发送的字节数，并重试该操作，直到应用程序发送 `buffer`中的所有字节。</span><span class="sxs-lookup"><span data-stu-id="42801-3388">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`.</span></span> <span data-ttu-id="42801-3389">还不能保证发送的数据会立即显示在网络上。</span><span class="sxs-lookup"><span data-stu-id="42801-3389">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="42801-3390">为了提高网络效率，基础系统可能会延迟传输，直到收集大量传出数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3390">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="42801-3391">成功完成 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3391">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="42801-3392">如果在阻止模式下使用无连接协议，则在发送数据报之前，将阻止 <xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-3392">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="42801-3393">如果要将数据发送到广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将套接字选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="42801-3393">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-3394">还必须确保发送的字节数不超过基础服务提供程序的最大数据包大小。</span><span class="sxs-lookup"><span data-stu-id="42801-3394">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="42801-3395">如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.SendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3395">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3396">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-3396">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-3397">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-3397">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3398">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-3398">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-3399">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-3399">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-3400">下面的代码示例将无连接数据报发送到指定的远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3400">The following code example sends a connectionless datagram to the specified remote host.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-3401"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3401"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="42801-3402">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-3402">-or-</span></span> 
 <span data-ttu-id="42801-3403"><paramref name="remoteEP" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3403"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-3404">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-3404">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-3405"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-3405">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-3406">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3406">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-3407"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-3407">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="42801-3408"><see cref="T:System.Net.EndPoint" />，它表示数据的目标位置。</span><span class="sxs-lookup"><span data-stu-id="42801-3408">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span></span></param>
        <summary><span data-ttu-id="42801-3409">使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，将数据发送到特定的终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-3409">Sends data to a specific endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="42801-3410">已发送的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3410">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-3411">在此重载中，缓冲区偏移量默认为0，发送的字节数默认为 `buffer`的大小。</span><span class="sxs-lookup"><span data-stu-id="42801-3411">In this overload, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the `buffer`.</span></span> <span data-ttu-id="42801-3412">如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则将不路由要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3412">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="42801-3413">如果使用的是无连接协议，则在调用 <xref:System.Net.Sockets.Socket.SendTo%2A>之前，无需使用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3413">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="42801-3414">如果要调用 <xref:System.Net.Sockets.Socket.Send%2A> 方法，只需执行此操作。</span><span class="sxs-lookup"><span data-stu-id="42801-3414">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="42801-3415">如果在调用 <xref:System.Net.Sockets.Socket.SendTo%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法，`remoteEP` 参数将重写该发送操作的指定默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3415">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="42801-3416">你还不需要调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法，因为基础服务提供程序将分配最适当的本地网络地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-3416">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="42801-3417">如果需要确定分配的本地网络地址和端口号，可以在 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法成功完成后使用 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="42801-3417">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="42801-3418">尽管适用于无连接协议，但 <xref:System.Net.Sockets.Socket.SendTo%2A> 也适用于面向连接的协议。</span><span class="sxs-lookup"><span data-stu-id="42801-3418">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="42801-3419">如果使用面向连接的协议，则必须先通过调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法来建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 方法接受传入的连接请求。</span><span class="sxs-lookup"><span data-stu-id="42801-3419">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="42801-3420">如果未建立或接受远程主机连接，<xref:System.Net.Sockets.Socket.SendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3420">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-3421">还可以在调用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法之前，为无连接协议建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3421">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="42801-3422">在这两种情况下，<xref:System.Net.Sockets.Socket.SendTo%2A> 将忽略 `remoteEP` 参数，只将数据发送到已连接或默认的远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3422">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="42801-3423">阻止套接字将会阻塞，直到发送了 `buffer` 中的所有字节。</span><span class="sxs-lookup"><span data-stu-id="42801-3423">Blocking sockets will block until the requested all of the bytes in the `buffer` are sent.</span></span> <span data-ttu-id="42801-3424">由于非阻止 <xref:System.Net.Sockets.Socket> 会立即完成，因此它可能不会发送 `buffer`中的所有字节。</span><span class="sxs-lookup"><span data-stu-id="42801-3424">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`.</span></span> <span data-ttu-id="42801-3425">应用程序负责跟踪发送的字节数，并重试该操作，直到应用程序发送 `buffer`中的所有字节。</span><span class="sxs-lookup"><span data-stu-id="42801-3425">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`.</span></span> <span data-ttu-id="42801-3426">还不能保证发送的数据会立即显示在网络上。</span><span class="sxs-lookup"><span data-stu-id="42801-3426">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="42801-3427">为了提高网络效率，基础系统可能会延迟传输，直到收集了大量的传出数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3427">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="42801-3428">成功完成 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3428">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="42801-3429">如果在阻止模式下使用无连接协议，则在发送数据报之前，将阻止 <xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-3429">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="42801-3430">如果要将数据发送到广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将套接字选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="42801-3430">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-3431">还必须确保发送的字节数不超过基础服务提供程序的最大数据包大小。</span><span class="sxs-lookup"><span data-stu-id="42801-3431">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="42801-3432">如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.SendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3432">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3433">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-3433">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-3434">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-3434">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3435">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-3435">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-3436">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-3436">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-3437">下面的代码示例将无连接数据报发送到指定的远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3437">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="42801-3438"><xref:System.Net.Sockets.SocketFlags> 传递到 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-3438"><xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-3439"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3439"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="42801-3440">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-3440">-or-</span></span> 
 <span data-ttu-id="42801-3441"><paramref name="remoteEP" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3441"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-3442">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-3442">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-3443"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-3443">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-3444">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3444">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="size"><span data-ttu-id="42801-3445">要发送的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3445">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-3446"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-3446">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="42801-3447"><see cref="T:System.Net.EndPoint" />，它表示数据的目标位置。</span><span class="sxs-lookup"><span data-stu-id="42801-3447">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span></span></param>
        <summary><span data-ttu-id="42801-3448">使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，将指定字节数的数据发送到指定的终结点。</span><span class="sxs-lookup"><span data-stu-id="42801-3448">Sends the specified number of bytes of data to the specified endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="42801-3449">已发送的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3449">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-3450">在此重载中，缓冲区偏移量默认为0。</span><span class="sxs-lookup"><span data-stu-id="42801-3450">In this overload, the buffer offset defaults to 0.</span></span> <span data-ttu-id="42801-3451">如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则将不路由要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3451">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="42801-3452">如果使用的是无连接协议，则在调用 <xref:System.Net.Sockets.Socket.SendTo%2A>之前，无需使用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3452">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="42801-3453">如果要调用 <xref:System.Net.Sockets.Socket.Send%2A> 方法，只需执行此操作。</span><span class="sxs-lookup"><span data-stu-id="42801-3453">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="42801-3454">如果在调用 <xref:System.Net.Sockets.Socket.SendTo%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法，`remoteEP` 参数将重写该发送操作的指定默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3454">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="42801-3455">你还不需要调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法，因为基础服务提供程序将分配最适当的本地网络地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-3455">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="42801-3456">如果需要确定分配的本地网络地址和端口号，可以在 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法成功完成后使用 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="42801-3456">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="42801-3457">尽管适用于无连接协议，但 <xref:System.Net.Sockets.Socket.SendTo%2A> 也适用于面向连接的协议。</span><span class="sxs-lookup"><span data-stu-id="42801-3457">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="42801-3458">如果使用面向连接的协议，则必须先通过调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法来建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 方法接受传入的连接请求。</span><span class="sxs-lookup"><span data-stu-id="42801-3458">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="42801-3459">如果未建立或接受远程主机连接，<xref:System.Net.Sockets.Socket.SendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3459">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-3460">还可以在调用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法之前，为无连接协议建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3460">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="42801-3461">在这两种情况下，<xref:System.Net.Sockets.Socket.SendTo%2A> 将忽略 `remoteEP` 参数，只将数据发送到已连接或默认的远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3461">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="42801-3462">阻止套接字将会阻止，直到发送请求的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3462">Blocking sockets will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="42801-3463">由于非阻止 <xref:System.Net.Sockets.Socket> 会立即完成，因此它可能不会在单个操作中发送所有请求的字节。</span><span class="sxs-lookup"><span data-stu-id="42801-3463">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation.</span></span> <span data-ttu-id="42801-3464">应用程序负责跟踪发送的字节数，并重试操作，直到应用程序发送请求的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3464">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="42801-3465">还不能保证发送的数据会立即显示在网络上。</span><span class="sxs-lookup"><span data-stu-id="42801-3465">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="42801-3466">为了提高网络效率，基础系统可能会延迟传输，直到收集了大量的传出数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3466">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="42801-3467">成功完成 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3467">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="42801-3468">如果在阻止模式下使用无连接协议，则在发送数据报之前，将阻止 <xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-3468">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="42801-3469">如果要将数据发送到广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将套接字选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="42801-3469">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-3470">还必须确保发送的字节数不超过基础服务提供程序的最大数据包大小。</span><span class="sxs-lookup"><span data-stu-id="42801-3470">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="42801-3471">如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.SendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3471">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3472">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-3472">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-3473">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-3473">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3474">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-3474">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-3475">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-3475">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-3476">下面的代码示例将无连接数据报发送到指定的远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3476">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="42801-3477">将大小和 <xref:System.Net.Sockets.SocketFlags> 传递到 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-3477">The size and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-3478"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3478"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="42801-3479">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-3479">-or-</span></span> 
 <span data-ttu-id="42801-3480"><paramref name="remoteEP" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3480"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-3481">指定的 <paramref name="size" /> 超出 <paramref name="buffer" /> 的大小。</span><span class="sxs-lookup"><span data-stu-id="42801-3481">The specified <paramref name="size" /> exceeds the size of <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-3482">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-3482">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-3483"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-3483">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="42801-3484">类型 <see cref="T:System.Byte" /> 的数组，其中包含要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3484">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="offset"><span data-ttu-id="42801-3485">开始发送数据的缓冲区中的位置。</span><span class="sxs-lookup"><span data-stu-id="42801-3485">The position in the data buffer at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="42801-3486">要发送的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3486">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="42801-3487"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的按位组合。</span><span class="sxs-lookup"><span data-stu-id="42801-3487">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="42801-3488"><see cref="T:System.Net.EndPoint" />，它表示数据的目标位置。</span><span class="sxs-lookup"><span data-stu-id="42801-3488">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span></span></param>
        <summary><span data-ttu-id="42801-3489">使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，将指定字节数的数据发送到指定终结点（从缓冲区中的指定位置开始）。</span><span class="sxs-lookup"><span data-stu-id="42801-3489">Sends the specified number of bytes of data to the specified endpoint, starting at the specified location in the buffer, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="42801-3490">已发送的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3490">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-3491">在此重载中，如果指定 <xref:System.Net.Sockets.SocketFlags.DontRoute> 标志作为 `socketflags` 参数，则将不会路由你要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3491">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="42801-3492">如果使用的是无连接协议，则在调用 <xref:System.Net.Sockets.Socket.SendTo%2A>之前，无需使用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3492">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="42801-3493">如果要调用 <xref:System.Net.Sockets.Socket.Send%2A> 方法，只需执行此操作。</span><span class="sxs-lookup"><span data-stu-id="42801-3493">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="42801-3494">如果在调用 <xref:System.Net.Sockets.Socket.SendTo%2A>之前调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法，`remoteEP` 参数将重写该发送操作的指定默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3494">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="42801-3495">你还不需要调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法，因为基础服务提供程序将分配最适当的本地网络地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-3495">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="42801-3496">如果需要确定分配的本地网络地址和端口号，可以在 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法成功完成后使用 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="42801-3496">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="42801-3497">尽管适用于无连接协议，但 <xref:System.Net.Sockets.Socket.SendTo%2A> 也适用于面向连接的协议。</span><span class="sxs-lookup"><span data-stu-id="42801-3497">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="42801-3498">如果使用面向连接的协议，则必须先通过调用 <xref:System.Net.Sockets.Socket.Connect%2A> 方法来建立远程主机连接，或使用 <xref:System.Net.Sockets.Socket.Accept%2A> 方法接受传入的连接请求。</span><span class="sxs-lookup"><span data-stu-id="42801-3498">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="42801-3499">如果未建立或接受远程主机连接，<xref:System.Net.Sockets.Socket.SendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3499">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-3500">还可以在调用 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法之前，为无连接协议建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3500">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="42801-3501">在这两种情况下，<xref:System.Net.Sockets.Socket.SendTo%2A> 将忽略 `remoteEP` 参数，只将数据发送到已连接或默认的远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3501">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="42801-3502">阻止套接字将会阻止，直到发送请求的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3502">Blocking sockets will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="42801-3503">由于非阻止性 <xref:System.Net.Sockets.Socket> 会立即完成，因此它可能不会在单个操作中发送所有请求的字节。</span><span class="sxs-lookup"><span data-stu-id="42801-3503">Since a non-blocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation.</span></span> <span data-ttu-id="42801-3504">应用程序负责跟踪发送的字节数，并重试操作，直到应用程序发送请求的字节数。</span><span class="sxs-lookup"><span data-stu-id="42801-3504">It is your applications responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="42801-3505">还不能保证发送的数据会立即显示在网络上。</span><span class="sxs-lookup"><span data-stu-id="42801-3505">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="42801-3506">为了提高网络效率，基础系统可能会延迟传输，直到收集了大量的传出数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3506">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="42801-3507">成功完成 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法意味着基础系统具有空间来缓冲用于网络发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3507">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="42801-3508">如果在阻止模式下使用无连接协议，则在发送数据报之前，将阻止 <xref:System.Net.Sockets.Socket.SendTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-3508">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="42801-3509">如果要将数据发送到广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将套接字选项设置为 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="42801-3509">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="42801-3510">您还必须确保大小不超过基础服务提供程序的最大数据包大小。</span><span class="sxs-lookup"><span data-stu-id="42801-3510">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="42801-3511">如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.SendTo%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3511">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3512">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-3512">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-3513">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-3513">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3514">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-3514">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-3515">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-3515">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-3516">下面的代码示例将无连接数据报发送到指定的远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3516">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="42801-3517">偏移量、大小和 <xref:System.Net.Sockets.SocketFlags> 传递到 <xref:System.Net.Sockets.Socket.SendTo%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-3517">The offset, size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-3518"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3518"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="42801-3519">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-3519">-or-</span></span> 
 <span data-ttu-id="42801-3520"><paramref name="remoteEP" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3520"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-3521"><paramref name="offset" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-3521"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-3522">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-3522">-or-</span></span> 
 <span data-ttu-id="42801-3523"><paramref name="offset" /> 大于 <paramref name="buffer" /> 的长度。</span><span class="sxs-lookup"><span data-stu-id="42801-3523"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="42801-3524">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-3524">-or-</span></span> 
 <span data-ttu-id="42801-3525"><paramref name="size" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="42801-3525"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="42801-3526">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-3526">-or-</span></span> 
 <span data-ttu-id="42801-3527"><paramref name="size" /> 大于 <paramref name="buffer" /> 的长度减去 <paramref name="offset" /> 参数的值。</span><span class="sxs-lookup"><span data-stu-id="42801-3527"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-3528"><paramref name="socketFlags" /> 不是有效的值组合。</span><span class="sxs-lookup"><span data-stu-id="42801-3528"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="42801-3529">- 或 -</span><span class="sxs-lookup"><span data-stu-id="42801-3529">-or-</span></span> 
<span data-ttu-id="42801-3530">访问 <see cref="T:System.Net.Sockets.Socket" /> 时出现操作系统错误。</span><span class="sxs-lookup"><span data-stu-id="42801-3530">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-3531"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-3531">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="42801-3532">调用堆栈中的调用方没有所需的权限。</span><span class="sxs-lookup"><span data-stu-id="42801-3532">A caller in the call stack does not have the required permissions.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="42801-3533">要用于此异步套接字操作的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="42801-3533">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="42801-3534">以异步方式将数据发送到特定远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3534">Sends data asynchronously to a specific remote host.</span></span></summary>
        <returns><span data-ttu-id="42801-3535">如果 I/O 操作挂起，则为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3535"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="42801-3536">操作完成时，将引发 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 参数的 <paramref name="e" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="42801-3536">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="42801-3537">如果 I/O 操作同步完成，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3537"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="42801-3538">在这种情况下，将不会引发 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 参数的 <paramref name="e" /> 事件，并且可能在方法调用返回后立即检查作为参数传递的 <paramref name="e" /> 对象以检索操作的结果。</span><span class="sxs-lookup"><span data-stu-id="42801-3538">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-3539"><xref:System.Net.Sockets.Socket.SendToAsync%2A> 方法将异步发送操作发送到 `e` 参数的 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 属性中指定的远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3539">The <xref:System.Net.Sockets.Socket.SendToAsync%2A> method starts an asynchronous send operation to the remote host specified in the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property of the `e` parameter.</span></span> <span data-ttu-id="42801-3540">调用 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 方法使你能够在单独的执行线程中发送数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3540">Calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method gives you the ability to send data within a separate execution thread.</span></span> <span data-ttu-id="42801-3541">尽管此方法用于无连接协议，但 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 适用于连接和面向连接的协议。</span><span class="sxs-lookup"><span data-stu-id="42801-3541">Although this method is intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendToAsync%2A> works with both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="42801-3542">若要在完成时收到通知，您必须创建一个回调方法，用于实现 EventHandler\<SocketAsyncEventArgs > 委托并将回调附加到 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 事件。</span><span class="sxs-lookup"><span data-stu-id="42801-3542">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="42801-3543">若要成功调用此方法，需要 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> 对象上的下列属性和事件：</span><span class="sxs-lookup"><span data-stu-id="42801-3543">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="42801-3544">调用方可以在调用 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 方法之前将 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> 属性设置为所需的任何用户状态对象，以便可以在回调方法中检索信息。</span><span class="sxs-lookup"><span data-stu-id="42801-3544">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="42801-3545">如果回调需要比单个对象更多的信息，则可以创建一个小类，以将其他所需的状态信息保存为成员。</span><span class="sxs-lookup"><span data-stu-id="42801-3545">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="42801-3546">如果使用面向连接的协议，则必须先调用 <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-3546">If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span> <span data-ttu-id="42801-3547">否则 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3547">Otherwise <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-3548">使用面向连接的协议时，<xref:System.Net.Sockets.Socket.SendToAsync%2A> 方法将忽略 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 属性，并将数据发送到 <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法中建立的 <xref:System.Net.EndPoint?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="42801-3548">When using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method will ignore the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property and send data to the <xref:System.Net.EndPoint?displayProperty=nameWithType> established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span>  
  
 <span data-ttu-id="42801-3549">如果使用的是无连接协议，则在调用 <xref:System.Net.Sockets.Socket.SendToAsync%2A>之前，无需使用 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法建立默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3549">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>.</span></span> <span data-ttu-id="42801-3550">仅当要调用 <xref:System.Net.Sockets.Socket.BeginSend%2A> 或 <xref:System.Net.Sockets.Socket.SendAsync%2A> 方法时，才需要执行此操作。</span><span class="sxs-lookup"><span data-stu-id="42801-3550">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.SendAsync%2A> methods.</span></span> <span data-ttu-id="42801-3551">如果在调用 <xref:System.Net.Sockets.Socket.SendToAsync%2A>之前调用了 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>或 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 方法，则 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> 属性将为该发送操作重写指定的默认远程主机。</span><span class="sxs-lookup"><span data-stu-id="42801-3551">If you do call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>, the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="42801-3552">您也不需要调用 <xref:System.Net.Sockets.Socket.Bind%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-3552">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="42801-3553">在这种情况下，基础服务提供程序将分配最适当的本地网络 IP 地址和端口号。</span><span class="sxs-lookup"><span data-stu-id="42801-3553">In this case, the underlying service provider will assign the most appropriate local network IP address and port number.</span></span> <span data-ttu-id="42801-3554">如果希望基础服务提供商选择可用端口，请使用端口号零。</span><span class="sxs-lookup"><span data-stu-id="42801-3554">Use a port number of zero if you want the underlying service provider to select a free port.</span></span> <span data-ttu-id="42801-3555">如果需要确定分配的本地网络 IP 地址和端口号，可以在 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> 事件终止后使用 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 属性，并调用关联的委托。</span><span class="sxs-lookup"><span data-stu-id="42801-3555">If you need to identify the assigned local network IP address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event is signaled and the associated delegates are called.</span></span>  
  
 <span data-ttu-id="42801-3556">如果要将数据发送到广播地址，则必须先调用 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> 方法，并将 <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> 的套接字选项设置为 true。</span><span class="sxs-lookup"><span data-stu-id="42801-3556">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option for <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> to true.</span></span> <span data-ttu-id="42801-3557">还必须确保缓冲区的大小不超过基础服务提供程序的最大数据包大小。</span><span class="sxs-lookup"><span data-stu-id="42801-3557">You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="42801-3558">如果是这样，则将不发送数据报并且 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3558">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="42801-3559">如果在 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> 属性中指定 DontRoute 标志，则将不路由要发送的数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3559">If you specify the DontRoute flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="42801-3560">对于面向消息的套接字，必须注意不要超出基础传输的最大消息大小。</span><span class="sxs-lookup"><span data-stu-id="42801-3560">For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport.</span></span> <span data-ttu-id="42801-3561">如果缓冲区的大小超过了基础服务提供程序的最大数据包大小，则不会发送数据报并且 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 将引发 <xref:System.Net.Sockets.SocketException>。</span><span class="sxs-lookup"><span data-stu-id="42801-3561">If the size of the buffer exceeds the maximum packet size of the underlying service provider, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="42801-3562">成功完成 <xref:System.Net.Sockets.Socket.SendToAsync%2A> 方法并不表示数据已成功传递。</span><span class="sxs-lookup"><span data-stu-id="42801-3562">The successful completion of a <xref:System.Net.Sockets.Socket.SendToAsync%2A> method does not indicate that the data was successfully delivered.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-3563"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不能为 null。</span><span class="sxs-lookup"><span data-stu-id="42801-3563">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-3564">已经在使用 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 参数中指定的 <paramref name="e" /> 对象执行套接字操作。</span><span class="sxs-lookup"><span data-stu-id="42801-3564">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-3565">此方法需要 Windows XP 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="42801-3565">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-3566"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-3566">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-3567">指定的协议是面向连接的，但 <see cref="T:System.Net.Sockets.Socket" /> 尚未连接。</span><span class="sxs-lookup"><span data-stu-id="42801-3567">The protocol specified is connection-oriented, but the <see cref="T:System.Net.Sockets.Socket" /> is not yet connected.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="level"><span data-ttu-id="42801-3568">要为此套接字设置的 IP 保护级别。</span><span class="sxs-lookup"><span data-stu-id="42801-3568">The IP protection level to set on this socket.</span></span></param>
        <summary><span data-ttu-id="42801-3569">设置套接字的 IP 保护级别。</span><span class="sxs-lookup"><span data-stu-id="42801-3569">Set the IP protection level on a socket.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-3570">使用 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> 方法可以限制 IPv6 或 IP 套接字侦听指定的作用域（例如，具有相同的链接本地或站点本地前缀的地址）。</span><span class="sxs-lookup"><span data-stu-id="42801-3570">The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method enables restricting an a IPv6 or IP socket to listen on a specified scope, such as addresses with the same link local or site local prefix.</span></span> <span data-ttu-id="42801-3571">此套接字选项使应用程序可以对 IPv6 或 IP 套接字设置访问限制。</span><span class="sxs-lookup"><span data-stu-id="42801-3571">This socket option enables applications to place access restrictions on IPv6 or IP sockets.</span></span> <span data-ttu-id="42801-3572">通过应用此类限制，可让在专用局域网上运行的应用程序能够通过简单的方式很好地增强自身的安全性，以便防范外部攻击。</span><span class="sxs-lookup"><span data-stu-id="42801-3572">Such restrictions enable an application running on a private LAN to simply and robustly harden itself against external attacks.</span></span> <span data-ttu-id="42801-3573">如果 `level` 参数设置为 <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>，则也可以使用此套接字选项来删除访问限制。</span><span class="sxs-lookup"><span data-stu-id="42801-3573">This socket option can also be used to remove access restrictions if the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>.</span></span> <span data-ttu-id="42801-3574">此套接字选项可以扩大或缩小侦听套接字的范围，从而使得公共用户和私人用户可以在适当情况下对站点进行无限制的访问，或者可以根据需要对同一站点进行有限制的访问。</span><span class="sxs-lookup"><span data-stu-id="42801-3574">This socket option widens or narrows the scope of a listening socket, enabling unrestricted access from public and private users when appropriate, or restricting access only to the same site, as required.</span></span>  
  
 <span data-ttu-id="42801-3575">此套接字选项具有 <xref:System.Net.Sockets.IPProtectionLevel> 枚举中指定的已定义保护级别。</span><span class="sxs-lookup"><span data-stu-id="42801-3575">This socket option has defined protection levels specified in the <xref:System.Net.Sockets.IPProtectionLevel> enumeration.</span></span>  
  
 <span data-ttu-id="42801-3576"><xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> 方法用于为 <xref:System.Net.Sockets.Socket> 实例启用或禁用网络地址遍历（NAT）。</span><span class="sxs-lookup"><span data-stu-id="42801-3576">The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method is used to enable or disable Network Address Traversal (NAT) for a <xref:System.Net.Sockets.Socket> instance.</span></span> <span data-ttu-id="42801-3577">可以使用 Teredo、6to4 或 ISATAP 隧道来提供 NAT 遍历。</span><span class="sxs-lookup"><span data-stu-id="42801-3577">NAT traversal may be provided using Teredo, 6to4, or an ISATAP tunnel.</span></span>  
  
 <span data-ttu-id="42801-3578">将 `level` 参数设置为 <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>或 <xref:System.Net.Sockets.IPProtectionLevel.Restricted>时，这会显式禁用 <xref:System.Net.Sockets.Socket> 实例的 NAT 遍历。</span><span class="sxs-lookup"><span data-stu-id="42801-3578">When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, or <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, this explicitly disables NAT traversal for a <xref:System.Net.Sockets.Socket> instance.</span></span>  
  
 <span data-ttu-id="42801-3579">将 `level` 参数设置为 <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>时，这可能会允许 NAT <xref:System.Net.Sockets.Socket> 遍历系统上的防火墙规则。</span><span class="sxs-lookup"><span data-stu-id="42801-3579">When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, this may allow NAT traversal for a <xref:System.Net.Sockets.Socket> depending on firewall rules in place on the system.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="42801-3580"><paramref name="level" /> 参数不能为 <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3580">The <paramref name="level" /> parameter cannot be <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />.</span></span> <span data-ttu-id="42801-3581">IP 保护级别不能设置为未指定。</span><span class="sxs-lookup"><span data-stu-id="42801-3581">The IP protection level cannot be set to unspecified.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-3582">套接字的 <see cref="T:System.Net.Sockets.AddressFamily" /> 必须为 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3582">The <see cref="T:System.Net.Sockets.AddressFamily" /> of the socket must be either <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</span></span></exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="42801-3583">设置 <see cref="T:System.Net.Sockets.Socket" /> 选项。</span><span class="sxs-lookup"><span data-stu-id="42801-3583">Sets a <see cref="T:System.Net.Sockets.Socket" /> option.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionValue" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="42801-3584"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-3584">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="42801-3585"><see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-3585">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="42801-3586">选项的值，表示为 <see cref="T:System.Boolean" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3586">The value of the option, represented as a <see cref="T:System.Boolean" />.</span></span></param>
        <summary><span data-ttu-id="42801-3587">将指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项设置为指定的 <see cref="T:System.Boolean" /> 值。</span><span class="sxs-lookup"><span data-stu-id="42801-3587">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified <see cref="T:System.Boolean" /> value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-3588"><xref:System.Net.Sockets.Socket> 选项确定当前 <xref:System.Net.Sockets.Socket>的行为。</span><span class="sxs-lookup"><span data-stu-id="42801-3588"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-3589">将 `optionValue` 设置为 `true` 以启用该选项，或设置为 `false` 禁用该选项。</span><span class="sxs-lookup"><span data-stu-id="42801-3589">Set `optionValue` to `true` to enable the option, or to `false` to disable the option.</span></span>  
  
 <span data-ttu-id="42801-3590"><xref:System.Net.Sockets.Socket> 选项按协议支持级别进行分组。</span><span class="sxs-lookup"><span data-stu-id="42801-3590"><xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.</span></span>  
  
 <span data-ttu-id="42801-3591">下面列出了可以使用此重载设置的各种 <xref:System.Net.Sockets.Socket> 选项。</span><span class="sxs-lookup"><span data-stu-id="42801-3591">Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload.</span></span> <span data-ttu-id="42801-3592">这些选项按适当的 <xref:System.Net.Sockets.SocketOptionLevel> 值进行分组。</span><span class="sxs-lookup"><span data-stu-id="42801-3592">These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value.</span></span> <span data-ttu-id="42801-3593">如果要设置这些选项中的任何一个，请确保对 `optionLevel` 参数使用适当的 <xref:System.Net.Sockets.SocketOptionLevel> 值。</span><span class="sxs-lookup"><span data-stu-id="42801-3593">If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value for the `optionLevel` parameter.</span></span> <span data-ttu-id="42801-3594">您选择设置的选项必须在 `optionName` 参数中指定。</span><span class="sxs-lookup"><span data-stu-id="42801-3594">The option you choose to set must be specified in the `optionName` parameter.</span></span> <span data-ttu-id="42801-3595">如果要获取所列出的任何选项的当前值，请使用 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-3595">If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
 <span data-ttu-id="42801-3596">可以使用此重载设置 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> 选项。</span><span class="sxs-lookup"><span data-stu-id="42801-3596"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <span data-ttu-id="42801-3597">可以使用此重载设置 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> 选项。</span><span class="sxs-lookup"><span data-stu-id="42801-3597"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <span data-ttu-id="42801-3598">可以使用此重载设置 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> 选项。</span><span class="sxs-lookup"><span data-stu-id="42801-3598"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <span data-ttu-id="42801-3599">可以使用此重载设置 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> 选项。</span><span class="sxs-lookup"><span data-stu-id="42801-3599"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <span data-ttu-id="42801-3600">有关这些选项的详细信息，请参阅 <xref:System.Net.Sockets.SocketOptionName> 枚举。</span><span class="sxs-lookup"><span data-stu-id="42801-3600">For more information on these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3601">如果收到 <xref:System.Net.Sockets.SocketException> 异常，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-3601">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-3602">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-3602">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-3603">下面的代码示例打开套接字，并启用 `DontLinger` 和 `OutOfBandInline` 套接字选项。</span><span class="sxs-lookup"><span data-stu-id="42801-3603">The following code example opens a socket and enables the `DontLinger` and the `OutOfBandInline` socket options.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-3604"><see cref="T:System.Net.Sockets.Socket" /> 对象已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-3604">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-3605">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-3605">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="42801-3606"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-3606">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="42801-3607"><see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-3607">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="42801-3608"><see cref="T:System.Byte" /> 类型的数组，表示选项值。</span><span class="sxs-lookup"><span data-stu-id="42801-3608">An array of type <see cref="T:System.Byte" /> that represents the value of the option.</span></span></param>
        <summary><span data-ttu-id="42801-3609">将指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项设置为指定的值，表示为字节数组。</span><span class="sxs-lookup"><span data-stu-id="42801-3609">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as a byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-3610"><xref:System.Net.Sockets.Socket> 选项确定当前 <xref:System.Net.Sockets.Socket>的行为。</span><span class="sxs-lookup"><span data-stu-id="42801-3610"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-3611">使用此重载设置那些需要字节数组作为选项值 <xref:System.Net.Sockets.Socket> 选项。</span><span class="sxs-lookup"><span data-stu-id="42801-3611">Use this overload to set those <xref:System.Net.Sockets.Socket> options that require a byte array as an option value.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3612">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-3612">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-3613">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-3613">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3614">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-3614">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-3615">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-3615">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-3616">下面的代码示例将 <xref:System.Net.Sockets.LingerOption> 和 <xref:System.Net.Sockets.Socket.Send%2A> 超时值。</span><span class="sxs-lookup"><span data-stu-id="42801-3616">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-3617">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-3617">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-3618"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-3618">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionValue" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="42801-3619"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-3619">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="42801-3620"><see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-3620">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="42801-3621">该选项的值。</span><span class="sxs-lookup"><span data-stu-id="42801-3621">A value of the option.</span></span></param>
        <summary><span data-ttu-id="42801-3622">将指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项设置为指定的整数值。</span><span class="sxs-lookup"><span data-stu-id="42801-3622">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified integer value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-3623"><xref:System.Net.Sockets.Socket> 选项确定当前 <xref:System.Net.Sockets.Socket>的行为。</span><span class="sxs-lookup"><span data-stu-id="42801-3623"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-3624">对于具有 <xref:System.Boolean> 数据类型的选项，请指定一个非零值以启用该选项，并指定零值以禁用该选项。</span><span class="sxs-lookup"><span data-stu-id="42801-3624">For an option with a <xref:System.Boolean> data type, specify a nonzero value to enable the option, and a zero value to disable the option.</span></span> <span data-ttu-id="42801-3625">对于整数数据类型的选项，请指定相应的值。</span><span class="sxs-lookup"><span data-stu-id="42801-3625">For an option with an integer data type, specify the appropriate value.</span></span> <span data-ttu-id="42801-3626"><xref:System.Net.Sockets.Socket> 选项按协议支持级别进行分组。</span><span class="sxs-lookup"><span data-stu-id="42801-3626"><xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.</span></span>  
  
 <span data-ttu-id="42801-3627">下面列出了可以使用此重载设置的各种 <xref:System.Net.Sockets.Socket> 选项。</span><span class="sxs-lookup"><span data-stu-id="42801-3627">Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload.</span></span> <span data-ttu-id="42801-3628">这些选项按适当的 <xref:System.Net.Sockets.SocketOptionLevel>分组。</span><span class="sxs-lookup"><span data-stu-id="42801-3628">These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel>.</span></span> <span data-ttu-id="42801-3629">如果要设置这些选项中的任何一个，请确保对 `optionLevel` 参数使用适当的 <xref:System.Net.Sockets.SocketOptionLevel>。</span><span class="sxs-lookup"><span data-stu-id="42801-3629">If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> for the `optionLevel` parameter.</span></span> <span data-ttu-id="42801-3630">您选择设置的选项必须在 `optionName` 参数中指定。</span><span class="sxs-lookup"><span data-stu-id="42801-3630">The option you choose to set must be specified in the `optionName` parameter.</span></span> <span data-ttu-id="42801-3631">如果要获取所列出的任何选项的当前值，请使用 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-3631">If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
 <span data-ttu-id="42801-3632">可以使用此重载设置 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> 选项。</span><span class="sxs-lookup"><span data-stu-id="42801-3632"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <span data-ttu-id="42801-3633">可以使用此重载设置 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> 选项。</span><span class="sxs-lookup"><span data-stu-id="42801-3633"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <span data-ttu-id="42801-3634">可以使用此重载设置 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> 选项。</span><span class="sxs-lookup"><span data-stu-id="42801-3634"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <span data-ttu-id="42801-3635">可以使用此重载设置 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> 选项。</span><span class="sxs-lookup"><span data-stu-id="42801-3635"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <span data-ttu-id="42801-3636">可以使用此重载设置 <xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> 选项。</span><span class="sxs-lookup"><span data-stu-id="42801-3636"><xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 <span data-ttu-id="42801-3637">有关这些选项的详细信息，请参阅 <xref:System.Net.Sockets.SocketOptionName> 枚举。</span><span class="sxs-lookup"><span data-stu-id="42801-3637">For more information about these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3638">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-3638">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-3639">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-3639">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3640">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-3640">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-3641">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-3641">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-3642">下面的代码示例将 <xref:System.Net.Sockets.LingerOption> 和 <xref:System.Net.Sockets.Socket.Send%2A> 超时值。</span><span class="sxs-lookup"><span data-stu-id="42801-3642">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-3643">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-3643">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-3644"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-3644">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="optionValue" Type="System.Object" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="42801-3645"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-3645">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="42801-3646"><see cref="T:System.Net.Sockets.SocketOptionName" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-3646">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="42801-3647">一个 <see cref="T:System.Net.Sockets.LingerOption" /> 或 <see cref="T:System.Net.Sockets.MulticastOption" />，它包含该选项的值。</span><span class="sxs-lookup"><span data-stu-id="42801-3647">A <see cref="T:System.Net.Sockets.LingerOption" /> or <see cref="T:System.Net.Sockets.MulticastOption" /> that contains the value of the option.</span></span></param>
        <summary><span data-ttu-id="42801-3648">将指定的 <see cref="T:System.Net.Sockets.Socket" /> 选项设置为指定值，表示为对象。</span><span class="sxs-lookup"><span data-stu-id="42801-3648">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-3649"><xref:System.Net.Sockets.Socket> 选项确定当前 <xref:System.Net.Sockets.Socket>的行为。</span><span class="sxs-lookup"><span data-stu-id="42801-3649"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-3650">使用此重载设置 <xref:System.Net.Sockets.SocketOptionName.Linger>、<xref:System.Net.Sockets.SocketOptionName.AddMembership>和 <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> 选项。</span><span class="sxs-lookup"><span data-stu-id="42801-3650">Use this overload to set the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options.</span></span> <span data-ttu-id="42801-3651">对于 <xref:System.Net.Sockets.SocketOptionName.Linger> 选项，请对 `optionLevel` 参数使用 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-3651">For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter.</span></span> <span data-ttu-id="42801-3652">对于 <xref:System.Net.Sockets.SocketOptionName.AddMembership> 和 <xref:System.Net.Sockets.SocketOptionName.DropMembership>，请使用 <xref:System.Net.Sockets.SocketOptionLevel.IP>。</span><span class="sxs-lookup"><span data-stu-id="42801-3652">For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span></span> <span data-ttu-id="42801-3653">如果要获取上面列出的任何选项的当前值，请使用 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-3653">If you want to get the current value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3654">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-3654">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-3655">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-3655">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-3656">下面的代码示例设置 <xref:System.Net.Sockets.LingerOption> 和 <xref:System.Net.Sockets.Socket.Send%2A> 超时值。</span><span class="sxs-lookup"><span data-stu-id="42801-3656">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="42801-3657"><paramref name="optionValue" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3657"><paramref name="optionValue" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-3658">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-3658">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-3659"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-3659">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how"><span data-ttu-id="42801-3660"><see cref="T:System.Net.Sockets.SocketShutdown" /> 值之一，它指定不再允许执行的操作。</span><span class="sxs-lookup"><span data-stu-id="42801-3660">One of the <see cref="T:System.Net.Sockets.SocketShutdown" /> values that specifies the operation that will no longer be allowed.</span></span></param>
        <summary><span data-ttu-id="42801-3661">禁用某 <see cref="T:System.Net.Sockets.Socket" /> 上的发送和接收。</span><span class="sxs-lookup"><span data-stu-id="42801-3661">Disables sends and receives on a <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-3662">使用面向连接的 <xref:System.Net.Sockets.Socket>时，请在关闭 <xref:System.Net.Sockets.Socket>之前始终调用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="42801-3662">When using a connection-oriented <xref:System.Net.Sockets.Socket>, always call the <xref:System.Net.Sockets.Socket.Shutdown%2A> method before closing the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-3663">这可确保所有数据在连接的套接字关闭之前都已发送和接收。</span><span class="sxs-lookup"><span data-stu-id="42801-3663">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="42801-3664">调用 <xref:System.Net.Sockets.Socket.Close%2A> 方法，释放与 <xref:System.Net.Sockets.Socket>关联的所有托管资源和非托管资源。</span><span class="sxs-lookup"><span data-stu-id="42801-3664">Call the <xref:System.Net.Sockets.Socket.Close%2A> method to free all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-3665">请勿尝试在关闭后重用 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-3665">Do not attempt to reuse the <xref:System.Net.Sockets.Socket> after closing.</span></span>  
  
 <span data-ttu-id="42801-3666">下表显示了对 `how` 参数有效的 <xref:System.Net.Sockets.SocketShutdown> 枚举值。</span><span class="sxs-lookup"><span data-stu-id="42801-3666">The following table shows the <xref:System.Net.Sockets.SocketShutdown> enumeration values that are valid for the `how` parameter.</span></span>  
  
|<span data-ttu-id="42801-3667">值</span><span class="sxs-lookup"><span data-stu-id="42801-3667">Value</span></span>|<span data-ttu-id="42801-3668">说明</span><span class="sxs-lookup"><span data-stu-id="42801-3668">Description</span></span>|  
|-----------|-----------------|  
|<span data-ttu-id="42801-3669">发送</span><span class="sxs-lookup"><span data-stu-id="42801-3669">Send</span></span>|<span data-ttu-id="42801-3670">禁用此 <xref:System.Net.Sockets.Socket>上的发送。</span><span class="sxs-lookup"><span data-stu-id="42801-3670">Disable sending on this <xref:System.Net.Sockets.Socket>.</span></span>|  
|<span data-ttu-id="42801-3671">接收</span><span class="sxs-lookup"><span data-stu-id="42801-3671">Receive</span></span>|<span data-ttu-id="42801-3672">禁用此 <xref:System.Net.Sockets.Socket>上的接收。</span><span class="sxs-lookup"><span data-stu-id="42801-3672">Disable receiving on this <xref:System.Net.Sockets.Socket>.</span></span>|  
|<span data-ttu-id="42801-3673">两者同时</span><span class="sxs-lookup"><span data-stu-id="42801-3673">Both</span></span>|<span data-ttu-id="42801-3674">在此 <xref:System.Net.Sockets.Socket>上禁用发送和接收。</span><span class="sxs-lookup"><span data-stu-id="42801-3674">Disable both sending and receiving on this <xref:System.Net.Sockets.Socket>.</span></span>|  
  
 <span data-ttu-id="42801-3675">将 `how` 设置为 <xref:System.Net.Sockets.SocketShutdown.Send> 指定不允许对 <xref:System.Net.Sockets.Socket.Send%2A> 的后续调用。</span><span class="sxs-lookup"><span data-stu-id="42801-3675">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Send> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Send%2A> are not allowed.</span></span> <span data-ttu-id="42801-3676">如果使用的是无连接 <xref:System.Net.Sockets.Socket>，则指定 <xref:System.Net.Sockets.SocketShutdown.Send> 将不起作用。</span><span class="sxs-lookup"><span data-stu-id="42801-3676">If you are using a connectionless <xref:System.Net.Sockets.Socket>, specifying <xref:System.Net.Sockets.SocketShutdown.Send> will have no effect.</span></span>  
  
 <span data-ttu-id="42801-3677">将 `how` 设置为 <xref:System.Net.Sockets.SocketShutdown.Receive> 指定不允许对 <xref:System.Net.Sockets.Socket.Receive%2A> 的后续调用。</span><span class="sxs-lookup"><span data-stu-id="42801-3677">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Receive> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Receive%2A> are not allowed.</span></span> <span data-ttu-id="42801-3678">这在较低的协议层上不起作用。</span><span class="sxs-lookup"><span data-stu-id="42801-3678">This has no effect on lower protocol layers.</span></span> <span data-ttu-id="42801-3679">如果使用面向连接的协议，则在调用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 后，如果存在以下任一条件，则将终止连接：</span><span class="sxs-lookup"><span data-stu-id="42801-3679">If you are using a connection-oriented protocol, the connection is terminated if either of the following conditions exist after a call to <xref:System.Net.Sockets.Socket.Shutdown%2A> :</span></span>  
  
-   <span data-ttu-id="42801-3680">数据位于传入网络缓冲区中等待接收。</span><span class="sxs-lookup"><span data-stu-id="42801-3680">Data is in the incoming network buffer waiting to be received.</span></span>  
  
-   <span data-ttu-id="42801-3681">已到达更多数据。</span><span class="sxs-lookup"><span data-stu-id="42801-3681">More data has arrived.</span></span>  
  
 <span data-ttu-id="42801-3682">如果使用的是无连接协议，则接受并排队数据报。</span><span class="sxs-lookup"><span data-stu-id="42801-3682">If you are using a connectionless protocol, datagrams are accepted and queued.</span></span> <span data-ttu-id="42801-3683">但是，如果没有可用于附加传入数据报的缓冲区空间，则将丢弃这些数据，并且不会将错误返回给发件人。</span><span class="sxs-lookup"><span data-stu-id="42801-3683">However, if no buffer space is available for additional incoming datagrams, they will be discarded and no error will be returned to the sender.</span></span> <span data-ttu-id="42801-3684">不建议对无连接 <xref:System.Net.Sockets.Socket> 使用 <xref:System.Net.Sockets.Socket.Shutdown%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-3684">Using <xref:System.Net.Sockets.Socket.Shutdown%2A> on a connectionless <xref:System.Net.Sockets.Socket> is not recommended.</span></span>  
  
 <span data-ttu-id="42801-3685">将 `how` 设置为 <xref:System.Net.Sockets.SocketShutdown.Both> 将按如上所述禁用发送和接收。</span><span class="sxs-lookup"><span data-stu-id="42801-3685">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Both> disables both sends and receives as described above.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3686">如果在调用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法时接收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性来获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-3686">If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-3687">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-3687">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="42801-3688">当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="42801-3688">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="42801-3689">有关详细信息，请参阅[.NET Framework 中的网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-3689">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-3690">下面的代码示例使用 <xref:System.Net.Sockets.Socket.Shutdown%2A> 禁用 <xref:System.Net.Sockets.Socket>。</span><span class="sxs-lookup"><span data-stu-id="42801-3690">The following code example uses <xref:System.Net.Sockets.Socket.Shutdown%2A> to disable the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-3691">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-3691">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-3692"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-3692">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-3693">获取 <see cref="T:System.Net.Sockets.Socket" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="42801-3693">Gets the type of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="42801-3694"><see cref="T:System.Net.Sockets.SocketType" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="42801-3694">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-3695"><xref:System.Net.Sockets.Socket.SocketType%2A> 为只读，并在创建 <xref:System.Net.Sockets.Socket> 时设置。</span><span class="sxs-lookup"><span data-stu-id="42801-3695"><xref:System.Net.Sockets.Socket.SocketType%2A> is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-3696">下面的代码示例显示控制台 <xref:System.Net.Sockets.AddressFamily>、<xref:System.Net.Sockets.SocketType>和 <xref:System.Net.Sockets.ProtocolType>。</span><span class="sxs-lookup"><span data-stu-id="42801-3696">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-3697">获取一个值，该值指示在当前主机上 IPv4 支持是否可用并且已启用。</span><span class="sxs-lookup"><span data-stu-id="42801-3697">Gets a value indicating whether IPv4 support is available and enabled on the current host.</span></span></summary>
        <value><span data-ttu-id="42801-3698">如果当前主机支持 IPv4 协议，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3698"><see langword="true" /> if the current host supports the IPv4 protocol; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-3699">操作系统可能支持 IPv4 和 IPv6 协议。</span><span class="sxs-lookup"><span data-stu-id="42801-3699">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-3700">获取一个值，该值指示 Framework 对某些已过时的 <see cref="T:System.Net.Dns" /> 成员是否支持 IPv6。</span><span class="sxs-lookup"><span data-stu-id="42801-3700">Gets a value that indicates whether the Framework supports IPv6 for certain obsolete <see cref="T:System.Net.Dns" /> members.</span></span></summary>
        <value><span data-ttu-id="42801-3701">如果 Framework 对某些已过时的 <see langword="true" /> 方法支持 IPv6，则为 <see cref="T:System.Net.Dns" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3701"><see langword="true" /> if the Framework supports IPv6 for certain obsolete <see cref="T:System.Net.Dns" /> methods; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-3702">操作系统可能支持 IPv4 和 IPv6 协议。</span><span class="sxs-lookup"><span data-stu-id="42801-3702">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="42801-3703">释放 <see cref="T:System.Net.Sockets.Socket" /> 使用的所有资源。</span><span class="sxs-lookup"><span data-stu-id="42801-3703">Releases all resources used by the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="42801-3704">使用完 <xref:System.Net.Sockets.Socket>后，请调用 IDisposable。</span><span class="sxs-lookup"><span data-stu-id="42801-3704">Call IDisposable.Dispose when you are finished using the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-3705">IDisposable 方法将 <xref:System.Net.Sockets.Socket> 保持为不可用状态。</span><span class="sxs-lookup"><span data-stu-id="42801-3705">The IDisposable.Dispose method leaves the <xref:System.Net.Sockets.Socket> in an unusable state.</span></span> <span data-ttu-id="42801-3706">调用 IDisposable 之后，必须释放对 <xref:System.Net.Sockets.Socket> 的所有引用，以便垃圾回收器可以回收 <xref:System.Net.Sockets.Socket> 占用的内存。</span><span class="sxs-lookup"><span data-stu-id="42801-3706">After calling IDisposable.Dispose, you must release all references to the <xref:System.Net.Sockets.Socket> so the garbage collector can reclaim the memory that the <xref:System.Net.Sockets.Socket> was occupying.</span></span> <span data-ttu-id="42801-3707">有关详细信息，请参阅[清理非托管资源](~/docs/standard/garbage-collection/unmanaged.md)和[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。</span><span class="sxs-lookup"><span data-stu-id="42801-3707">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>

> [!NOTE] 
> <span data-ttu-id="42801-3708">在释放对 <xref:System.Net.Sockets.Socket>的最后一个引用之前，请始终调用 IDisposable。</span><span class="sxs-lookup"><span data-stu-id="42801-3708">Always call IDisposable.Dispose before you release your last reference to the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="42801-3709">否则，在垃圾回收器调用 <xref:System.Net.Sockets.Socket> 对象的 `Finalize` 方法之前，该对象正在使用的资源不会被释放。</span><span class="sxs-lookup"><span data-stu-id="42801-3709">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Net.Sockets.Socket> object's `Finalize` method.</span></span>

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-3710">获取或设置一个值，指定 <see cref="T:System.Net.Sockets.Socket" /> 发送的 Internet 协议 (IP) 数据包的生存时间 (TTL) 值。</span><span class="sxs-lookup"><span data-stu-id="42801-3710">Gets or sets a value that specifies the Time To Live (TTL) value of Internet Protocol (IP) packets sent by the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="42801-3711">TTL 值。</span><span class="sxs-lookup"><span data-stu-id="42801-3711">The TTL value.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-3712">TTL 值表示在路由器丢弃数据包并且 Internet 控制消息协议（ICMP） "超过 TTL" 错误消息返回给发件人之前，数据包可以遍历的路由器的最大数目。</span><span class="sxs-lookup"><span data-stu-id="42801-3712">The TTL value indicates the maximum number of routers the packet can traverse before the router discards the packet and an Internet Control Message Protocol (ICMP) "TTL exceeded" error message is returned to the sender.</span></span>  
  
 <span data-ttu-id="42801-3713">TTL 值可以设置为0到255之间的值。</span><span class="sxs-lookup"><span data-stu-id="42801-3713">The TTL value may be set to a value from 0 to 255.</span></span> <span data-ttu-id="42801-3714">如果未设置此属性，则套接字的默认 TTL 值为32。</span><span class="sxs-lookup"><span data-stu-id="42801-3714">When this property is not set, the default TTL value for a socket is 32.</span></span>  
  
 <span data-ttu-id="42801-3715">如果使用套接字建立成功的连接，则 TCP/IP 堆栈将忽略对传输控制协议（TCP）套接字设置此属性。</span><span class="sxs-lookup"><span data-stu-id="42801-3715">Setting this property on a Transmission Control Protocol (TCP) socket is ignored by the TCP/IP stack if a successful connection has been established using the socket.</span></span>  
  
 <span data-ttu-id="42801-3716">如果收到 <xref:System.Net.Sockets.SocketException>，请使用 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> 属性获取特定的错误代码。</span><span class="sxs-lookup"><span data-stu-id="42801-3716">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="42801-3717">获取此代码后，请参阅[Windows 套接字版本 2 API 错误代码](/windows/desktop/winsock/windows-sockets-error-codes-2)文档，以获取有关错误的详细说明。</span><span class="sxs-lookup"><span data-stu-id="42801-3717">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="42801-3718">下面的代码示例演示如何使用 <xref:System.Net.Sockets.Socket.Ttl%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="42801-3718">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.Ttl%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="42801-3719">TTL 值不能设置为负数。</span><span class="sxs-lookup"><span data-stu-id="42801-3719">The TTL value can't be set to a negative number.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="42801-3720">只有对于在 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 族中的套接字，才可以设置此属性。</span><span class="sxs-lookup"><span data-stu-id="42801-3720">This property can be set only for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="42801-3721">尝试访问套接字时出错。</span><span class="sxs-lookup"><span data-stu-id="42801-3721">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="42801-3722">在尝试将 TTL 设置为大于 255 的值时，也将返回此错误。</span><span class="sxs-lookup"><span data-stu-id="42801-3722">This error is also returned when an attempt was made to set TTL to a value higher than 255.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="42801-3723"><see cref="T:System.Net.Sockets.Socket" /> 已关闭。</span><span class="sxs-lookup"><span data-stu-id="42801-3723">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="42801-3724">指定套接字是否应仅使用重叠 I/O 模式。</span><span class="sxs-lookup"><span data-stu-id="42801-3724">Specifies whether the socket should only use Overlapped I/O mode.</span></span></summary>
        <value><span data-ttu-id="42801-3725">如果 <see langword="true" /> 仅使用重叠 I/O，则为 <see cref="T:System.Net.Sockets.Socket" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3725"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> uses only overlapped I/O; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="42801-3726">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="42801-3726">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="42801-3727">将此属性设置为要对其调用 <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>的 <xref:System.Net.Sockets.Socket> 的 `true`。</span><span class="sxs-lookup"><span data-stu-id="42801-3727">Set this property to `true` for a <xref:System.Net.Sockets.Socket> you intend to call <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span></span> <span data-ttu-id="42801-3728">否则，框架可能会为套接字分配完成端口，这将禁止使用 <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>。</span><span class="sxs-lookup"><span data-stu-id="42801-3728">Otherwise, the Framework may assign a completion port to the socket, which would prohibit the use of <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="42801-3729">套接字已绑定到完成端口。</span><span class="sxs-lookup"><span data-stu-id="42801-3729">The socket has been bound to a completion port.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
