<Type Name="CodeDomProvider" FullName="System.CodeDom.Compiler.CodeDomProvider">
  <Metadata><Meta Name="ms.openlocfilehash" Value="71835372e0553700f798b49f0bd01813aac74155" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75153546" /></Metadata><TypeSignature Language="C#" Value="public abstract class CodeDomProvider : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CodeDomProvider extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.CodeDom.Compiler.CodeDomProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeDomProvider&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeDomProvider abstract : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type CodeDomProvider = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.CodeDom</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="18a6d-101">为 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现提供基类。</span><span class="sxs-lookup"><span data-stu-id="18a6d-101">Provides a base class for <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implementations.</span></span> <span data-ttu-id="18a6d-102">此类是抽象类。</span><span class="sxs-lookup"><span data-stu-id="18a6d-102">This class is abstract.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18a6d-103"><xref:System.CodeDom.Compiler.CodeDomProvider> 可用于创建和检索代码生成器和代码编译器的实例。</span><span class="sxs-lookup"><span data-stu-id="18a6d-103">A <xref:System.CodeDom.Compiler.CodeDomProvider> can be used to create and retrieve instances of code generators and code compilers.</span></span> <span data-ttu-id="18a6d-104">代码生成器可用于以特定的语言生成代码，而代码编译器可用于将代码编译为程序集。</span><span class="sxs-lookup"><span data-stu-id="18a6d-104">Code generators can be used to generate code in a particular language, and code compilers can be used to compile code into assemblies.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="18a6d-105">在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]中，代码生成器和代码编译器中提供的方法可直接从代码提供程序获取。</span><span class="sxs-lookup"><span data-stu-id="18a6d-105">In the [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], the methods made available in the code generator and code compiler are available directly from the code provider.</span></span> <span data-ttu-id="18a6d-106">不需要调用 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> 或 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> 来访问这些方法，这些方法被标记为过时。</span><span class="sxs-lookup"><span data-stu-id="18a6d-106">You do not need to call <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> or <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> to access the methods, and those methods are marked as obsolete.</span></span> <span data-ttu-id="18a6d-107">这适用于预先存在的以及新的代码提供程序实现。</span><span class="sxs-lookup"><span data-stu-id="18a6d-107">This applies to preexisting as well as new code provider implementations.</span></span>  
  
 <span data-ttu-id="18a6d-108"><xref:System.CodeDom.Compiler.CodeDomProvider> 实现通常提供代码生成和/或代码编译接口，用于为单一编程语言生成代码和管理编译。</span><span class="sxs-lookup"><span data-stu-id="18a6d-108">A <xref:System.CodeDom.Compiler.CodeDomProvider> implementation typically provides code generation and/or code compilation interfaces for generating code and managing compilation for a single programming language.</span></span> <span data-ttu-id="18a6d-109">Windows SDK 附带 <xref:System.CodeDom.Compiler.CodeDomProvider> 实现支持多种语言。</span><span class="sxs-lookup"><span data-stu-id="18a6d-109">Several languages are supported by <xref:System.CodeDom.Compiler.CodeDomProvider> implementations that ship with the Windows SDK.</span></span> <span data-ttu-id="18a6d-110">这些语言包括 C#、Visual Basic、C++ 和 JScript。</span><span class="sxs-lookup"><span data-stu-id="18a6d-110">These languages include C#, Visual Basic, C++, and JScript.</span></span> <span data-ttu-id="18a6d-111">开发人员或编译器供应商可以实现 <xref:System.CodeDom.Compiler.ICodeGenerator> 和 <xref:System.CodeDom.Compiler.ICodeCompiler> 接口，并提供将 CodeDOM 支持扩展到其他编程语言的 <xref:System.CodeDom.Compiler.CodeDomProvider>。</span><span class="sxs-lookup"><span data-stu-id="18a6d-111">Developers or compiler vendors can implement the <xref:System.CodeDom.Compiler.ICodeGenerator> and <xref:System.CodeDom.Compiler.ICodeCompiler> interfaces and provide a <xref:System.CodeDom.Compiler.CodeDomProvider> that extends CodeDOM support to other programming languages.</span></span>  
  
 <span data-ttu-id="18a6d-112">计算机配置文件（Machine.config）中的[&lt;system.object&gt; 元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)提供了一种机制，使开发人员和编译器供应商可以为其他 <xref:System.CodeDom.Compiler.CodeDomProvider> 实现添加配置设置。</span><span class="sxs-lookup"><span data-stu-id="18a6d-112">The [&lt;system.codedom&gt; Element](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) in the machine configuration file (Machine.config) provides a mechanism for developers and compiler vendors to add configuration settings for additional <xref:System.CodeDom.Compiler.CodeDomProvider> implementations.</span></span>  
  
 <span data-ttu-id="18a6d-113"><xref:System.CodeDom.Compiler.CodeDomProvider> 类提供静态方法，用于发现和枚举计算机上的 <xref:System.CodeDom.Compiler.CodeDomProvider> 实现。</span><span class="sxs-lookup"><span data-stu-id="18a6d-113">The <xref:System.CodeDom.Compiler.CodeDomProvider> class provides static methods to discover and enumerate the <xref:System.CodeDom.Compiler.CodeDomProvider> implementations on a computer.</span></span> <span data-ttu-id="18a6d-114"><xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> 方法返回计算机上所有 <xref:System.CodeDom.Compiler.CodeDomProvider> 实现的设置。</span><span class="sxs-lookup"><span data-stu-id="18a6d-114">The <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> method returns the settings for all <xref:System.CodeDom.Compiler.CodeDomProvider> implementations on a computer.</span></span> <span data-ttu-id="18a6d-115"><xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> 方法根据编程语言名称返回特定 <xref:System.CodeDom.Compiler.CodeDomProvider> 实现的设置。</span><span class="sxs-lookup"><span data-stu-id="18a6d-115">The <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> method returns the settings for a specific <xref:System.CodeDom.Compiler.CodeDomProvider> implementation, based on the programming language name.</span></span> <span data-ttu-id="18a6d-116"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> 方法返回特定语言的 <xref:System.CodeDom.Compiler.CodeDomProvider> 实现的实例。</span><span class="sxs-lookup"><span data-stu-id="18a6d-116">The <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> method returns an instance of a <xref:System.CodeDom.Compiler.CodeDomProvider> implementation for a specific language.</span></span>  
  
 <span data-ttu-id="18a6d-117">有关配置文件中的语言提供程序设置的更多详细信息，请参阅[编译器和语言提供程序设置架构](~/docs/framework/configure-apps/file-schema/compiler/index.md)。</span><span class="sxs-lookup"><span data-stu-id="18a6d-117">For more details on language provider settings in the configuration file, see [Compiler and Language Provider Settings Schema](~/docs/framework/configure-apps/file-schema/compiler/index.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="18a6d-118">此类在类级别建立链接要求和继承要求。</span><span class="sxs-lookup"><span data-stu-id="18a6d-118">This class makes a link demand and an inheritance demand at the class level.</span></span> <span data-ttu-id="18a6d-119">如果直接调用方或派生类不具有 "完全信任" 权限，则会引发 <xref:System.Security.SecurityException>。</span><span class="sxs-lookup"><span data-stu-id="18a6d-119">A <xref:System.Security.SecurityException> is thrown if either the immediate caller or the derived class does not have full trust permission.</span></span> <span data-ttu-id="18a6d-120">有关安全要求的详细信息，请参阅[链接要求](~/docs/framework/misc/link-demands.md)和[继承要求](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/x4yx82e6(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="18a6d-120">For details about security demands, see [Link Demands](~/docs/framework/misc/link-demands.md) and [Inheritance Demands](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/x4yx82e6(v=vs.100)).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18a6d-121">下面的示例程序可以基于使用 <xref:System.Console> 类打印 "Hello World" 的程序的 CodeDOM 模型生成和编译源代码。</span><span class="sxs-lookup"><span data-stu-id="18a6d-121">The following example program can generate and compile source code based on a CodeDOM model of a program that prints "Hello World" using the <xref:System.Console> class.</span></span> <span data-ttu-id="18a6d-122">提供 Windows 窗体用户界面。</span><span class="sxs-lookup"><span data-stu-id="18a6d-122">A Windows Forms user interface is provided.</span></span> <span data-ttu-id="18a6d-123">用户可以从以下几个选项中选择目标编程语言C#：、Visual Basic 和 JScript。</span><span class="sxs-lookup"><span data-stu-id="18a6d-123">The user can select the target programming language from several selections: C#, Visual Basic, and JScript.</span></span>  
  
 [!code-cpp[CodeDomExample#1](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#1)]
 [!code-csharp[CodeDomExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#1)]
 [!code-vb[CodeDomExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="18a6d-124">完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="18a6d-124">for full trust for the immediate caller.</span></span> <span data-ttu-id="18a6d-125">此类不能由部分信任的代码使用。</span><span class="sxs-lookup"><span data-stu-id="18a6d-125">This class cannot be used by partially trusted code.</span></span></permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="18a6d-126">完全信任继承者。</span><span class="sxs-lookup"><span data-stu-id="18a6d-126">for full trust for inheritors.</span></span> <span data-ttu-id="18a6d-127">此类不能由部分信任的代码继承。</span><span class="sxs-lookup"><span data-stu-id="18a6d-127">This class cannot be inherited by partially trusted code.</span></span></permission>
    <block subset="none" type="overrides"><para><span data-ttu-id="18a6d-128">在 .NET Framework 版本1.0 和1.1 中，代码提供程序包含 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />、<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />、<see cref="T:System.CodeDom.Compiler.ICodeParser" />和 <see cref="T:System.CodeDom.Compiler.ICodeCompiler" />的实现。</span><span class="sxs-lookup"><span data-stu-id="18a6d-128">In the .NET Framework versions 1.0 and 1.1, code providers consist of implementations of <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />, <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />, <see cref="T:System.CodeDom.Compiler.ICodeParser" />, and <see cref="T:System.CodeDom.Compiler.ICodeCompiler" />.</span></span> <span data-ttu-id="18a6d-129">在 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]中，<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />、<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> 方法已过时，<see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> 和 <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> 的方法可在 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 类中直接使用。</span><span class="sxs-lookup"><span data-stu-id="18a6d-129">In the [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />, <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />, and <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> methods are obsolete, and the methods of <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> and <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> are directly available in the <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> class.</span></span> <span data-ttu-id="18a6d-130">应在代码提供程序实现中重写这些方法，而不调用基方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-130">You should override those methods in your code provider implementation and not call the base methods.</span></span></para></block>
    <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
    <altmember cref="T:Microsoft.CSharp.CSharpCodeProvider" />
    <altmember cref="T:Microsoft.VisualBasic.VBCodeProvider" />
    <altmember cref="T:Microsoft.JScript.JScriptCodeProvider" />
    <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md"><span data-ttu-id="18a6d-131">编译器和语言提供程序设置架构</span><span class="sxs-lookup"><span data-stu-id="18a6d-131">Compiler and Language Provider Settings Schema</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeDomProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeDomProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="18a6d-132">初始化 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="18a6d-132">Initializes a new instance of the <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="18a6d-133">完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="18a6d-133">for full trust for the immediate caller.</span></span> <span data-ttu-id="18a6d-134">此类不能由部分信任的代码使用。</span><span class="sxs-lookup"><span data-stu-id="18a6d-134">This class cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromDom">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom (System.CodeDom.Compiler.CompilerParameters options, params System.CodeDom.CodeCompileUnit[] compilationUnits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom(class System.CodeDom.Compiler.CompilerParameters options, class System.CodeDom.CodeCompileUnit[] compilationUnits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromDom(System.CodeDom.Compiler.CompilerParameters,System.CodeDom.CodeCompileUnit[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromDom (options As CompilerParameters, ParamArray compilationUnits As CodeCompileUnit()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromDom(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::CodeDom::CodeCompileUnit ^&gt; ^ compilationUnits);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromDom : System.CodeDom.Compiler.CompilerParameters * System.CodeDom.CodeCompileUnit[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromDom : System.CodeDom.Compiler.CompilerParameters * System.CodeDom.CodeCompileUnit[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromDom (options, compilationUnits)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="compilationUnits" Type="System.CodeDom.CodeCompileUnit[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options"><span data-ttu-id="18a6d-135">一个 <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> 对象，它指示编译的设置。</span><span class="sxs-lookup"><span data-stu-id="18a6d-135">A <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> object that indicates the settings for the compilation.</span></span></param>
        <param name="compilationUnits"><span data-ttu-id="18a6d-136"><see cref="T:System.CodeDom.CodeCompileUnit" /> 类型数组，指示要编译的代码。</span><span class="sxs-lookup"><span data-stu-id="18a6d-136">An array of type <see cref="T:System.CodeDom.CodeCompileUnit" /> that indicates the code to compile.</span></span></param>
        <summary><span data-ttu-id="18a6d-137">基于包含在 <see cref="N:System.CodeDom" /> 对象的指定数组中的 <see cref="T:System.CodeDom.CodeCompileUnit" /> 树，使用指定的编译器设置编译程序集。</span><span class="sxs-lookup"><span data-stu-id="18a6d-137">Compiles an assembly based on the <see cref="N:System.CodeDom" /> trees contained in the specified array of <see cref="T:System.CodeDom.CodeCompileUnit" /> objects, using the specified compiler settings.</span></span></summary>
        <returns><span data-ttu-id="18a6d-138">一个 <see cref="T:System.CodeDom.Compiler.CompilerResults" /> 对象，它指示编译的结果。</span><span class="sxs-lookup"><span data-stu-id="18a6d-138">A <see cref="T:System.CodeDom.Compiler.CompilerResults" /> object that indicates the results of the compilation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="18a6d-139">在 .NET Framework 版本1.0 和1.1 中，此方法由提供程序的 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> 方法返回的 <xref:System.CodeDom.Compiler.ICodeCompiler> 实现提供。</span><span class="sxs-lookup"><span data-stu-id="18a6d-139">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeCompiler> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> method of the provider.</span></span> <span data-ttu-id="18a6d-140">在版本2.0 中，可以直接在代码提供程序上调用此方法，即使代码提供程序未重写此方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-140">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="18a6d-141">如果代码提供程序未重写此方法，则由基类调用 <xref:System.CodeDom.Compiler.ICodeCompiler> 实现。</span><span class="sxs-lookup"><span data-stu-id="18a6d-141">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeCompiler> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="18a6d-142">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> 方法均不在派生类中重写。</span><span class="sxs-lookup"><span data-stu-id="18a6d-142">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> method is overridden in a derived class.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="18a6d-143">如果重写此方法，则不能调用基类的相应方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-143">If you override this method, you must not call the corresponding method of the base class.</span></span> <span data-ttu-id="18a6d-144">基类方法使用过时的 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> 方法在派生类中创建一个生成器，以便与使用代码编译器的预先存在的提供程序兼容。</span><span class="sxs-lookup"><span data-stu-id="18a6d-144">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> method for compatibility with preexisting providers that use code compilers.</span></span> <span data-ttu-id="18a6d-145">然后，基类方法调用 <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> 实现中的等效方法来执行此函数。</span><span class="sxs-lookup"><span data-stu-id="18a6d-145">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> implementation to perform this function.</span></span> <span data-ttu-id="18a6d-146">如果从不使用代码编译器的代码提供程序调用基类方法，将会收到 <see cref="T:System.NotImplementedException" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-146">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code compiler.</span></span></para></block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromFile">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile (System.CodeDom.Compiler.CompilerParameters options, params string[] fileNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile(class System.CodeDom.Compiler.CompilerParameters options, string[] fileNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromFile(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromFile (options As CompilerParameters, ParamArray fileNames As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromFile(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ fileNames);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromFile : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromFile : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromFile (options, fileNames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="fileNames" Type="System.String[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options"><span data-ttu-id="18a6d-147">一个 <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> 对象，它指示编译的设置。</span><span class="sxs-lookup"><span data-stu-id="18a6d-147">A <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> object that indicates the settings for the compilation.</span></span></param>
        <param name="fileNames"><span data-ttu-id="18a6d-148">要编译的文件名称的数组。</span><span class="sxs-lookup"><span data-stu-id="18a6d-148">An array of the names of the files to compile.</span></span></param>
        <summary><span data-ttu-id="18a6d-149">从包含在指定文件中的源代码，使用指定的编译器设置编译程序集。</span><span class="sxs-lookup"><span data-stu-id="18a6d-149">Compiles an assembly from the source code contained in the specified files, using the specified compiler settings.</span></span></summary>
        <returns><span data-ttu-id="18a6d-150">指示编译结果的 <see cref="T:System.CodeDom.Compiler.CompilerResults" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="18a6d-150">A <see cref="T:System.CodeDom.Compiler.CompilerResults" /> object that indicates the results of compilation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="18a6d-151">在 .NET Framework 版本1.0 和1.1 中，此方法由提供程序的 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> 方法返回的 <xref:System.CodeDom.Compiler.ICodeCompiler> 实现提供。</span><span class="sxs-lookup"><span data-stu-id="18a6d-151">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeCompiler> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> method of the provider.</span></span> <span data-ttu-id="18a6d-152">在版本2.0 中，可以直接在代码提供程序上调用此方法，即使代码提供程序未重写此方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-152">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="18a6d-153">如果代码提供程序未重写此方法，则由基类调用 <xref:System.CodeDom.Compiler.ICodeCompiler> 实现。</span><span class="sxs-lookup"><span data-stu-id="18a6d-153">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeCompiler> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="18a6d-154">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> 方法均不在派生类中重写。</span><span class="sxs-lookup"><span data-stu-id="18a6d-154">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> method is overridden in a derived class.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="18a6d-155">如果重写此方法，则不能调用基类的相应方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-155">If you override this method, you must not call the corresponding method of the base class.</span></span> <span data-ttu-id="18a6d-156">基类方法使用过时的 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> 方法在派生类中创建一个生成器，以便与使用代码编译器的预先存在的提供程序兼容。</span><span class="sxs-lookup"><span data-stu-id="18a6d-156">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> method for compatibility with preexisting providers that use code compilers.</span></span> <span data-ttu-id="18a6d-157">然后，基类方法调用 <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> 实现中的等效方法来执行此函数。</span><span class="sxs-lookup"><span data-stu-id="18a6d-157">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> implementation to perform this function.</span></span> <span data-ttu-id="18a6d-158">如果从不使用代码编译器的代码提供程序调用基类方法，将会收到 <see cref="T:System.NotImplementedException" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-158">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code compiler.</span></span></para></block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromSource">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource (System.CodeDom.Compiler.CompilerParameters options, params string[] sources);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource(class System.CodeDom.Compiler.CompilerParameters options, string[] sources) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromSource(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromSource (options As CompilerParameters, ParamArray sources As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromSource(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ sources);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromSource : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromSource : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromSource (options, sources)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="sources" Type="System.String[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options"><span data-ttu-id="18a6d-159">一个 <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> 对象，它指示此编译的编译器设置。</span><span class="sxs-lookup"><span data-stu-id="18a6d-159">A <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> object that indicates the compiler settings for this compilation.</span></span></param>
        <param name="sources"><span data-ttu-id="18a6d-160">要编译的源代码字符串的数组。</span><span class="sxs-lookup"><span data-stu-id="18a6d-160">An array of source code strings to compile.</span></span></param>
        <summary><span data-ttu-id="18a6d-161">从包含源代码的字符串的指定数组，使用指定的编译器设置编译程序集。</span><span class="sxs-lookup"><span data-stu-id="18a6d-161">Compiles an assembly from the specified array of strings containing source code, using the specified compiler settings.</span></span></summary>
        <returns><span data-ttu-id="18a6d-162">指示编译结果的 <see cref="T:System.CodeDom.Compiler.CompilerResults" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="18a6d-162">A <see cref="T:System.CodeDom.Compiler.CompilerResults" /> object that indicates the results of compilation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="18a6d-163">在 .NET Framework 版本1.0 和1.1 中，此方法由提供程序的 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> 方法返回的 <xref:System.CodeDom.Compiler.ICodeCompiler> 实现提供。</span><span class="sxs-lookup"><span data-stu-id="18a6d-163">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeCompiler> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A> method of the provider.</span></span> <span data-ttu-id="18a6d-164">在版本2.0 中，可以直接在代码提供程序上调用此方法，即使代码提供程序未重写此方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-164">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="18a6d-165">如果代码提供程序未重写此方法，则由基类调用 <xref:System.CodeDom.Compiler.ICodeCompiler> 实现。</span><span class="sxs-lookup"><span data-stu-id="18a6d-165">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeCompiler> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="18a6d-166">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> 方法均不在派生类中重写。</span><span class="sxs-lookup"><span data-stu-id="18a6d-166">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> method is overridden in a derived class.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="18a6d-167">如果重写此方法，则不能调用基类的相应方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-167">If you override this method, you must not call the corresponding method of the base class.</span></span> <span data-ttu-id="18a6d-168">基类方法使用过时的 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> 方法在派生类中创建一个生成器，以便与使用代码编译器的预先存在的提供程序兼容。</span><span class="sxs-lookup"><span data-stu-id="18a6d-168">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> method for compatibility with preexisting providers that use code compilers.</span></span> <span data-ttu-id="18a6d-169">然后，基类方法调用 <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> 实现中的等效方法来执行此函数。</span><span class="sxs-lookup"><span data-stu-id="18a6d-169">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> implementation to perform this function.</span></span> <span data-ttu-id="18a6d-170">如果从不使用代码编译器的代码提供程序调用基类方法，将会收到 <see cref="T:System.NotImplementedException" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-170">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code compiler.</span></span></para></block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CreateCompiler">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeCompiler CreateCompiler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeCompiler CreateCompiler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCompiler () As ICodeCompiler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeCompiler ^ CreateCompiler();" />
      <MemberSignature Language="F#" Value="abstract member CreateCompiler : unit -&gt; System.CodeDom.Compiler.ICodeCompiler" Usage="codeDomProvider.CreateCompiler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeCompiler is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.1">
          <AttributeName>System.Obsolete("Callers should not use the ICodeCompiler interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeCompiler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="18a6d-171">在派生类中重写时，创建一个新的代码编译器。</span><span class="sxs-lookup"><span data-stu-id="18a6d-171">When overridden in a derived class, creates a new code compiler.</span></span></summary>
        <returns><span data-ttu-id="18a6d-172"><see cref="T:System.CodeDom.Compiler.ICodeCompiler" />，可用于编译基于 <see cref="N:System.CodeDom" /> 的源代码表示形式。</span><span class="sxs-lookup"><span data-stu-id="18a6d-172">An <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> that can be used for compilation of <see cref="N:System.CodeDom" /> based source code representations.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18a6d-173">此方法在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]中已过时。</span><span class="sxs-lookup"><span data-stu-id="18a6d-173">This method is obsolete in the [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)].</span></span> <span data-ttu-id="18a6d-174">建议的替代项是调用在代码提供程序中直接可用的 <xref:System.CodeDom.Compiler.ICodeCompiler> 方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-174">The recommended alternative is to call the <xref:System.CodeDom.Compiler.ICodeCompiler> methods that are directly available in the code provider.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="18a6d-175">在 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]中，应在 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 类中实现 <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> 成员，并在调用此方法时引发 <see cref="T:System.NotSupportedException" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-175">In the [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], you should implement the <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> members in the <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> class and throw a <see cref="T:System.NotSupportedException" /> when this method is called.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="CreateEscapedIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateEscapedIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateEscapedIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateEscapedIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateEscapedIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CreateEscapedIdentifier : string -&gt; string&#xA;override this.CreateEscapedIdentifier : string -&gt; string" Usage="codeDomProvider.CreateEscapedIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="18a6d-176">要为其创建转义标识符的字符串。</span><span class="sxs-lookup"><span data-stu-id="18a6d-176">The string for which to create an escaped identifier.</span></span></param>
        <summary><span data-ttu-id="18a6d-177">创建指定值的转义标识符。</span><span class="sxs-lookup"><span data-stu-id="18a6d-177">Creates an escaped identifier for the specified value.</span></span></summary>
        <returns><span data-ttu-id="18a6d-178">值的转义标识符。</span><span class="sxs-lookup"><span data-stu-id="18a6d-178">The escaped identifier for the value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18a6d-179"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier%2A> 测试标识符是否与任何保留关键字或语言关键字冲突，如果是，则返回具有特定于语言的转义代码格式的等效名称。</span><span class="sxs-lookup"><span data-stu-id="18a6d-179"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier%2A> tests whether the identifier conflicts with any reserved or language keywords, and if so, returns an equivalent name with language-specific escape code formatting.</span></span> <span data-ttu-id="18a6d-180">这称为转义标识符。</span><span class="sxs-lookup"><span data-stu-id="18a6d-180">This is referred to an escaped identifier.</span></span> <span data-ttu-id="18a6d-181">该转义标识符包含相同的 `value`，但添加了转义码格式设置，以使标识符有别于关键字。</span><span class="sxs-lookup"><span data-stu-id="18a6d-181">The escaped identifier contains the same `value` but has escape-code formatting added to differentiate the identifier from the keyword.</span></span> <span data-ttu-id="18a6d-182">两个实现示例在 `value` 前面带有 "@"，或将 `value` 与 "[" 和 "]" 括号。</span><span class="sxs-lookup"><span data-stu-id="18a6d-182">Two implementation examples are preceding the `value` with "@" or bracketing the `value` with "[" and "]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="18a6d-183">在 .NET Framework 版本1.0 和1.1 中，此方法由提供程序的 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> 方法返回的 <xref:System.CodeDom.Compiler.ICodeGenerator> 实现提供。</span><span class="sxs-lookup"><span data-stu-id="18a6d-183">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="18a6d-184">在版本2.0 中，可以直接在代码提供程序上调用此方法，即使代码提供程序未重写此方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-184">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="18a6d-185">如果代码提供程序未重写此方法，则由基类调用 <xref:System.CodeDom.Compiler.ICodeGenerator> 实现。</span><span class="sxs-lookup"><span data-stu-id="18a6d-185">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="18a6d-186">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</span><span class="sxs-lookup"><span data-stu-id="18a6d-186">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="18a6d-187">如果重写此方法，则不能调用基类的相应方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-187">If you override this method, you must not call the corresponding method of the base class.</span></span> <span data-ttu-id="18a6d-188">基类方法使用过时的 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法在派生类中创建一个生成器，以便与使用代码生成器的预先存在的提供程序兼容。</span><span class="sxs-lookup"><span data-stu-id="18a6d-188">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span></span> <span data-ttu-id="18a6d-189">然后，基类方法调用 <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> 实现中的等效方法来执行此函数。</span><span class="sxs-lookup"><span data-stu-id="18a6d-189">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span></span> <span data-ttu-id="18a6d-190">如果从不使用代码生成器的代码提供程序调用基类方法，将会收到 <see cref="T:System.NotImplementedException" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-190">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span></span></para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateGenerator">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="18a6d-191">在派生类中重写时，创建一个新的代码生成器。</span><span class="sxs-lookup"><span data-stu-id="18a6d-191">When overridden in a derived class, creates a new code generator.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeGenerator CreateGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateGenerator () As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator();" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : unit -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeGenerator is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.1">
          <AttributeName>System.Obsolete("Callers should not use the ICodeGenerator interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="18a6d-192">在派生类中重写时，创建一个新的代码生成器。</span><span class="sxs-lookup"><span data-stu-id="18a6d-192">When overridden in a derived class, creates a new code generator.</span></span></summary>
        <returns><span data-ttu-id="18a6d-193"><see cref="T:System.CodeDom.Compiler.ICodeGenerator" />，可用于生成基于 <see cref="N:System.CodeDom" /> 的源代码表示形式。</span><span class="sxs-lookup"><span data-stu-id="18a6d-193">An <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> that can be used to generate <see cref="N:System.CodeDom" /> based source code representations.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18a6d-194">此方法在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]中已过时。</span><span class="sxs-lookup"><span data-stu-id="18a6d-194">This method is obsolete in the [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)].</span></span> <span data-ttu-id="18a6d-195">建议的替代项是调用 <xref:System.CodeDom.Compiler.CodeDomProvider> 类中直接可用的 <xref:System.CodeDom.Compiler.ICodeGenerator> 方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-195">The recommended alternative is to call the <xref:System.CodeDom.Compiler.ICodeGenerator> methods that are directly available in the <xref:System.CodeDom.Compiler.CodeDomProvider> class.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="18a6d-196">在 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]中，应在 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 类中实现 <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> 成员，并在调用此方法时引发 <see cref="T:System.NotSupportedException" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-196">In the [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], you should implement the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> members in the <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> class and throw a <see cref="T:System.NotSupportedException" /> when this method is called.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (output As TextWriter) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : System.IO.TextWriter -&gt; System.CodeDom.Compiler.ICodeGenerator&#xA;override this.CreateGenerator : System.IO.TextWriter -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator output" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="output"><span data-ttu-id="18a6d-197">用于输出的 <see cref="T:System.IO.TextWriter" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-197">A <see cref="T:System.IO.TextWriter" /> to use to output.</span></span></param>
        <summary><span data-ttu-id="18a6d-198">在派生类中重写时，使用指定的 <see cref="T:System.IO.TextWriter" /> 创建新的代码生成器以用于输出。</span><span class="sxs-lookup"><span data-stu-id="18a6d-198">When overridden in a derived class, creates a new code generator using the specified <see cref="T:System.IO.TextWriter" /> for output.</span></span></summary>
        <returns><span data-ttu-id="18a6d-199"><see cref="T:System.CodeDom.Compiler.ICodeGenerator" />，可用于生成基于 <see cref="N:System.CodeDom" /> 的源代码表示形式。</span><span class="sxs-lookup"><span data-stu-id="18a6d-199">An <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> that can be used to generate <see cref="N:System.CodeDom" /> based source code representations.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18a6d-200">此方法使用指定的 <xref:System.IO.TextWriter> 进行输出。</span><span class="sxs-lookup"><span data-stu-id="18a6d-200">This method uses the specified <xref:System.IO.TextWriter> for output.</span></span> <span data-ttu-id="18a6d-201">此方法支持更多优化的代码生成，以增量方式更新源代码。</span><span class="sxs-lookup"><span data-stu-id="18a6d-201">This method supports more optimized code generation that incrementally updates the source code.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="18a6d-202">基类实现调用 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> 方法，该方法在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中已过时，如果未返回 <xref:System.CodeDom.Compiler.ICodeGenerator> 对象，则会生成 <xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="18a6d-202">The base class implementation calls the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method, which is obsolete in the [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] and results in a <xref:System.NotSupportedException> if an <xref:System.CodeDom.Compiler.ICodeGenerator> object is not returned.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.TextWriter" />
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (fileName As String) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : string -&gt; System.CodeDom.Compiler.ICodeGenerator&#xA;override this.CreateGenerator : string -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="18a6d-203">要输出到的文件名。</span><span class="sxs-lookup"><span data-stu-id="18a6d-203">The file name to output to.</span></span></param>
        <summary><span data-ttu-id="18a6d-204">在派生类中重写时，使用指定文件名创建新的代码生成器以用于输出。</span><span class="sxs-lookup"><span data-stu-id="18a6d-204">When overridden in a derived class, creates a new code generator using the specified file name for output.</span></span></summary>
        <returns><span data-ttu-id="18a6d-205"><see cref="T:System.CodeDom.Compiler.ICodeGenerator" />，可用于生成基于 <see cref="N:System.CodeDom" /> 的源代码表示形式。</span><span class="sxs-lookup"><span data-stu-id="18a6d-205">An <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> that can be used to generate <see cref="N:System.CodeDom" /> based source code representations.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18a6d-206">此方法使用指定的输出文件名。</span><span class="sxs-lookup"><span data-stu-id="18a6d-206">This method uses the specified file name for output.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="18a6d-207">基类实现调用 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> 方法，该方法在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中已过时，如果未返回 <xref:System.CodeDom.Compiler.ICodeGenerator> 对象，则会生成 <xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="18a6d-207">The base class implementation calls the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method, which is obsolete in the [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] and results in a <xref:System.NotSupportedException> if an <xref:System.CodeDom.Compiler.ICodeGenerator> object is not returned.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateParser">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeParser CreateParser ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeParser CreateParser() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateParser () As ICodeParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeParser ^ CreateParser();" />
      <MemberSignature Language="F#" Value="abstract member CreateParser : unit -&gt; System.CodeDom.Compiler.ICodeParser&#xA;override this.CreateParser : unit -&gt; System.CodeDom.Compiler.ICodeParser" Usage="codeDomProvider.CreateParser " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeParser is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.1">
          <AttributeName>System.Obsolete("Callers should not use the ICodeParser interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeParser</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="18a6d-208">在派生类中重写时，创建一个新的代码分析器。</span><span class="sxs-lookup"><span data-stu-id="18a6d-208">When overridden in a derived class, creates a new code parser.</span></span></summary>
        <returns><span data-ttu-id="18a6d-209"><see cref="T:System.CodeDom.Compiler.ICodeParser" />，可用于分析源代码。</span><span class="sxs-lookup"><span data-stu-id="18a6d-209">An <see cref="T:System.CodeDom.Compiler.ICodeParser" /> that can be used to parse source code.</span></span> <span data-ttu-id="18a6d-210">此基实现总是返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-210">The base implementation always returns <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateProvider">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="18a6d-211">获取指定语言的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="18a6d-211">Gets a <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> instance for the specified language.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member CreateProvider : string -&gt; System.CodeDom.Compiler.CodeDomProvider" Usage="System.CodeDom.Compiler.CodeDomProvider.CreateProvider language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language"><span data-ttu-id="18a6d-212">语言名称。</span><span class="sxs-lookup"><span data-stu-id="18a6d-212">The language name.</span></span></param>
        <summary><span data-ttu-id="18a6d-213">获取指定语言的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="18a6d-213">Gets a <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> instance for the specified language.</span></span></summary>
        <returns><span data-ttu-id="18a6d-214">为指定语言名称实现的 CodeDOM 提供程序。</span><span class="sxs-lookup"><span data-stu-id="18a6d-214">A CodeDOM provider that is implemented for the specified language name.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="18a6d-215">此方法最常用于在应用程序中创建代码提供程序的实例，该实例可以选择使用多个提供程序之一。</span><span class="sxs-lookup"><span data-stu-id="18a6d-215">This method is most commonly used to create an instance of a code provider in an application that may optionally use one of several providers.</span></span> <span data-ttu-id="18a6d-216"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> 允许您在运行时指定要实例化的代码提供程序。</span><span class="sxs-lookup"><span data-stu-id="18a6d-216"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> allows you to specify at run time the code provider you wish to instantiate.</span></span> <span data-ttu-id="18a6d-217">如果您在设计时知道要使用哪一个代码提供程序，则应创建该代码提供程序的实例，而不是使用 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-217">If you know at design time which code provider is to be used, you should create an instance of that code provider rather than use the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> method.</span></span>  
  
 <span data-ttu-id="18a6d-218"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> 方法返回特定语言名称的 <xref:System.CodeDom.Compiler.CodeDomProvider> 实例;它类似于通过语言提供程序类型调用 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-218">The <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> method returns a <xref:System.CodeDom.Compiler.CodeDomProvider> instance for a specific language name; it is similar to calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method with the language provider type.</span></span> <span data-ttu-id="18a6d-219">若要动态查找语言名称的已配置提供程序实现，请使用 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>。</span><span class="sxs-lookup"><span data-stu-id="18a6d-219">Use <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> when you want to dynamically find a configured provider implementation for a language name.</span></span>  
  
 <span data-ttu-id="18a6d-220">如果为语言名称配置了多个提供程序实现，<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> 将为最后一个匹配的配置元素返回提供程序实例。</span><span class="sxs-lookup"><span data-stu-id="18a6d-220">If more than one provider implementation is configured for the language name, <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> returns a provider instance for the last matching configuration element.</span></span>  
  
 <span data-ttu-id="18a6d-221">如果需要特定的语言提供程序实现，请使用 <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> 方法重载。</span><span class="sxs-lookup"><span data-stu-id="18a6d-221">Use the <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> method overload when you want a specific language provider implementation.</span></span> <span data-ttu-id="18a6d-222">例如，使用 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> 方法获取支持语言名称 `"CSharp"`的提供程序实例。使用 <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> 方法重载获取专用于 <xref:Microsoft.CSharp.CSharpCodeProvider?displayProperty=nameWithType> 实现的提供程序实例。</span><span class="sxs-lookup"><span data-stu-id="18a6d-222">For example, use the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> method to get a provider instance that supports the language name `"CSharp"`; use the <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> method overload to get a provider instance specifically for the <xref:Microsoft.CSharp.CSharpCodeProvider?displayProperty=nameWithType> implementation.</span></span> <span data-ttu-id="18a6d-223">你应使用 [\]，CultureInfo，对象\<x： 28System.object% 2csystem.string% 2csystem.string% 2csystem.string% 2csystem.string%%%%%%%% 5D% \* %29 （& e）？ displayProperty = Namewithtype> > 方法，如果你有一个语言的多个代码提供程序，并且想要实例化特定的代码提供程序。</span><span class="sxs-lookup"><span data-stu-id="18a6d-223">You should use the [\], CultureInfo, Object\<xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> method if you have multiple code providers for a language and you desire to instantiate a specific code provider.</span></span>  
  
 <span data-ttu-id="18a6d-224"><xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> 方法将检查是否至少有一个提供程序实现支持特定语言。</span><span class="sxs-lookup"><span data-stu-id="18a6d-224">The <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> method checks whether at least one provider implementation supports a specific language.</span></span> <span data-ttu-id="18a6d-225">您可以使用 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> 验证语言名称，然后将其传递给 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>。</span><span class="sxs-lookup"><span data-stu-id="18a6d-225">You can validate a language name using <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> before passing it to <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>.</span></span> <span data-ttu-id="18a6d-226">如果将不受支持的语言名称传递到 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> 将引发 <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="18a6d-226">If you pass an unsupported language name to <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> a <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> is thrown.</span></span>  
  
 <span data-ttu-id="18a6d-227"><xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> 方法可用于确定计算机上的所有 <xref:System.CodeDom.Compiler.CodeDomProvider> 实现，包括开发人员和编译器供应商提供的其他实现，这些实现在计算机配置文件（Machine.config）中的[&lt;system.object&gt; 元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)中标识。</span><span class="sxs-lookup"><span data-stu-id="18a6d-227">The <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> method can be used to determine all <xref:System.CodeDom.Compiler.CodeDomProvider> implementations on a computer, including additional implementations provided by developers and compiler vendors that are identified in the [&lt;system.codedom&gt; Element](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) in the machine configuration file (Machine.config).</span></span>  
  
 <span data-ttu-id="18a6d-228"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> 方法返回特定语言的 <xref:System.CodeDom.Compiler.CodeDomProvider> 实现的实例。</span><span class="sxs-lookup"><span data-stu-id="18a6d-228">The <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> method returns an instance of a <xref:System.CodeDom.Compiler.CodeDomProvider> implementation for a specific language.</span></span>  
  
 <span data-ttu-id="18a6d-229">语言名称不区分大小写。</span><span class="sxs-lookup"><span data-stu-id="18a6d-229">Language names are case-insensitive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18a6d-230">下面的代码示例确定输入语言的 <xref:System.CodeDom.Compiler.CodeDomProvider> 实现，并显示语言提供程序的配置设置。</span><span class="sxs-lookup"><span data-stu-id="18a6d-230">The following code example determines the <xref:System.CodeDom.Compiler.CodeDomProvider> implementation for an input language and displays the configured settings for the language provider.</span></span> <span data-ttu-id="18a6d-231">此代码示例是为 <xref:System.CodeDom.Compiler.CompilerInfo> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="18a6d-231">This code example is part of a larger example provided for the <xref:System.CodeDom.Compiler.CompilerInfo> class.</span></span>  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException"><span data-ttu-id="18a6d-232"><paramref name="language" /> 在此计算机上没有已配置的提供程序。</span><span class="sxs-lookup"><span data-stu-id="18a6d-232">The <paramref name="language" /> does not have a configured provider on this computer.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="18a6d-233"><paramref name="language" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-233">The <paramref name="language" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="18a6d-234">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="18a6d-234">The caller does not have the required permission.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="18a6d-235">完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="18a6d-235">for full trust for the immediate caller.</span></span> <span data-ttu-id="18a6d-236">部分信任的程式碼無法使用此成員。</span><span class="sxs-lookup"><span data-stu-id="18a6d-236">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language, System.Collections.Generic.IDictionary&lt;string,string&gt; providerOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; providerOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String,System.Collections.Generic.IDictionary{System.String,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String, providerOptions As IDictionary(Of String, String)) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ providerOptions);" />
      <MemberSignature Language="F#" Value="static member CreateProvider : string * System.Collections.Generic.IDictionary&lt;string, string&gt; -&gt; System.CodeDom.Compiler.CodeDomProvider" Usage="System.CodeDom.Compiler.CodeDomProvider.CreateProvider (language, providerOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="providerOptions" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language"><span data-ttu-id="18a6d-237">语言名称。</span><span class="sxs-lookup"><span data-stu-id="18a6d-237">The language name.</span></span></param>
        <param name="providerOptions"><span data-ttu-id="18a6d-238">来自配置文件的提供程序选项的集合。</span><span class="sxs-lookup"><span data-stu-id="18a6d-238">A collection of provider options from the configuration file.</span></span></param>
        <summary><span data-ttu-id="18a6d-239">获取指定的语言和提供程序选项的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="18a6d-239">Gets a <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> instance for the specified language and provider options.</span></span></summary>
        <returns><span data-ttu-id="18a6d-240">为指定语言名称和选项实现的 CodeDOM 提供程序。</span><span class="sxs-lookup"><span data-stu-id="18a6d-240">A CodeDOM provider that is implemented for the specified language name and options.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="18a6d-241">此方法最常用于在应用程序中创建代码提供程序的实例，该实例可以选择使用多个提供程序之一。</span><span class="sxs-lookup"><span data-stu-id="18a6d-241">This method is most commonly used to create an instance of a code provider in an application that may optionally use one of several providers.</span></span> <span data-ttu-id="18a6d-242"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> 使你能够在运行时指定要实例化的代码提供程序的版本。</span><span class="sxs-lookup"><span data-stu-id="18a6d-242"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> enables you to specify at run time the version of the code provider you want to instantiate.</span></span> <span data-ttu-id="18a6d-243">如果在设计时知道要使用哪种代码提供程序，则应创建该代码提供程序的实例，而不是使用 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-243">If you know at design time which code provider is to be used, you should create an instance of that code provider instead of using the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> method.</span></span>  
  
 <span data-ttu-id="18a6d-244">若要为特定语言和选项动态查找已配置的提供程序实现，请使用 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29>。</span><span class="sxs-lookup"><span data-stu-id="18a6d-244">Use <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29> when you want to dynamically find a configured provider implementation for a specific language and options.</span></span> <span data-ttu-id="18a6d-245">语言名称不区分大小写。</span><span class="sxs-lookup"><span data-stu-id="18a6d-245">Language names are case-insensitive.</span></span> <span data-ttu-id="18a6d-246">有关支持的提供程序选项的信息，请参阅特定的 CodeDOM 提供程序文档。</span><span class="sxs-lookup"><span data-stu-id="18a6d-246">For information about supported provider options, see the specific CodeDOM provider documentation.</span></span>  
  
 <span data-ttu-id="18a6d-247">有关为语言名称配置了多个提供程序实现的验证提供程序和调用提供程序的信息，请参阅 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%29> 方法的 "备注" 部分。</span><span class="sxs-lookup"><span data-stu-id="18a6d-247">For information about validating a provider and calling a provider if more than one provider implementation is configured for the language name, see the Remarks section of the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%29> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18a6d-248">下面的示例演示如何使用 `providerOptions` 参数创建提供程序的实例。</span><span class="sxs-lookup"><span data-stu-id="18a6d-248">The following example shows how to create an instance of a provider by using the `providerOptions` parameter.</span></span>  
  
 [!code-csharp[CodeDomProvider.ProviderOptions#1](~/samples/snippets/csharp/VS_Snippets_CLR/codedomprovider.provideroptions/cs/program.cs#1)]
 [!code-vb[CodeDomProvider.ProviderOptions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/codedomprovider.provideroptions/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateValidIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateValidIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CreateValidIdentifier : string -&gt; string&#xA;override this.CreateValidIdentifier : string -&gt; string" Usage="codeDomProvider.CreateValidIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="18a6d-249">要为其生成有效标识符的字符串。</span><span class="sxs-lookup"><span data-stu-id="18a6d-249">The string for which to generate a valid identifier.</span></span></param>
        <summary><span data-ttu-id="18a6d-250">为指定的值创建有效标识符。</span><span class="sxs-lookup"><span data-stu-id="18a6d-250">Creates a valid identifier for the specified value.</span></span></summary>
        <returns><span data-ttu-id="18a6d-251">指定值的有效标识符。</span><span class="sxs-lookup"><span data-stu-id="18a6d-251">A valid identifier for the specified value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18a6d-252"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier%2A> 测试标识符是否与保留关键字或语言关键字冲突，如果是，则将尝试返回一个不冲突的有效标识符名称。</span><span class="sxs-lookup"><span data-stu-id="18a6d-252"><xref:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier%2A> tests whether the identifier conflicts with reserved or language keywords, and if so, attempts to return a valid identifier name that does not conflict.</span></span> <span data-ttu-id="18a6d-253">通常，只会略微修改返回的标识符，以区别关键字中的标识符;例如，名称前面可能有下划线（"_"）字符。</span><span class="sxs-lookup"><span data-stu-id="18a6d-253">Usually the returned identifier is only slightly modified to differentiate the identifier from the keyword; for example, the name might be preceded by the underscore ("_") character.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="18a6d-254">在 .NET Framework 版本1.0 和1.1 中，此方法由提供程序的 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> 方法返回的 <xref:System.CodeDom.Compiler.ICodeGenerator> 实现提供。</span><span class="sxs-lookup"><span data-stu-id="18a6d-254">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="18a6d-255">在版本2.0 中，可以直接在代码提供程序上调用此方法，即使代码提供程序未重写此方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-255">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="18a6d-256">如果代码提供程序未重写此方法，则由基类调用 <xref:System.CodeDom.Compiler.ICodeGenerator> 实现。</span><span class="sxs-lookup"><span data-stu-id="18a6d-256">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="18a6d-257">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</span><span class="sxs-lookup"><span data-stu-id="18a6d-257">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="18a6d-258">如果重写此方法，则不能调用基类的相应方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-258">If you override this method, you must not call the corresponding method of the base class.</span></span> <span data-ttu-id="18a6d-259">基类方法使用过时的 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法在派生类中创建一个生成器，以便与使用代码生成器的预先存在的提供程序兼容。</span><span class="sxs-lookup"><span data-stu-id="18a6d-259">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span></span> <span data-ttu-id="18a6d-260">然后，基类方法调用 <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> 实现中的等效方法来执行此函数。</span><span class="sxs-lookup"><span data-stu-id="18a6d-260">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span></span> <span data-ttu-id="18a6d-261">如果从不使用代码生成器的代码提供程序调用基类方法，将会收到 <see cref="T:System.NotImplementedException" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-261">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="FileExtension">
      <MemberSignature Language="C#" Value="public virtual string FileExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FileExtension" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.FileExtension" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FileExtension As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FileExtension { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FileExtension : string" Usage="System.CodeDom.Compiler.CodeDomProvider.FileExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="18a6d-262">获取用于当前语言的源代码文件的默认文件扩展名。</span><span class="sxs-lookup"><span data-stu-id="18a6d-262">Gets the default file name extension to use for source code files in the current language.</span></span></summary>
        <value><span data-ttu-id="18a6d-263">与当前语言的源文件扩展名相对应的文件扩展名。</span><span class="sxs-lookup"><span data-stu-id="18a6d-263">A file name extension corresponding to the extension of the source files of the current language.</span></span> <span data-ttu-id="18a6d-264">此基实现总是返回 <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-264">The base implementation always returns <see cref="F:System.String.Empty" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18a6d-265">代码生成器和代码编译器使用此属性来指示应生成或使用的文件扩展名。</span><span class="sxs-lookup"><span data-stu-id="18a6d-265">This property is used by code generators and code compilers to indicate what file extensions should be generated or used.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18a6d-266">下面的代码示例创建 <xref:Microsoft.VisualBasic.VBCodeProvider?displayProperty=nameWithType>的实例。</span><span class="sxs-lookup"><span data-stu-id="18a6d-266">The following code example creates an instance of <xref:Microsoft.VisualBasic.VBCodeProvider?displayProperty=nameWithType>.</span></span> <span data-ttu-id="18a6d-267">该示例显示了新提供程序实例的提供程序名称、哈希代码和默认文件扩展名。</span><span class="sxs-lookup"><span data-stu-id="18a6d-267">The example displays the provider name, hash code and default file name extension for the new provider instance.</span></span>  
  
 [!code-cpp[CodeDom_CompilerInfo#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#3)]
 [!code-csharp[CodeDom_CompilerInfo#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#3)]
 [!code-vb[CodeDom_CompilerInfo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromCompileUnit">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromCompileUnit (System.CodeDom.CodeCompileUnit compileUnit, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromCompileUnit(class System.CodeDom.CodeCompileUnit compileUnit, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit(System.CodeDom.CodeCompileUnit,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromCompileUnit (compileUnit As CodeCompileUnit, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromCompileUnit(System::CodeDom::CodeCompileUnit ^ compileUnit, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromCompileUnit : System.CodeDom.CodeCompileUnit * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromCompileUnit : System.CodeDom.CodeCompileUnit * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromCompileUnit (compileUnit, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="compileUnit" Type="System.CodeDom.CodeCompileUnit" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="compileUnit"><span data-ttu-id="18a6d-268">要为其生成代码的 <see cref="T:System.CodeDom.CodeCompileUnit" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-268">A <see cref="T:System.CodeDom.CodeCompileUnit" /> for which to generate code.</span></span></param>
        <param name="writer"><span data-ttu-id="18a6d-269">输出代码将被发送到的 <see cref="T:System.IO.TextWriter" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-269">The <see cref="T:System.IO.TextWriter" /> to which the output code is sent.</span></span></param>
        <param name="options"><span data-ttu-id="18a6d-270"><see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，指示用于生成代码的选项。</span><span class="sxs-lookup"><span data-stu-id="18a6d-270">A <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> that indicates the options to use for generating code.</span></span></param>
        <summary><span data-ttu-id="18a6d-271">为指定的代码文档对象模型 (CodeDOM) 编译单元生成代码，并使用指定的选项将代码发送到指定的文本编写器。</span><span class="sxs-lookup"><span data-stu-id="18a6d-271">Generates code for the specified Code Document Object Model (CodeDOM) compilation unit and sends it to the specified text writer, using the specified options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="18a6d-272">在 .NET Framework 版本1.0 和1.1 中，此方法由提供程序的 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> 方法返回的 <xref:System.CodeDom.Compiler.ICodeGenerator> 实现提供。</span><span class="sxs-lookup"><span data-stu-id="18a6d-272">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="18a6d-273">在版本2.0 中，可以直接在代码提供程序上调用此方法，即使代码提供程序未重写此方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-273">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="18a6d-274">如果代码提供程序未重写此方法，则由基类调用 <xref:System.CodeDom.Compiler.ICodeGenerator> 实现。</span><span class="sxs-lookup"><span data-stu-id="18a6d-274">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18a6d-275">下面的代码示例演示如何使用 <xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit%2A> 方法从 <xref:System.CodeDom.CodeCompileUnit>为 "Hello World" 应用程序生成代码。</span><span class="sxs-lookup"><span data-stu-id="18a6d-275">The following code example shows the use of the <xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit%2A> method to generate code for a "Hello World" application from a <xref:System.CodeDom.CodeCompileUnit>.</span></span> <span data-ttu-id="18a6d-276">此示例是为 <xref:System.CodeDom.Compiler.CodeDomProvider> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="18a6d-276">This example is part of a larger example provided for the <xref:System.CodeDom.Compiler.CodeDomProvider> class.</span></span>  
  
 [!code-cpp[CodeDomExample#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#3)]
 [!code-csharp[CodeDomExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#3)]
 [!code-vb[CodeDomExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="18a6d-277">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</span><span class="sxs-lookup"><span data-stu-id="18a6d-277">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="18a6d-278">如果重写此方法，则不能调用基类的相应方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-278">If you override this method, you must not call the corresponding method of the base class.</span></span> <span data-ttu-id="18a6d-279">基类方法使用过时的 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法在派生类中创建一个生成器，以便与使用代码生成器的预先存在的提供程序兼容。</span><span class="sxs-lookup"><span data-stu-id="18a6d-279">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span></span> <span data-ttu-id="18a6d-280">然后，基类方法调用 <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> 实现中的等效方法来执行此函数。</span><span class="sxs-lookup"><span data-stu-id="18a6d-280">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span></span> <span data-ttu-id="18a6d-281">如果从不使用代码生成器的代码提供程序调用基类方法，将会收到 <see cref="T:System.NotImplementedException" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-281">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span></span></para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromExpression">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromExpression (System.CodeDom.CodeExpression expression, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromExpression(class System.CodeDom.CodeExpression expression, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromExpression(System.CodeDom.CodeExpression,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromExpression (expression As CodeExpression, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromExpression(System::CodeDom::CodeExpression ^ expression, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromExpression : System.CodeDom.CodeExpression * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromExpression : System.CodeDom.CodeExpression * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromExpression (expression, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.CodeDom.CodeExpression" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression"><span data-ttu-id="18a6d-282">一个 <see cref="T:System.CodeDom.CodeExpression" /> 对象，指示要为其生成代码的表达式。</span><span class="sxs-lookup"><span data-stu-id="18a6d-282">A <see cref="T:System.CodeDom.CodeExpression" /> object that indicates the expression for which to generate code.</span></span></param>
        <param name="writer"><span data-ttu-id="18a6d-283">输出代码将被发送到的 <see cref="T:System.IO.TextWriter" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-283">The <see cref="T:System.IO.TextWriter" /> to which output code is sent.</span></span></param>
        <param name="options"><span data-ttu-id="18a6d-284"><see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，指示用于生成代码的选项。</span><span class="sxs-lookup"><span data-stu-id="18a6d-284">A <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> that indicates the options to use for generating code.</span></span></param>
        <summary><span data-ttu-id="18a6d-285">为指定的代码文档对象模型 (CodeDOM) 表达式生成代码，并使用指定的选项将代码发送到指定的文本编写器。</span><span class="sxs-lookup"><span data-stu-id="18a6d-285">Generates code for the specified Code Document Object Model (CodeDOM) expression and sends it to the specified text writer, using the specified options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="18a6d-286">在 .NET Framework 版本1.0 和1.1 中，此方法由提供程序的 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> 方法返回的 <xref:System.CodeDom.Compiler.ICodeGenerator> 实现提供。</span><span class="sxs-lookup"><span data-stu-id="18a6d-286">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="18a6d-287">在版本2.0 中，可以直接在代码提供程序上调用此方法，即使代码提供程序未重写此方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-287">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="18a6d-288">如果代码提供程序未重写此方法，则由基类调用 <xref:System.CodeDom.Compiler.ICodeGenerator> 实现。</span><span class="sxs-lookup"><span data-stu-id="18a6d-288">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="18a6d-289">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</span><span class="sxs-lookup"><span data-stu-id="18a6d-289">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="18a6d-290">如果重写此方法，则不能调用基类的相应方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-290">If you override this method, you must not call the corresponding method of the base class.</span></span> <span data-ttu-id="18a6d-291">基类方法使用过时的 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法在派生类中创建一个生成器，以便与使用代码生成器的预先存在的提供程序兼容。</span><span class="sxs-lookup"><span data-stu-id="18a6d-291">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span></span> <span data-ttu-id="18a6d-292">然后，基类方法调用 <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> 实现中的等效方法来执行此函数。</span><span class="sxs-lookup"><span data-stu-id="18a6d-292">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span></span> <span data-ttu-id="18a6d-293">如果从不使用代码生成器的代码提供程序调用基类方法，将会收到 <see cref="T:System.NotImplementedException" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-293">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span></span></para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromMember">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromMember (System.CodeDom.CodeTypeMember member, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromMember(class System.CodeDom.CodeTypeMember member, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember(System.CodeDom.CodeTypeMember,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromMember (member As CodeTypeMember, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromMember(System::CodeDom::CodeTypeMember ^ member, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromMember : System.CodeDom.CodeTypeMember * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromMember : System.CodeDom.CodeTypeMember * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromMember (member, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.CodeDom.CodeTypeMember" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="member"><span data-ttu-id="18a6d-294">一个 <see cref="T:System.CodeDom.CodeTypeMember" /> 对象，指示要为其生成代码的成员。</span><span class="sxs-lookup"><span data-stu-id="18a6d-294">A <see cref="T:System.CodeDom.CodeTypeMember" /> object that indicates the member for which to generate code.</span></span></param>
        <param name="writer"><span data-ttu-id="18a6d-295">输出代码将被发送到的 <see cref="T:System.IO.TextWriter" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-295">The <see cref="T:System.IO.TextWriter" /> to which output code is sent.</span></span></param>
        <param name="options"><span data-ttu-id="18a6d-296"><see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，指示用于生成代码的选项。</span><span class="sxs-lookup"><span data-stu-id="18a6d-296">A <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> that indicates the options to use for generating code.</span></span></param>
        <summary><span data-ttu-id="18a6d-297">为指定的代码文档对象模型 (CodeDOM) 成员声明生成代码，并使用指定的选项将代码发送到指定的文本编写器。</span><span class="sxs-lookup"><span data-stu-id="18a6d-297">Generates code for the specified Code Document Object Model (CodeDOM) member declaration and sends it to the specified text writer, using the specified options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18a6d-298">基类实现引发 <xref:System.NotImplementedException>。</span><span class="sxs-lookup"><span data-stu-id="18a6d-298">The base class implementation throws a <xref:System.NotImplementedException>.</span></span> <span data-ttu-id="18a6d-299">有关说明此方法的实现的文档，请参阅 <xref:Microsoft.CSharp.CSharpCodeProvider.GenerateCodeFromMember%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="18a6d-299">See <xref:Microsoft.CSharp.CSharpCodeProvider.GenerateCodeFromMember%2A?displayProperty=nameWithType> for documentation describing an implementation of this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18a6d-300">下面的代码示例演示如何使用 <xref:Microsoft.CSharp.CSharpCodeProvider> 和 <xref:Microsoft.VisualBasic.VBCodeProvider> 类实现的 <xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-300">The following code example shows the use of the <xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember%2A> method as implemented by the <xref:Microsoft.CSharp.CSharpCodeProvider> and <xref:Microsoft.VisualBasic.VBCodeProvider> classes.</span></span>  
  
 [!code-csharp[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/cs/program.cs#1)]
 [!code-vb[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="18a6d-301">此方法不会在派生类中被重写。</span><span class="sxs-lookup"><span data-stu-id="18a6d-301">This method is not overridden in a derived class.</span></span></exception>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeMember" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromNamespace">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromNamespace (System.CodeDom.CodeNamespace codeNamespace, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromNamespace(class System.CodeDom.CodeNamespace codeNamespace, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromNamespace(System.CodeDom.CodeNamespace,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromNamespace(System::CodeDom::CodeNamespace ^ codeNamespace, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromNamespace : System.CodeDom.CodeNamespace * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromNamespace : System.CodeDom.CodeNamespace * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromNamespace (codeNamespace, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeNamespace" Type="System.CodeDom.CodeNamespace" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codeNamespace"><span data-ttu-id="18a6d-302">一个 <see cref="T:System.CodeDom.CodeNamespace" /> 对象，指示要为其生成代码的命名空间。</span><span class="sxs-lookup"><span data-stu-id="18a6d-302">A <see cref="T:System.CodeDom.CodeNamespace" /> object that indicates the namespace for which to generate code.</span></span></param>
        <param name="writer"><span data-ttu-id="18a6d-303">输出代码将被发送到的 <see cref="T:System.IO.TextWriter" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-303">The <see cref="T:System.IO.TextWriter" /> to which output code is sent.</span></span></param>
        <param name="options"><span data-ttu-id="18a6d-304"><see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，指示用于生成代码的选项。</span><span class="sxs-lookup"><span data-stu-id="18a6d-304">A <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> that indicates the options to use for generating code.</span></span></param>
        <summary><span data-ttu-id="18a6d-305">为指定的代码文档对象模型 (CodeDOM) 命名空间生成代码，并使用指定的选项将代码发送到指定的文本编写器。</span><span class="sxs-lookup"><span data-stu-id="18a6d-305">Generates code for the specified Code Document Object Model (CodeDOM) namespace and sends it to the specified text writer, using the specified options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="18a6d-306">在 .NET Framework 版本1.0 和1.1 中，此方法由提供程序的 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> 方法返回的 <xref:System.CodeDom.Compiler.ICodeGenerator> 实现提供。</span><span class="sxs-lookup"><span data-stu-id="18a6d-306">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="18a6d-307">在版本2.0 中，可以直接在代码提供程序上调用此方法，即使代码提供程序未重写此方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-307">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="18a6d-308">如果代码提供程序未重写此方法，则由基类调用 <xref:System.CodeDom.Compiler.ICodeGenerator> 实现。</span><span class="sxs-lookup"><span data-stu-id="18a6d-308">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="18a6d-309">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</span><span class="sxs-lookup"><span data-stu-id="18a6d-309">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="18a6d-310">如果重写此方法，则不能调用基类的相应方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-310">If you override this method, you must not call the corresponding method of the base class.</span></span> <span data-ttu-id="18a6d-311">基类方法使用过时的 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法在派生类中创建一个生成器，以便与使用代码生成器的预先存在的提供程序兼容。</span><span class="sxs-lookup"><span data-stu-id="18a6d-311">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span></span> <span data-ttu-id="18a6d-312">然后，基类方法调用 <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> 实现中的等效方法来执行此函数。</span><span class="sxs-lookup"><span data-stu-id="18a6d-312">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span></span> <span data-ttu-id="18a6d-313">如果从不使用代码生成器的代码提供程序调用基类方法，将会收到 <see cref="T:System.NotImplementedException" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-313">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span></span></para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeNamespace" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromStatement">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromStatement (System.CodeDom.CodeStatement statement, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromStatement(class System.CodeDom.CodeStatement statement, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromStatement(System.CodeDom.CodeStatement,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromStatement (statement As CodeStatement, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromStatement(System::CodeDom::CodeStatement ^ statement, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromStatement : System.CodeDom.CodeStatement * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromStatement : System.CodeDom.CodeStatement * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromStatement (statement, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="statement" Type="System.CodeDom.CodeStatement" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="statement"><span data-ttu-id="18a6d-314"><see cref="T:System.CodeDom.CodeStatement" />，包含要为其生成代码的 CodeDOM 元素。</span><span class="sxs-lookup"><span data-stu-id="18a6d-314">A <see cref="T:System.CodeDom.CodeStatement" /> containing the CodeDOM elements for which to generate code.</span></span></param>
        <param name="writer"><span data-ttu-id="18a6d-315">输出代码将被发送到的 <see cref="T:System.IO.TextWriter" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-315">The <see cref="T:System.IO.TextWriter" /> to which output code is sent.</span></span></param>
        <param name="options"><span data-ttu-id="18a6d-316"><see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，指示用于生成代码的选项。</span><span class="sxs-lookup"><span data-stu-id="18a6d-316">A <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> that indicates the options to use for generating code.</span></span></param>
        <summary><span data-ttu-id="18a6d-317">为指定的代码文档对象模型 (CodeDOM) 语句生成代码，并使用指定的选项将代码发送到指定的文本编写器。</span><span class="sxs-lookup"><span data-stu-id="18a6d-317">Generates code for the specified Code Document Object Model (CodeDOM) statement and sends it to the specified text writer, using the specified options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="18a6d-318">在 .NET Framework 版本1.0 和1.1 中，此方法由提供程序的 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> 方法返回的 <xref:System.CodeDom.Compiler.ICodeGenerator> 实现提供。</span><span class="sxs-lookup"><span data-stu-id="18a6d-318">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="18a6d-319">在版本2.0 中，可以直接在代码提供程序上调用此方法，即使代码提供程序未重写此方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-319">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="18a6d-320">如果代码提供程序未重写此方法，则由基类调用 <xref:System.CodeDom.Compiler.ICodeGenerator> 实现。</span><span class="sxs-lookup"><span data-stu-id="18a6d-320">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="18a6d-321">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</span><span class="sxs-lookup"><span data-stu-id="18a6d-321">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="18a6d-322">如果重写此方法，则不能调用基类的相应方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-322">If you override this method, you must not call the corresponding method of the base class.</span></span> <span data-ttu-id="18a6d-323">基类方法使用过时的 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法在派生类中创建一个生成器，以便与使用代码生成器的预先存在的提供程序兼容。</span><span class="sxs-lookup"><span data-stu-id="18a6d-323">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span></span> <span data-ttu-id="18a6d-324">然后，基类方法调用 <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> 实现中的等效方法来执行此函数。</span><span class="sxs-lookup"><span data-stu-id="18a6d-324">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span></span> <span data-ttu-id="18a6d-325">如果从不使用代码生成器的代码提供程序调用基类方法，将会收到 <see cref="T:System.NotImplementedException" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-325">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span></span></para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeStatement" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromType">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromType (System.CodeDom.CodeTypeDeclaration codeType, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromType(class System.CodeDom.CodeTypeDeclaration codeType, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromType(System.CodeDom.CodeTypeDeclaration,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromType (codeType As CodeTypeDeclaration, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromType(System::CodeDom::CodeTypeDeclaration ^ codeType, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromType : System.CodeDom.CodeTypeDeclaration * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromType : System.CodeDom.CodeTypeDeclaration * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromType (codeType, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeType" Type="System.CodeDom.CodeTypeDeclaration" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codeType"><span data-ttu-id="18a6d-326">一个 <see cref="T:System.CodeDom.CodeTypeDeclaration" /> 对象，指示要为其生成代码的类型。</span><span class="sxs-lookup"><span data-stu-id="18a6d-326">A <see cref="T:System.CodeDom.CodeTypeDeclaration" /> object that indicates the type for which to generate code.</span></span></param>
        <param name="writer"><span data-ttu-id="18a6d-327">输出代码将被发送到的 <see cref="T:System.IO.TextWriter" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-327">The <see cref="T:System.IO.TextWriter" /> to which output code is sent.</span></span></param>
        <param name="options"><span data-ttu-id="18a6d-328"><see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，指示用于生成代码的选项。</span><span class="sxs-lookup"><span data-stu-id="18a6d-328">A <see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" /> that indicates the options to use for generating code.</span></span></param>
        <summary><span data-ttu-id="18a6d-329">为指定的代码文档对象模型 (CodeDOM) 类型声明生成代码，并使用指定的选项将代码发送到指定的文本编写器。</span><span class="sxs-lookup"><span data-stu-id="18a6d-329">Generates code for the specified Code Document Object Model (CodeDOM) type declaration and sends it to the specified text writer, using the specified options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="18a6d-330">在 .NET Framework 版本1.0 和1.1 中，此方法由提供程序的 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> 方法返回的 <xref:System.CodeDom.Compiler.ICodeGenerator> 实现提供。</span><span class="sxs-lookup"><span data-stu-id="18a6d-330">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="18a6d-331">在版本2.0 中，可以直接在代码提供程序上调用此方法，即使代码提供程序未重写此方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-331">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="18a6d-332">如果代码提供程序未重写此方法，则由基类调用 <xref:System.CodeDom.Compiler.ICodeGenerator> 实现。</span><span class="sxs-lookup"><span data-stu-id="18a6d-332">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="18a6d-333">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</span><span class="sxs-lookup"><span data-stu-id="18a6d-333">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="18a6d-334">如果重写此方法，则不能调用基类的相应方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-334">If you override this method, you must not call the corresponding method of the base class.</span></span> <span data-ttu-id="18a6d-335">基类方法使用过时的 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法在派生类中创建一个生成器，以便与使用代码生成器的预先存在的提供程序兼容。</span><span class="sxs-lookup"><span data-stu-id="18a6d-335">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span></span> <span data-ttu-id="18a6d-336">然后，基类方法调用 <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> 实现中的等效方法来执行此函数。</span><span class="sxs-lookup"><span data-stu-id="18a6d-336">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span></span> <span data-ttu-id="18a6d-337">如果从不使用代码生成器的代码提供程序调用基类方法，将会收到 <see cref="T:System.NotImplementedException" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-337">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span></span></para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeDeclaration" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GetAllCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllCompilerInfo () As CompilerInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::CodeDom::Compiler::CompilerInfo ^&gt; ^ GetAllCompilerInfo();" />
      <MemberSignature Language="F#" Value="static member GetAllCompilerInfo : unit -&gt; System.CodeDom.Compiler.CompilerInfo[]" Usage="System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="18a6d-338">返回此计算机的语言提供程序和编译器配置设置。</span><span class="sxs-lookup"><span data-stu-id="18a6d-338">Returns the language provider and compiler configuration settings for this computer.</span></span></summary>
        <returns><span data-ttu-id="18a6d-339">一个 <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> 类型的数组，表示所有配置的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现的设置。</span><span class="sxs-lookup"><span data-stu-id="18a6d-339">An array of type <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> representing the settings of all configured <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implementations.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18a6d-340">使用 <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> 方法可枚举计算机上的语言提供程序设置。</span><span class="sxs-lookup"><span data-stu-id="18a6d-340">Use the <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> method to enumerate the language provider settings on a computer.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="18a6d-341">在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]中，.NET Framework 提供的默认语言提供程序未在[&lt;system.exception&gt; 元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)编译器配置节中指定，因此不能将其删除，因此此方法返回配置文件中的默认提供程序和任何指定的信息。</span><span class="sxs-lookup"><span data-stu-id="18a6d-341">In the [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], the default language providers supplied by the .NET Framework are not specified in the [&lt;system.codedom&gt; Element](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) compiler configuration section and cannot be removed, so this method returns information about the default providers and any specified in the configuration file.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18a6d-342">下面的代码示例枚举计算机上的语言提供程序，并显示每个语言提供程序的配置和编译器设置。</span><span class="sxs-lookup"><span data-stu-id="18a6d-342">The following code example enumerates the language providers on the computer and displays the configuration and compiler settings for each language provider.</span></span> <span data-ttu-id="18a6d-343">此代码示例是为 <xref:System.CodeDom.Compiler.CompilerInfo> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="18a6d-343">This code example is part of a larger example provided for the <xref:System.CodeDom.Compiler.CompilerInfo> class.</span></span>  
  
 [!code-cpp[CodeDom_CompilerInfo#8](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#8)]
 [!code-csharp[CodeDom_CompilerInfo#8](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#8)]
 [!code-vb[CodeDom_CompilerInfo#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="18a6d-344">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="18a6d-344">The caller does not have the required permission.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="18a6d-345">完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="18a6d-345">for full trust for the immediate caller.</span></span> <span data-ttu-id="18a6d-346">部分信任的程式碼無法使用此成員。</span><span class="sxs-lookup"><span data-stu-id="18a6d-346">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md"><span data-ttu-id="18a6d-347">编译器和语言提供程序设置架构</span><span class="sxs-lookup"><span data-stu-id="18a6d-347">Compiler and Language Provider Settings Schema</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo GetCompilerInfo (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo GetCompilerInfo(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompilerInfo (language As String) As CompilerInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CompilerInfo ^ GetCompilerInfo(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member GetCompilerInfo : string -&gt; System.CodeDom.Compiler.CompilerInfo" Usage="System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language"><span data-ttu-id="18a6d-348">语言名称。</span><span class="sxs-lookup"><span data-stu-id="18a6d-348">A language name.</span></span></param>
        <summary><span data-ttu-id="18a6d-349">返回指定语言的语言提供程序和编译器配置设置。</span><span class="sxs-lookup"><span data-stu-id="18a6d-349">Returns the language provider and compiler configuration settings for the specified language.</span></span></summary>
        <returns><span data-ttu-id="18a6d-350">一个 <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> 对象，由已配置的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现的设置填充。</span><span class="sxs-lookup"><span data-stu-id="18a6d-350">A <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> object populated with settings of the configured <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implementation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18a6d-351">计算机配置文件中的[&lt;system.object&gt; 元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)包含计算机上每个 <xref:System.CodeDom.Compiler.CodeDomProvider> 实现的语言提供程序和编译器配置设置。</span><span class="sxs-lookup"><span data-stu-id="18a6d-351">The [&lt;system.codedom&gt; Element](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) in the machine configuration file contains the language provider and compiler configuration settings for each <xref:System.CodeDom.Compiler.CodeDomProvider> implementation on the computer.</span></span> <span data-ttu-id="18a6d-352">有关计算机配置文件的信息，请参阅[配置应用](~/docs/framework/configure-apps/index.md)中的计算机配置文件部分。</span><span class="sxs-lookup"><span data-stu-id="18a6d-352">For information about machine configuration files, see the Machine Configuration Files section in [Configuring Apps](~/docs/framework/configure-apps/index.md).</span></span> <span data-ttu-id="18a6d-353"><xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> 方法会搜索指定语言名称的每个提供程序配置元素。</span><span class="sxs-lookup"><span data-stu-id="18a6d-353">The <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> method searches each provider configuration element for the specified language name.</span></span> <span data-ttu-id="18a6d-354">返回的 <xref:System.CodeDom.Compiler.CompilerInfo> 实例包含已配置的语言提供程序和编译器设置。</span><span class="sxs-lookup"><span data-stu-id="18a6d-354">The returned <xref:System.CodeDom.Compiler.CompilerInfo> instance contains the configured language provider and compiler settings.</span></span>  
  
 <span data-ttu-id="18a6d-355"><xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> 方法将检查是否至少有一个提供程序实现支持特定语言。</span><span class="sxs-lookup"><span data-stu-id="18a6d-355">The <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> method checks whether at least one provider implementation supports a specific language.</span></span> <span data-ttu-id="18a6d-356">您可以使用 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> 验证语言名称，然后将其传递给 <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>。</span><span class="sxs-lookup"><span data-stu-id="18a6d-356">You can validate a language name using <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> before passing it to <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>.</span></span> <span data-ttu-id="18a6d-357">这会阻止在访问不受支持的语言名称的 <xref:System.CodeDom.Compiler.CompilerInfo> 实例时引发 <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="18a6d-357">This prevents throwing a <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> when you access the <xref:System.CodeDom.Compiler.CompilerInfo> instance for an unsupported language name.</span></span>  
  
 <span data-ttu-id="18a6d-358">如果为输入语言名称配置了多个提供程序实现，<xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> 将从上一个匹配提供程序配置元素返回设置。</span><span class="sxs-lookup"><span data-stu-id="18a6d-358">If more than one provider implementation is configured for the input language name, <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> returns the settings from the last matching provider configuration element.</span></span>  
  
 <span data-ttu-id="18a6d-359">语言名称不区分大小写。</span><span class="sxs-lookup"><span data-stu-id="18a6d-359">Language names are case-insensitive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18a6d-360">下面的代码示例确定输入语言的 <xref:System.CodeDom.Compiler.CodeDomProvider> 实现，并显示语言提供程序的配置设置。</span><span class="sxs-lookup"><span data-stu-id="18a6d-360">The following code example determines the <xref:System.CodeDom.Compiler.CodeDomProvider> implementation for an input language and displays the configured settings for the language provider.</span></span> <span data-ttu-id="18a6d-361">此代码示例是为 <xref:System.CodeDom.Compiler.CompilerInfo> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="18a6d-361">This code example is part of a larger example provided for the <xref:System.CodeDom.Compiler.CompilerInfo> class.</span></span>  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException"><span data-ttu-id="18a6d-362"><paramref name="language" /> 在此计算机上没有已配置的提供程序。</span><span class="sxs-lookup"><span data-stu-id="18a6d-362">The <paramref name="language" /> does not have a configured provider on this computer.</span></span></exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException"><span data-ttu-id="18a6d-363"><paramref name="language" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-363">The <paramref name="language" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="18a6d-364">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="18a6d-364">The caller does not have the required permission.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="18a6d-365">完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="18a6d-365">for full trust for the immediate caller.</span></span> <span data-ttu-id="18a6d-366">部分信任的程式碼無法使用此成員。</span><span class="sxs-lookup"><span data-stu-id="18a6d-366">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md"><span data-ttu-id="18a6d-367">编译器和语言提供程序设置架构</span><span class="sxs-lookup"><span data-stu-id="18a6d-367">Compiler and Language Provider Settings Schema</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.TypeConverter GetConverter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.TypeConverter GetConverter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetConverter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::TypeConverter ^ GetConverter(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetConverter : Type -&gt; System.ComponentModel.TypeConverter&#xA;override this.GetConverter : Type -&gt; System.ComponentModel.TypeConverter" Usage="codeDomProvider.GetConverter type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="18a6d-368">要为其检索类型转换器的对象类型。</span><span class="sxs-lookup"><span data-stu-id="18a6d-368">The type of object to retrieve a type converter for.</span></span></param>
        <summary><span data-ttu-id="18a6d-369">获取指定数据类型的 <see cref="T:System.ComponentModel.TypeConverter" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-369">Gets a <see cref="T:System.ComponentModel.TypeConverter" /> for the specified data type.</span></span></summary>
        <returns><span data-ttu-id="18a6d-370">指定类型的 <see cref="T:System.ComponentModel.TypeConverter" />；如果无法找到指定类型的 <see langword="null" />，则为 <see cref="T:System.ComponentModel.TypeConverter" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-370">A <see cref="T:System.ComponentModel.TypeConverter" /> for the specified type, or <see langword="null" /> if a <see cref="T:System.ComponentModel.TypeConverter" /> for the specified type cannot be found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18a6d-371">派生类可以重写此方法，以便为特定的数据类型提供类型转换器的特定类型。</span><span class="sxs-lookup"><span data-stu-id="18a6d-371">A derived class can override this method to provide specific types of type converters for specific data types.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetLanguageFromExtension">
      <MemberSignature Language="C#" Value="public static string GetLanguageFromExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetLanguageFromExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLanguageFromExtension (extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetLanguageFromExtension(System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member GetLanguageFromExtension : string -&gt; string" Usage="System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension extension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="extension"><span data-ttu-id="18a6d-372">一个文件扩展名。</span><span class="sxs-lookup"><span data-stu-id="18a6d-372">A file name extension.</span></span></param>
        <summary><span data-ttu-id="18a6d-373">返回与指定文件扩展名关联的语言名称，如 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 编译器配置节中所配置的那样。</span><span class="sxs-lookup"><span data-stu-id="18a6d-373">Returns a language name associated with the specified file name extension, as configured in the <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> compiler configuration section.</span></span></summary>
        <returns><span data-ttu-id="18a6d-374">与文件扩展名关联的语言名称，如 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 编译器配置设置中所配置的那样。</span><span class="sxs-lookup"><span data-stu-id="18a6d-374">A language name associated with the file name extension, as configured in the <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> compiler configuration settings.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18a6d-375">计算机配置文件（Machine.config）中的[&lt;system.object&gt; 元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)包含计算机上每个 <xref:System.CodeDom.Compiler.CodeDomProvider> 实现的语言提供程序和编译器配置设置。</span><span class="sxs-lookup"><span data-stu-id="18a6d-375">The [&lt;system.codedom&gt; Element](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) in the machine configuration file (Machine.config) contains the language provider and compiler configuration settings for each <xref:System.CodeDom.Compiler.CodeDomProvider> implementation on the computer.</span></span> <span data-ttu-id="18a6d-376"><xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> 方法在每个提供程序配置元素中搜索指定的文件扩展名。</span><span class="sxs-lookup"><span data-stu-id="18a6d-376">The <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> method searches each provider configuration element for the specified file name extension.</span></span>  
  
 <span data-ttu-id="18a6d-377"><xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> 方法将检查是否至少有一个提供程序实现支持特定的文件扩展名。</span><span class="sxs-lookup"><span data-stu-id="18a6d-377">The <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> method checks whether at least one provider implementation supports a specific file name extension.</span></span> <span data-ttu-id="18a6d-378">您可以使用 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> 验证文件扩展名，然后将其传递给 <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>。</span><span class="sxs-lookup"><span data-stu-id="18a6d-378">You can validate a file name extension using <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> before passing it to <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>.</span></span> <span data-ttu-id="18a6d-379">这会阻止 <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> 引发不受支持的文件扩展名的 <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="18a6d-379">This prevents <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> from throwing a <xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> for an unsupported file name extension.</span></span>  
  
 <span data-ttu-id="18a6d-380">如果提供程序实现支持输入文件扩展名，并且为该提供程序配置了多个受支持的语言，则 <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> 将返回该提供程序的第一个语言名称。</span><span class="sxs-lookup"><span data-stu-id="18a6d-380">If a provider implementation supports the input file name extension, and there are multiple supported languages configured for that provider, then <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> returns the first language name for that provider.</span></span> <span data-ttu-id="18a6d-381">如果为输入文件扩展名配置了多个提供程序实现，<xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> 将从上一个匹配提供程序配置元素返回语言名称。</span><span class="sxs-lookup"><span data-stu-id="18a6d-381">If more than one provider implementation is configured for the input file name extension, <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A> returns the language name from the last matching provider configuration element.</span></span>  
  
 <span data-ttu-id="18a6d-382">语言名称和文件扩展名不区分大小写。</span><span class="sxs-lookup"><span data-stu-id="18a6d-382">Language names and file name extensions are case-insensitive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18a6d-383">下面的代码示例确定输入文件扩展名的 <xref:System.CodeDom.Compiler.CodeDomProvider> 实现，并显示语言提供程序的配置设置。</span><span class="sxs-lookup"><span data-stu-id="18a6d-383">The following code example determines the <xref:System.CodeDom.Compiler.CodeDomProvider> implementation for an input file name extension and displays the configured settings for the language provider.</span></span> <span data-ttu-id="18a6d-384">此代码示例是为 <xref:System.CodeDom.Compiler.CompilerInfo> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="18a6d-384">This code example is part of a larger example provided for the <xref:System.CodeDom.Compiler.CompilerInfo> class.</span></span>  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException"><span data-ttu-id="18a6d-385"><paramref name="extension" /> 在此计算机上没有已配置的语言提供程序。</span><span class="sxs-lookup"><span data-stu-id="18a6d-385">The <paramref name="extension" /> does not have a configured language provider on this computer.</span></span></exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException"><span data-ttu-id="18a6d-386"><paramref name="extension" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-386">The <paramref name="extension" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="18a6d-387">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="18a6d-387">The caller does not have the required permission.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="18a6d-388">完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="18a6d-388">for full trust for the immediate caller.</span></span> <span data-ttu-id="18a6d-389">部分信任的程式碼無法使用此成員。</span><span class="sxs-lookup"><span data-stu-id="18a6d-389">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md"><span data-ttu-id="18a6d-390">编译器和语言提供程序设置架构</span><span class="sxs-lookup"><span data-stu-id="18a6d-390">Compiler and Language Provider Settings Schema</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTypeOutput">
      <MemberSignature Language="C#" Value="public virtual string GetTypeOutput (System.CodeDom.CodeTypeReference type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeOutput(class System.CodeDom.CodeTypeReference type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetTypeOutput(System.CodeDom.CodeTypeReference)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeOutput (type As CodeTypeReference) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetTypeOutput(System::CodeDom::CodeTypeReference ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeOutput : System.CodeDom.CodeTypeReference -&gt; string&#xA;override this.GetTypeOutput : System.CodeDom.CodeTypeReference -&gt; string" Usage="codeDomProvider.GetTypeOutput type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.CodeDom.CodeTypeReference" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="18a6d-391">指示返回类型的 <see cref="T:System.CodeDom.CodeTypeReference" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-391">A <see cref="T:System.CodeDom.CodeTypeReference" /> that indicates the type to return.</span></span></param>
        <summary><span data-ttu-id="18a6d-392">获取由指定的 <see cref="T:System.CodeDom.CodeTypeReference" /> 指示的类型。</span><span class="sxs-lookup"><span data-stu-id="18a6d-392">Gets the type indicated by the specified <see cref="T:System.CodeDom.CodeTypeReference" />.</span></span></summary>
        <returns><span data-ttu-id="18a6d-393">指定类型的文本表示形式，针对此代码生成器生成代码时所用的语言进行了格式设置。</span><span class="sxs-lookup"><span data-stu-id="18a6d-393">A text representation of the specified type, formatted for the language in which code is generated by this code generator.</span></span> <span data-ttu-id="18a6d-394">例如，在 Visual Basic 中，为 <see cref="T:System.CodeDom.CodeTypeReference" /> 类型传入 <see cref="T:System.Int32" /> 将返回“Integer”。</span><span class="sxs-lookup"><span data-stu-id="18a6d-394">In Visual Basic, for example, passing in a <see cref="T:System.CodeDom.CodeTypeReference" /> for the <see cref="T:System.Int32" /> type will return "Integer".</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="18a6d-395">在 .NET Framework 版本1.0 和1.1 中，此方法由提供程序的 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> 方法返回的 <xref:System.CodeDom.Compiler.ICodeGenerator> 实现提供。</span><span class="sxs-lookup"><span data-stu-id="18a6d-395">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="18a6d-396">在版本2.0 中，可以直接在代码提供程序上调用此方法，即使代码提供程序未重写此方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-396">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="18a6d-397">如果代码提供程序未重写此方法，则由基类调用 <xref:System.CodeDom.Compiler.ICodeGenerator> 实现。</span><span class="sxs-lookup"><span data-stu-id="18a6d-397">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="18a6d-398">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</span><span class="sxs-lookup"><span data-stu-id="18a6d-398">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="18a6d-399">如果重写此方法，则不能调用基类的相应方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-399">If you override this method, you must not call the corresponding method of the base class.</span></span> <span data-ttu-id="18a6d-400">基类方法使用过时的 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法在派生类中创建一个生成器，以便与使用代码生成器的预先存在的提供程序兼容。</span><span class="sxs-lookup"><span data-stu-id="18a6d-400">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span></span> <span data-ttu-id="18a6d-401">然后，基类方法调用 <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> 实现中的等效方法来执行此函数。</span><span class="sxs-lookup"><span data-stu-id="18a6d-401">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span></span> <span data-ttu-id="18a6d-402">如果从不使用代码生成器的代码提供程序调用基类方法，将会收到 <see cref="T:System.NotImplementedException" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-402">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="IsDefinedExtension">
      <MemberSignature Language="C#" Value="public static bool IsDefinedExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedExtension (extension As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedExtension(System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member IsDefinedExtension : string -&gt; bool" Usage="System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension extension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="extension"><span data-ttu-id="18a6d-403">一个文件扩展名。</span><span class="sxs-lookup"><span data-stu-id="18a6d-403">A file name extension.</span></span></param>
        <summary><span data-ttu-id="18a6d-404">测试文件扩展名是否在计算机上配置了关联的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="18a6d-404">Tests whether a file name extension has an associated <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implementation configured on the computer.</span></span></summary>
        <returns><span data-ttu-id="18a6d-405">如果为指定的文件扩展名配置了 <see langword="true" /> 实现，则为 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />；否则，为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-405"><see langword="true" /> if a <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implementation is configured for the specified file name extension; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18a6d-406">计算机配置文件（Machine.config）中的[&lt;system.object&gt; 元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)包含计算机上每个 <xref:System.CodeDom.Compiler.CodeDomProvider> 实现的语言提供程序和编译器配置设置。</span><span class="sxs-lookup"><span data-stu-id="18a6d-406">The [&lt;system.codedom&gt; Element](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) in the machine configuration file (Machine.config) contains the language provider and compiler configuration settings for each <xref:System.CodeDom.Compiler.CodeDomProvider> implementation on the computer.</span></span> <span data-ttu-id="18a6d-407"><xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> 方法在提供程序配置元素中搜索指定的文件扩展名。</span><span class="sxs-lookup"><span data-stu-id="18a6d-407">The <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A> method searches the provider configuration elements for the specified file name extension.</span></span>  
  
 <span data-ttu-id="18a6d-408">文件扩展名不区分大小写。</span><span class="sxs-lookup"><span data-stu-id="18a6d-408">File name extensions are case-insensitive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18a6d-409">下面的代码示例确定输入文件扩展名的 <xref:System.CodeDom.Compiler.CodeDomProvider> 实现，并显示语言提供程序的配置设置。</span><span class="sxs-lookup"><span data-stu-id="18a6d-409">The following code example determines the <xref:System.CodeDom.Compiler.CodeDomProvider> implementation for an input file name extension and displays the configured settings for the language provider.</span></span> <span data-ttu-id="18a6d-410">此代码示例是为 <xref:System.CodeDom.Compiler.CompilerInfo> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="18a6d-410">This code example is part of a larger example provided for the <xref:System.CodeDom.Compiler.CompilerInfo> class.</span></span>  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="18a6d-411"><paramref name="extension" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-411">The <paramref name="extension" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="18a6d-412">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="18a6d-412">The caller does not have the required permission.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="18a6d-413">完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="18a6d-413">for full trust for the immediate caller.</span></span> <span data-ttu-id="18a6d-414">部分信任的程式碼無法使用此成員。</span><span class="sxs-lookup"><span data-stu-id="18a6d-414">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md"><span data-ttu-id="18a6d-415">编译器和语言提供程序设置架构</span><span class="sxs-lookup"><span data-stu-id="18a6d-415">Compiler and Language Provider Settings Schema</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsDefinedLanguage">
      <MemberSignature Language="C#" Value="public static bool IsDefinedLanguage (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedLanguage(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedLanguage (language As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedLanguage(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member IsDefinedLanguage : string -&gt; bool" Usage="System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language"><span data-ttu-id="18a6d-416">语言名称。</span><span class="sxs-lookup"><span data-stu-id="18a6d-416">The language name.</span></span></param>
        <summary><span data-ttu-id="18a6d-417">测试某语言是否已在计算机上配置了 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现。</span><span class="sxs-lookup"><span data-stu-id="18a6d-417">Tests whether a language has a <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implementation configured on the computer.</span></span></summary>
        <returns><span data-ttu-id="18a6d-418">如果为指定语言配置了 <see langword="true" /> 实现，则为 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />；否则，为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-418"><see langword="true" /> if a <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> implementation is configured for the specified language; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18a6d-419">计算机配置文件（Machine.config）中的[&lt;system.object&gt; 元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)包含计算机上每个 <xref:System.CodeDom.Compiler.CodeDomProvider> 实现的语言提供程序和编译器配置设置。</span><span class="sxs-lookup"><span data-stu-id="18a6d-419">The [&lt;system.codedom&gt; Element](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md) in the machine configuration file (Machine.config) contains the language provider and compiler configuration settings for each <xref:System.CodeDom.Compiler.CodeDomProvider> implementation on the computer.</span></span> <span data-ttu-id="18a6d-420"><xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> 方法在提供程序配置元素中搜索指定的语言名称。</span><span class="sxs-lookup"><span data-stu-id="18a6d-420">The <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> method searches the provider configuration elements for the specified language name.</span></span>  
  
 <span data-ttu-id="18a6d-421">语言名称不区分大小写。</span><span class="sxs-lookup"><span data-stu-id="18a6d-421">Language names are case-insensitive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="18a6d-422">下面的代码示例确定输入语言的 <xref:System.CodeDom.Compiler.CodeDomProvider> 实现，并显示语言提供程序的配置设置。</span><span class="sxs-lookup"><span data-stu-id="18a6d-422">The following code example determines the <xref:System.CodeDom.Compiler.CodeDomProvider> implementation for an input language and displays the configured settings for the language provider.</span></span> <span data-ttu-id="18a6d-423">此代码示例是为 <xref:System.CodeDom.Compiler.CompilerInfo> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="18a6d-423">This code example is part of a larger example provided for the <xref:System.CodeDom.Compiler.CompilerInfo> class.</span></span>  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="18a6d-424"><paramref name="language" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-424">The <paramref name="language" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="18a6d-425">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="18a6d-425">The caller does not have the required permission.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="18a6d-426">完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="18a6d-426">for full trust for the immediate caller.</span></span> <span data-ttu-id="18a6d-427">部分信任的程式碼無法使用此成員。</span><span class="sxs-lookup"><span data-stu-id="18a6d-427">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md"><span data-ttu-id="18a6d-428">编译器和语言提供程序设置架构</span><span class="sxs-lookup"><span data-stu-id="18a6d-428">Compiler and Language Provider Settings Schema</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual bool IsValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsValidIdentifier (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsValidIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsValidIdentifier : string -&gt; bool&#xA;override this.IsValidIdentifier : string -&gt; bool" Usage="codeDomProvider.IsValidIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="18a6d-429">要验证为一个有效标识符的值。</span><span class="sxs-lookup"><span data-stu-id="18a6d-429">The value to verify as a valid identifier.</span></span></param>
        <summary><span data-ttu-id="18a6d-430">返回一个值，该值指示指定的值是否是当前语言的有效标识符。</span><span class="sxs-lookup"><span data-stu-id="18a6d-430">Returns a value that indicates whether the specified value is a valid identifier for the current language.</span></span></summary>
        <returns><span data-ttu-id="18a6d-431">如果 <see langword="true" /> 参数是有效标识符，则为 <paramref name="value" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-431"><see langword="true" /> if the <paramref name="value" /> parameter is a valid identifier; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18a6d-432">此方法测试标识符是否有效。</span><span class="sxs-lookup"><span data-stu-id="18a6d-432">This method tests whether an identifier is valid.</span></span> <span data-ttu-id="18a6d-433"><xref:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier%2A> 方法是特定于提供程序的。</span><span class="sxs-lookup"><span data-stu-id="18a6d-433">The <xref:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier%2A> method is provider specific.</span></span> <span data-ttu-id="18a6d-434">对于一个提供程序有效的标识符可能对其他提供程序无效。</span><span class="sxs-lookup"><span data-stu-id="18a6d-434">Identifiers that are valid for one provider might not be valid for other providers.</span></span> <span data-ttu-id="18a6d-435">如果 `value` 包含 ASCII 字符范围之外的字符，请检查可用于编译代码的所有语言的标识符。</span><span class="sxs-lookup"><span data-stu-id="18a6d-435">If `value` contains characters outside of the ASCII character range, check the identifier for all the languages that might be used to compile the code.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="18a6d-436">在 .NET Framework 版本1.0 和1.1 中，此方法由提供程序的 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> 方法返回的 <xref:System.CodeDom.Compiler.ICodeGenerator> 实现提供。</span><span class="sxs-lookup"><span data-stu-id="18a6d-436">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="18a6d-437">在版本2.0 中，可以直接在代码提供程序上调用此方法，即使代码提供程序未重写此方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-437">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="18a6d-438">如果代码提供程序未重写此方法，则由基类调用 <xref:System.CodeDom.Compiler.ICodeGenerator> 实现。</span><span class="sxs-lookup"><span data-stu-id="18a6d-438">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="18a6d-439">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</span><span class="sxs-lookup"><span data-stu-id="18a6d-439">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="18a6d-440">当在派生类中重写 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" /> 时，将方法设计为仅在值符合语言规则且不与关键字冲突时返回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-440">When overriding <see cref="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" /> in a derived class, design the method to return <see langword="true" /> only if the value fits the rules of the language and does not conflict with a keyword.</span></span>  
  
<span data-ttu-id="18a6d-441">如果重写此方法，则不能调用基类的相应方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-441">If you override this method, you must not call the corresponding method of the base class.</span></span> <span data-ttu-id="18a6d-442">基类方法使用过时的 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法在派生类中创建一个生成器，以便与使用代码生成器的预先存在的提供程序兼容。</span><span class="sxs-lookup"><span data-stu-id="18a6d-442">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span></span> <span data-ttu-id="18a6d-443">然后，基类方法调用 <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> 实现中的等效方法来执行此函数。</span><span class="sxs-lookup"><span data-stu-id="18a6d-443">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span></span> <span data-ttu-id="18a6d-444">如果从不使用代码生成器的代码提供程序调用基类方法，将会收到 <see cref="T:System.NotImplementedException" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-444">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="LanguageOptions">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.LanguageOptions LanguageOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.CodeDom.Compiler.LanguageOptions LanguageOptions" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.LanguageOptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LanguageOptions As LanguageOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::CodeDom::Compiler::LanguageOptions LanguageOptions { System::CodeDom::Compiler::LanguageOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.LanguageOptions : System.CodeDom.Compiler.LanguageOptions" Usage="System.CodeDom.Compiler.CodeDomProvider.LanguageOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.LanguageOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="18a6d-445">获取语言功能标识符。</span><span class="sxs-lookup"><span data-stu-id="18a6d-445">Gets a language features identifier.</span></span></summary>
        <value><span data-ttu-id="18a6d-446">指示语言的特殊功能的 <see cref="T:System.CodeDom.Compiler.LanguageOptions" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-446">A <see cref="T:System.CodeDom.Compiler.LanguageOptions" /> that indicates special features of the language.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.CodeCompileUnit Parse (System.IO.TextReader codeStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.CodeCompileUnit Parse(class System.IO.TextReader codeStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Parse(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Parse (codeStream As TextReader) As CodeCompileUnit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::CodeCompileUnit ^ Parse(System::IO::TextReader ^ codeStream);" />
      <MemberSignature Language="F#" Value="abstract member Parse : System.IO.TextReader -&gt; System.CodeDom.CodeCompileUnit&#xA;override this.Parse : System.IO.TextReader -&gt; System.CodeDom.CodeCompileUnit" Usage="codeDomProvider.Parse codeStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeCompileUnit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeStream" Type="System.IO.TextReader" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codeStream"><span data-ttu-id="18a6d-447">用于读取待分析代码的 <see cref="T:System.IO.TextReader" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="18a6d-447">A <see cref="T:System.IO.TextReader" /> object that is used to read the code to be parsed.</span></span></param>
        <summary><span data-ttu-id="18a6d-448">将从指定文本流读取的代码编译进 <see cref="T:System.CodeDom.CodeCompileUnit" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-448">Compiles the code read from the specified text stream into a <see cref="T:System.CodeDom.CodeCompileUnit" />.</span></span></summary>
        <returns><span data-ttu-id="18a6d-449"><see cref="T:System.CodeDom.CodeCompileUnit" />，包含已分析代码的表示形式。</span><span class="sxs-lookup"><span data-stu-id="18a6d-449">A <see cref="T:System.CodeDom.CodeCompileUnit" /> that contains a representation of the parsed code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="18a6d-450">在 .NET Framework 版本1.0 和1.1 中，此方法由提供程序的 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateParser%2A> 方法返回的 <xref:System.CodeDom.Compiler.ICodeParser> 实现提供。</span><span class="sxs-lookup"><span data-stu-id="18a6d-450">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeParser> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateParser%2A> method of the provider.</span></span> <span data-ttu-id="18a6d-451">在版本2.0 中，可以直接在代码提供程序上调用此方法，即使代码提供程序未重写此方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-451">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="18a6d-452">如果代码提供程序未重写此方法，则由基类调用 <xref:System.CodeDom.Compiler.ICodeParser> 实现。</span><span class="sxs-lookup"><span data-stu-id="18a6d-452">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeParser> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="18a6d-453">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</span><span class="sxs-lookup"><span data-stu-id="18a6d-453">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="18a6d-454">如果重写此方法，则不能调用基类的相应方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-454">If you override this method, you must not call the corresponding method of the base class.</span></span> <span data-ttu-id="18a6d-455">基类方法使用过时的 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" /> 方法在派生类中创建分析器，以便与使用代码分析器的预先存在的提供程序兼容。</span><span class="sxs-lookup"><span data-stu-id="18a6d-455">The base-class method creates a parser in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" /> method for compatibility with preexisting providers that use code parsers.</span></span> <span data-ttu-id="18a6d-456">然后，基类方法调用 <see cref="T:System.CodeDom.Compiler.ICodeParser" /> 实现中的等效方法来执行此函数。</span><span class="sxs-lookup"><span data-stu-id="18a6d-456">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeParser" /> implementation to perform this function.</span></span> <span data-ttu-id="18a6d-457">如果从不使用代码分析器的代码提供程序调用基类方法，将会收到 <see cref="T:System.NotImplementedException" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-457">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code parser.</span></span></para></block>
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.IO.TextReader" />
      </Docs>
    </Member>
    <Member MemberName="Supports">
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport generatorSupport);" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport generatorSupport) cil managed" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Supports(System.CodeDom.Compiler.GeneratorSupport)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport generatorSupport);" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="abstract member Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool&#xA;override this.Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool" Usage="codeDomProvider.Supports generatorSupport" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport supports) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Supports (supports As GeneratorSupport) As Boolean" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool&#xA;override this.Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool" Usage="codeDomProvider.Supports supports" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generatorSupport" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="supports" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generatorSupport"><span data-ttu-id="18a6d-458">一个 <see cref="T:System.CodeDom.Compiler.GeneratorSupport" /> 对象，指示要验证的代码生成支持类型。</span><span class="sxs-lookup"><span data-stu-id="18a6d-458">A <see cref="T:System.CodeDom.Compiler.GeneratorSupport" /> object that indicates the type of code generation support to verify.</span></span></param>
        <param name="supports">To be added.</param>
        <summary><span data-ttu-id="18a6d-459">返回一个值，该值指示是否提供了指定的代码生成支持。</span><span class="sxs-lookup"><span data-stu-id="18a6d-459">Returns a value indicating whether the specified code generation support is provided.</span></span></summary>
        <returns><span data-ttu-id="18a6d-460">如果提供了指定的代码生成支持，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-460"><see langword="true" /> if the specified code generation support is provided; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="18a6d-461">可以一次使用多个 <xref:System.CodeDom.Compiler.GeneratorSupport> 标志来调用此方法，通过将一组相应的功能标志与一个二元 `OR` 运算符（&#124;）相联接来测试一组功能。</span><span class="sxs-lookup"><span data-stu-id="18a6d-461">This method can be called with a number of <xref:System.CodeDom.Compiler.GeneratorSupport> flags at once to test for a set of capabilities by joining a set of appropriate capability flags together with a binary `OR` operator (&#124;).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="18a6d-462">在 .NET Framework 版本1.0 和1.1 中，此方法由提供程序的 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> 方法返回的 <xref:System.CodeDom.Compiler.ICodeGenerator> 实现提供。</span><span class="sxs-lookup"><span data-stu-id="18a6d-462">In the .NET Framework versions 1.0 and 1.1, this method is provided by the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation that is returned by the <xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A> method of the provider.</span></span> <span data-ttu-id="18a6d-463">在版本2.0 中，可以直接在代码提供程序上调用此方法，即使代码提供程序未重写此方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-463">In version 2.0, this method can be called directly on the code provider even if it is not overridden by the code provider.</span></span> <span data-ttu-id="18a6d-464">如果代码提供程序未重写此方法，则由基类调用 <xref:System.CodeDom.Compiler.ICodeGenerator> 实现。</span><span class="sxs-lookup"><span data-stu-id="18a6d-464">If the code provider does not override this method, the <xref:System.CodeDom.Compiler.ICodeGenerator> implementation is called by the base class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="18a6d-465">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</span><span class="sxs-lookup"><span data-stu-id="18a6d-465">Neither this method nor the <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method is overridden in a derived class.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="18a6d-466">如果重写此方法，则不能调用基类的相应方法。</span><span class="sxs-lookup"><span data-stu-id="18a6d-466">If you override this method, you must not call the corresponding method of the base class.</span></span> <span data-ttu-id="18a6d-467">基类方法使用过时的 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法在派生类中创建一个生成器，以便与使用代码生成器的预先存在的提供程序兼容。</span><span class="sxs-lookup"><span data-stu-id="18a6d-467">The base-class method creates a generator in the derived class using the obsolete <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> method for compatibility with preexisting providers that use code generators.</span></span> <span data-ttu-id="18a6d-468">然后，基类方法调用 <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> 实现中的等效方法来执行此函数。</span><span class="sxs-lookup"><span data-stu-id="18a6d-468">The base-class method then calls the equivalent method in the <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> implementation to perform this function.</span></span> <span data-ttu-id="18a6d-469">如果从不使用代码生成器的代码提供程序调用基类方法，将会收到 <see cref="T:System.NotImplementedException" />。</span><span class="sxs-lookup"><span data-stu-id="18a6d-469">You will get a <see cref="T:System.NotImplementedException" /> if you call the base-class method from a code provider that does not use a code generator.</span></span></para></block>
        <altmember cref="T:System.CodeDom.Compiler.GeneratorSupport" />
      </Docs>
    </Member>
  </Members>
</Type>
