<Type Name="RemotingServices" FullName="System.Runtime.Remoting.RemotingServices">
  <Metadata><Meta Name="ms.openlocfilehash" Value="805a83ea5069883e5631234b3bca4d4943e10a71" /><Meta Name="ms.sourcegitcommit" Value="a8ff98b48bda124cfcb2605f5da9b21bc6dcd791" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="02/14/2020" /><Meta Name="ms.locfileid" Value="77221752" /></Metadata><TypeSignature Language="C#" Value="public static class RemotingServices" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed RemotingServices extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.RemotingServices" />
  <TypeSignature Language="VB.NET" Value="Public Class RemotingServices" />
  <TypeSignature Language="C++ CLI" Value="public ref class RemotingServices abstract sealed" />
  <TypeSignature Language="F#" Value="type RemotingServices = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="b27ea-101">提供多种使用和发布远程对象及代理的方法。</span><span class="sxs-lookup"><span data-stu-id="b27ea-101">Provides several methods for using and publishing remoted objects and proxies.</span></span> <span data-ttu-id="b27ea-102">无法继承此类。</span><span class="sxs-lookup"><span data-stu-id="b27ea-102">This class cannot be inherited.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b27ea-103">除非您是处理激活、生存期管理或事务等问题的服务提供程序，否则不需要区分代理引用和对象引用。</span><span class="sxs-lookup"><span data-stu-id="b27ea-103">Unless you are a service provider dealing with issues such as activation, lifetime management, or transactions, you do not need to distinguish between proxy references and object references.</span></span> <span data-ttu-id="b27ea-104">远程处理基础结构使用透明代理，该代理给出远程对象驻留在客户端空间中的印象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-104">The remoting infrastructure uses transparent proxies that give the impression that the remote objects reside in the client's space.</span></span> <span data-ttu-id="b27ea-105">代理通过将对它们进行的调用转发到远程位置的实际对象来实现此目的。</span><span class="sxs-lookup"><span data-stu-id="b27ea-105">Proxies achieve this by forwarding calls made on them to the real objects at remote locations.</span></span>

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b27ea-106">为已知对象创建一个代理。</span><span class="sxs-lookup"><span data-stu-id="b27ea-106">Creates a proxy for a well-known object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classToProxy"><span data-ttu-id="b27ea-107">要连接到的位于服务器端的已知对象的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-107">The <see cref="T:System.Type" /> of a well-known object on the server end to which you want to connect.</span></span></param>
        <param name="url"><span data-ttu-id="b27ea-108">服务器类的 URL。</span><span class="sxs-lookup"><span data-stu-id="b27ea-108">The URL of the server class.</span></span></param>
        <summary><span data-ttu-id="b27ea-109">使用给定的 <see cref="T:System.Type" /> 和 URL，为已知对象创建一个代理。</span><span class="sxs-lookup"><span data-stu-id="b27ea-109">Creates a proxy for a well-known object, given the <see cref="T:System.Type" /> and URL.</span></span></summary>
        <returns><span data-ttu-id="b27ea-110">远程对象的代理，指向由指定的已知对象提供的终结点。</span><span class="sxs-lookup"><span data-stu-id="b27ea-110">A proxy to the remote object that points to an endpoint served by the specified well-known object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b27ea-111">返回的代理对象指向由指定的已知对象提供的终结点。</span><span class="sxs-lookup"><span data-stu-id="b27ea-111">The returned proxy object points to an endpoint served by the specified well-known object.</span></span> <span data-ttu-id="b27ea-112">在代理上调用方法之前，不会通过网络发送消息。</span><span class="sxs-lookup"><span data-stu-id="b27ea-112">No messages are sent over the network until a method is called on the proxy.</span></span>



## Examples
 <span data-ttu-id="b27ea-113">下面的代码示例演示如何使用 <xref:System.Runtime.Remoting.RemotingServices.Connect%2A> 方法为已知对象创建一个代理。</span><span class="sxs-lookup"><span data-stu-id="b27ea-113">The following code example demonstrates how to use the <xref:System.Runtime.Remoting.RemotingServices.Connect%2A> method to create a proxy to a well-known object.</span></span>

 [!code-cpp[RemotingServices.BasicSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/basicclient.cpp#1)]
 [!code-csharp[RemotingServices.BasicSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/basicclient.cs#1)]
 [!code-vb[RemotingServices.BasicSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/basicclient.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b27ea-114">直接调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="b27ea-114">The immediate caller does not have permission to configure remoting types and channels.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String, data As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string * obj -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="classToProxy"><span data-ttu-id="b27ea-115">要连接到的已知对象的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-115">The <see cref="T:System.Type" /> of the well-known object to which you want to connect.</span></span></param>
        <param name="url"><span data-ttu-id="b27ea-116">已知对象的 URL。</span><span class="sxs-lookup"><span data-stu-id="b27ea-116">The URL of the well-known object.</span></span></param>
        <param name="data"><span data-ttu-id="b27ea-117">信道特定的数据。</span><span class="sxs-lookup"><span data-stu-id="b27ea-117">Channel specific data.</span></span> <span data-ttu-id="b27ea-118">可以为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-118">Can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="b27ea-119">使用给定的 <see cref="T:System.Type" />、URL 和信道特定数据，为已知对象创建一个代理。</span><span class="sxs-lookup"><span data-stu-id="b27ea-119">Creates a proxy for a well-known object, given the <see cref="T:System.Type" />, URL, and channel-specific data.</span></span></summary>
        <returns><span data-ttu-id="b27ea-120">指向由所请求的已知对象提供的终结点的代理。</span><span class="sxs-lookup"><span data-stu-id="b27ea-120">A proxy that points to an endpoint that is served by the requested well-known object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b27ea-121">返回的代理对象指向由指定的已知对象提供的终结点。</span><span class="sxs-lookup"><span data-stu-id="b27ea-121">The returned proxy object points to an endpoint served by the specified well-known object.</span></span> <span data-ttu-id="b27ea-122">在代理上调用方法之前，不会通过网络发送消息。</span><span class="sxs-lookup"><span data-stu-id="b27ea-122">No messages are sent over the network until a method is called on the proxy.</span></span>

 <span data-ttu-id="b27ea-123">`data` 对象用于将信息传递给通道，并传递给 <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="b27ea-123">The `data` object is used to communicate information to the channel, and is passed to the <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b27ea-124">直接调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="b27ea-124">The immediate caller does not have permission to configure remoting types and channels.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public static bool Disconnect (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Disconnect(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Disconnect (obj As MarshalByRefObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Disconnect(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member Disconnect : MarshalByRefObject -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.Disconnect obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="b27ea-125">要与其信道断开连接的对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-125">Object to disconnect from its channel.</span></span></param>
        <summary><span data-ttu-id="b27ea-126">阻止对象通过注册的远程处理信道再接收任何消息。</span><span class="sxs-lookup"><span data-stu-id="b27ea-126">Stops an object from receiving any further messages through the registered remoting channels.</span></span></summary>
        <returns><span data-ttu-id="b27ea-127">如果对象与注册的远程处理信道成功断开连接，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-127"><see langword="true" /> if the object was disconnected from the registered remoting channels successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 <span data-ttu-id="b27ea-128">下面的代码示例演示如何使用 <xref:System.Runtime.Remoting.RemotingServices.Disconnect%2A> 方法断开对象与远程处理通道的连接。</span><span class="sxs-lookup"><span data-stu-id="b27ea-128">The following code example demonstrates how to use the <xref:System.Runtime.Remoting.RemotingServices.Disconnect%2A> method to disconnect an object from the remoting channels.</span></span>

 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b27ea-129"><paramref name="obj" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-129">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b27ea-130"><paramref name="obj" /> 参数是一个代理。</span><span class="sxs-lookup"><span data-stu-id="b27ea-130">The <paramref name="obj" /> parameter is a proxy.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b27ea-131">直接调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="b27ea-131">The immediate caller does not have permission to configure remoting types and channels.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExecuteMessage">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage (MarshalByRefObject target, System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage(class System.MarshalByRefObject target, class System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExecuteMessage (target As MarshalByRefObject, reqMsg As IMethodCallMessage) As IMethodReturnMessage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMethodReturnMessage ^ ExecuteMessage(MarshalByRefObject ^ target, System::Runtime::Remoting::Messaging::IMethodCallMessage ^ reqMsg);" />
      <MemberSignature Language="F#" Value="static member ExecuteMessage : MarshalByRefObject * System.Runtime.Remoting.Messaging.IMethodCallMessage -&gt; System.Runtime.Remoting.Messaging.IMethodReturnMessage" Usage="System.Runtime.Remoting.RemotingServices.ExecuteMessage (target, reqMsg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMethodReturnMessage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.MarshalByRefObject" />
        <Parameter Name="reqMsg" Type="System.Runtime.Remoting.Messaging.IMethodCallMessage" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="b27ea-132">要调用其方法的远程对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-132">The remote object whose method you want to call.</span></span></param>
        <param name="reqMsg"><span data-ttu-id="b27ea-133">指定的远程对象的方法的方法调用消息。</span><span class="sxs-lookup"><span data-stu-id="b27ea-133">A method call message to the specified remote object's method.</span></span></param>
        <summary><span data-ttu-id="b27ea-134">连接到指定的远程对象，并对其执行提供的 <see cref="T:System.Runtime.Remoting.Messaging.IMethodCallMessage" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-134">Connects to the specified remote object, and executes the provided <see cref="T:System.Runtime.Remoting.Messaging.IMethodCallMessage" /> on it.</span></span></summary>
        <returns><span data-ttu-id="b27ea-135">远程方法的响应。</span><span class="sxs-lookup"><span data-stu-id="b27ea-135">The response of the remote method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b27ea-136">当前方法用于在特殊情况下由服务器用于将指定方法调用转发给另一个可能是远程对象的。</span><span class="sxs-lookup"><span data-stu-id="b27ea-136">The current method is used in special cases by the server to forward the specified method call to another, possibly remote, object.</span></span> <span data-ttu-id="b27ea-137">仅当调用方处于适当的上下文时，才能调用此方法。</span><span class="sxs-lookup"><span data-stu-id="b27ea-137">This method can be called only when the caller is in the appropriate context.</span></span>



## Examples
 <span data-ttu-id="b27ea-138">下面的代码示例演示如何使用 <xref:System.Runtime.Remoting.RemotingServices.ExecuteMessage%2A> 方法将方法调用转发到远程对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-138">The following code example demonstrates how to use the <xref:System.Runtime.Remoting.RemotingServices.ExecuteMessage%2A> method to forward method calls to remote objects.</span></span>

 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b27ea-139">直接调用方没有基础结构权限。</span><span class="sxs-lookup"><span data-stu-id="b27ea-139">The immediate caller does not have infrastructure permission.</span></span></exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><span data-ttu-id="b27ea-140">该方法从除对象的本机上下文之外的上下文调用。</span><span class="sxs-lookup"><span data-stu-id="b27ea-140">The method was called from a context other than the native context of the object.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnvoyChainForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvoyChainForProxy (obj As MarshalByRefObject) As IMessageSink" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMessageSink ^ GetEnvoyChainForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetEnvoyChainForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.Messaging.IMessageSink" Usage="System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageSink</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="b27ea-141">与请求的 Envoy 接收器关联的远程对象的代理。</span><span class="sxs-lookup"><span data-stu-id="b27ea-141">The proxy of the remote object that requested envoy sinks are associated with.</span></span></param>
        <summary><span data-ttu-id="b27ea-142">返回在将消息发送到指定的代理所表示的远程对象时应使用的一系列 Envoy 接收器。</span><span class="sxs-lookup"><span data-stu-id="b27ea-142">Returns a chain of envoy sinks that should be used when sending messages to the remote object represented by the specified proxy.</span></span></summary>
        <returns><span data-ttu-id="b27ea-143">与指定的代理关联的一系列 Envoy 接收器。</span><span class="sxs-lookup"><span data-stu-id="b27ea-143">A chain of envoy sinks associated with the specified proxy.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b27ea-144">Envoy 接收器是发送到对象的消息时所使用对象的 <xref:System.Runtime.Remoting.ObjRef> 的接收器。</span><span class="sxs-lookup"><span data-stu-id="b27ea-144">Envoy sinks are sinks sent along with the <xref:System.Runtime.Remoting.ObjRef> of an object that is used when returning messages to that object.</span></span> <span data-ttu-id="b27ea-145">当前方法返回在对象的代理与对象本身之间进行通信时使用的 envoy 接收器。</span><span class="sxs-lookup"><span data-stu-id="b27ea-145">The current method returns the envoy sinks that are used during communication between the proxy of the object and the object itself.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b27ea-146">直接调用方没有基础结构权限。</span><span class="sxs-lookup"><span data-stu-id="b27ea-146">The immediate caller does not have infrastructure permission.</span></span></exception>
        <altmember cref="T:System.Runtime.Remoting.IEnvoyInfo" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetLifetimeService">
      <MemberSignature Language="C#" Value="public static object GetLifetimeService (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLifetimeService(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLifetimeService (obj As MarshalByRefObject) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLifetimeService(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetLifetimeService : MarshalByRefObject -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.GetLifetimeService obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="b27ea-147">为其获得生存期服务的对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-147">The object to obtain lifetime service for.</span></span></param>
        <summary><span data-ttu-id="b27ea-148">返回控制指定对象的生存期策略的生存期服务对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-148">Returns a lifetime service object that controls the lifetime policy of the specified object.</span></span></summary>
        <returns><span data-ttu-id="b27ea-149">控制 <paramref name="obj" /> 的生存期的对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-149">The object that controls the lifetime of <paramref name="obj" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b27ea-150">对于默认生存期服务，返回的对象将是 <xref:System.Runtime.Remoting.Lifetime.ILease>类型的对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-150">For the default lifetime service the returned object will be an object of type <xref:System.Runtime.Remoting.Lifetime.ILease>.</span></span> <span data-ttu-id="b27ea-151">如果 `obj` 参数 `null`，则方法返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="b27ea-151">If the `obj` parameter is `null`, the method returns `null`.</span></span>



## Examples
 <span data-ttu-id="b27ea-152">下面的代码示例演示如何使用 <xref:System.Runtime.Remoting.RemotingServices.GetLifetimeService%2A> 方法获取指定对象的生存期租约。</span><span class="sxs-lookup"><span data-stu-id="b27ea-152">The following code example demonstrates how to use the <xref:System.Runtime.Remoting.RemotingServices.GetLifetimeService%2A> method to get a lifetime lease for the specified object.</span></span>

 [!code-cpp[RemotingServices.TimerSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.TimerSample/CPP/timerclient.cpp#1)]
 [!code-csharp[RemotingServices.TimerSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerclient.cs#1)]
 [!code-vb[RemotingServices.TimerSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerclient.vb#1)]

 <span data-ttu-id="b27ea-153">若要编译并运行此示例，需要编译和运行服务器 timerserver，并编译共享库 timerservice。</span><span class="sxs-lookup"><span data-stu-id="b27ea-153">To compile and run this example, you will need to compile and run a server, timerserver.exe, and compile a shared library, timerservice.dll.</span></span>

 <span data-ttu-id="b27ea-154">Timerserver 的源如下所示：</span><span class="sxs-lookup"><span data-stu-id="b27ea-154">The source for timerserver.exe follows:</span></span>

 [!code-csharp[RemotingServices.TimerSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerserver.cs#2)]
 [!code-vb[RemotingServices.TimerSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerserver.vb#2)]

 <span data-ttu-id="b27ea-155">Timerservice 的源如下所示：</span><span class="sxs-lookup"><span data-stu-id="b27ea-155">The source for timerservice.dll follows:</span></span>

 [!code-csharp[RemotingServices.TimerSample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerservice.cs#3)]
 [!code-vb[RemotingServices.TimerSample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerservice.vb#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b27ea-156">直接调用方没有基础结构权限。</span><span class="sxs-lookup"><span data-stu-id="b27ea-156">The immediate caller does not have infrastructure permission.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBaseFromMethodMessage">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodBaseFromMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodBaseFromMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodBaseFromMethodMessage (msg As IMethodMessage) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodBaseFromMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetMethodBaseFromMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; System.Reflection.MethodBase" Usage="System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg"><span data-ttu-id="b27ea-157">从其中提取方法库的方法消息。</span><span class="sxs-lookup"><span data-stu-id="b27ea-157">The method message to extract the method base from.</span></span></param>
        <summary><span data-ttu-id="b27ea-158">从给定的 <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" /> 返回方法库。</span><span class="sxs-lookup"><span data-stu-id="b27ea-158">Returns the method base from the given <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" />.</span></span></summary>
        <returns><span data-ttu-id="b27ea-159">从 <paramref name="msg" /> 参数提取的方法库。</span><span class="sxs-lookup"><span data-stu-id="b27ea-159">The method base extracted from the <paramref name="msg" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b27ea-160">这将根据 <xref:System.Runtime.Remoting.Messaging.IMethodMessage> 的 <xref:System.Runtime.Remoting.Messaging.IMethodMessage.TypeName%2A>、<xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodName%2A>和 <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature%2A> 属性确定方法基数，并由实现 <xref:System.Runtime.Remoting.Messaging.IMethodMessage> 接口的类使用。</span><span class="sxs-lookup"><span data-stu-id="b27ea-160">This determines the method base from the <xref:System.Runtime.Remoting.Messaging.IMethodMessage.TypeName%2A>, <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodName%2A>, and <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature%2A> properties of <xref:System.Runtime.Remoting.Messaging.IMethodMessage> and is used by classes implementing the <xref:System.Runtime.Remoting.Messaging.IMethodMessage> interface.</span></span> <span data-ttu-id="b27ea-161"><xref:System.Runtime.Remoting.Messaging.IMethodMessage> 类的使用者应引用 <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="b27ea-161">Consumers of <xref:System.Runtime.Remoting.Messaging.IMethodMessage> classes should reference the <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase%2A?displayProperty=nameWithType> property.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b27ea-162">直接调用方没有基础结构权限，或者调用堆栈上部至少有一个调用方没有检索非公共成员的类型信息的权限。</span><span class="sxs-lookup"><span data-stu-id="b27ea-162">Either the immediate caller does not have infrastructure permission, or at least one of the callers higher in the callstack does not have permission to retrieve the type information of non-public members.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public static void GetObjectData (object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetObjectData(object obj, class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetObjectData (obj As Object, info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetObjectData(System::Object ^ obj, System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="static member GetObjectData : obj * System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.GetObjectData (obj, info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="b27ea-163">要序列化的对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-163">The object to serialize.</span></span></param>
        <param name="info"><span data-ttu-id="b27ea-164">将对象序列化为的 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-164">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> into which the object is serialized.</span></span></param>
        <param name="context"><span data-ttu-id="b27ea-165">序列化的源和目标。</span><span class="sxs-lookup"><span data-stu-id="b27ea-165">The source and destination of the serialization.</span></span></param>
        <summary><span data-ttu-id="b27ea-166">按引用对象将指定封送序列化为所提供的 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-166">Serializes the specified marshal by reference object into the provided <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b27ea-167"><paramref name="obj" /> 或 <paramref name="info" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-167">The <paramref name="obj" /> or <paramref name="info" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b27ea-168">直接调用方没有基础结构权限。</span><span class="sxs-lookup"><span data-stu-id="b27ea-168">The immediate caller does not have infrastructure permission.</span></span></exception>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectUri">
      <MemberSignature Language="C#" Value="public static string GetObjectUri (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetObjectUri(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectUri (obj As MarshalByRefObject) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetObjectUri(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjectUri : MarshalByRefObject -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetObjectUri obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="b27ea-169">为其请求 URI 的 <see cref="T:System.MarshalByRefObject" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-169">The <see cref="T:System.MarshalByRefObject" /> for which a URI is requested.</span></span></param>
        <summary><span data-ttu-id="b27ea-170">为指定的对象检索 URI。</span><span class="sxs-lookup"><span data-stu-id="b27ea-170">Retrieves the URI for the specified object.</span></span></summary>
        <returns><span data-ttu-id="b27ea-171">如果指定的对象具有 URI，则为该对象的 URI；或者如果该对象尚未被封送，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-171">The URI of the specified object if it has one, or <see langword="null" /> if the object has not yet been marshaled.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 [!code-cpp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#18)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#18)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#18)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b27ea-172">直接调用方没有基础结构权限。</span><span class="sxs-lookup"><span data-stu-id="b27ea-172">The immediate caller does not have infrastructure permission.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjRefForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef GetObjRefForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef GetObjRefForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjRefForProxy (obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ GetObjRefForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjRefForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.GetObjRefForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="b27ea-173">一个代理，连接到要为其创建 <see cref="T:System.Runtime.Remoting.ObjRef" /> 的对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-173">A proxy connected to the object you want to create a <see cref="T:System.Runtime.Remoting.ObjRef" /> for.</span></span></param>
        <summary><span data-ttu-id="b27ea-174">从指定的代理返回表示远程对象的 <see cref="T:System.Runtime.Remoting.ObjRef" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-174">Returns the <see cref="T:System.Runtime.Remoting.ObjRef" /> that represents the remote object from the specified proxy.</span></span></summary>
        <returns><span data-ttu-id="b27ea-175"><see cref="T:System.Runtime.Remoting.ObjRef" />，它表示指定的代理要连接到的远程对象；或者如果对象或代理未被封送，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-175">A <see cref="T:System.Runtime.Remoting.ObjRef" /> that represents the remote object the specified proxy is connected to, or <see langword="null" /> if the object or proxy have not been marshaled.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b27ea-176"><xref:System.Runtime.Remoting.ObjRef> 是用于跨应用程序域边界传输对象引用的对象的可序列化表示形式。</span><span class="sxs-lookup"><span data-stu-id="b27ea-176">A <xref:System.Runtime.Remoting.ObjRef> is a serializable representation of an object used to transfer an object reference across an application domain boundary.</span></span> <span data-ttu-id="b27ea-177">为对象创建 <xref:System.Runtime.Remoting.ObjRef> 称为封送处理。</span><span class="sxs-lookup"><span data-stu-id="b27ea-177">Creating a <xref:System.Runtime.Remoting.ObjRef> for an object is known as marshaling.</span></span> <span data-ttu-id="b27ea-178"><xref:System.Runtime.Remoting.ObjRef> 可以通过通道传输到另一个应用程序域（可能在其他进程或计算机上）。</span><span class="sxs-lookup"><span data-stu-id="b27ea-178">The <xref:System.Runtime.Remoting.ObjRef> can be transferred through a channel into another application domain (possibly on another process or computer).</span></span> <span data-ttu-id="b27ea-179">在其他应用程序域中，必须对 <xref:System.Runtime.Remoting.ObjRef> 进行分析，以便为该对象创建一个代理，该代理通常连接到实际对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-179">Once in the other application domain, the <xref:System.Runtime.Remoting.ObjRef> must be parsed to create a proxy for the object, generally connected to the real object.</span></span> <span data-ttu-id="b27ea-180">此操作称为 "取消封送"。</span><span class="sxs-lookup"><span data-stu-id="b27ea-180">This operation is known as unmarshaling.</span></span> <span data-ttu-id="b27ea-181">在取消封送过程中，将对 <xref:System.Runtime.Remoting.ObjRef> 进行分析以提取远程对象的方法信息，并创建透明代理和 <xref:System.Runtime.Remoting.Proxies.RealProxy> 对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-181">During unmarshaling, the <xref:System.Runtime.Remoting.ObjRef> is parsed to extract the method information of the remote object and both the transparent proxy and <xref:System.Runtime.Remoting.Proxies.RealProxy> objects are created.</span></span>

 <span data-ttu-id="b27ea-182"><xref:System.Runtime.Remoting.ObjRef> 包含描述正在被封送处理的对象的 <xref:System.Type> 和类的信息、唯一标识特定对象实例的 URI 以及有关如何访问该对象所在的远程应用程序的通信相关信息。</span><span class="sxs-lookup"><span data-stu-id="b27ea-182">A <xref:System.Runtime.Remoting.ObjRef> contains information that describes the <xref:System.Type> and class of the object being marshaled, a URI that uniquely identifies the specific object instance, and communication related information about how to reach the remote application where the object is located.</span></span>



## Examples
 <span data-ttu-id="b27ea-183">下面的代码示例演示如何获取指定对象的 <xref:System.Runtime.Remoting.ObjRef> 实例。</span><span class="sxs-lookup"><span data-stu-id="b27ea-183">The following code example demonstrates how to get a <xref:System.Runtime.Remoting.ObjRef> instance for the specified object.</span></span>

 [!code-cpp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CPP/client.cpp#1)]
 [!code-csharp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CS/client.cs#1)]
 [!code-vb[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/VB/client.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b27ea-184">直接调用方没有基础结构权限。</span><span class="sxs-lookup"><span data-stu-id="b27ea-184">The immediate caller does not have infrastructure permission.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetRealProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Proxies.RealProxy GetRealProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Proxies.RealProxy GetRealProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRealProxy (proxy As Object) As RealProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Proxies::RealProxy ^ GetRealProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member GetRealProxy : obj -&gt; System.Runtime.Remoting.Proxies.RealProxy" Usage="System.Runtime.Remoting.RemotingServices.GetRealProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Proxies.RealProxy</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy"><span data-ttu-id="b27ea-185">透明代理。</span><span class="sxs-lookup"><span data-stu-id="b27ea-185">A transparent proxy.</span></span></param>
        <summary><span data-ttu-id="b27ea-186">返回指定透明代理后面的真实代理。</span><span class="sxs-lookup"><span data-stu-id="b27ea-186">Returns the real proxy backing the specified transparent proxy.</span></span></summary>
        <returns><span data-ttu-id="b27ea-187">透明代理后面的真实代理实例。</span><span class="sxs-lookup"><span data-stu-id="b27ea-187">The real proxy instance backing the transparent proxy.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b27ea-188">在任何类型的远程处理边界上使用对象的客户端实际使用的是对象的透明代理。</span><span class="sxs-lookup"><span data-stu-id="b27ea-188">A client that uses an object across any kind of remoting boundary is actually using a transparent proxy for the object.</span></span> <span data-ttu-id="b27ea-189">透明代理提供实际对象在客户端空间中所驻留的印象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-189">The transparent proxy gives the impression that the actual object resides in the client's space.</span></span> <span data-ttu-id="b27ea-190">它通过使用远程处理基础结构将对其进行的调用转发到实际对象来实现此目标。</span><span class="sxs-lookup"><span data-stu-id="b27ea-190">It achieves this by forwarding calls made on it to the real object using the remoting infrastructure.</span></span>

 <span data-ttu-id="b27ea-191">透明代理由 <xref:System.Runtime.Remoting.Proxies.RealProxy>类型的托管运行时类的实例支持。</span><span class="sxs-lookup"><span data-stu-id="b27ea-191">The transparent proxy is backed by an instance of a managed runtime class of type <xref:System.Runtime.Remoting.Proxies.RealProxy>.</span></span> <span data-ttu-id="b27ea-192"><xref:System.Runtime.Remoting.Proxies.RealProxy> 实现从透明代理转发操作所需的部分功能。</span><span class="sxs-lookup"><span data-stu-id="b27ea-192">The <xref:System.Runtime.Remoting.Proxies.RealProxy> implements a part of the functionality needed to forward the operations from the transparent proxy.</span></span>

 <span data-ttu-id="b27ea-193">代理对象继承托管对象的关联语义，如垃圾回收、对成员和方法的支持，并可进行扩展以形成新的类。</span><span class="sxs-lookup"><span data-stu-id="b27ea-193">A proxy object inherits the associated semantics of managed objects such as garbage collection, support for members and methods, and can be extended to form new classes.</span></span> <span data-ttu-id="b27ea-194">代理充当与远程对象（透明代理）相同的类的对象，也是托管对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-194">The proxy acts as an object of the same class as the remote object (transparent proxy), and is also a managed object.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b27ea-195">直接调用方没有基础结构权限。</span><span class="sxs-lookup"><span data-stu-id="b27ea-195">The immediate caller does not have infrastructure permission.</span></span></exception>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetServerTypeForUri">
      <MemberSignature Language="C#" Value="public static Type GetServerTypeForUri (string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetServerTypeForUri(string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetServerTypeForUri (URI As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetServerTypeForUri(System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member GetServerTypeForUri : string -&gt; Type" Usage="System.Runtime.Remoting.RemotingServices.GetServerTypeForUri URI" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="URI"><span data-ttu-id="b27ea-196">请求其 <see cref="T:System.Type" /> 的对象的 URI。</span><span class="sxs-lookup"><span data-stu-id="b27ea-196">The URI of the object whose <see cref="T:System.Type" /> is requested.</span></span></param>
        <summary><span data-ttu-id="b27ea-197">返回具有指定 URI 的对象的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-197">Returns the <see cref="T:System.Type" /> of the object with the specified URI.</span></span></summary>
        <returns><span data-ttu-id="b27ea-198">具有指定 URI 的对象的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-198">The <see cref="T:System.Type" /> of the object with the specified URI.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b27ea-199">由于远程处理使用 Uri 标识终结点，因此 <xref:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri%2A> 方法对于使用 <xref:System.Runtime.Remoting.Messaging.IMessage> 对象的远程处理基础结构（例如，信道接收器、动态接收器和上下文接收器）的可插入部分非常有用，因为当前方法将从 URI 返回关联的类型对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-199">Because remoting identifies endpoints using URIs, the <xref:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri%2A> method is very useful in the pluggable parts of the remoting infrastructure (for example, channel sinks, dynamic sinks, and context sinks) that use <xref:System.Runtime.Remoting.Messaging.IMessage> objects, because the current method will return the associated type object from the URI.</span></span>



## Examples
 [!code-cpp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#7)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#7)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#7)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b27ea-200">直接调用方没有基础结构权限，或者调用堆栈上部至少有一个调用方没有检索非公共成员的类型信息的权限。</span><span class="sxs-lookup"><span data-stu-id="b27ea-200">Either the immediate caller does not have infrastructure permission, or at least one of the callers higher in the callstack does not have permission to retrieve the type information of non-public members.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetSessionIdForMethodMessage">
      <MemberSignature Language="C#" Value="public static string GetSessionIdForMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetSessionIdForMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSessionIdForMethodMessage (msg As IMethodMessage) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetSessionIdForMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetSessionIdForMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg"><span data-ttu-id="b27ea-201">为其请求会话 ID 的 <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-201">The <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" /> for which a session ID is requested.</span></span></param>
        <summary><span data-ttu-id="b27ea-202">检索消息的会话 ID。</span><span class="sxs-lookup"><span data-stu-id="b27ea-202">Retrieves a session ID for a message.</span></span></summary>
        <returns><span data-ttu-id="b27ea-203">唯一标识当前会话的会话 ID 字符串。</span><span class="sxs-lookup"><span data-stu-id="b27ea-203">A session ID string that uniquely identifies the current session.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b27ea-204">同一应用程序中的对象可能返回相同的会话 ID，但对于不同的远程应用程序中的两个对象，此方法从不返回相同的会话 ID。</span><span class="sxs-lookup"><span data-stu-id="b27ea-204">The same session ID might be returned for objects in the same application, but this method will never return the same session ID for two objects in different remote applications.</span></span>

 <span data-ttu-id="b27ea-205">有关确定会话和会话 Id 的详细信息，请参阅 ASP.Net [ASP.NET Session State 概述](https://docs.microsoft.com/previous-versions/aspnet/ms178581(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="b27ea-205">For more information about identifying sessions and session IDs, see ASP.Net [ASP.NET Session State Overview](https://docs.microsoft.com/previous-versions/aspnet/ms178581(v=vs.100)).</span></span>



## Examples
 <span data-ttu-id="b27ea-206">下面的代码示例演示如何获取当前会话的会话 ID 字符串。</span><span class="sxs-lookup"><span data-stu-id="b27ea-206">The following code example demonstrates how to get the session ID string for the current session.</span></span>

 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b27ea-207">直接调用方没有基础结构权限。</span><span class="sxs-lookup"><span data-stu-id="b27ea-207">The immediate caller does not have infrastructure permission.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsMethodOverloaded">
      <MemberSignature Language="C#" Value="public static bool IsMethodOverloaded (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMethodOverloaded(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMethodOverloaded (msg As IMethodMessage) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMethodOverloaded(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member IsMethodOverloaded : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsMethodOverloaded msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg"><span data-ttu-id="b27ea-208">包含对上述方法的调用的消息。</span><span class="sxs-lookup"><span data-stu-id="b27ea-208">The message that contains a call to the method in question.</span></span></param>
        <summary><span data-ttu-id="b27ea-209">返回一个布尔值，该值指示是否重载给定消息中的方法。</span><span class="sxs-lookup"><span data-stu-id="b27ea-209">Returns a Boolean value that indicates whether the method in the given message is overloaded.</span></span></summary>
        <returns><span data-ttu-id="b27ea-210">如果重载 <see langword="true" /> 中调用的方法，则为 <paramref name="msg" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-210"><see langword="true" /> if the method called in <paramref name="msg" /> is overloaded; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b27ea-211">直接调用方没有基础结构权限。</span><span class="sxs-lookup"><span data-stu-id="b27ea-211">The immediate caller does not have infrastructure permission.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfAppDomain">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfAppDomain (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfAppDomain(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfAppDomain (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfAppDomain(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfAppDomain : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp"><span data-ttu-id="b27ea-212">要检查的对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-212">The object to check.</span></span></param>
        <summary><span data-ttu-id="b27ea-213">返回一个布尔值，该值指示给定透明代理指定的对象是否包含在与调用当前方法的对象不同的应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="b27ea-213">Returns a Boolean value that indicates whether the object specified by the given transparent proxy is contained in a different application domain than the object that called the current method.</span></span></summary>
        <returns><span data-ttu-id="b27ea-214">如果该对象在当前应用程序域之外，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-214"><see langword="true" /> if the object is out of the current application domain; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b27ea-215">有关应用程序域的信息，请参阅[应用程序域](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90))。</span><span class="sxs-lookup"><span data-stu-id="b27ea-215">For information about application domains, see [Application Domains](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)).</span></span>



## Examples
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)"><span data-ttu-id="b27ea-216">应用程序域</span><span class="sxs-lookup"><span data-stu-id="b27ea-216">Application Domains</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfContext">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfContext (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfContext(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfContext (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfContext(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfContext : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp"><span data-ttu-id="b27ea-217">要检查的对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-217">The object to check.</span></span></param>
        <summary><span data-ttu-id="b27ea-218">返回一个布尔值，该值指示给定代理表示的对象是否包含在与调用当前方法的对象不同的上下文中。</span><span class="sxs-lookup"><span data-stu-id="b27ea-218">Returns a Boolean value that indicates whether the object represented by the given proxy is contained in a different context than the object that called the current method.</span></span></summary>
        <returns><span data-ttu-id="b27ea-219">如果该对象在当前上下文之外，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-219"><see langword="true" /> if the object is out of the current context; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b27ea-220">上下文是一系列有序属性，这些属性定义驻留在其中的对象的环境。</span><span class="sxs-lookup"><span data-stu-id="b27ea-220">A context is an ordered sequence of properties that define an environment for the objects that reside inside it.</span></span> <span data-ttu-id="b27ea-221">上下文是在对象的激活过程中创建的，这些对象配置为需要某些自动服务，例如同步、事务、实时激活、安全等。</span><span class="sxs-lookup"><span data-stu-id="b27ea-221">Contexts are created during the activation process for objects that are configured to require certain automatic services such synchronization, transactions, just-in-time activation, security, and so on.</span></span> <span data-ttu-id="b27ea-222">多个对象可以存留在一个上下文内。</span><span class="sxs-lookup"><span data-stu-id="b27ea-222">Multiple objects can live inside a context.</span></span>



## Examples
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Contexts.Context" />
      </Docs>
    </Member>
    <Member MemberName="IsOneWay">
      <MemberSignature Language="C#" Value="public static bool IsOneWay (System.Reflection.MethodBase method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsOneWay(class System.Reflection.MethodBase method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsOneWay (method As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsOneWay(System::Reflection::MethodBase ^ method);" />
      <MemberSignature Language="F#" Value="static member IsOneWay : System.Reflection.MethodBase -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsOneWay method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="b27ea-223">上述方法。</span><span class="sxs-lookup"><span data-stu-id="b27ea-223">The method in question.</span></span></param>
        <summary><span data-ttu-id="b27ea-224">返回一个布尔值，该值指示调用给定消息中指定的方法的客户端在继续执行之前是否等待服务器完成该方法的处理。</span><span class="sxs-lookup"><span data-stu-id="b27ea-224">Returns a Boolean value that indicates whether the client that called the method specified in the given message is waiting for the server to finish processing the method before continuing execution.</span></span></summary>
        <returns><span data-ttu-id="b27ea-225">如果该方法是单向的，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-225"><see langword="true" /> if the method is one way; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b27ea-226">调用单向方法时，客户端不会等待服务器处理完消息。</span><span class="sxs-lookup"><span data-stu-id="b27ea-226">When a one-way method is called, the client does not wait for the server to finish processing the message.</span></span> <span data-ttu-id="b27ea-227">客户端方法返回到应用程序，并且不知道服务器是否将成功处理消息。</span><span class="sxs-lookup"><span data-stu-id="b27ea-227">The client method returns to the application with no knowledge of whether or not the server will successfully process the message.</span></span> <span data-ttu-id="b27ea-228">方法使用 <xref:System.Runtime.Remoting.Messaging.OneWayAttribute>进行标记。</span><span class="sxs-lookup"><span data-stu-id="b27ea-228">Methods are marked as one way using the <xref:System.Runtime.Remoting.Messaging.OneWayAttribute>.</span></span>

 <span data-ttu-id="b27ea-229">单向方法不能有返回值或任何输出参数。</span><span class="sxs-lookup"><span data-stu-id="b27ea-229">One-way methods cannot have a return value or any out parameters.</span></span>



## Examples
 [!code-cpp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#2)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#2)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b27ea-230">直接调用方没有基础结构权限。</span><span class="sxs-lookup"><span data-stu-id="b27ea-230">The immediate caller does not have infrastructure permission.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsTransparentProxy">
      <MemberSignature Language="C#" Value="public static bool IsTransparentProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsTransparentProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsTransparentProxy (proxy As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsTransparentProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member IsTransparentProxy : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsTransparentProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy"><span data-ttu-id="b27ea-231">对要检查的对象的引用。</span><span class="sxs-lookup"><span data-stu-id="b27ea-231">The reference to the object to check.</span></span></param>
        <summary><span data-ttu-id="b27ea-232">返回一个布尔值，该值指示给定的对象是透明代理还是实际对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-232">Returns a Boolean value that indicates whether the given object is a transparent proxy or a real object.</span></span></summary>
        <returns><span data-ttu-id="b27ea-233">一个布尔值，该值指示 <paramref name="proxy" /> 参数中指定的对象是透明代理还是实际对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-233">A Boolean value that indicates whether the object specified in the <paramref name="proxy" /> parameter is a transparent proxy or a real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b27ea-234">使用对象的任何类型的远程处理边界的客户端实际上使用的是对象的透明代理。</span><span class="sxs-lookup"><span data-stu-id="b27ea-234">A client that uses an object across any kind of a remoting boundary is actually using a transparent proxy for the object.</span></span> <span data-ttu-id="b27ea-235">透明代理提供实际对象在客户端空间中所驻留的印象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-235">The transparent proxy gives the impression that the actual object resides in the client's space.</span></span> <span data-ttu-id="b27ea-236">它通过使用远程处理基础结构将对其进行的调用转发到实际对象来实现此目标。</span><span class="sxs-lookup"><span data-stu-id="b27ea-236">It achieves this by forwarding calls made on it to the real object using the remoting infrastructure.</span></span>

 <span data-ttu-id="b27ea-237">透明代理本身由 <xref:System.Runtime.Remoting.Proxies.RealProxy>类型的托管运行时类的实例驻留。</span><span class="sxs-lookup"><span data-stu-id="b27ea-237">The transparent proxy is itself housed by an instance of a managed runtime class of type <xref:System.Runtime.Remoting.Proxies.RealProxy>.</span></span> <span data-ttu-id="b27ea-238"><xref:System.Runtime.Remoting.Proxies.RealProxy> 实现从透明代理转发操作所需的部分功能。</span><span class="sxs-lookup"><span data-stu-id="b27ea-238">The <xref:System.Runtime.Remoting.Proxies.RealProxy> implements a part of the functionality needed to forward the operations from the transparent proxy.</span></span> <span data-ttu-id="b27ea-239">代理对象继承托管对象的关联语义，如垃圾回收、对成员和方法的支持，并可进行扩展以形成新的类。</span><span class="sxs-lookup"><span data-stu-id="b27ea-239">A proxy object inherits the associated semantics of managed objects such as garbage collection, support for members and methods, and can be extended to form new classes.</span></span> <span data-ttu-id="b27ea-240">因此，代理具有双重性质;一方面，它需要充当与远程对象（透明代理）相同的类的对象，另一种方法是托管对象本身。</span><span class="sxs-lookup"><span data-stu-id="b27ea-240">Thus the proxy has a dual nature; on the one hand it needs to act as an object of the same class as the remote object (transparent proxy), and on the other it is a managed object itself.</span></span>

 <span data-ttu-id="b27ea-241">代理对象可在不考虑 <xref:System.AppDomain>中的任何远程处理细分的情况下使用。</span><span class="sxs-lookup"><span data-stu-id="b27ea-241">A proxy object can be used without regard to any remoting subdivisions within a <xref:System.AppDomain>.</span></span> <span data-ttu-id="b27ea-242">应用程序不需要区分代理引用和对象引用。</span><span class="sxs-lookup"><span data-stu-id="b27ea-242">Applications need not distinguish between proxy references and object references.</span></span> <span data-ttu-id="b27ea-243">不过，处理诸如激活、生存期管理和事务等问题的服务提供商需要进行这种区分。</span><span class="sxs-lookup"><span data-stu-id="b27ea-243">However, service providers dealing with issues such as activation, lifetime management, and transactions need to make such distinctions.</span></span>



## Examples
 <span data-ttu-id="b27ea-244">下面的代码示例演示如何使用 <xref:System.Runtime.Remoting.RemotingServices.IsTransparentProxy%2A> 方法来确定对象是代理还是实际对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-244">The following code example demonstrates the use of the <xref:System.Runtime.Remoting.RemotingServices.IsTransparentProxy%2A> method to determine whether an object is a proxy or a real object.</span></span> <span data-ttu-id="b27ea-245">有关完整的示例代码，请参阅 <xref:System.Runtime.Remoting.Messaging.AsyncResult> 类的示例。</span><span class="sxs-lookup"><span data-stu-id="b27ea-245">For the complete example code, see the example for the <xref:System.Runtime.Remoting.Messaging.AsyncResult> class.</span></span>

 [!code-cpp[AsyncResult.NewExamples#6](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncResult.NewExamples/CPP/ad.cpp#6)]
 [!code-csharp[AsyncResult.NewExamples#6](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncResult.NewExamples/CS/ad.cs#6)]
 [!code-vb[AsyncResult.NewExamples#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncResult.NewExamples/VB/ad.vb#6)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="LogRemotingStage">
      <MemberSignature Language="C#" Value="public static void LogRemotingStage (int stage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LogRemotingStage(int32 stage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LogRemotingStage (stage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LogRemotingStage(int stage);" />
      <MemberSignature Language="F#" Value="static member LogRemotingStage : int -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.LogRemotingStage stage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("REMOTING_PERF")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("It existed for only internal use in .NET and unimplemented in mono")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use of this method is not recommended. The LogRemotingStage existed for internal diagnostic purposes only.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stage"><span data-ttu-id="b27ea-246">标识远程处理交换中所处的阶段的内部定义常数。</span><span class="sxs-lookup"><span data-stu-id="b27ea-246">An internally defined constant that identifies the stage in a remoting exchange.</span></span></param>
        <summary><span data-ttu-id="b27ea-247">记录与外部调试器进行的远程处理交换所处的阶段。</span><span class="sxs-lookup"><span data-stu-id="b27ea-247">Logs the stage in a remoting exchange to an external debugger.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b27ea-248">使用 <xref:System.Diagnostics.ConditionalAttribute> 属性将 `"REMOTING_PERF"` 预处理符号应用于方法。</span><span class="sxs-lookup"><span data-stu-id="b27ea-248">A `"REMOTING_PERF"` preprocessing symbol is applied to the method by using the <xref:System.Diagnostics.ConditionalAttribute> attribute.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Marshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b27ea-249">将给定的 <see cref="T:System.MarshalByRefObject" /> 转换为 <see cref="T:System.Runtime.Remoting.ObjRef" /> 类的实例，可以将该实例序列化以便在应用程序域之间以及通过网络进行传输。</span><span class="sxs-lookup"><span data-stu-id="b27ea-249">Converts the given <see cref="T:System.MarshalByRefObject" /> into an instance of the <see cref="T:System.Runtime.Remoting.ObjRef" /> class, which can be serialized for transmission between application domains and over a network.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal Obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="Obj"><span data-ttu-id="b27ea-250">要转换的对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-250">The object to convert.</span></span></param>
        <summary><span data-ttu-id="b27ea-251">接受 <see cref="T:System.MarshalByRefObject" />，将其注册到远程处理基础结构，然后将其转换为 <see cref="T:System.Runtime.Remoting.ObjRef" /> 类的实例。</span><span class="sxs-lookup"><span data-stu-id="b27ea-251">Takes a <see cref="T:System.MarshalByRefObject" />, registers it with the remoting infrastructure, and converts it into an instance of the <see cref="T:System.Runtime.Remoting.ObjRef" /> class.</span></span></summary>
        <returns><span data-ttu-id="b27ea-252"><see cref="T:System.Runtime.Remoting.ObjRef" /> 类的一个实例，它表示 <paramref name="Obj" /> 参数中指定的对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-252">An instance of the <see cref="T:System.Runtime.Remoting.ObjRef" /> class that represents the object specified in the <paramref name="Obj" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b27ea-253"><xref:System.Runtime.Remoting.ObjRef> 是用于跨应用程序域边界传输对象引用的对象的可序列化表示形式。</span><span class="sxs-lookup"><span data-stu-id="b27ea-253">A <xref:System.Runtime.Remoting.ObjRef> is a serializable representation of an object used to transfer an object reference across an application domain boundary.</span></span> <span data-ttu-id="b27ea-254">为对象创建 <xref:System.Runtime.Remoting.ObjRef> 称为封送处理。</span><span class="sxs-lookup"><span data-stu-id="b27ea-254">Creating a <xref:System.Runtime.Remoting.ObjRef> for an object is known as marshaling.</span></span> <span data-ttu-id="b27ea-255"><xref:System.Runtime.Remoting.ObjRef> 可以通过通道传输到另一个应用程序域（可能在其他进程或计算机上）。</span><span class="sxs-lookup"><span data-stu-id="b27ea-255">The <xref:System.Runtime.Remoting.ObjRef> can be transferred through a channel into another application domain (possibly on another process or computer).</span></span> <span data-ttu-id="b27ea-256">在其他应用程序域中，必须对 <xref:System.Runtime.Remoting.ObjRef> 进行分析，以便为该对象创建一个代理，该代理通常连接到实际对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-256">Once in the other application domain, the <xref:System.Runtime.Remoting.ObjRef> must be parsed to create a proxy for the object, generally connected to the real object.</span></span> <span data-ttu-id="b27ea-257">此操作称为 "取消封送"。</span><span class="sxs-lookup"><span data-stu-id="b27ea-257">This operation is known as unmarshaling.</span></span>

 <span data-ttu-id="b27ea-258"><xref:System.Runtime.Remoting.ObjRef> 包含描述正在被封送处理的对象的 <xref:System.Type> 和类的信息、唯一标识特定对象实例的 URI 以及有关如何访问该对象所在的远程处理细分的通信相关信息。</span><span class="sxs-lookup"><span data-stu-id="b27ea-258">A <xref:System.Runtime.Remoting.ObjRef> contains information that describes the <xref:System.Type> and class of the object being marshaled, a URI that uniquely identifies the specific object instance, and communication related information about how to reach the remoting subdivision where the object is located.</span></span>

 <span data-ttu-id="b27ea-259">在封送处理期间，将使用当前线程中的上下文，而不是创建对象时处于活动状态的上下文。</span><span class="sxs-lookup"><span data-stu-id="b27ea-259">During marshaling, the context from the current thread is used, not the context that was active when the object was created.</span></span> <span data-ttu-id="b27ea-260">如果 <xref:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal%2A> 方法未显式设置 URI，则由远程处理标识基础结构自动生成。</span><span class="sxs-lookup"><span data-stu-id="b27ea-260">If a URI was not explicitly set by the <xref:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal%2A> method, it is automatically generated by the remoting identity infrastructure.</span></span>

 <span data-ttu-id="b27ea-261">由于以下两个原因之一，你无法将 URI 与代理关联：要么是在服务器端为它所表示的对象生成了 URI，要么该对象是已知的，在这种情况下，URI 是已知的。</span><span class="sxs-lookup"><span data-stu-id="b27ea-261">You cannot associate a URI with a proxy for one of two reasons: either the URI was generated at the server side for the object it represents, or the object is well known, in which case the URI is known.</span></span> <span data-ttu-id="b27ea-262">出于此原因，如果 `Obj` 参数为代理，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="b27ea-262">For this reason, if the `Obj` parameter is a proxy, an exception will be thrown.</span></span> <span data-ttu-id="b27ea-263">对于自定义代理，此限制非常宽松，因为透明代理被视为服务器对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-263">For custom proxies this restriction is relaxed because the transparent proxy is treated as the server object.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><span data-ttu-id="b27ea-264"><paramref name="Obj" /> 参数是一个对象代理。</span><span class="sxs-lookup"><span data-stu-id="b27ea-264">The <paramref name="Obj" /> parameter is an object proxy.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b27ea-265">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="b27ea-265">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span></exception>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)"><span data-ttu-id="b27ea-266">应用程序域</span><span class="sxs-lookup"><span data-stu-id="b27ea-266">Application Domains</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, URI As String) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, URI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Obj"><span data-ttu-id="b27ea-267">要转换的对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-267">The object to convert.</span></span></param>
        <param name="URI"><span data-ttu-id="b27ea-268">指定的 URI，使用它来初始化新 <see cref="T:System.Runtime.Remoting.ObjRef" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-268">The specified URI with which to initialize the new <see cref="T:System.Runtime.Remoting.ObjRef" />.</span></span> <span data-ttu-id="b27ea-269">可以为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-269">Can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="b27ea-270">将给定的 <see cref="T:System.MarshalByRefObject" /> 转换为具有指定 URI 的 <see cref="T:System.Runtime.Remoting.ObjRef" /> 类的实例。</span><span class="sxs-lookup"><span data-stu-id="b27ea-270">Converts the given <see cref="T:System.MarshalByRefObject" /> into an instance of the <see cref="T:System.Runtime.Remoting.ObjRef" /> class with the specified URI.</span></span></summary>
        <returns><span data-ttu-id="b27ea-271"><see cref="T:System.Runtime.Remoting.ObjRef" /> 类的一个实例，它表示 <paramref name="Obj" /> 参数中指定的对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-271">An instance of the <see cref="T:System.Runtime.Remoting.ObjRef" /> class that represents the object specified in the <paramref name="Obj" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b27ea-272"><xref:System.Runtime.Remoting.ObjRef> 是用于跨应用程序域边界传输对象引用的对象的可序列化表示形式。</span><span class="sxs-lookup"><span data-stu-id="b27ea-272">A <xref:System.Runtime.Remoting.ObjRef> is a serializable representation of an object used to transfer an object reference across an application domain boundary.</span></span> <span data-ttu-id="b27ea-273">为对象创建 <xref:System.Runtime.Remoting.ObjRef> 称为封送处理。</span><span class="sxs-lookup"><span data-stu-id="b27ea-273">Creating a <xref:System.Runtime.Remoting.ObjRef> for an object is known as marshaling.</span></span> <span data-ttu-id="b27ea-274"><xref:System.Runtime.Remoting.ObjRef> 可以通过通道传输到另一个应用程序域（可能在其他进程或计算机上）。</span><span class="sxs-lookup"><span data-stu-id="b27ea-274">The <xref:System.Runtime.Remoting.ObjRef> can be transferred through a channel into another application domain (possibly on another process or computer).</span></span> <span data-ttu-id="b27ea-275">在其他应用程序域中，必须对 <xref:System.Runtime.Remoting.ObjRef> 进行分析，以便为该对象创建一个代理，该代理通常连接到实际对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-275">Once in the other application domain, the <xref:System.Runtime.Remoting.ObjRef> must be parsed to create a proxy for the object, generally connected to the real object.</span></span> <span data-ttu-id="b27ea-276">此操作称为 "取消封送"。</span><span class="sxs-lookup"><span data-stu-id="b27ea-276">This operation is known as unmarshaling.</span></span>

 <span data-ttu-id="b27ea-277"><xref:System.Runtime.Remoting.ObjRef> 包含描述正在被封送处理的对象的 <xref:System.Type> 和类的信息、唯一标识特定对象实例的 URI 以及有关如何访问该对象所在的远程处理细分的通信相关信息。</span><span class="sxs-lookup"><span data-stu-id="b27ea-277">A <xref:System.Runtime.Remoting.ObjRef> contains information that describes the <xref:System.Type> and class of the object being marshaled, a URI that uniquely identifies the specific object instance, and communication related information about how to reach the remoting subdivision where the object is located.</span></span>

 <span data-ttu-id="b27ea-278">在封送处理期间，将使用当前线程中的上下文，而不是创建对象时处于活动状态的上下文。</span><span class="sxs-lookup"><span data-stu-id="b27ea-278">During marshaling, the context from the current thread is used, not the context that was active when the object was created.</span></span>

 <span data-ttu-id="b27ea-279">由于以下两个原因之一，你无法将 URI 与代理关联：要么是在服务器端为它所表示的对象生成了 URI，要么该对象是已知的，在这种情况下，URI 是已知的。</span><span class="sxs-lookup"><span data-stu-id="b27ea-279">You cannot associate a URI with a proxy for one of two reasons: either the URI was generated at the server side for the object it represents, or the object is well known, in which case the URI is known.</span></span> <span data-ttu-id="b27ea-280">出于此原因，如果 `Obj` 参数为代理，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="b27ea-280">For this reason, if the `Obj` parameter is a proxy, an exception will be thrown.</span></span> <span data-ttu-id="b27ea-281">对于自定义代理，此限制非常宽松，因为透明代理被视为服务器对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-281">For custom proxies this restriction is relaxed because the transparent proxy is treated as the server object.</span></span>



## Examples
 <span data-ttu-id="b27ea-282">下面的代码示例演示如何使用当前 <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> 方法封送指定的对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-282">The following code example demonstrates how to use the current <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> method to marshal a specified object.</span></span>

 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><span data-ttu-id="b27ea-283"><paramref name="Obj" /> 是一个对象代理，<paramref name="URI" /> 参数不为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-283"><paramref name="Obj" /> is an object proxy, and the <paramref name="URI" /> parameter is not <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b27ea-284">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="b27ea-284">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span></exception>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)"><span data-ttu-id="b27ea-285">应用程序域</span><span class="sxs-lookup"><span data-stu-id="b27ea-285">Application Domains</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string ObjURI, Type RequestedType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string ObjURI, class System.Type RequestedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, ObjURI As String, RequestedType As Type) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ ObjURI, Type ^ RequestedType);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string * Type -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, ObjURI, RequestedType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="ObjURI" Type="System.String" />
        <Parameter Name="RequestedType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="Obj"><span data-ttu-id="b27ea-286">要转换为 <see cref="T:System.Runtime.Remoting.ObjRef" /> 的对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-286">The object to convert into a <see cref="T:System.Runtime.Remoting.ObjRef" />.</span></span></param>
        <param name="ObjURI"><span data-ttu-id="b27ea-287">URI，使用它对 <paramref name="Obj" /> 参数中指定的对象进行封送。</span><span class="sxs-lookup"><span data-stu-id="b27ea-287">The URI the object specified in the <paramref name="Obj" /> parameter is marshaled with.</span></span> <span data-ttu-id="b27ea-288">可以为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-288">Can be <see langword="null" />.</span></span></param>
        <param name="RequestedType"><span data-ttu-id="b27ea-289"><see cref="T:System.Type" /> 被封送为的 <paramref name="Obj" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-289">The <see cref="T:System.Type" /><paramref name="Obj" /> is marshaled as.</span></span> <span data-ttu-id="b27ea-290">可以为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-290">Can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="b27ea-291">接受 <see cref="T:System.MarshalByRefObject" />，并将其转换为具有指定 URI 和提供的 <see cref="T:System.Runtime.Remoting.ObjRef" /> 的 <see cref="T:System.Type" /> 类的实例。</span><span class="sxs-lookup"><span data-stu-id="b27ea-291">Takes a <see cref="T:System.MarshalByRefObject" /> and converts it into an instance of the <see cref="T:System.Runtime.Remoting.ObjRef" /> class with the specified URI, and the provided <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="b27ea-292"><see cref="T:System.Runtime.Remoting.ObjRef" /> 类的一个实例，它表示 <paramref name="Obj" /> 参数中指定的对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-292">An instance of the <see cref="T:System.Runtime.Remoting.ObjRef" /> class that represents the object specified in the <paramref name="Obj" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b27ea-293"><xref:System.Runtime.Remoting.ObjRef> 是用于跨应用程序域边界传输对象引用的对象的可序列化表示形式。</span><span class="sxs-lookup"><span data-stu-id="b27ea-293">A <xref:System.Runtime.Remoting.ObjRef> is a serializable representation of an object used to transfer an object reference across an application domain boundary.</span></span> <span data-ttu-id="b27ea-294">为对象创建 <xref:System.Runtime.Remoting.ObjRef> 称为封送处理。</span><span class="sxs-lookup"><span data-stu-id="b27ea-294">Creating a <xref:System.Runtime.Remoting.ObjRef> for an object is known as marshaling.</span></span> <span data-ttu-id="b27ea-295"><xref:System.Runtime.Remoting.ObjRef> 可以通过通道传输到另一个应用程序域（可能在其他进程或计算机上）。</span><span class="sxs-lookup"><span data-stu-id="b27ea-295">The <xref:System.Runtime.Remoting.ObjRef> can be transferred through a channel into another application domain (possibly on another process or computer).</span></span> <span data-ttu-id="b27ea-296">在其他应用程序域中，必须对 <xref:System.Runtime.Remoting.ObjRef> 进行分析，以便为该对象创建一个代理，该代理通常连接到实际对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-296">Once in the other application domain, the <xref:System.Runtime.Remoting.ObjRef> must be parsed to create a proxy for the object, generally connected to the real object.</span></span> <span data-ttu-id="b27ea-297">此操作称为 "取消封送"。</span><span class="sxs-lookup"><span data-stu-id="b27ea-297">This operation is known as unmarshaling.</span></span>

 <span data-ttu-id="b27ea-298"><xref:System.Runtime.Remoting.ObjRef> 包含描述正在被封送处理的对象的 <xref:System.Type> 和类的信息、唯一标识特定对象实例的 URI 以及有关如何访问该对象所在的远程处理细分的通信相关信息。</span><span class="sxs-lookup"><span data-stu-id="b27ea-298">A <xref:System.Runtime.Remoting.ObjRef> contains information that describes the <xref:System.Type> and class of the object being marshaled, a URI that uniquely identifies the specific object instance, and communication related information about how to reach the remoting subdivision where the object is located.</span></span>

 <span data-ttu-id="b27ea-299">指定的 <xref:System.Type> 由远程处理基础结构用来限制公开的类型层次结构的作用域。</span><span class="sxs-lookup"><span data-stu-id="b27ea-299">The specified <xref:System.Type> is used by the remoting infrastructure to limit the scope of the exposed type hierarchy.</span></span> <span data-ttu-id="b27ea-300">例如，如果对象 A 从对象 B 派生，而后者是从对象 C 派生的，并且调用了 <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A>，则客户端可以将代理强制转换为 C 和 B，而不是转换为。</span><span class="sxs-lookup"><span data-stu-id="b27ea-300">For example, if object A derives from object B, which derives from object C, and <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> is called, then the client can cast the proxy between C and B but not to A.</span></span>

 <span data-ttu-id="b27ea-301">在封送处理期间，将使用当前线程中的上下文，而不是创建对象时处于活动状态的上下文。</span><span class="sxs-lookup"><span data-stu-id="b27ea-301">During marshaling, the context from the current thread is used, not the context that was active when the object was created.</span></span>

 <span data-ttu-id="b27ea-302">由于以下两个原因之一，你无法将 URI 与代理关联：要么是在服务器端为它所表示的对象生成了 URI，要么该对象是已知的，在这种情况下，URI 是已知的。</span><span class="sxs-lookup"><span data-stu-id="b27ea-302">You cannot associate a URI with a proxy for one of two reasons: either the URI was generated at the server side for the object it represents, or the object is well known, in which case the URI is known.</span></span> <span data-ttu-id="b27ea-303">出于此原因，如果 `Obj` 参数为代理，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="b27ea-303">For this reason, if the `Obj` parameter is a proxy, an exception will be thrown.</span></span> <span data-ttu-id="b27ea-304">对于自定义代理，此限制非常宽松，因为透明代理被视为服务器对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-304">For custom proxies this restriction is relaxed because the transparent proxy is treated as the server object.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><span data-ttu-id="b27ea-305"><paramref name="Obj" /> 是远程对象的代理，<paramref name="ObjUri" /> 参数不为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-305"><paramref name="Obj" /> is a proxy of a remote object, and the <paramref name="ObjUri" /> parameter is not <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b27ea-306">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="b27ea-306">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span></exception>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)"><span data-ttu-id="b27ea-307">应用程序域</span><span class="sxs-lookup"><span data-stu-id="b27ea-307">Application Domains</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetObjectUriForMarshal">
      <MemberSignature Language="C#" Value="public static void SetObjectUriForMarshal (MarshalByRefObject obj, string uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetObjectUriForMarshal(class System.MarshalByRefObject obj, string uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetObjectUriForMarshal (obj As MarshalByRefObject, uri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetObjectUriForMarshal(MarshalByRefObject ^ obj, System::String ^ uri);" />
      <MemberSignature Language="F#" Value="static member SetObjectUriForMarshal : MarshalByRefObject * string -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal (obj, uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
        <Parameter Name="uri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="b27ea-308">为其设置 URI 的对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-308">The object to set a URI for.</span></span></param>
        <param name="uri"><span data-ttu-id="b27ea-309">要分配给指定对象的 URI。</span><span class="sxs-lookup"><span data-stu-id="b27ea-309">The URI to assign to the specified object.</span></span></param>
        <summary><span data-ttu-id="b27ea-310">为后续的 <see cref="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" /> 方法调用设置 URI。</span><span class="sxs-lookup"><span data-stu-id="b27ea-310">Sets the URI for the subsequent call to the <see cref="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" /> method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b27ea-311">当封送处理给定的对象时，将使用当前方法设置的 URI。</span><span class="sxs-lookup"><span data-stu-id="b27ea-311">The URI set by the current method is used when marshaling the given object.</span></span>

 <span data-ttu-id="b27ea-312">封送处理后，将指定对象的 URI 设置为追加到当前 <xref:System.AppDomain>的 <xref:System.Guid> 上的 `uri` 参数中的字符串。</span><span class="sxs-lookup"><span data-stu-id="b27ea-312">After marshaling, the URI of the specified object is set to the string in the `uri` parameter appended onto the <xref:System.Guid> of the current <xref:System.AppDomain>.</span></span>

 <span data-ttu-id="b27ea-313">如果当前应用程序正在侦听 HTTP 端口，则 `uri` 参数中指定的字符串和追加到当前 <xref:System.AppDomain> 的 <xref:System.Guid> 的 `uri` 字符串都将路由到指定的对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-313">If the current application is listening on an HTTP port, then both the string specified in the `uri` parameter and the `uri` string appended onto the <xref:System.Guid> of the current <xref:System.AppDomain> route to the specified object.</span></span> <span data-ttu-id="b27ea-314">例如，如果应用程序正在侦听 HTTP 端口9000，则 `http://localhost:9000/objectUri`和 `http://localhost:9000/<appdomainguid>/objectUri` 路由到 `obj` 参数中指定的对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-314">For example, if the application is listening on HTTP port 9000, then both `http://localhost:9000/objectUri`, and `http://localhost:9000/<appdomainguid>/objectUri` route to the object specified in the `obj` parameter.</span></span>



## Examples
 <span data-ttu-id="b27ea-315">下面的代码示例演示如何设置在封送指定的对象时 <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> 方法将使用的 URI。</span><span class="sxs-lookup"><span data-stu-id="b27ea-315">The following code example demonstrates how to set the URI that will be used by the <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> method when marshaling the specified object.</span></span>

 [!code-cpp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CPP/source.cpp#1)]
 [!code-csharp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CS/source.cs#1)]
 [!code-vb[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><span data-ttu-id="b27ea-316"><paramref name="obj" /> 不是局部对象、已被封送、或已对其调用了当前方法。</span><span class="sxs-lookup"><span data-stu-id="b27ea-316"><paramref name="obj" /> is not a local object, has already been marshaled, or the current method has already been called on.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b27ea-317">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="b27ea-317">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span></exception>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unmarshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b27ea-318">将给定的 <see cref="T:System.Runtime.Remoting.ObjRef" /> 转换为代理对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-318">Converts a given <see cref="T:System.Runtime.Remoting.ObjRef" /> into a proxy object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal objectRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
      </Parameters>
      <Docs>
        <param name="objectRef"><span data-ttu-id="b27ea-319"><see cref="T:System.Runtime.Remoting.ObjRef" />，它代表正在为其创建代理的远程对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-319">The <see cref="T:System.Runtime.Remoting.ObjRef" /> that represents the remote object for which the proxy is being created.</span></span></param>
        <summary><span data-ttu-id="b27ea-320">接受 <see cref="T:System.Runtime.Remoting.ObjRef" /> 并从它创建一个代理对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-320">Takes a <see cref="T:System.Runtime.Remoting.ObjRef" /> and creates a proxy object out of it.</span></span></summary>
        <returns><span data-ttu-id="b27ea-321">给定的 <see cref="T:System.Runtime.Remoting.ObjRef" /> 所代表对象的代理。</span><span class="sxs-lookup"><span data-stu-id="b27ea-321">A proxy to the object that the given <see cref="T:System.Runtime.Remoting.ObjRef" /> represents.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b27ea-322"><xref:System.Runtime.Remoting.ObjRef> 是用于跨应用程序域边界传输对象引用的对象的可序列化表示形式。</span><span class="sxs-lookup"><span data-stu-id="b27ea-322">A <xref:System.Runtime.Remoting.ObjRef> is a serializable representation of an object used to transfer an object reference across an application domain boundary.</span></span> <span data-ttu-id="b27ea-323">为对象创建 <xref:System.Runtime.Remoting.ObjRef> 称为封送处理。</span><span class="sxs-lookup"><span data-stu-id="b27ea-323">Creating a <xref:System.Runtime.Remoting.ObjRef> for an object is known as marshaling.</span></span> <span data-ttu-id="b27ea-324"><xref:System.Runtime.Remoting.ObjRef> 可以通过通道传输到另一个应用程序域（可能在其他进程或计算机上）。</span><span class="sxs-lookup"><span data-stu-id="b27ea-324">The <xref:System.Runtime.Remoting.ObjRef> can be transferred through a channel into another application domain (possibly on another process or computer).</span></span> <span data-ttu-id="b27ea-325">在其他应用程序域中，必须对 <xref:System.Runtime.Remoting.ObjRef> 进行分析，以便为该对象创建一个代理，该代理通常连接到实际对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-325">Once in the other application domain, the <xref:System.Runtime.Remoting.ObjRef> must be parsed to create a proxy for the object, generally connected to the real object.</span></span> <span data-ttu-id="b27ea-326">此操作称为 "取消封送"。</span><span class="sxs-lookup"><span data-stu-id="b27ea-326">This operation is known as unmarshaling.</span></span> <span data-ttu-id="b27ea-327">在取消封送过程中，将对 <xref:System.Runtime.Remoting.ObjRef> 进行分析以提取远程对象的方法信息，并创建透明代理和 <xref:System.Runtime.Remoting.Proxies.RealProxy> 对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-327">During unmarshaling, the <xref:System.Runtime.Remoting.ObjRef> is parsed to extract the method information of the remote object and both the transparent proxy and <xref:System.Runtime.Remoting.Proxies.RealProxy> objects are created.</span></span> <span data-ttu-id="b27ea-328">在将透明代理注册到公共语言运行时之前，已分析的 <xref:System.Runtime.Remoting.ObjRef> 的内容将添加到透明代理。</span><span class="sxs-lookup"><span data-stu-id="b27ea-328">The content of the parsed <xref:System.Runtime.Remoting.ObjRef> is added to the transparent proxy before the transparent proxy is registered with the common language runtime.</span></span>

 <span data-ttu-id="b27ea-329"><xref:System.Runtime.Remoting.ObjRef> 包含描述正在被封送处理的对象的 <xref:System.Type> 和类的信息、唯一标识特定对象实例的 URI 以及有关如何访问该对象所在的远程处理细分的通信相关信息。</span><span class="sxs-lookup"><span data-stu-id="b27ea-329">A <xref:System.Runtime.Remoting.ObjRef> contains information that describes the <xref:System.Type> and class of the object being marshaled, a URI that uniquely identifies the specific object instance, and communication related information about how to reach the remoting subdivision where the object is located.</span></span>



## Examples
 <span data-ttu-id="b27ea-330">下面的代码示例演示如何取消封送对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-330">The following code example demonstrates how to unmarshal an object.</span></span>

 [!code-cpp[RemotingServices.Unmarshal#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CPP/client.cpp#2)]
 [!code-csharp[RemotingServices.Unmarshal#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CS/client.cs#2)]
 [!code-vb[RemotingServices.Unmarshal#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.Unmarshal/VB/client.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b27ea-331"><see cref="T:System.Runtime.Remoting.ObjRef" /> 参数中指定的 <paramref name="objectRef" /> 实例不是格式良好的。</span><span class="sxs-lookup"><span data-stu-id="b27ea-331">The <see cref="T:System.Runtime.Remoting.ObjRef" /> instance specified in the <paramref name="objectRef" /> parameter is not well-formed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b27ea-332">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="b27ea-332">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span></exception>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef, bool fRefine);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef, bool fRefine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef, fRefine As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef, bool fRefine);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef * bool -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal (objectRef, fRefine)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
        <Parameter Name="fRefine" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="objectRef"><span data-ttu-id="b27ea-333"><see cref="T:System.Runtime.Remoting.ObjRef" />，它代表正在为其创建代理的远程对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-333">The <see cref="T:System.Runtime.Remoting.ObjRef" /> that represents the remote object for which the proxy is being created.</span></span></param>
        <param name="fRefine"><span data-ttu-id="b27ea-334">如果为 <see langword="true" />，则将代理精炼为服务器上的类型；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b27ea-334"><see langword="true" /> to refine the proxy to the type on the server; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="b27ea-335">接受 <see cref="T:System.Runtime.Remoting.ObjRef" /> 并从它创建一个代理对象，然后将其精炼为服务器上的类型。</span><span class="sxs-lookup"><span data-stu-id="b27ea-335">Takes a <see cref="T:System.Runtime.Remoting.ObjRef" /> and creates a proxy object out of it, refining it to the type on the server.</span></span></summary>
        <returns><span data-ttu-id="b27ea-336">给定的 <see cref="T:System.Runtime.Remoting.ObjRef" /> 所代表对象的代理。</span><span class="sxs-lookup"><span data-stu-id="b27ea-336">A proxy to the object that the given <see cref="T:System.Runtime.Remoting.ObjRef" /> represents.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="b27ea-337"><xref:System.Runtime.Remoting.ObjRef> 是用于跨应用程序域边界传输对象引用的对象的可序列化表示形式。</span><span class="sxs-lookup"><span data-stu-id="b27ea-337">A <xref:System.Runtime.Remoting.ObjRef> is a serializable representation of an object used to transfer an object reference across an application domain boundary.</span></span> <span data-ttu-id="b27ea-338">为对象创建 <xref:System.Runtime.Remoting.ObjRef> 称为封送处理。</span><span class="sxs-lookup"><span data-stu-id="b27ea-338">Creating a <xref:System.Runtime.Remoting.ObjRef> for an object is known as marshaling.</span></span> <span data-ttu-id="b27ea-339"><xref:System.Runtime.Remoting.ObjRef> 可以通过通道传输到另一个应用程序域（可能在其他进程或计算机上）。</span><span class="sxs-lookup"><span data-stu-id="b27ea-339">The <xref:System.Runtime.Remoting.ObjRef> can be transferred through a channel into another application domain (possibly on another process or computer).</span></span> <span data-ttu-id="b27ea-340">在其他应用程序域中，必须对 <xref:System.Runtime.Remoting.ObjRef> 进行分析，以便为该对象创建一个代理，该代理通常连接到实际对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-340">Once in the other application domain, the <xref:System.Runtime.Remoting.ObjRef> must be parsed to create a proxy for the object, generally connected to the real object.</span></span> <span data-ttu-id="b27ea-341">此操作称为 "取消封送"。</span><span class="sxs-lookup"><span data-stu-id="b27ea-341">This operation is known as unmarshaling.</span></span> <span data-ttu-id="b27ea-342">在取消封送过程中，将对 <xref:System.Runtime.Remoting.ObjRef> 进行分析以提取远程对象的方法信息，并创建透明代理和 <xref:System.Runtime.Remoting.Proxies.RealProxy> 对象。</span><span class="sxs-lookup"><span data-stu-id="b27ea-342">During unmarshaling, the <xref:System.Runtime.Remoting.ObjRef> is parsed to extract the method information of the remote object and both the transparent proxy and <xref:System.Runtime.Remoting.Proxies.RealProxy> objects are created.</span></span> <span data-ttu-id="b27ea-343">在将透明代理注册到公共语言运行时之前，已分析的 <xref:System.Runtime.Remoting.ObjRef> 的内容将添加到透明代理。</span><span class="sxs-lookup"><span data-stu-id="b27ea-343">The content of the parsed <xref:System.Runtime.Remoting.ObjRef> is added to the transparent proxy before the transparent proxy is registered with the common language runtime.</span></span>

 <span data-ttu-id="b27ea-344"><xref:System.Runtime.Remoting.ObjRef> 包含描述正在被封送处理的对象的 <xref:System.Type> 和类的信息、唯一标识特定对象实例的 URI 以及有关如何访问该对象所在的远程处理细分的通信相关信息。</span><span class="sxs-lookup"><span data-stu-id="b27ea-344">A <xref:System.Runtime.Remoting.ObjRef> contains information that describes the <xref:System.Type> and class of the object being marshaled, a URI that uniquely identifies the specific object instance, and communication related information about how to reach the remoting subdivision where the object is located.</span></span>

 <span data-ttu-id="b27ea-345">第一次创建时，代理的类型为 <xref:System.MarshalByRefObject>。</span><span class="sxs-lookup"><span data-stu-id="b27ea-345">When first created, the proxy is of type <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="b27ea-346">将其转换为不同的类型时，远程处理基础结构将跟踪使用最多的类型，以避免不必要地加载该类型。</span><span class="sxs-lookup"><span data-stu-id="b27ea-346">As you cast it into different types, the remoting infrastructure keeps track of the most used type to avoid loading the type unnecessarily.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b27ea-347"><see cref="T:System.Runtime.Remoting.ObjRef" /> 参数中指定的 <paramref name="objectRef" /> 实例不是格式良好的。</span><span class="sxs-lookup"><span data-stu-id="b27ea-347">The <see cref="T:System.Runtime.Remoting.ObjRef" /> instance specified in the <paramref name="objectRef" /> parameter is not well-formed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b27ea-348">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</span><span class="sxs-lookup"><span data-stu-id="b27ea-348">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels.</span></span></exception>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
  </Members>
</Type>
