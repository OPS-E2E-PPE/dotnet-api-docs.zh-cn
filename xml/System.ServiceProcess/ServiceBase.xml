<Type Name="ServiceBase" FullName="System.ServiceProcess.ServiceBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="772f84e9b1ed7bfd268e036852814e604459b1b8" /><Meta Name="ms.sourcegitcommit" Value="a8ff98b48bda124cfcb2605f5da9b21bc6dcd791" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="02/14/2020" /><Meta Name="ms.locfileid" Value="77221075" /></Metadata><TypeSignature Language="C#" Value="public class ServiceBase : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceBase extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ServiceProcess.ServiceBase" />
  <TypeSignature Language="VB.NET" Value="Public Class ServiceBase&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBase : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type ServiceBase = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>4.2.3.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.ServiceProcess.ServiceProcessInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.UserNTServiceDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.IRootDesigner")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="6d86a-101">为将作为服务应用程序的一部分而存在的服务提供基类。</span><span class="sxs-lookup"><span data-stu-id="6d86a-101">Provides a base class for a service that will exist as part of a service application.</span></span> <span data-ttu-id="6d86a-102">在创建新的服务类时，必须从 <see cref="T:System.ServiceProcess.ServiceBase" /> 派生。</span><span class="sxs-lookup"><span data-stu-id="6d86a-102"><see cref="T:System.ServiceProcess.ServiceBase" /> must be derived from when creating a new service class.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6d86a-103">在服务应用程序中定义服务类时从 <xref:System.ServiceProcess.ServiceBase> 派生。</span><span class="sxs-lookup"><span data-stu-id="6d86a-103">Derive from <xref:System.ServiceProcess.ServiceBase> when defining your service class in a service application.</span></span> <span data-ttu-id="6d86a-104">任何有用的服务都将覆盖 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 和 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="6d86a-104">Any useful service overrides the <xref:System.ServiceProcess.ServiceBase.OnStart%2A> and <xref:System.ServiceProcess.ServiceBase.OnStop%2A> methods.</span></span> <span data-ttu-id="6d86a-105">对于其他功能，可以重写 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 和 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>，以响应服务状态的更改。</span><span class="sxs-lookup"><span data-stu-id="6d86a-105">For additional functionality, you can override <xref:System.ServiceProcess.ServiceBase.OnPause%2A> and <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> with specific behavior in response to changes in the service state.</span></span>  
  
 <span data-ttu-id="6d86a-106">服务是长时间运行的可执行文件，它不支持用户界面，而且可能不会在登录用户帐户下运行。</span><span class="sxs-lookup"><span data-stu-id="6d86a-106">A service is a long-running executable that does not support a user interface, and which might not run under the logged-on user account.</span></span> <span data-ttu-id="6d86a-107">此服务可以在没有任何用户登录到计算机的情况下运行。</span><span class="sxs-lookup"><span data-stu-id="6d86a-107">The service can run without any user being logged on to the computer.</span></span>  
  
 <span data-ttu-id="6d86a-108">默认情况下，服务在系统帐户下运行，该帐户不是管理员帐户。</span><span class="sxs-lookup"><span data-stu-id="6d86a-108">By default, services run under the System account, which is not the same as the Administrator account.</span></span> <span data-ttu-id="6d86a-109">不能更改系统帐户的权限。</span><span class="sxs-lookup"><span data-stu-id="6d86a-109">You cannot change the rights of the System account.</span></span> <span data-ttu-id="6d86a-110">或者，你可以使用 <xref:System.ServiceProcess.ServiceProcessInstaller> 来指定运行该服务所用的用户帐户。</span><span class="sxs-lookup"><span data-stu-id="6d86a-110">Alternatively, you can use a <xref:System.ServiceProcess.ServiceProcessInstaller> to specify a user account under which the service will run.</span></span>  
  
 <span data-ttu-id="6d86a-111">一个可执行文件可以包含多个服务，但必须包含每个服务的单独 <xref:System.ServiceProcess.ServiceInstaller>。</span><span class="sxs-lookup"><span data-stu-id="6d86a-111">An executable can contain more than one service but must contain a separate <xref:System.ServiceProcess.ServiceInstaller> for each service.</span></span> <span data-ttu-id="6d86a-112"><xref:System.ServiceProcess.ServiceInstaller> 实例将服务注册到系统。</span><span class="sxs-lookup"><span data-stu-id="6d86a-112">The <xref:System.ServiceProcess.ServiceInstaller> instance registers the service with the system.</span></span> <span data-ttu-id="6d86a-113">安装程序还将每个服务与可用于记录服务命令的事件日志相关联。</span><span class="sxs-lookup"><span data-stu-id="6d86a-113">The installer also associates each service with an event log that you can use to record service commands.</span></span> <span data-ttu-id="6d86a-114">可执行文件中的 `main()` 函数定义了应运行哪些服务。</span><span class="sxs-lookup"><span data-stu-id="6d86a-114">The `main()` function in the executable defines which services should run.</span></span> <span data-ttu-id="6d86a-115">服务的当前工作目录是系统目录，而不是可执行文件所在的目录。</span><span class="sxs-lookup"><span data-stu-id="6d86a-115">The current working directory of the service is the system directory, not the directory in which the executable is located.</span></span>  
  
 <span data-ttu-id="6d86a-116">启动服务时，系统将查找可执行文件，并运行该服务的 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 方法，该方法包含在可执行文件中。</span><span class="sxs-lookup"><span data-stu-id="6d86a-116">When you start a service, the system locates the executable and runs the <xref:System.ServiceProcess.ServiceBase.OnStart%2A> method for that service, contained within the executable.</span></span> <span data-ttu-id="6d86a-117">但是，运行该服务与运行可执行文件不同。</span><span class="sxs-lookup"><span data-stu-id="6d86a-117">However, running the service is not the same as running the executable.</span></span> <span data-ttu-id="6d86a-118">可执行文件只会加载服务。</span><span class="sxs-lookup"><span data-stu-id="6d86a-118">The executable only loads the service.</span></span> <span data-ttu-id="6d86a-119">服务可通过服务控制管理器进行访问（例如，已启动和停止）。</span><span class="sxs-lookup"><span data-stu-id="6d86a-119">The service is accessed (for example, started and stopped) through the Service Control Manager.</span></span>  
  
 <span data-ttu-id="6d86a-120">第一次在服务上调用时，可执行文件调用 <xref:System.ServiceProcess.ServiceBase> 派生类的构造函数。</span><span class="sxs-lookup"><span data-stu-id="6d86a-120">The executable calls the <xref:System.ServiceProcess.ServiceBase> derived class's constructor the first time you call Start on the service.</span></span> <span data-ttu-id="6d86a-121"><xref:System.ServiceProcess.ServiceBase.OnStart%2A> 命令处理方法将在构造函数执行后立即调用。</span><span class="sxs-lookup"><span data-stu-id="6d86a-121">The <xref:System.ServiceProcess.ServiceBase.OnStart%2A> command-handling method is called immediately after the constructor executes.</span></span> <span data-ttu-id="6d86a-122">第一次加载服务后，不会再次执行构造函数，因此必须将由构造函数执行的处理与 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>执行的处理分离。</span><span class="sxs-lookup"><span data-stu-id="6d86a-122">The constructor is not executed again after the first time the service has been loaded, so it is necessary to separate the processing performed by the constructor from that performed by <xref:System.ServiceProcess.ServiceBase.OnStart%2A>.</span></span> <span data-ttu-id="6d86a-123"><xref:System.ServiceProcess.ServiceBase.OnStop%2A> 可以发布的任何资源都应在 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>中创建。</span><span class="sxs-lookup"><span data-stu-id="6d86a-123">Any resources that can be released by <xref:System.ServiceProcess.ServiceBase.OnStop%2A> should be created in <xref:System.ServiceProcess.ServiceBase.OnStart%2A>.</span></span> <span data-ttu-id="6d86a-124">如果在 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 释放资源后再次启动了服务，则在构造函数中创建资源可防止正确创建这些资源。</span><span class="sxs-lookup"><span data-stu-id="6d86a-124">Creating resources in the constructor prevents them from being created properly if the service is started again after <xref:System.ServiceProcess.ServiceBase.OnStop%2A> has released the resources.</span></span>  
  
 <span data-ttu-id="6d86a-125">服务控制管理器（SCM）提供了一种与服务交互的方式。</span><span class="sxs-lookup"><span data-stu-id="6d86a-125">The Service Control Manager (SCM) provides a way to interact with the service.</span></span> <span data-ttu-id="6d86a-126">可以使用 SCM 将开始、停止、暂停、继续或自定义命令传递到服务中。</span><span class="sxs-lookup"><span data-stu-id="6d86a-126">You can use the SCM to pass Start, Stop, Pause, Continue, or custom commands into the service.</span></span> <span data-ttu-id="6d86a-127">SCM 使用 <xref:System.ServiceProcess.ServiceBase.CanStop%2A> 和 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> 的值来确定服务是否接受 "停止"、"暂停" 或 "继续" 命令。</span><span class="sxs-lookup"><span data-stu-id="6d86a-127">The SCM uses the values of <xref:System.ServiceProcess.ServiceBase.CanStop%2A> and <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> to determine whether the service accepts Stop, Pause, or Continue commands.</span></span> <span data-ttu-id="6d86a-128">仅当在服务类中 `true` 了相应的属性 <xref:System.ServiceProcess.ServiceBase.CanStop%2A> 或 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> 时，才会在 SCM 的上下文菜单中启用 "停止"、"暂停" 和 "继续"。</span><span class="sxs-lookup"><span data-stu-id="6d86a-128">Stop, Pause, and Continue are enabled in the SCM's context menus only if the corresponding property <xref:System.ServiceProcess.ServiceBase.CanStop%2A> or <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> is `true` in the service class.</span></span> <span data-ttu-id="6d86a-129">如果启用，则会将命令传递到服务，并调用 <xref:System.ServiceProcess.ServiceBase.OnStop%2A>、<xref:System.ServiceProcess.ServiceBase.OnPause%2A>或 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>。</span><span class="sxs-lookup"><span data-stu-id="6d86a-129">If enabled, the command is passed to the service, and <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, or <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> is called.</span></span> <span data-ttu-id="6d86a-130">如果 `false`<xref:System.ServiceProcess.ServiceBase.CanStop%2A>、<xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>或 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>，则将不会处理相应的命令处理方法（如 <xref:System.ServiceProcess.ServiceBase.OnStop%2A>），即使已实现了方法也是如此。</span><span class="sxs-lookup"><span data-stu-id="6d86a-130">If <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, or <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> is `false`, the corresponding command-handling method (such as <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) will not be processed, even if you have implemented the method.</span></span>  
  
 <span data-ttu-id="6d86a-131">您可以使用 <xref:System.ServiceProcess.ServiceController> 类以编程方式使用用户界面执行 SCM 的操作。</span><span class="sxs-lookup"><span data-stu-id="6d86a-131">You can use the <xref:System.ServiceProcess.ServiceController> class to do programmatically what the SCM does using a user interface.</span></span> <span data-ttu-id="6d86a-132">可以自动执行控制台中提供的任务。</span><span class="sxs-lookup"><span data-stu-id="6d86a-132">You can automate the tasks available in the console.</span></span> <span data-ttu-id="6d86a-133">如果 `true` <xref:System.ServiceProcess.ServiceBase.CanStop%2A>、<xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>或 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> 但尚未实现相应的命令处理方法（如 <xref:System.ServiceProcess.ServiceBase.OnStop%2A>），则系统将引发异常并忽略命令。</span><span class="sxs-lookup"><span data-stu-id="6d86a-133">If <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, or <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> is `true` but you have not implemented a corresponding command-handling method (such as <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) the system throws an exception and ignores the command.</span></span>  
  
 <span data-ttu-id="6d86a-134">不需要在 <xref:System.ServiceProcess.ServiceBase>中实现 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>、<xref:System.ServiceProcess.ServiceBase.OnStop%2A>或任何其他方法。</span><span class="sxs-lookup"><span data-stu-id="6d86a-134">You do not have to implement <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, or any other method in <xref:System.ServiceProcess.ServiceBase>.</span></span> <span data-ttu-id="6d86a-135">但是，在 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>中描述了服务的行为，因此至少应覆盖此成员。</span><span class="sxs-lookup"><span data-stu-id="6d86a-135">However, the service's behavior is described in <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, so at minimum, this member should be overridden.</span></span> <span data-ttu-id="6d86a-136">可执行文件的 `main()` 函数通过调用 <xref:System.ServiceProcess.ServiceBase.Run%2A> 方法，将可执行文件中的服务注册到服务控制管理器。</span><span class="sxs-lookup"><span data-stu-id="6d86a-136">The `main()` function of the executable registers the service in the executable with the Service Control Manager by calling the <xref:System.ServiceProcess.ServiceBase.Run%2A> method.</span></span> <span data-ttu-id="6d86a-137">传递给 <xref:System.ServiceProcess.ServiceBase.Run%2A> 方法的 <xref:System.ServiceProcess.ServiceBase> 对象的 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> 属性必须与该服务的服务安装程序的 <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A> 属性匹配。</span><span class="sxs-lookup"><span data-stu-id="6d86a-137">The <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> property of the <xref:System.ServiceProcess.ServiceBase> object passed to the <xref:System.ServiceProcess.ServiceBase.Run%2A> method must match the <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A> property of the service installer for that service.</span></span>  
  
 <span data-ttu-id="6d86a-138">您可以使用 `InstallUtil.exe` 在您的系统上安装服务。</span><span class="sxs-lookup"><span data-stu-id="6d86a-138">You can use `InstallUtil.exe` to install services on your system.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6d86a-139">可以指定除应用程序事件日志以外的日志来接收服务调用的通知，但 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> 和 <xref:System.ServiceProcess.ServiceBase.EventLog%2A> 属性都不能写入自定义日志。</span><span class="sxs-lookup"><span data-stu-id="6d86a-139">You can specify a log other than the Application event log to receive notification of service calls, but neither the <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> nor the <xref:System.ServiceProcess.ServiceBase.EventLog%2A> property can write to a custom log.</span></span> <span data-ttu-id="6d86a-140">如果你不希望使用自动日志记录，请将 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> 设置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="6d86a-140">Set <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> to `false` if you do not want to use automatic logging.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceProcess.ServiceProcessInstaller" />
    <altmember cref="T:System.ServiceProcess.ServiceInstaller" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6d86a-141">创建 <see cref="T:System.ServiceProcess.ServiceBase" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="6d86a-141">Creates a new instance of the <see cref="T:System.ServiceProcess.ServiceBase" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6d86a-142">请勿创建 <xref:System.ServiceProcess.ServiceBase> 类的实例。</span><span class="sxs-lookup"><span data-stu-id="6d86a-142">Do not create an instance of the <xref:System.ServiceProcess.ServiceBase> class.</span></span> <span data-ttu-id="6d86a-143">相反，派生自 <xref:System.ServiceProcess.ServiceBase> 并实例化派生类。</span><span class="sxs-lookup"><span data-stu-id="6d86a-143">Instead, derive from <xref:System.ServiceProcess.ServiceBase> and instantiate your derived class.</span></span> <span data-ttu-id="6d86a-144">在从 <xref:System.ServiceProcess.ServiceBase> 继承的类的构造函数中实现所需的最小值是在组件上设置 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>。</span><span class="sxs-lookup"><span data-stu-id="6d86a-144">The minimum you need to implement in the constructor for a class inherited from <xref:System.ServiceProcess.ServiceBase> is to set the <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> on your component.</span></span> <span data-ttu-id="6d86a-145">构造函数中不特别需要其他处理。</span><span class="sxs-lookup"><span data-stu-id="6d86a-145">No other processing is specifically required in the constructor.</span></span> <span data-ttu-id="6d86a-146">应在 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 而不是在构造函数中处理大多数初始化。</span><span class="sxs-lookup"><span data-stu-id="6d86a-146">You should handle most initialization in <xref:System.ServiceProcess.ServiceBase.OnStart%2A> rather than in the constructor.</span></span> <span data-ttu-id="6d86a-147">否则，在服务停止后重新启动该服务时，对象将重新初始化。</span><span class="sxs-lookup"><span data-stu-id="6d86a-147">Otherwise, there is no guarantee the objects will be reinitialized when you restart a service after it has been stopped.</span></span>  
  
 <span data-ttu-id="6d86a-148">如果重写派生类中的构造函数，请在代码中调用基类构造函数。</span><span class="sxs-lookup"><span data-stu-id="6d86a-148">If you override the constructor in your derived class, call the base class constructor in your code.</span></span>  
  
 <span data-ttu-id="6d86a-149"><xref:System.ServiceProcess.ServiceBase> 构造函数将 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> 设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="6d86a-149">The <xref:System.ServiceProcess.ServiceBase> constructor sets <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> to `true`.</span></span> <span data-ttu-id="6d86a-150">如果你不希望从服务控制管理器（SCM）自动记录对服务的调用，请将 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> 设置为 `false`。</span><span class="sxs-lookup"><span data-stu-id="6d86a-150">If you do not want to automatically log calls to the service from the Service Control Manager (SCM), set <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> to `false`.</span></span>  
  
 <span data-ttu-id="6d86a-151">如果可执行文件包含单个服务，则在从 SCM 中选择 "启动" 时，系统会调用服务的构造函数，如果调用了 Stop，则会运行析构函数。</span><span class="sxs-lookup"><span data-stu-id="6d86a-151">If the executable contains a single service, the system calls the service's constructor when Start is selected from the SCM, and runs the destructor if Stop is called.</span></span>  
  
 <span data-ttu-id="6d86a-152">如果可执行文件包含多个服务，则对一个服务调用 "启动" 将导致为可执行文件中的所有服务调用构造函数，但只启动指定的服务。</span><span class="sxs-lookup"><span data-stu-id="6d86a-152">If the executable contains multiple services, calling Start on one service causes the constructors to be called for all services in the executable, but only the specified service is started.</span></span> <span data-ttu-id="6d86a-153">所有服务都已停止时，服务的析构函数会一起运行，而不会在每个服务停止时单独运行。</span><span class="sxs-lookup"><span data-stu-id="6d86a-153">Destructors for the services are run together when all services have been stopped, not individually when each service is stopped.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6d86a-154">如果重写基类构造函数，则应在派生类的构造函数中显式调用它。</span><span class="sxs-lookup"><span data-stu-id="6d86a-154">If you override the base class constructor, you should explicitly call it in the constructor of your derived class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      </Docs>
    </Member>
    <Member MemberName="AutoLog">
      <MemberSignature Language="C#" Value="public bool AutoLog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoLog As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoLog { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoLog : bool with get, set" Usage="System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBAutoLog")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6d86a-155">指示是否在事件日志中报告“开始”、“停止”、“暂停”以及“继续”命令。</span><span class="sxs-lookup"><span data-stu-id="6d86a-155">Indicates whether to report Start, Stop, Pause, and Continue commands in the event log.</span></span></summary>
        <value><span data-ttu-id="6d86a-156">为 <see langword="true" /> 时在事件日志中报告信息；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6d86a-156"><see langword="true" /> to report information in the event log; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6d86a-157">将 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> 设置为 `true` 会指示服务使用应用程序事件日志来报告命令失败，并将状态更改信息用于服务上的 "启动"、"停止"、"暂停" 和 "继续" 事件。</span><span class="sxs-lookup"><span data-stu-id="6d86a-157">Setting <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> to `true` instructs the service to use the Application event log to report command failures, as well as state change information for Start, Stop, Pause, and Continue events on the service.</span></span> <span data-ttu-id="6d86a-158">服务名称用作日志的 <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6d86a-158">The name of the service is used as the log's <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="6d86a-159">若要将信息报告给自定义事件日志而不是应用程序日志，请将 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> 设置为 `false` 并在命令处理方法中编写指令 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>、<xref:System.ServiceProcess.ServiceBase.OnPause%2A>或 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 发布到适当的日志。</span><span class="sxs-lookup"><span data-stu-id="6d86a-159">To report information to a custom event log rather than the Application log, set <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> to `false` and write instructions within the command-handling methods <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, or <xref:System.ServiceProcess.ServiceBase.OnStop%2A> to post to the appropriate log.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6d86a-160">在服务尝试写入事件日志之前，必须设置提供事件日志的源字符串的 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>。</span><span class="sxs-lookup"><span data-stu-id="6d86a-160">The <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, which supplies the source string for the event log, must be set before the service attempts to write to the event log.</span></span> <span data-ttu-id="6d86a-161">尝试在设置源名称之前访问事件日志会引发异常。</span><span class="sxs-lookup"><span data-stu-id="6d86a-161">Trying to access the event log before the source name is set throws an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.EventLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandlePowerEvent">
      <MemberSignature Language="C#" Value="public bool CanHandlePowerEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandlePowerEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandlePowerEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandlePowerEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandlePowerEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6d86a-162">获取或设置一个值，该值指示服务是否可以处理计算机电源状态更改通知。</span><span class="sxs-lookup"><span data-stu-id="6d86a-162">Gets or sets a value indicating whether the service can handle notifications of computer power status changes.</span></span></summary>
        <value><span data-ttu-id="6d86a-163">如果服务处理 <see langword="true" /> 类中指示的计算机电源状态更改，则为 <see cref="T:System.ServiceProcess.PowerBroadcastStatus" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6d86a-163"><see langword="true" /> if the service handles the computer power status changes indicated in the <see cref="T:System.ServiceProcess.PowerBroadcastStatus" /> class, otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6d86a-164">当计算机电源状态更改时，服务控制管理器（SCM）使用 <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>的值验证服务是否接受电源事件命令。</span><span class="sxs-lookup"><span data-stu-id="6d86a-164">When the computer power status changes, the Service Control Manager (SCM) verifies whether the service accepts power event commands using the value of <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>.</span></span>  
  
 <span data-ttu-id="6d86a-165">如果 `true`<xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>，则会将命令传递到服务，并在定义的情况下调用 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="6d86a-165">If <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> is `true`, the command is passed to the service and the <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> method is called if defined.</span></span> <span data-ttu-id="6d86a-166">如果未在派生类中实现 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>，则 SCM 通过空基类 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=nameWithType> 方法来处理电源事件。</span><span class="sxs-lookup"><span data-stu-id="6d86a-166">If <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> is not implemented in the derived class, the SCM handles the power event through the empty base class <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6d86a-167">此属性将在服务启动后被修改。</span><span class="sxs-lookup"><span data-stu-id="6d86a-167">This property is modified after the service was started.</span></span></exception>
        <altmember cref="T:System.ServiceProcess.PowerBroadcastStatus" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandleSessionChangeEvent">
      <MemberSignature Language="C#" Value="public bool CanHandleSessionChangeEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandleSessionChangeEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandleSessionChangeEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandleSessionChangeEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandleSessionChangeEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6d86a-168">获取或设置一个值，该值指示服务是否可以处理从终端服务器会话接收到的会话更改事件。</span><span class="sxs-lookup"><span data-stu-id="6d86a-168">Gets or sets a value that indicates whether the service can handle session change events received from a Terminal Server session.</span></span></summary>
        <value><span data-ttu-id="6d86a-169">如果服务可以处理终端服务器会话更改事件，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6d86a-169"><see langword="true" /> if the service can handle Terminal Server session change events; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6d86a-170">此属性将在服务启动后被修改。</span><span class="sxs-lookup"><span data-stu-id="6d86a-170">This property is modified after the service was started.</span></span></exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanPauseAndContinue">
      <MemberSignature Language="C#" Value="public bool CanPauseAndContinue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanPauseAndContinue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberSignature Language="VB.NET" Value="Public Property CanPauseAndContinue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanPauseAndContinue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanPauseAndContinue : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6d86a-171">获取或设置指示服务是否可以暂停并再继续的值。</span><span class="sxs-lookup"><span data-stu-id="6d86a-171">Gets or sets a value indicating whether the service can be paused and resumed.</span></span></summary>
        <value><span data-ttu-id="6d86a-172">如果服务可以暂停，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6d86a-172"><see langword="true" /> if the service can be paused; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6d86a-173">在服务的构造函数中设置 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> 属性的值。</span><span class="sxs-lookup"><span data-stu-id="6d86a-173">Set the value of the <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> property in the constructor for the service.</span></span>  
  
 <span data-ttu-id="6d86a-174">服务暂停时，它会暂停正在进行的操作。</span><span class="sxs-lookup"><span data-stu-id="6d86a-174">When a service is paused, it halts what it is doing.</span></span> <span data-ttu-id="6d86a-175">当你通过服务控制管理器或以编程方式继续服务时，<xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 将运行。</span><span class="sxs-lookup"><span data-stu-id="6d86a-175">When you continue the service (either through the Service Control Manager or programmatically), <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> runs.</span></span>  
  
 <span data-ttu-id="6d86a-176">向服务发送暂停请求可以节省系统资源。</span><span class="sxs-lookup"><span data-stu-id="6d86a-176">Sending a Pause request to the service can conserve system resources.</span></span> <span data-ttu-id="6d86a-177">暂停可能不会释放所有系统资源，而是停止。</span><span class="sxs-lookup"><span data-stu-id="6d86a-177">Pause may not release all system resources, but Stop does.</span></span> <span data-ttu-id="6d86a-178">通常实现 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 和 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 来执行比 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 和 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>更少的处理。</span><span class="sxs-lookup"><span data-stu-id="6d86a-178"><xref:System.ServiceProcess.ServiceBase.OnPause%2A> and <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> are often implemented to perform less processing than <xref:System.ServiceProcess.ServiceBase.OnStop%2A> and <xref:System.ServiceProcess.ServiceBase.OnStart%2A>.</span></span>  
  
 <span data-ttu-id="6d86a-179">`true`<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> 时，重写 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 和 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 以指定在服务控制管理器（SCM）向服务传递暂停或继续请求时应发生的处理。</span><span class="sxs-lookup"><span data-stu-id="6d86a-179">When <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> is `true`, override <xref:System.ServiceProcess.ServiceBase.OnPause%2A> and <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> to specify the processing that should occur when the Service Control Manager (SCM) passes a Pause or Continue request to your service.</span></span> <span data-ttu-id="6d86a-180">应该实现 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 来撤消 <xref:System.ServiceProcess.ServiceBase.OnPause%2A>中的处理。</span><span class="sxs-lookup"><span data-stu-id="6d86a-180"><xref:System.ServiceProcess.ServiceBase.OnContinue%2A> should be implemented to undo the processing in <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.</span></span>  
  
 <span data-ttu-id="6d86a-181">如果 `false`<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>，则 SCM 将不会向服务传递暂停或继续请求，因此不会调用 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 和 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 方法，即使它们是实现的也是如此。</span><span class="sxs-lookup"><span data-stu-id="6d86a-181">If <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> is `false`, the SCM will not pass Pause or Continue requests to the service, so the <xref:System.ServiceProcess.ServiceBase.OnPause%2A> and <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> methods will not be called even if they are implemented.</span></span> <span data-ttu-id="6d86a-182">在 SCM 中，<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> `false`时禁用 `Pause` 和 `Continue` 控件。</span><span class="sxs-lookup"><span data-stu-id="6d86a-182">In the SCM, the `Pause` and `Continue` controls are disabled when <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6d86a-183">服务已启动。</span><span class="sxs-lookup"><span data-stu-id="6d86a-183">The service has already been started.</span></span> <span data-ttu-id="6d86a-184">在服务启动后不能更改 <see cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="6d86a-184">The <see cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" /> property cannot be changed once the service has started.</span></span></exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanShutdown">
      <MemberSignature Language="C#" Value="public bool CanShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property CanShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanShutdown : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6d86a-185">获取或设置一个值，该值指示系统关闭时是否应通知服务。</span><span class="sxs-lookup"><span data-stu-id="6d86a-185">Gets or sets a value indicating whether the service should be notified when the system is shutting down.</span></span></summary>
        <value><span data-ttu-id="6d86a-186">如果系统关闭时应通知服务，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6d86a-186"><see langword="true" /> if the service should be notified when the system is shutting down; otherwise, <see langword="false" />.</span></span>  <span data-ttu-id="6d86a-187">默认为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6d86a-187">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6d86a-188">如果 `true`<xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>，系统将在关闭系统时通知服务。</span><span class="sxs-lookup"><span data-stu-id="6d86a-188">If <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> is `true`, the service is notified when the system is shutting down.</span></span> <span data-ttu-id="6d86a-189">关机时，如果已在派生类中实现，则调用 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="6d86a-189">At shutdown, the <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> method is called if it has been implemented in your derived class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6d86a-190">只有系统会导致 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> 方法执行;服务可以调用它，但不建议这样做。</span><span class="sxs-lookup"><span data-stu-id="6d86a-190">Only the system should cause the <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> method to execute; the service can call it, but this is not recommended.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6d86a-191">服务已启动。</span><span class="sxs-lookup"><span data-stu-id="6d86a-191">The service has already been started.</span></span> <span data-ttu-id="6d86a-192">在服务启动后不能更改 <see cref="P:System.ServiceProcess.ServiceBase.CanShutdown" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="6d86a-192">The <see cref="P:System.ServiceProcess.ServiceBase.CanShutdown" /> property cannot be changed once the service has started.</span></span></exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanStop">
      <MemberSignature Language="C#" Value="public bool CanStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanStop" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanStop" />
      <MemberSignature Language="VB.NET" Value="Public Property CanStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanStop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanStop : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6d86a-193">获取或设置一个值，该值指示服务启动后是否可以停止。</span><span class="sxs-lookup"><span data-stu-id="6d86a-193">Gets or sets a value indicating whether the service can be stopped once it has started.</span></span></summary>
        <value><span data-ttu-id="6d86a-194">如果服务可以停止并调用了 <see langword="true" /> 方法，则为 <see cref="M:System.ServiceProcess.ServiceBase.OnStop" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6d86a-194"><see langword="true" /> if the service can be stopped and the <see cref="M:System.ServiceProcess.ServiceBase.OnStop" /> method called; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6d86a-195">当对服务调用 "停止" 时，服务控制管理器（SCM）使用 <xref:System.ServiceProcess.ServiceBase.CanStop%2A>的值验证服务是否接受 Stop 命令。</span><span class="sxs-lookup"><span data-stu-id="6d86a-195">When Stop is called on a service, the Service Control Manager (SCM) verifies whether the service accepts Stop commands using the value of <xref:System.ServiceProcess.ServiceBase.CanStop%2A>.</span></span> <span data-ttu-id="6d86a-196">对于大多数服务，<xref:System.ServiceProcess.ServiceBase.CanStop%2A> 的值是 `true`的，但是一些操作系统服务不允许用户将其停止。</span><span class="sxs-lookup"><span data-stu-id="6d86a-196">For most services, the value of <xref:System.ServiceProcess.ServiceBase.CanStop%2A> is `true`, but some operating system services, for example, do not allow the user to stop them.</span></span>  
  
 <span data-ttu-id="6d86a-197">如果 `true`<xref:System.ServiceProcess.ServiceBase.CanStop%2A>，则会将 Stop 命令传递给服务，并在定义 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 方法的情况下调用它。</span><span class="sxs-lookup"><span data-stu-id="6d86a-197">If <xref:System.ServiceProcess.ServiceBase.CanStop%2A> is `true`, the Stop command is passed to the service and the <xref:System.ServiceProcess.ServiceBase.OnStop%2A> method is called if it is defined.</span></span> <span data-ttu-id="6d86a-198">如果未在派生类中实现 <xref:System.ServiceProcess.ServiceBase.OnStop%2A>，则 SCM 通过空基类 <xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=nameWithType> 方法来处理 Stop 命令。</span><span class="sxs-lookup"><span data-stu-id="6d86a-198">If <xref:System.ServiceProcess.ServiceBase.OnStop%2A> is not implemented in the derived class, the SCM handles the Stop command through the empty base class <xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6d86a-199">服务已启动。</span><span class="sxs-lookup"><span data-stu-id="6d86a-199">The service has already been started.</span></span> <span data-ttu-id="6d86a-200">在服务启动后不能更改 <see cref="P:System.ServiceProcess.ServiceBase.CanStop" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="6d86a-200">The <see cref="P:System.ServiceProcess.ServiceBase.CanStop" /> property cannot be changed once the service has started.</span></span></exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="serviceBase.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="6d86a-201">如果为 <see langword="true" />，则托管及非托管资源都释放；如果为 <see langword="false" />，则仅释放非托管资源。</span><span class="sxs-lookup"><span data-stu-id="6d86a-201"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="6d86a-202">处置由 <see cref="T:System.ServiceProcess.ServiceBase" /> 占用的资源（内存除外）。</span><span class="sxs-lookup"><span data-stu-id="6d86a-202">Disposes of the resources (other than memory) used by the <see cref="T:System.ServiceProcess.ServiceBase" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6d86a-203">使用派生类完成后，在派生类中调用 <xref:System.ServiceProcess.ServiceBase.Dispose%2A> （以及在 <xref:System.ServiceProcess.ServiceBase> 类中）。</span><span class="sxs-lookup"><span data-stu-id="6d86a-203">Call <xref:System.ServiceProcess.ServiceBase.Dispose%2A> in your derived class (and through it, in the <xref:System.ServiceProcess.ServiceBase> class) when you are finished using the derived class.</span></span> <span data-ttu-id="6d86a-204"><xref:System.ServiceProcess.ServiceBase.Dispose%2A> 方法使派生类处于不可用状态。</span><span class="sxs-lookup"><span data-stu-id="6d86a-204">The <xref:System.ServiceProcess.ServiceBase.Dispose%2A> method leaves the derived class in an unusable state.</span></span> <span data-ttu-id="6d86a-205">在调用 <xref:System.ServiceProcess.ServiceBase.Dispose%2A>之后，必须释放对派生类的所有引用，并 <xref:System.ServiceProcess.ServiceBase>，以便可通过垃圾回收来回收它们占用的内存。</span><span class="sxs-lookup"><span data-stu-id="6d86a-205">After calling <xref:System.ServiceProcess.ServiceBase.Dispose%2A>, you must release all references to the derived class and <xref:System.ServiceProcess.ServiceBase> so the memory they were occupying can be reclaimed by garbage collection.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6d86a-206">在释放从 <xref:System.ServiceProcess.ServiceBase>派生的类的最后一个引用之前，请始终调用 <xref:System.ServiceProcess.ServiceBase.Dispose%2A>。</span><span class="sxs-lookup"><span data-stu-id="6d86a-206">Always call <xref:System.ServiceProcess.ServiceBase.Dispose%2A> before you release your last reference to the class derived from <xref:System.ServiceProcess.ServiceBase>.</span></span> <span data-ttu-id="6d86a-207">否则，在垃圾回收调用对象的析构函数之前，将不会释放 <xref:System.ServiceProcess.ServiceBase> 和派生类所使用的资源。</span><span class="sxs-lookup"><span data-stu-id="6d86a-207">Otherwise, the resources <xref:System.ServiceProcess.ServiceBase> and the derived class are using will not be freed until garbage collection calls the objects' destructors.</span></span>  
  
 <span data-ttu-id="6d86a-208">通常实现 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 以处理 <xref:System.ServiceProcess.ServiceBase.OnPause%2A>中的代码，并结合对 <xref:System.ServiceProcess.ServiceBase.Dispose%2A>的调用。</span><span class="sxs-lookup"><span data-stu-id="6d86a-208"><xref:System.ServiceProcess.ServiceBase.OnStop%2A> is often implemented to process the code in <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, combined with a call to <xref:System.ServiceProcess.ServiceBase.Dispose%2A>.</span></span> <span data-ttu-id="6d86a-209">如果在派生类中选择执行此操作，则可以实现 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 来分配已发布的任何 <xref:System.ServiceProcess.ServiceBase.Dispose%2A>。</span><span class="sxs-lookup"><span data-stu-id="6d86a-209">If you choose to do this in your derived class, it is customary to implement <xref:System.ServiceProcess.ServiceBase.OnStart%2A> to allocate whatever <xref:System.ServiceProcess.ServiceBase.Dispose%2A> released.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="EventLog">
      <MemberSignature Language="C#" Value="public virtual System.Diagnostics.EventLog EventLog { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLog EventLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.EventLog" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EventLog As EventLog" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Diagnostics::EventLog ^ EventLog { System::Diagnostics::EventLog ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EventLog : System.Diagnostics.EventLog" Usage="System.ServiceProcess.ServiceBase.EventLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6d86a-210">获取一个事件日志，它可用于将服务命令调用的通知（如“开始”和“停止”）写入“应用程序”事件日志。</span><span class="sxs-lookup"><span data-stu-id="6d86a-210">Gets an event log you can use to write notification of service command calls, such as Start and Stop, to the Application event log.</span></span></summary>
        <value><span data-ttu-id="6d86a-211"><see cref="T:System.Diagnostics.EventLog" /> 实例，它的源注册到 Application 日志中。</span><span class="sxs-lookup"><span data-stu-id="6d86a-211">An <see cref="T:System.Diagnostics.EventLog" /> instance whose source is registered to the Application log.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6d86a-212">构造函数将 <xref:System.ServiceProcess.ServiceBase.EventLog%2A> 属性初始化为具有 <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> 和 <xref:System.Diagnostics.EventLog.Log%2A?displayProperty=nameWithType> 属性集的实例。</span><span class="sxs-lookup"><span data-stu-id="6d86a-212">The constructor initializes the <xref:System.ServiceProcess.ServiceBase.EventLog%2A> property to an instance with the <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> and <xref:System.Diagnostics.EventLog.Log%2A?displayProperty=nameWithType> properties set.</span></span> <span data-ttu-id="6d86a-213">源是服务的 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>，日志是计算机的应用程序日志。</span><span class="sxs-lookup"><span data-stu-id="6d86a-213">The source is the <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> of the service, and the log is the computer's Application log.</span></span> <span data-ttu-id="6d86a-214">这些值是自动设置的，不能更改以自动记录服务命令。</span><span class="sxs-lookup"><span data-stu-id="6d86a-214">These values are set automatically and cannot be changed for automatic logging of service commands.</span></span>  
  
 <span data-ttu-id="6d86a-215">`true`<xref:System.ServiceProcess.ServiceBase.AutoLog%2A> 时，会自动在应用程序事件日志中记录 "启动"、"停止"、"暂停"、"继续" 和 "自定义" 命令。</span><span class="sxs-lookup"><span data-stu-id="6d86a-215">When <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> is `true`, Start, Stop, Pause, Continue, and custom commands are recorded automatically in the Application event log.</span></span> <span data-ttu-id="6d86a-216">还可以使用 <xref:System.ServiceProcess.ServiceBase.EventLog%2A> 属性将其他消息写入该日志。</span><span class="sxs-lookup"><span data-stu-id="6d86a-216">You can use the <xref:System.ServiceProcess.ServiceBase.EventLog%2A> property to write additional messages to that log as well.</span></span> <span data-ttu-id="6d86a-217">组件使用此 <xref:System.ServiceProcess.ServiceBase.EventLog%2A> 成员调用 <xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6d86a-217">The component calls <xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=nameWithType> using this <xref:System.ServiceProcess.ServiceBase.EventLog%2A> member.</span></span>  
  
 <span data-ttu-id="6d86a-218">若要将信息报告给自定义事件日志而不是应用程序日志，请将 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> 设置为 `false` 并在命令处理方法中编写指令 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>、<xref:System.ServiceProcess.ServiceBase.OnPause%2A>或 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 发布到适当的日志。</span><span class="sxs-lookup"><span data-stu-id="6d86a-218">To report information to a custom event log rather than the Application log, set <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> to `false` and write instructions within the command-handling methods <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, or <xref:System.ServiceProcess.ServiceBase.OnStop%2A> to post to the appropriate log.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLog" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6d86a-219">获取或设置服务的退出代码。</span><span class="sxs-lookup"><span data-stu-id="6d86a-219">Gets or sets the exit code for the service.</span></span></summary>
        <value><span data-ttu-id="6d86a-220">服务的退出代码。</span><span class="sxs-lookup"><span data-stu-id="6d86a-220">The exit code for the service.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6d86a-221">在停止服务以向服务控制管理器指示错误之前，将 <xref:System.ServiceProcess.ServiceBase.ExitCode%2A> 属性设置为一个非零值。</span><span class="sxs-lookup"><span data-stu-id="6d86a-221">Set the <xref:System.ServiceProcess.ServiceBase.ExitCode%2A> property to a non-zero value before stopping the service to indicate an error to the Service Control Manager.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNameLength">
      <MemberSignature Language="C#" Value="public const int MaxNameLength = 80;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MaxNameLength = (80)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxNameLength As Integer  = 80" />
      <MemberSignature Language="C++ CLI" Value="public: int MaxNameLength = 80;" />
      <MemberSignature Language="F#" Value="val mutable MaxNameLength : int" Usage="System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>80</MemberValue>
      <Docs>
        <summary><span data-ttu-id="6d86a-222">指示服务名称的最大大小。</span><span class="sxs-lookup"><span data-stu-id="6d86a-222">Indicates the maximum size for a service name.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6d86a-223">ServiceName 和 DisplayName 都具有大小限制，在设置服务类的属性时必须遵循这些限制。</span><span class="sxs-lookup"><span data-stu-id="6d86a-223">ServiceName and DisplayName both have size restrictions that must be observed when setting the properties on your service class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.ServiceName" />
      </Docs>
    </Member>
    <Member MemberName="OnContinue">
      <MemberSignature Language="C#" Value="protected virtual void OnContinue ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContinue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnContinue" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContinue ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContinue();" />
      <MemberSignature Language="F#" Value="abstract member OnContinue : unit -&gt; unit&#xA;override this.OnContinue : unit -&gt; unit" Usage="serviceBase.OnContinue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6d86a-224">在派生类中实现时，<see cref="M:System.ServiceProcess.ServiceBase.OnContinue" /> 于“服务控制管理器”(SCM) 将“继续”命令发送到服务时运行。</span><span class="sxs-lookup"><span data-stu-id="6d86a-224">When implemented in a derived class, <see cref="M:System.ServiceProcess.ServiceBase.OnContinue" /> runs when a Continue command is sent to the service by the Service Control Manager (SCM).</span></span> <span data-ttu-id="6d86a-225">指定要在服务暂停后恢复正常功能时采取的操作。</span><span class="sxs-lookup"><span data-stu-id="6d86a-225">Specifies actions to take when a service resumes normal functioning after being paused.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6d86a-226">实现 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>，将应用程序的响应镜像到 <xref:System.ServiceProcess.ServiceBase.OnPause%2A>。</span><span class="sxs-lookup"><span data-stu-id="6d86a-226">Implement <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> to mirror your application's response to <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.</span></span> <span data-ttu-id="6d86a-227">当你通过服务控制台或以编程方式继续服务时，<xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 处理将运行，并且服务将再次变为活动状态。</span><span class="sxs-lookup"><span data-stu-id="6d86a-227">When you continue the service (either through the Services console or programmatically), the <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> processing runs, and the service becomes active again.</span></span>  
  
 <span data-ttu-id="6d86a-228">`true`<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> 属性时，应覆盖 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>。</span><span class="sxs-lookup"><span data-stu-id="6d86a-228"><xref:System.ServiceProcess.ServiceBase.OnContinue%2A> is expected to be overridden when the <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> property is `true`.</span></span>  
  
 <span data-ttu-id="6d86a-229">如果 `false`<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>，则 SCM 将不会向服务传递暂停或继续请求，因此不会调用 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 和 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 方法，即使它们是实现的也是如此。</span><span class="sxs-lookup"><span data-stu-id="6d86a-229">If <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> is `false`, the SCM will not pass Pause or Continue requests to the service, so the <xref:System.ServiceProcess.ServiceBase.OnPause%2A> and <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> methods will not be called even if they are implemented.</span></span> <span data-ttu-id="6d86a-230">在 SCM 中，<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> `false`时禁用 `Pause` 和 `Continue` 控件。</span><span class="sxs-lookup"><span data-stu-id="6d86a-230">In the SCM, the `Pause` and `Continue` controls are disabled when <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnCustomCommand">
      <MemberSignature Language="C#" Value="protected virtual void OnCustomCommand (int command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCustomCommand(int32 command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCustomCommand (command As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCustomCommand(int command);" />
      <MemberSignature Language="F#" Value="abstract member OnCustomCommand : int -&gt; unit&#xA;override this.OnCustomCommand : int -&gt; unit" Usage="serviceBase.OnCustomCommand command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="command"><span data-ttu-id="6d86a-231">发送给服务的命令消息。</span><span class="sxs-lookup"><span data-stu-id="6d86a-231">The command message sent to the service.</span></span></param>
        <summary><span data-ttu-id="6d86a-232">在派生类中实现时，<see cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" /> 于“服务控制管理器”(SCM) 向服务传递自定义命令时执行。</span><span class="sxs-lookup"><span data-stu-id="6d86a-232">When implemented in a derived class, <see cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" /> executes when the Service Control Manager (SCM) passes a custom command to the service.</span></span> <span data-ttu-id="6d86a-233">指定要在具有指定参数值的命令出现时采取的操作。</span><span class="sxs-lookup"><span data-stu-id="6d86a-233">Specifies actions to take when a command with the specified parameter value occurs.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6d86a-234"><xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> 允许你指定除启动、停止、暂停和继续服务以外的其他功能。</span><span class="sxs-lookup"><span data-stu-id="6d86a-234"><xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> lets you specify additional functionality beyond starting, stopping, pausing and continuing services.</span></span>  
  
 <span data-ttu-id="6d86a-235">SCM 不检查自定义命令来验证服务是否支持传入的 `command` 参数。</span><span class="sxs-lookup"><span data-stu-id="6d86a-235">The SCM does not examine the custom command to verify whether the service supports the `command` parameter passed in.</span></span> <span data-ttu-id="6d86a-236">它将自定义命令直接传递给服务。</span><span class="sxs-lookup"><span data-stu-id="6d86a-236">It passes the custom command directly to the service.</span></span> <span data-ttu-id="6d86a-237">如果服务不能识别 `command` 参数，则不会执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="6d86a-237">If the service does not recognize the `command` parameter, it does nothing.</span></span>  
  
 <span data-ttu-id="6d86a-238">自定义命令由 <xref:System.ServiceProcess.ServiceController> 组件中的 <xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A> 语句引发。</span><span class="sxs-lookup"><span data-stu-id="6d86a-238">Custom commands are raised by an <xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A> statement in a <xref:System.ServiceProcess.ServiceController> component.</span></span> <span data-ttu-id="6d86a-239">使用 switch 语句或 if .。。用于处理在服务上定义的自定义命令的条件。</span><span class="sxs-lookup"><span data-stu-id="6d86a-239">Use a switch statement or if..then condition to handle the custom commands you define on your service.</span></span>  
  
 <span data-ttu-id="6d86a-240">可以在应用程序中定义或在 <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> 中使用的自定义命令的唯一值是128到255之间的值。</span><span class="sxs-lookup"><span data-stu-id="6d86a-240">The only values for a custom command that you can define in your application or use in <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> are those between 128 and 255.</span></span> <span data-ttu-id="6d86a-241">低于128的整数对应于系统保留值。</span><span class="sxs-lookup"><span data-stu-id="6d86a-241">Integers below 128 correspond to system-reserved values.</span></span>  
  
 <span data-ttu-id="6d86a-242">如果 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> 属性是 `true`，则自定义命令（如所有其他命令）会将条目写入事件日志，以报告方法执行是成功还是失败。</span><span class="sxs-lookup"><span data-stu-id="6d86a-242">If the <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> property is `true`, custom commands, like all other commands, write entries to the event log to report whether the method execution succeeded or failed.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="OnPause">
      <MemberSignature Language="C#" Value="protected virtual void OnPause ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPause" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPause ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPause();" />
      <MemberSignature Language="F#" Value="abstract member OnPause : unit -&gt; unit&#xA;override this.OnPause : unit -&gt; unit" Usage="serviceBase.OnPause " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6d86a-243">在派生类中实现时，该方法于“服务控制管理器”(SCM) 将“暂停”命令发送到服务时执行。</span><span class="sxs-lookup"><span data-stu-id="6d86a-243">When implemented in a derived class, executes when a Pause command is sent to the service by the Service Control Manager (SCM).</span></span> <span data-ttu-id="6d86a-244">指定要在服务暂停时采取的操作。</span><span class="sxs-lookup"><span data-stu-id="6d86a-244">Specifies actions to take when a service pauses.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6d86a-245">使用 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 指定当服务接收暂停命令时发生的处理。</span><span class="sxs-lookup"><span data-stu-id="6d86a-245">Use <xref:System.ServiceProcess.ServiceBase.OnPause%2A> to specify the processing that occurs when the service receives a Pause command.</span></span> <span data-ttu-id="6d86a-246">`true`<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> 属性时，应覆盖 <xref:System.ServiceProcess.ServiceBase.OnPause%2A>。</span><span class="sxs-lookup"><span data-stu-id="6d86a-246"><xref:System.ServiceProcess.ServiceBase.OnPause%2A> is expected to be overridden when the <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> property is `true`.</span></span>  
  
 <span data-ttu-id="6d86a-247">当你通过服务控制台或以编程方式继续暂停的服务时，将运行 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 处理，并且该服务将再次变为活动状态。</span><span class="sxs-lookup"><span data-stu-id="6d86a-247">When you continue a paused service (either through the Services console or programmatically), the <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> processing is run, and the service becomes active again.</span></span>  
  
 <span data-ttu-id="6d86a-248">Pause 命令仅允许应用程序响应特定事件。</span><span class="sxs-lookup"><span data-stu-id="6d86a-248">The Pause command only allows your application to react to a specific event.</span></span> <span data-ttu-id="6d86a-249"><xref:System.ServiceProcess.ServiceBase.OnPause%2A> 不会对未定义的服务执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="6d86a-249"><xref:System.ServiceProcess.ServiceBase.OnPause%2A> does nothing to the service that you do not define it to do.</span></span>  
  
 <span data-ttu-id="6d86a-250">向服务发送暂停请求可能会保留系统资源，因为暂停无需释放所有系统资源。</span><span class="sxs-lookup"><span data-stu-id="6d86a-250">Sending a Pause request to the service can conserve system resources because Pause need not release all system resources.</span></span> <span data-ttu-id="6d86a-251">例如，如果线程已由进程打开，则暂停服务而不是停止它可以使线程保持打开状态，避免在服务继续时需要重新分配它们。</span><span class="sxs-lookup"><span data-stu-id="6d86a-251">For example, if threads have been opened by the process, pausing a service rather than stopping it can allow the threads to remain open, obviating the need to reallocate them when the service continues.</span></span> <span data-ttu-id="6d86a-252">如果将 Pause 定义为释放所有系统资源，它的行为类似于停止命令。</span><span class="sxs-lookup"><span data-stu-id="6d86a-252">If you define Pause to release all system resources, it behaves like a Stop command.</span></span>  
  
 <span data-ttu-id="6d86a-253">将 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> 设置为 `true`，并重写 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 和 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>，以指定当 SCM 向服务传递暂停或继续请求时应发生的处理。</span><span class="sxs-lookup"><span data-stu-id="6d86a-253">Set <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> to `true`, and override <xref:System.ServiceProcess.ServiceBase.OnPause%2A> and <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> to specify the processing that should occur when the SCM passes a Pause or Continue request to your service.</span></span> <span data-ttu-id="6d86a-254">应该实现 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 来撤消 <xref:System.ServiceProcess.ServiceBase.OnPause%2A>中的处理。</span><span class="sxs-lookup"><span data-stu-id="6d86a-254"><xref:System.ServiceProcess.ServiceBase.OnContinue%2A> should be implemented to undo the processing in <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.</span></span>  
  
 <span data-ttu-id="6d86a-255">如果 `false`<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>，则 SCM 将不会向服务传递暂停或继续请求，因此即使实现了，<xref:System.ServiceProcess.ServiceBase.OnPause%2A> 和 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 方法也不会被调用。</span><span class="sxs-lookup"><span data-stu-id="6d86a-255">If <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> is `false`, the SCM will not pass Pause or Continue requests to the service, so the <xref:System.ServiceProcess.ServiceBase.OnPause%2A> and <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> methods will not be called even if implemented.</span></span> <span data-ttu-id="6d86a-256">在 SCM 中，<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> `false`时禁用 `Pause` 和 `Continue` 控件。</span><span class="sxs-lookup"><span data-stu-id="6d86a-256">In the SCM, the `Pause` and `Continue` controls are disabled when <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnPowerEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnPowerEvent (System.ServiceProcess.PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnPowerEvent(valuetype System.ServiceProcess.PowerBroadcastStatus powerStatus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnPowerEvent (powerStatus As PowerBroadcastStatus) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnPowerEvent(System::ServiceProcess::PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="F#" Value="abstract member OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool&#xA;override this.OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool" Usage="serviceBase.OnPowerEvent powerStatus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="powerStatus" Type="System.ServiceProcess.PowerBroadcastStatus" />
      </Parameters>
      <Docs>
        <param name="powerStatus"><span data-ttu-id="6d86a-257"><see cref="T:System.ServiceProcess.PowerBroadcastStatus" />，指示来自系统的有关电源状态的通知。</span><span class="sxs-lookup"><span data-stu-id="6d86a-257">A <see cref="T:System.ServiceProcess.PowerBroadcastStatus" /> that indicates a notification from the system about its power status.</span></span></param>
        <summary><span data-ttu-id="6d86a-258">当在派生类中实现时，该方法于计算机电源状态更改时执行。</span><span class="sxs-lookup"><span data-stu-id="6d86a-258">When implemented in a derived class, executes when the computer's power status has changed.</span></span> <span data-ttu-id="6d86a-259">这适用于膝上型计算机进入挂起模式时的情况，该模式不同于系统关闭。</span><span class="sxs-lookup"><span data-stu-id="6d86a-259">This applies to laptop computers when they go into suspended mode, which is not the same as a system shutdown.</span></span></summary>
        <returns><span data-ttu-id="6d86a-260">当在派生类中实现时，应用程序的需要将确定要返回的值。</span><span class="sxs-lookup"><span data-stu-id="6d86a-260">When implemented in a derived class, the needs of your application determine what value to return.</span></span> <span data-ttu-id="6d86a-261">例如，如果传递了 <see langword="QuerySuspend" /> 广播状态，则可以通过返回 <see langword="false" /> 来使应用程序拒绝查询。</span><span class="sxs-lookup"><span data-stu-id="6d86a-261">For example, if a <see langword="QuerySuspend" /> broadcast status is passed, you could cause your application to reject the query by returning <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6d86a-262">使用 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> 指定发生 <xref:System.ServiceProcess.PowerBroadcastStatus> 枚举中指示的系统事件时进行的处理-例如，当计算机处于挂起模式或指示电池电量不足时。</span><span class="sxs-lookup"><span data-stu-id="6d86a-262">Use <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> to specify the processing that occurs when the system event indicated in the <xref:System.ServiceProcess.PowerBroadcastStatus> enumeration occurs--for example, when the computer is placed in suspended mode or indicates low battery power.</span></span>  
  
 <span data-ttu-id="6d86a-263">`true`<xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> 属性时，应覆盖 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="6d86a-263"><xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> is expected to be overridden when the <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> property is `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionChange">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionChange (System.ServiceProcess.SessionChangeDescription changeDescription);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionChange(valuetype System.ServiceProcess.SessionChangeDescription changeDescription) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionChange (changeDescription As SessionChangeDescription)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionChange(System::ServiceProcess::SessionChangeDescription changeDescription);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit&#xA;override this.OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit" Usage="serviceBase.OnSessionChange changeDescription" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeDescription" Type="System.ServiceProcess.SessionChangeDescription" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="changeDescription"><span data-ttu-id="6d86a-264">标识更改类型的结构。</span><span class="sxs-lookup"><span data-stu-id="6d86a-264">A structure that identifies the change type.</span></span></param>
        <summary><span data-ttu-id="6d86a-265">从终端服务器会话接收到更改事件时执行。</span><span class="sxs-lookup"><span data-stu-id="6d86a-265">Executes when a change event is received from a Terminal Server session.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6d86a-266">必须将 <xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A> 属性设置为 `true`，才能执行此方法。</span><span class="sxs-lookup"><span data-stu-id="6d86a-266">You must set the <xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A> property to `true` to enable the execution of this method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
        <altmember cref="T:System.ServiceProcess.SessionChangeDescription" />
      </Docs>
    </Member>
    <Member MemberName="OnShutdown">
      <MemberSignature Language="C#" Value="protected virtual void OnShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnShutdown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShutdown();" />
      <MemberSignature Language="F#" Value="abstract member OnShutdown : unit -&gt; unit&#xA;override this.OnShutdown : unit -&gt; unit" Usage="serviceBase.OnShutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6d86a-267">在派生类中实现时，该方法于系统即将关闭时执行。</span><span class="sxs-lookup"><span data-stu-id="6d86a-267">When implemented in a derived class, executes when the system is shutting down.</span></span> <span data-ttu-id="6d86a-268">该方法指定应在系统即将关闭前执行的处理。</span><span class="sxs-lookup"><span data-stu-id="6d86a-268">Specifies what should occur immediately prior to the system shutting down.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6d86a-269">使用 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> 来指定系统关闭时进行的处理。</span><span class="sxs-lookup"><span data-stu-id="6d86a-269">Use <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> to specify the processing that occurs when the system shuts down.</span></span>  
  
 <span data-ttu-id="6d86a-270">此事件仅在操作系统关闭时出现，而不在计算机关闭时发生。</span><span class="sxs-lookup"><span data-stu-id="6d86a-270">This event occurs only when the operating system is shut down, not when the computer is turned off.</span></span>  
  
 <span data-ttu-id="6d86a-271">`true`<xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> 属性时，应覆盖 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>。</span><span class="sxs-lookup"><span data-stu-id="6d86a-271"><xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> is expected to be overridden when the <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> property is `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStart">
      <MemberSignature Language="C#" Value="protected virtual void OnStart (string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStart(string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStart (args As String())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStart(cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnStart : string[] -&gt; unit&#xA;override this.OnStart : string[] -&gt; unit" Usage="serviceBase.OnStart args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="args"><span data-ttu-id="6d86a-272">启动命令传递的数据。</span><span class="sxs-lookup"><span data-stu-id="6d86a-272">Data passed by the start command.</span></span></param>
        <summary><span data-ttu-id="6d86a-273">当在派生类中实现时，在下列情况下执行：在“服务控制管理器”(SCM) 向服务发送“开始”命令时，或者在操作系统启动时（对于自动启动的服务）。</span><span class="sxs-lookup"><span data-stu-id="6d86a-273">When implemented in a derived class, executes when a Start command is sent to the service by the Service Control Manager (SCM) or when the operating system starts (for a service that starts automatically).</span></span> <span data-ttu-id="6d86a-274">指定服务启动时采取的操作。</span><span class="sxs-lookup"><span data-stu-id="6d86a-274">Specifies actions to take when the service starts.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6d86a-275">使用 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 指定在服务接收开始命令时发生的处理。</span><span class="sxs-lookup"><span data-stu-id="6d86a-275">Use <xref:System.ServiceProcess.ServiceBase.OnStart%2A> to specify the processing that occurs when the service receives a Start command.</span></span> <span data-ttu-id="6d86a-276"><xref:System.ServiceProcess.ServiceBase.OnStart%2A> 是指定服务行为的方法。</span><span class="sxs-lookup"><span data-stu-id="6d86a-276"><xref:System.ServiceProcess.ServiceBase.OnStart%2A> is the method in which you specify the behavior of the service.</span></span> <span data-ttu-id="6d86a-277"><xref:System.ServiceProcess.ServiceBase.OnStart%2A> 可以将参数用作传递数据的一种方法，但这种情况很少发生。</span><span class="sxs-lookup"><span data-stu-id="6d86a-277"><xref:System.ServiceProcess.ServiceBase.OnStart%2A> can take arguments as a way to pass data, but this usage is rare.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="6d86a-278">不要使用构造函数来执行应在 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>中的处理。</span><span class="sxs-lookup"><span data-stu-id="6d86a-278">Do not use the constructor to perform processing that should be in <xref:System.ServiceProcess.ServiceBase.OnStart%2A>.</span></span> <span data-ttu-id="6d86a-279">使用 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 处理服务的所有初始化。</span><span class="sxs-lookup"><span data-stu-id="6d86a-279">Use <xref:System.ServiceProcess.ServiceBase.OnStart%2A> to handle all initialization of your service.</span></span> <span data-ttu-id="6d86a-280">此构造函数在应用程序的可执行文件运行时调用，而不是在服务运行时调用。</span><span class="sxs-lookup"><span data-stu-id="6d86a-280">The constructor is called when the application's executable runs, not when the service runs.</span></span> <span data-ttu-id="6d86a-281">可执行文件在 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>之前运行。</span><span class="sxs-lookup"><span data-stu-id="6d86a-281">The executable runs before <xref:System.ServiceProcess.ServiceBase.OnStart%2A>.</span></span> <span data-ttu-id="6d86a-282">例如，当继续操作时，不会再次调用构造函数，因为 SCM 已在内存中保存对象。</span><span class="sxs-lookup"><span data-stu-id="6d86a-282">When you continue, for example, the constructor is not called again because the SCM already holds the object in memory.</span></span> <span data-ttu-id="6d86a-283">如果 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 释放在构造函数中分配的资源，而不是在 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>中分配的资源，则在第二次调用服务时，不会再次创建所需的资源。</span><span class="sxs-lookup"><span data-stu-id="6d86a-283">If <xref:System.ServiceProcess.ServiceBase.OnStop%2A> releases resources allocated in the constructor rather than in <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, the needed resources would not be created again the second time the service is called.</span></span>  
  
 <span data-ttu-id="6d86a-284">在计算机重新启动时，可以将服务设置为自动启动，方法是将服务安装程序的 <xref:System.ServiceProcess.ServiceInstaller.StartType%2A> 设置为 <xref:System.ServiceProcess.ServiceStartMode.Automatic>。</span><span class="sxs-lookup"><span data-stu-id="6d86a-284">Services can be set to start automatically when the computer reboots by setting the <xref:System.ServiceProcess.ServiceInstaller.StartType%2A> on the service's installer to <xref:System.ServiceProcess.ServiceStartMode.Automatic>.</span></span> <span data-ttu-id="6d86a-285">在这种情况下，将在系统启动时调用 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>。</span><span class="sxs-lookup"><span data-stu-id="6d86a-285">In such a situation, <xref:System.ServiceProcess.ServiceBase.OnStart%2A> would be called at system startup.</span></span>  
  
 <span data-ttu-id="6d86a-286">应在派生类中重写 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>。</span><span class="sxs-lookup"><span data-stu-id="6d86a-286"><xref:System.ServiceProcess.ServiceBase.OnStart%2A> is expected to be overridden in the derived class.</span></span> <span data-ttu-id="6d86a-287">若要使服务有用，应在服务类中实现 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 和 <xref:System.ServiceProcess.ServiceBase.OnStop%2A>。</span><span class="sxs-lookup"><span data-stu-id="6d86a-287">For the service to be useful, <xref:System.ServiceProcess.ServiceBase.OnStart%2A> and <xref:System.ServiceProcess.ServiceBase.OnStop%2A> should both be implemented in your service class.</span></span>  
  
 <span data-ttu-id="6d86a-288"><xref:System.ServiceProcess.ServiceBase.OnStart%2A> 方法中的服务的处理初始化参数，而不是在 Main 方法中。</span><span class="sxs-lookup"><span data-stu-id="6d86a-288">Process initialization arguments for the service in the <xref:System.ServiceProcess.ServiceBase.OnStart%2A> method, not in the Main method.</span></span> <span data-ttu-id="6d86a-289">可以在 "服务" 控制台中服务的 "属性" 窗口中手动设置 `args` 参数数组中的参数。</span><span class="sxs-lookup"><span data-stu-id="6d86a-289">The arguments in the `args` parameter array can be set manually in the properties window for the service in the Services console.</span></span> <span data-ttu-id="6d86a-290">不保存在控制台中输入的参数;从 "控制面板" 启动该服务时，它们将一次性传递到服务。</span><span class="sxs-lookup"><span data-stu-id="6d86a-290">The arguments entered in the console are not saved; they are passed to the service on a one-time basis when the service is started from the control panel.</span></span> <span data-ttu-id="6d86a-291">自动启动服务时必须存在的参数可放置在服务注册表项（HKEY_LOCAL_MACHINE \SYSTEM\CurrentControlSet\Services\\*\<服务名称 >*）的 ImagePath 字符串值中。</span><span class="sxs-lookup"><span data-stu-id="6d86a-291">Arguments that must be present when the service is automatically started can be placed in the ImagePath string value for the service's registry key (HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\\*\<service name>*).</span></span> <span data-ttu-id="6d86a-292">您可以使用 <xref:System.Environment.GetCommandLineArgs%2A> 方法从注册表获取参数，例如： `string[] imagePathArgs = Environment.GetCommandLineArgs();`。</span><span class="sxs-lookup"><span data-stu-id="6d86a-292">You can obtain the arguments from the registry using the <xref:System.Environment.GetCommandLineArgs%2A> method, for example:  `string[] imagePathArgs = Environment.GetCommandLineArgs();`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStop">
      <MemberSignature Language="C#" Value="protected virtual void OnStop ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStop" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStop ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStop();" />
      <MemberSignature Language="F#" Value="abstract member OnStop : unit -&gt; unit&#xA;override this.OnStop : unit -&gt; unit" Usage="serviceBase.OnStop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6d86a-293">在派生类中实现时，该方法于“服务控制管理器”(SCM) 将“停止”命令发送到服务时执行。</span><span class="sxs-lookup"><span data-stu-id="6d86a-293">When implemented in a derived class, executes when a Stop command is sent to the service by the Service Control Manager (SCM).</span></span> <span data-ttu-id="6d86a-294">指定服务停止运行时采取的操作。</span><span class="sxs-lookup"><span data-stu-id="6d86a-294">Specifies actions to take when a service stops running.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6d86a-295">使用 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 指定当服务接收到 Stop 命令时发生的处理。</span><span class="sxs-lookup"><span data-stu-id="6d86a-295">Use <xref:System.ServiceProcess.ServiceBase.OnStop%2A> to specify the processing that occurs when the service receives a Stop command.</span></span>  
  
 <span data-ttu-id="6d86a-296">当 SCM 收到停止命令时，它将使用 <xref:System.ServiceProcess.ServiceBase.CanStop%2A> 的值来验证服务是否接受 Stop 命令。</span><span class="sxs-lookup"><span data-stu-id="6d86a-296">When the SCM receives a Stop command, it uses the value of <xref:System.ServiceProcess.ServiceBase.CanStop%2A> to verify whether the service accepts Stop commands.</span></span> <span data-ttu-id="6d86a-297">如果 `true`<xref:System.ServiceProcess.ServiceBase.CanStop%2A>，则停止命令将传递到服务，并在定义 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 方法时调用。</span><span class="sxs-lookup"><span data-stu-id="6d86a-297">If <xref:System.ServiceProcess.ServiceBase.CanStop%2A> is `true`, the Stop command is passed to the service, and the <xref:System.ServiceProcess.ServiceBase.OnStop%2A> method is called if it is defined.</span></span> <span data-ttu-id="6d86a-298">如果服务中未实现 <xref:System.ServiceProcess.ServiceBase.OnStop%2A>，SCM 将处理 Stop 命令。</span><span class="sxs-lookup"><span data-stu-id="6d86a-298">If <xref:System.ServiceProcess.ServiceBase.OnStop%2A> is not implemented in the service, the SCM handles the Stop command.</span></span>  
  
 <span data-ttu-id="6d86a-299">如果 `false`<xref:System.ServiceProcess.ServiceBase.CanStop%2A>，则 SCM 将忽略停止命令。</span><span class="sxs-lookup"><span data-stu-id="6d86a-299">If <xref:System.ServiceProcess.ServiceBase.CanStop%2A> is `false`, the SCM ignores the Stop command.</span></span> <span data-ttu-id="6d86a-300">它不会传递给服务。</span><span class="sxs-lookup"><span data-stu-id="6d86a-300">It is not passed to the service.</span></span> <span data-ttu-id="6d86a-301">Stop 命令返回并引发异常。</span><span class="sxs-lookup"><span data-stu-id="6d86a-301">The Stop command returns and throws an exception.</span></span>  
  
 <span data-ttu-id="6d86a-302">应在派生类中重写 <xref:System.ServiceProcess.ServiceBase.OnStop%2A>。</span><span class="sxs-lookup"><span data-stu-id="6d86a-302"><xref:System.ServiceProcess.ServiceBase.OnStop%2A> is expected to be overridden in the derived class.</span></span> <span data-ttu-id="6d86a-303">若要使服务有用，应在服务类中实现 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 和 <xref:System.ServiceProcess.ServiceBase.OnStop%2A>。</span><span class="sxs-lookup"><span data-stu-id="6d86a-303">For the service to be useful, <xref:System.ServiceProcess.ServiceBase.OnStart%2A> and <xref:System.ServiceProcess.ServiceBase.OnStop%2A> should both be implemented in your service class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RequestAdditionalTime">
      <MemberSignature Language="C#" Value="public void RequestAdditionalTime (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RequestAdditionalTime(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RequestAdditionalTime (milliseconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RequestAdditionalTime(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.RequestAdditionalTime : int -&gt; unit" Usage="serviceBase.RequestAdditionalTime milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="milliseconds"><span data-ttu-id="6d86a-304">请求的时间（以毫秒为单位）。</span><span class="sxs-lookup"><span data-stu-id="6d86a-304">The requested time in milliseconds.</span></span></param>
        <summary><span data-ttu-id="6d86a-305">为挂起操作请求额外的时间。</span><span class="sxs-lookup"><span data-stu-id="6d86a-305">Requests additional time for a pending operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6d86a-306"><xref:System.ServiceProcess.ServiceBase.RequestAdditionalTime%2A> 方法旨在由重写的 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>、<xref:System.ServiceProcess.ServiceBase.OnPause%2A>、<xref:System.ServiceProcess.ServiceBase.OnStart%2A>或 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 方法调用，以请求挂起操作的额外时间，以防服务控制管理器（SCM）将服务标记为 "无响应"。</span><span class="sxs-lookup"><span data-stu-id="6d86a-306">The <xref:System.ServiceProcess.ServiceBase.RequestAdditionalTime%2A> method is intended to be called by the overridden <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, or <xref:System.ServiceProcess.ServiceBase.OnStop%2A> methods to request additional time for a pending operation, to prevent the Service Control Manager (SCM) from marking the service as not responding.</span></span>  <span data-ttu-id="6d86a-307">如果挂起操作不是 "继续"、"暂停"、"启动" 或 "停止"，则会引发 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="6d86a-307">If the pending operation is not a continue, pause, start, or stop, an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6d86a-308">服务不处于挂起状态。</span><span class="sxs-lookup"><span data-stu-id="6d86a-308">The service is not in a pending state.</span></span></exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6d86a-309">为服务可执行文件提供主入口点。</span><span class="sxs-lookup"><span data-stu-id="6d86a-309">Provides the main entry point for a service executable.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase service);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (service As ServiceBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::ServiceProcess::ServiceBase ^ service);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run service" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.ServiceProcess.ServiceBase" />
      </Parameters>
      <Docs>
        <param name="service"><span data-ttu-id="6d86a-310"><see cref="T:System.ServiceProcess.ServiceBase" />，指示要启动的服务。</span><span class="sxs-lookup"><span data-stu-id="6d86a-310">A <see cref="T:System.ServiceProcess.ServiceBase" /> which indicates a service to start.</span></span></param>
        <summary><span data-ttu-id="6d86a-311">在服务控制管理器 (SCM) 中注册服务的可执行文件。</span><span class="sxs-lookup"><span data-stu-id="6d86a-311">Registers the executable for a service with the Service Control Manager (SCM).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6d86a-312">在服务可执行文件的 `main()` 函数中调用此重载，以向服务控制管理器注册该服务。</span><span class="sxs-lookup"><span data-stu-id="6d86a-312">Call this overload in the `main()` function of the service executable to register the service with the Service Control Manager.</span></span> <span data-ttu-id="6d86a-313">调用 <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%29>后，服务控制管理器将发出一个启动命令，这会导致调用服务中的 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="6d86a-313">After you call <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%29>, the Service Control Manager issues a Start command, which results in a call to the <xref:System.ServiceProcess.ServiceBase.OnStart%2A> method in the service.</span></span> <span data-ttu-id="6d86a-314">在执行开始命令之前，不会启动该服务。</span><span class="sxs-lookup"><span data-stu-id="6d86a-314">The service is not started until the Start command is executed.</span></span>  
  
 <span data-ttu-id="6d86a-315">调用 <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> 方法的方式与 Windows 窗体应用程序 <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> 的方式几乎相同。</span><span class="sxs-lookup"><span data-stu-id="6d86a-315">The <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> method is called in much the same way as <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> for Windows Forms applications.</span></span>  
  
 <span data-ttu-id="6d86a-316">如果 `true`<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>，则如果 `service` 参数指定的服务无法启动，则会向事件日志写入一个条目。</span><span class="sxs-lookup"><span data-stu-id="6d86a-316">If <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> is `true`, an entry is written to the event log if the service specified by the `service` parameter fails to start.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6d86a-317"><paramref name="service" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6d86a-317"><paramref name="service" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase[] services);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase[] services) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (services As ServiceBase())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(cli::array &lt;System::ServiceProcess::ServiceBase ^&gt; ^ services);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase[] -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run services" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="services" Type="System.ServiceProcess.ServiceBase[]" />
      </Parameters>
      <Docs>
        <param name="services"><span data-ttu-id="6d86a-318">一组 ServiceBase 实例，指示要启动的服务。</span><span class="sxs-lookup"><span data-stu-id="6d86a-318">An array of ServiceBase instances, which indicate services to start.</span></span></param>
        <summary><span data-ttu-id="6d86a-319">在服务控制管理器 (SCM) 中注册多项服务的可执行文件。</span><span class="sxs-lookup"><span data-stu-id="6d86a-319">Registers the executable for multiple services with the Service Control Manager (SCM).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6d86a-320">在服务可执行文件的 `main()` 函数中调用此重载，以将服务注册到服务控制管理器。</span><span class="sxs-lookup"><span data-stu-id="6d86a-320">Call this overload in the `main()` function of the service executable to register the services with the Service Control Manager.</span></span> <span data-ttu-id="6d86a-321">调用 <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%5B%5D%29>后，服务控制管理器将发出启动命令，这会导致对服务中的 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 方法的调用。</span><span class="sxs-lookup"><span data-stu-id="6d86a-321">After you call <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%5B%5D%29>, the Service Control Manager issues Start commands, which result in calls to the <xref:System.ServiceProcess.ServiceBase.OnStart%2A> methods in the services.</span></span> <span data-ttu-id="6d86a-322">在执行开始命令之前，服务不会启动。</span><span class="sxs-lookup"><span data-stu-id="6d86a-322">The services are not started until the Start commands are executed.</span></span>  
  
 <span data-ttu-id="6d86a-323">调用 <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> 方法的方式与 Windows 窗体应用程序的 <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> 方法大致相同。</span><span class="sxs-lookup"><span data-stu-id="6d86a-323">The <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> method is called in much the same way as the <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> method for Windows Forms applications.</span></span>  
  
 <span data-ttu-id="6d86a-324">如果 `true`<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>，则当阵列中的任何服务启动失败时，会向事件日志写入一项。</span><span class="sxs-lookup"><span data-stu-id="6d86a-324">If <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> is `true`, an entry is written to the event log if any service in the array fails to start.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6d86a-325">未提供要启动的服务。</span><span class="sxs-lookup"><span data-stu-id="6d86a-325">You did not supply a service to start.</span></span> <span data-ttu-id="6d86a-326">该数组可能为 <see langword="null" /> 或空。</span><span class="sxs-lookup"><span data-stu-id="6d86a-326">The array might be <see langword="null" /> or empty.</span></span></exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="ServiceHandle">
      <MemberSignature Language="C#" Value="protected IntPtr ServiceHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ServiceHandle" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ServiceHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IntPtr ServiceHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ServiceHandle : nativeint" Usage="System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6d86a-327">获取服务的服务控制句柄。</span><span class="sxs-lookup"><span data-stu-id="6d86a-327">Gets the service control handle for the service.</span></span></summary>
        <value><span data-ttu-id="6d86a-328">一个 <see cref="T:System.IntPtr" /> 结构，包含服务的服务控制句柄。</span><span class="sxs-lookup"><span data-stu-id="6d86a-328">An <see cref="T:System.IntPtr" /> structure that contains the service control handle for the service.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6d86a-329">服务控制句柄用于与服务控制管理器（SCM）进行通信。</span><span class="sxs-lookup"><span data-stu-id="6d86a-329">The service control handle is used to communicate with the Service Control Manager (SCM).</span></span>  <span data-ttu-id="6d86a-330">该句柄可用于使用非托管 `SetServiceStatus` 函数更新服务控制管理器的状态信息。</span><span class="sxs-lookup"><span data-stu-id="6d86a-330">The handle can be used to update the service control manager's status information for the calling service using the unmanaged `SetServiceStatus` function.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceMainCallback">
      <MemberSignature Language="C#" Value="public void ServiceMainCallback (int argCount, IntPtr argPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ServiceMainCallback(int32 argCount, native int argPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ServiceMainCallback (argCount As Integer, argPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ServiceMainCallback(int argCount, IntPtr argPointer);" />
      <MemberSignature Language="F#" Value="member this.ServiceMainCallback : int * nativeint -&gt; unit" Usage="serviceBase.ServiceMainCallback (argCount, argPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argCount" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="argPointer" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="argCount"><span data-ttu-id="6d86a-331">参数数组中的参数个数。</span><span class="sxs-lookup"><span data-stu-id="6d86a-331">The number of arguments in the argument array.</span></span></param>
        <param name="argPointer"><span data-ttu-id="6d86a-332">指向参数数组的 <see cref="T:System.IntPtr" /> 结构。</span><span class="sxs-lookup"><span data-stu-id="6d86a-332">An <see cref="T:System.IntPtr" /> structure that points to an array of arguments.</span></span></param>
        <summary><span data-ttu-id="6d86a-333">注册命令处理程序并启动服务。</span><span class="sxs-lookup"><span data-stu-id="6d86a-333">Registers the command handler and starts the service.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberSignature Language="VB.NET" Value="Public Property ServiceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ServiceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServiceName : string with get, set" Usage="System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBServiceName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6d86a-334">获取或设置用于向系统标识服务的简短名称。</span><span class="sxs-lookup"><span data-stu-id="6d86a-334">Gets or sets the short name used to identify the service to the system.</span></span></summary>
        <value><span data-ttu-id="6d86a-335">服务的名称。</span><span class="sxs-lookup"><span data-stu-id="6d86a-335">The name of the service.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6d86a-336"><xref:System.ServiceProcess.ServiceBase.ServiceName%2A> 将服务标识给服务控制管理器。</span><span class="sxs-lookup"><span data-stu-id="6d86a-336">The <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> identifies the service to the Service Control Manager.</span></span> <span data-ttu-id="6d86a-337">此属性的值必须与在相应安装程序类的 <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=nameWithType> 属性中为服务记录的名称相同。</span><span class="sxs-lookup"><span data-stu-id="6d86a-337">The value of this property must be identical to the name recorded for the service in the <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=nameWithType> property of the corresponding installer class.</span></span> <span data-ttu-id="6d86a-338">在代码中，通常会在可执行文件的 `main()` 函数中设置服务的 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>。</span><span class="sxs-lookup"><span data-stu-id="6d86a-338">In code, the <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> of the service is usually set in the `main()` function of the executable.</span></span>  
  
 <span data-ttu-id="6d86a-339"><xref:System.ServiceProcess.ServiceBase.ServiceName%2A> 还用于指定与 <xref:System.ServiceProcess.ServiceBase.EventLog%2A> 属性关联的 <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6d86a-339">The <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> is also used to specify the <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> associated with the <xref:System.ServiceProcess.ServiceBase.EventLog%2A> property.</span></span> <span data-ttu-id="6d86a-340">此 <xref:System.ServiceProcess.ServiceBase.EventLog%2A> 是将服务命令信息写入应用程序日志的实例。</span><span class="sxs-lookup"><span data-stu-id="6d86a-340">This <xref:System.ServiceProcess.ServiceBase.EventLog%2A> is an instance that writes service command information to the Application log.</span></span>  
  
 <span data-ttu-id="6d86a-341">提供事件日志的源字符串的 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>必须在服务写入事件日志之前设置。</span><span class="sxs-lookup"><span data-stu-id="6d86a-341">The <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, which supplies the source string for the event log, must be set before the service writes to the event log.</span></span> <span data-ttu-id="6d86a-342">尝试在设置源名称之前访问事件日志会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="6d86a-342">Trying to access the event log before the source name is set causes an exception to be thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6d86a-343">服务已启动。</span><span class="sxs-lookup"><span data-stu-id="6d86a-343">The service has already been started.</span></span> <span data-ttu-id="6d86a-344">在服务启动后不能更改 <see cref="P:System.ServiceProcess.ServiceBase.ServiceName" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="6d86a-344">The <see cref="P:System.ServiceProcess.ServiceBase.ServiceName" /> property cannot be changed once the service has started.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6d86a-345">指定的名称为零长度字符串，或长于 <see cref="F:System.ServiceProcess.ServiceBase.MaxNameLength" />，就或者指定的名称包含前斜线或后斜线字符。</span><span class="sxs-lookup"><span data-stu-id="6d86a-345">The specified name is a zero-length string or is longer than <see cref="F:System.ServiceProcess.ServiceBase.MaxNameLength" />, or the specified name contains forward slash or backslash characters.</span></span></exception>
        <altmember cref="P:System.ServiceProcess.ServiceInstaller.ServiceName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="serviceBase.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6d86a-346">停止执行服务。</span><span class="sxs-lookup"><span data-stu-id="6d86a-346">Stops the executing service.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6d86a-347"><xref:System.ServiceProcess.ServiceBase.Stop%2A> 方法将服务状态设置为指示停止处于挂起状态，并调用 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="6d86a-347">The <xref:System.ServiceProcess.ServiceBase.Stop%2A> method sets the service state to indicate a stop is pending and calls the <xref:System.ServiceProcess.ServiceBase.OnStop%2A> method.</span></span>  <span data-ttu-id="6d86a-348">停止应用程序后，服务状态将设置为 "已停止"。</span><span class="sxs-lookup"><span data-stu-id="6d86a-348">After the application is stopped, the service state is set to stopped.</span></span> <span data-ttu-id="6d86a-349">如果应用程序是托管服务，则卸载应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6d86a-349">If the application is a hosted service, the application domain is unloaded.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
  </Members>
</Type>
