<Type Name="MethodBase" FullName="System.Reflection.MethodBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="911b4feb229109acf4d5b1f90ee015e7b288f429" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75167131" /></Metadata><TypeSignature Language="C#" Value="public abstract class MethodBase : System.Reflection.MemberInfo, System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit MethodBase extends System.Reflection.MemberInfo implements class System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.MethodBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MethodBase&#xA;Inherits MemberInfo&#xA;Implements _MethodBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodBase abstract : System::Reflection::MemberInfo, System::Runtime::InteropServices::_MethodBase" />
  <TypeSignature Language="F#" Value="type MethodBase = class&#xA;    inherit MemberInfo&#xA;    interface _MethodBase" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodBase</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBase))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="a0d49-101">提供有关方法和构造函数的信息。</span><span class="sxs-lookup"><span data-stu-id="a0d49-101">Provides information about methods and constructors.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-102">`MethodBase` 是 <xref:System.Reflection.MethodInfo> 和 <xref:System.Reflection.ConstructorInfo>的基类。</span><span class="sxs-lookup"><span data-stu-id="a0d49-102">`MethodBase` is the base class of <xref:System.Reflection.MethodInfo> and <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="a0d49-103">完全信任继承者。</span><span class="sxs-lookup"><span data-stu-id="a0d49-103">for full trust for inheritors.</span></span> <span data-ttu-id="a0d49-104">此类不能由部分信任的代码继承。</span><span class="sxs-lookup"><span data-stu-id="a0d49-104">This class cannot be inherited by partially trusted code.</span></span></permission>
    <threadsafe><span data-ttu-id="a0d49-105">此类型是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="a0d49-105">This type is thread safe.</span></span></threadsafe>
    <block subset="none" type="overrides"><para><span data-ttu-id="a0d49-106">从 <see langword="MethodBase" />继承时，必须重写以下成员： <see cref="M:System.Reflection.MethodBase.GetParameters" />、<see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />、<see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />、<see cref="P:System.Reflection.MethodBase.MethodHandle" />、<see cref="P:System.Reflection.MethodBase.Attributes" />、<see cref="P:System.Reflection.MemberInfo.Name" />、<see cref="P:System.Reflection.MemberInfo.DeclaringType" />、<see cref="P:System.Reflection.MemberInfo.MemberType" />、<see cref="P:System.Reflection.MemberInfo.ReflectedType" />、<see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />、<see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />和 <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-106">When you inherit from <see langword="MethodBase" />, you must override the following members: <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />, <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />, <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, and <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />.</span></span></para></block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodBase ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.#ctor" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodBase();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a0d49-107">初始化 <see cref="T:System.Reflection.MethodBase" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a0d49-107">Initializes a new instance of the <see cref="T:System.Reflection.MethodBase" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="a0d49-108">当通过 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />的机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="a0d49-108">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="a0d49-109">关联的枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-109">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.MethodBase.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-110">获取与此方法关联的属性。</span><span class="sxs-lookup"><span data-stu-id="a0d49-110">Gets the attributes associated with this method.</span></span></summary>
        <value><span data-ttu-id="a0d49-111"><see cref="T:System.Reflection.MethodAttributes" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="a0d49-111">One of the <see cref="T:System.Reflection.MethodAttributes" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-112">所有成员都具有一组属性，这些属性是相对于特定类型的成员定义的。</span><span class="sxs-lookup"><span data-stu-id="a0d49-112">All members have a set of attributes, which are defined in relation to the specific type of member.</span></span>  
  
 <span data-ttu-id="a0d49-113">若要获取 <xref:System.Reflection.MethodAttributes>，请先获取类型。</span><span class="sxs-lookup"><span data-stu-id="a0d49-113">To get the <xref:System.Reflection.MethodAttributes>, first get the type.</span></span> <span data-ttu-id="a0d49-114">从类型中获取方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-114">From the type, get the method.</span></span> <span data-ttu-id="a0d49-115">从方法获取 <xref:System.Reflection.MethodAttributes>。</span><span class="sxs-lookup"><span data-stu-id="a0d49-115">From the method, get the <xref:System.Reflection.MethodAttributes>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0d49-116">下面的代码示例显示了用户定义的方法 Mymethod 的特性。</span><span class="sxs-lookup"><span data-stu-id="a0d49-116">The following code example displays the attributes of the user-defined method Mymethod.</span></span>  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 <span data-ttu-id="a0d49-117">此代码生成以下输出：</span><span class="sxs-lookup"><span data-stu-id="a0d49-117">This code produces the following output:</span></span>  
  
 <span data-ttu-id="a0d49-118">MethodBase 示例</span><span class="sxs-lookup"><span data-stu-id="a0d49-118">Reflection.MethodBase.Attributes Sample</span></span>  
  
 <span data-ttu-id="a0d49-119">Mymethodbase = Void Mymethod （Int32，System.string，system.string，System.object ByRef）</span><span class="sxs-lookup"><span data-stu-id="a0d49-119">Mymethodbase = Void Mymethod(Int32, System.String ByRef, System.String ByRef)</span></span>  
  
 <span data-ttu-id="a0d49-120">PrivateScope</span><span class="sxs-lookup"><span data-stu-id="a0d49-120">PrivateScope</span></span>  
  
 <span data-ttu-id="a0d49-121">FamANDAssem</span><span class="sxs-lookup"><span data-stu-id="a0d49-121">FamANDAssem</span></span>  
  
 <span data-ttu-id="a0d49-122">家庭</span><span class="sxs-lookup"><span data-stu-id="a0d49-122">Family</span></span>  
  
 <span data-ttu-id="a0d49-123">公共</span><span class="sxs-lookup"><span data-stu-id="a0d49-123">Public</span></span>  
  
 <span data-ttu-id="a0d49-124">HideBySig</span><span class="sxs-lookup"><span data-stu-id="a0d49-124">HideBySig</span></span>  
  
 <span data-ttu-id="a0d49-125">ReuseSlot</span><span class="sxs-lookup"><span data-stu-id="a0d49-125">ReuseSlot</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="a0d49-126">使用 <see cref="P:System.Reflection.MethodBase.Attributes" /> 属性来确定方法是 <see langword="public" />、<see langword="private" />、<see langword="final" />、<see langword="virtual" />等。</span><span class="sxs-lookup"><span data-stu-id="a0d49-126">Use the <see cref="P:System.Reflection.MethodBase.Attributes" /> property to determine whether a method is <see langword="public" />, <see langword="private" />, <see langword="final" />, <see langword="virtual" />, and so on.</span></span></para></block>
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.MethodBase.CallingConvention" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.CallingConvention</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-127">获取一个值，该值指示此方法的调用约定。</span><span class="sxs-lookup"><span data-stu-id="a0d49-127">Gets a value indicating the calling conventions for this method.</span></span></summary>
        <value><span data-ttu-id="a0d49-128">此方法的 <see cref="T:System.Reflection.CallingConventions" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-128">The <see cref="T:System.Reflection.CallingConventions" /> for this method.</span></span></value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Reflection.CallingConventions" />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Reflection.MethodBase.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-129">获取一个值，该值指示泛型方法是否包含未赋值的泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="a0d49-129">Gets a value indicating whether the generic method contains unassigned generic type parameters.</span></span></summary>
        <value><span data-ttu-id="a0d49-130">如果当前 <see langword="true" /> 对象表示的泛型方法包含未赋值的泛型类型参数，则为 <see cref="T:System.Reflection.MethodBase" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-130"><see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> object represents a generic method that contains unassigned generic type parameters; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-131">仅当方法本身或任何封闭类型中没有泛型类型定义或开放式构造类型时，才能调用泛型方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-131">A generic method can be invoked only if there are no generic type definitions or open constructed types in the type arguments of the method itself or in any enclosing types.</span></span> <span data-ttu-id="a0d49-132">因为类型可能会很复杂，所以这种递归决定非常困难。</span><span class="sxs-lookup"><span data-stu-id="a0d49-132">Because types can be arbitrarily complex, making this recursive determination is difficult.</span></span> <span data-ttu-id="a0d49-133">为方便起见，若要减少出现错误的可能性，<xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 属性提供了一种标准方式来区分关闭的构造方法（可以调用）和开放构造方法（不能）。</span><span class="sxs-lookup"><span data-stu-id="a0d49-133">For convenience, and to reduce the chance of error, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property provides a standard way to distinguish between closed constructed methods, which can be invoked, and open constructed methods, which cannot.</span></span> <span data-ttu-id="a0d49-134">如果 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 属性返回 `true`，则无法调用此方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-134">If the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`, the method cannot be invoked.</span></span>  
  
 <span data-ttu-id="a0d49-135"><xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 属性以递归方式搜索类型参数。</span><span class="sxs-lookup"><span data-stu-id="a0d49-135">The <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property searches recursively for type parameters.</span></span> <span data-ttu-id="a0d49-136">例如，它为开放类型中的任何方法返回 `true` `A<T>` （`A(Of T)` Visual Basic），尽管该方法本身不是泛型方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-136">For example, it returns `true` for any method in an open type `A<T>` (`A(Of T)` in Visual Basic), even though the method itself is not generic.</span></span> <span data-ttu-id="a0d49-137">这与 <xref:System.Reflection.MethodBase.IsGenericMethod%2A> 属性的行为相反，后者返回此类方法的 `false`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-137">Contrast this with the behavior of the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property, which returns `false` for such a method.</span></span>  
  
 <span data-ttu-id="a0d49-138">同样，<xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 属性参数会为开放类型中的任何构造函数返回 `true`，即使构造函数不能具有其自己的类型参数。</span><span class="sxs-lookup"><span data-stu-id="a0d49-138">Similarly, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property parameter returns `true` for any constructor in an open type, even though constructors cannot have type parameters of their own.</span></span>  
  
 <span data-ttu-id="a0d49-139">有关特定于泛型方法的术语的固定条件列表，请参阅 <xref:System.Reflection.MethodBase.IsGenericMethod%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="a0d49-139">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="a0d49-140">有关泛型反射中使用的其他术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="a0d49-140">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="methodBase.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="a0d49-141">与此实例进行比较的对象，或为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-141">An object to compare with this instance, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="a0d49-142">返回一个值，该值指示此实例是否与指定的对象相等。</span><span class="sxs-lookup"><span data-stu-id="a0d49-142">Returns a value that indicates whether this instance is equal to a specified object.</span></span></summary>
        <returns><span data-ttu-id="a0d49-143">如果 <see langword="true" /> 等于此实例的类型和值，则为 <paramref name="obj" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-143"><see langword="true" /> if <paramref name="obj" /> equals the type and value of this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetCurrentMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetCurrentMethod() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetCurrentMethod" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentMethod () As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetCurrentMethod();" />
      <MemberSignature Language="F#" Value="static member GetCurrentMethod : unit -&gt; System.Reflection.MethodBase" Usage="System.Reflection.MethodBase.GetCurrentMethod " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a0d49-144">返回表示当前的执行方法的 <see langword="MethodBase" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="a0d49-144">Returns a <see langword="MethodBase" /> object representing the currently executing method.</span></span></summary>
        <returns><span data-ttu-id="a0d49-145"><see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /> 是一个静态方法，从一个执行方法中调用，且会返回有关该方法的信息。</span><span class="sxs-lookup"><span data-stu-id="a0d49-145"><see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /> is a static method that is called from within an executing method and that returns information about that method.</span></span>  
  
<span data-ttu-id="a0d49-146">表示当前的执行方法的 <see langword="MethodBase" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="a0d49-146">A <see langword="MethodBase" /> object representing the currently executing method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-147">如果对泛型类型定义当前正在执行的方法，则 <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> 返回的 <xref:System.Reflection.MethodInfo> 将从泛型类型定义（即，<xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType> 返回 `true`）中获取。</span><span class="sxs-lookup"><span data-stu-id="a0d49-147">If the currently executing method is defined on a generic type, the <xref:System.Reflection.MethodInfo> that is returned by <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> is obtained from the generic type definition (that is, <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType> returns `true`).</span></span> <span data-ttu-id="a0d49-148">因此，它不反映调用方法时使用的类型参数。</span><span class="sxs-lookup"><span data-stu-id="a0d49-148">Therefore, it does not reflect the type arguments that were used when the method was called.</span></span> <span data-ttu-id="a0d49-149">例如，如果在泛型类型上定义了一个方法 `M()` `C<T>` （`C(Of T)` Visual Basic），并且从 <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> 调用了 `C<string>.M()`，则 <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> 返回 `C<T>.M()` （`C(Of T).M()` 中的 Visual Basic）。</span><span class="sxs-lookup"><span data-stu-id="a0d49-149">For example, if a method `M()` is defined on a generic type `C<T>` (`C(Of T)` in Visual Basic), and <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> is called from `C<string>.M()`, then <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> returns `C<T>.M()` (`C(Of T).M()` in Visual Basic).</span></span>  
  
 <span data-ttu-id="a0d49-150">如果当前正在执行的方法是泛型方法，<xref:System.Reflection.MethodBase.GetCurrentMethod%2A> 将返回泛型方法定义。</span><span class="sxs-lookup"><span data-stu-id="a0d49-150">If the currently executing method is a generic method, <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> returns the generic method definition.</span></span> <span data-ttu-id="a0d49-151">如果对泛型类型定义泛型方法，则将从泛型类型定义获取 <xref:System.Reflection.MethodInfo>。</span><span class="sxs-lookup"><span data-stu-id="a0d49-151">If the generic method is defined on a generic type, the <xref:System.Reflection.MethodInfo> is obtained from the generic type definition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0d49-152">下面的示例定义了两个类型。</span><span class="sxs-lookup"><span data-stu-id="a0d49-152">The following example defines two types.</span></span> <span data-ttu-id="a0d49-153">第一个是非泛型类，`TestClass`包含构造函数、一个名为 `GetValue`的方法和一个名为 `GetValue`的读写属性。</span><span class="sxs-lookup"><span data-stu-id="a0d49-153">The first is a non-generic class, `TestClass`, includes a constructor, a method named `GetValue`, and a read-write property named `GetValue`.</span></span> <span data-ttu-id="a0d49-154">第二种方法是名为 `TestClass<T>` 的泛型类，其中包含构造函数、`GetValue` 方法和泛型方法 `ConvertValue<Y>`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-154">The second is a generic class named `TestClass<T>` that includes a constructor, a `GetValue` method, and a generic method, `ConvertValue<Y>`.</span></span> <span data-ttu-id="a0d49-155">每个构造函数、方法和属性访问器都包括对 <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> 方法的调用。</span><span class="sxs-lookup"><span data-stu-id="a0d49-155">Each constructor, method, and property accessor includes a call to the <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> method.</span></span>  
  
 [!code-csharp[System.Reflection.MethodBase.GetCurrentMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/cs/GetCurentMethod1.cs#1)]
 [!code-vb[System.Reflection.MethodBase.GetCurrentMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/vb/GetCurentMethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="a0d49-156">使用晚期绑定机制调用了此成员。</span><span class="sxs-lookup"><span data-stu-id="a0d49-156">This member was invoked with a late-binding mechanism.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="a0d49-157">当通过 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />的机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="a0d49-157">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="a0d49-158">关联的枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-158">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="methodBase.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a0d49-159">返回 <see cref="T:System.Type" /> 对象的数组，这些对象表示泛型方法的类型实参或泛型方法定义的类型形参。</span><span class="sxs-lookup"><span data-stu-id="a0d49-159">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span></span></summary>
        <returns><span data-ttu-id="a0d49-160"><see cref="T:System.Type" /> 对象的数组，这些对象表示泛型方法的类型变量或泛型方法定义的类型参数。</span><span class="sxs-lookup"><span data-stu-id="a0d49-160">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span></span> <span data-ttu-id="a0d49-161">如果当前方法不是泛型方法，则返回空数组。</span><span class="sxs-lookup"><span data-stu-id="a0d49-161">Returns an empty array if the current method is not a generic method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-162">返回数组的元素按它们出现在泛型方法的类型参数列表中的顺序排列。</span><span class="sxs-lookup"><span data-stu-id="a0d49-162">The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</span></span>  
  
-   <span data-ttu-id="a0d49-163">如果当前方法是封闭式构造方法（即，<xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 属性返回 `false`），则 <xref:System.Reflection.MethodBase.GetGenericArguments%2A> 方法返回的数组包含已分配给泛型方法定义的泛型类型参数的类型。</span><span class="sxs-lookup"><span data-stu-id="a0d49-163">If the current method is a closed constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Reflection.MethodBase.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic method definition.</span></span>  
  
-   <span data-ttu-id="a0d49-164">如果当前方法是泛型方法定义，则数组包含类型参数。</span><span class="sxs-lookup"><span data-stu-id="a0d49-164">If the current method is a generic method definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="a0d49-165">如果当前方法是开放构造方法（即，<xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 属性返回 `true`），其中特定类型已分配给某些类型参数，并且已将封闭泛型类型的类型参数分配给其他类型参数，则数组同时包含类型参数和类型参数。</span><span class="sxs-lookup"><span data-stu-id="a0d49-165">If the current method is an open constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters.</span></span> <span data-ttu-id="a0d49-166">使用 <xref:System.Type.IsGenericParameter%2A> 属性将它们区分开来。</span><span class="sxs-lookup"><span data-stu-id="a0d49-166">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="a0d49-167">有关此方案的演示，请参阅为 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 属性提供的代码示例。</span><span class="sxs-lookup"><span data-stu-id="a0d49-167">For a demonstration of this scenario, see the code example provided for the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="a0d49-168">.NET Framework 2.0 版不支持泛型构造函数。</span><span class="sxs-lookup"><span data-stu-id="a0d49-168">Generic constructors are not supported in the .NET Framework version 2.0.</span></span> <span data-ttu-id="a0d49-169">如果未在派生类中重写，则此属性会引发 <xref:System.NotSupportedException>，因此，如果当前实例的类型为 <xref:System.Reflection.ConstructorInfo>，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="a0d49-169">This property throws <xref:System.NotSupportedException> if not overridden in a derived class, so an exception is thrown if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 <span data-ttu-id="a0d49-170">有关特定于泛型方法的术语的固定条件列表，请参阅 <xref:System.Reflection.MethodBase.IsGenericMethod%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="a0d49-170">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="a0d49-171">有关泛型反射中使用的其他术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="a0d49-171">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a0d49-172">当前对象是 <see cref="T:System.Reflection.ConstructorInfo" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-172">The current object is a <see cref="T:System.Reflection.ConstructorInfo" />.</span></span> <span data-ttu-id="a0d49-173">.NET Framework 2.0 版不支持泛型构造函数。</span><span class="sxs-lookup"><span data-stu-id="a0d49-173">Generic constructors are not supported in the .NET Framework version 2.0.</span></span> <span data-ttu-id="a0d49-174">如果派生类未重写此方法，此异常即为默认行为。</span><span class="sxs-lookup"><span data-stu-id="a0d49-174">This exception is the default behavior if this method is not overridden in a derived class.</span></span></exception>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="M:System.Reflection.MethodInfo.GetGenericArguments" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="methodBase.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a0d49-175">返回此实例的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="a0d49-175">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="a0d49-176">32 位有符号整数哈希代码。</span><span class="sxs-lookup"><span data-stu-id="a0d49-176">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBody">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBody GetMethodBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBody GetMethodBody() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodBody" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMethodBody () As MethodBody" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodBody ^ GetMethodBody();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodBody : unit -&gt; System.Reflection.MethodBody&#xA;override this.GetMethodBody : unit -&gt; System.Reflection.MethodBody" Usage="methodBase.GetMethodBody " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBody</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a0d49-177">在派生类中重写后，获取 <see cref="T:System.Reflection.MethodBody" /> 对象，该对象提供对 MSIL 流、局部变量和当前方法的异常的访问。</span><span class="sxs-lookup"><span data-stu-id="a0d49-177">When overridden in a derived class, gets a <see cref="T:System.Reflection.MethodBody" /> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</span></span></summary>
        <returns><span data-ttu-id="a0d49-178"><see cref="T:System.Reflection.MethodBody" /> 对象，提供对 MSIL 流、局部变量和当前方法的异常的访问。</span><span class="sxs-lookup"><span data-stu-id="a0d49-178">A <see cref="T:System.Reflection.MethodBody" /> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-179">不需要重写 <xref:System.Reflection.MethodBase.GetMethodBody%2A>，即可使用它。</span><span class="sxs-lookup"><span data-stu-id="a0d49-179">You do not have to override the <xref:System.Reflection.MethodBase.GetMethodBody%2A> in order to use it.</span></span> <span data-ttu-id="a0d49-180">您可以对 <xref:System.Reflection.MethodInfo> 和 <xref:System.Reflection.ConstructorInfo> 对象调用 <xref:System.Reflection.MethodBase.GetMethodBody%2A> 方法，因为在这些类的运行时版本中会重写方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-180">You can call the <xref:System.Reflection.MethodBase.GetMethodBody%2A> method on <xref:System.Reflection.MethodInfo> and <xref:System.Reflection.ConstructorInfo> objects, because the method is overridden in the runtime versions of these classes.</span></span> <span data-ttu-id="a0d49-181">例如，<xref:System.Reflection.MethodInfo> 类的运行时版本派生自 <xref:System.Reflection.MethodInfo> 类，后者又派生自 <xref:System.Reflection.MethodBase> 类。</span><span class="sxs-lookup"><span data-stu-id="a0d49-181">For example, the runtime version of the <xref:System.Reflection.MethodInfo> class derives from the <xref:System.Reflection.MethodInfo> class, which in turn derives from the <xref:System.Reflection.MethodBase> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0d49-182">下面的代码示例定义一个名为 `MethodBodyExample` 的测试方法，并显示其本地变量信息和异常处理子句。</span><span class="sxs-lookup"><span data-stu-id="a0d49-182">The following code example defines a test method named `MethodBodyExample` and displays its local variable information and exception-handling clauses.</span></span> <span data-ttu-id="a0d49-183"><xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType> 方法用于获取测试方法的 <xref:System.Reflection.MethodBody> 对象。</span><span class="sxs-lookup"><span data-stu-id="a0d49-183">The <xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType> method is used to obtain a <xref:System.Reflection.MethodBody> object for the test method.</span></span>  
  
 <span data-ttu-id="a0d49-184"><xref:System.Reflection.MethodBody.LocalVariables%2A> 属性用于获取 <xref:System.Reflection.LocalVariableInfo> 对象的列表并显示其类型和索引顺序。</span><span class="sxs-lookup"><span data-stu-id="a0d49-184">The <xref:System.Reflection.MethodBody.LocalVariables%2A> property is used to obtain a list of <xref:System.Reflection.LocalVariableInfo> objects and display their types and index order.</span></span> <span data-ttu-id="a0d49-185"><xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A> 属性用于获取异常处理子句的列表。</span><span class="sxs-lookup"><span data-stu-id="a0d49-185">The <xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A> property is used to obtain a list of exception-handling clauses.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0d49-186">并非所有计算机语言都可以生成 <xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType> 子句。</span><span class="sxs-lookup"><span data-stu-id="a0d49-186">Not all computer languages can generate <xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType> clauses.</span></span> <span data-ttu-id="a0d49-187">Visual Basic 示例显示一个筛选器子句，该子句使用 Visual Basic `When` 表达式，这在其他语言的示例中是省略的。</span><span class="sxs-lookup"><span data-stu-id="a0d49-187">The Visual Basic example shows a filter clause, using a Visual Basic `When` expression, which is omitted from the examples for other languages.</span></span>  
  
 [!code-cpp[MethodBody#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBody/cpp/source.cpp#1)]
 [!code-csharp[MethodBody#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBody/CS/source.cs#1)]
 [!code-vb[MethodBody#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBody/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a0d49-188">除非在派生类中重写，否则此方法无效。</span><span class="sxs-lookup"><span data-stu-id="a0d49-188">This method is invalid unless overridden in a derived class.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="a0d49-189">用于对成员的元数据的访问。</span><span class="sxs-lookup"><span data-stu-id="a0d49-189">for the access to metadata for members.</span></span> <span data-ttu-id="a0d49-190">权限值： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="a0d49-190">Permission value: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethodFromHandle">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a0d49-191">使用指定句柄获取方法信息。</span><span class="sxs-lookup"><span data-stu-id="a0d49-191">Gets method information using the specified handle.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodFromHandle (handle As RuntimeMethodHandle) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodFromHandle(RuntimeMethodHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetMethodFromHandle : RuntimeMethodHandle -&gt; System.Reflection.MethodBase" Usage="System.Reflection.MethodBase.GetMethodFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="a0d49-192">方法的句柄。</span><span class="sxs-lookup"><span data-stu-id="a0d49-192">The method's handle.</span></span></param>
        <summary><span data-ttu-id="a0d49-193">通过使用方法的内部元数据表示形式（句柄）获取方法信息。</span><span class="sxs-lookup"><span data-stu-id="a0d49-193">Gets method information by using the method's internal metadata representation (handle).</span></span></summary>
        <returns><span data-ttu-id="a0d49-194"><see langword="MethodBase" />，包含方法的有关信息。</span><span class="sxs-lookup"><span data-stu-id="a0d49-194">A <see langword="MethodBase" /> containing information about the method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-195">句柄仅在获取它们的应用程序域中有效。</span><span class="sxs-lookup"><span data-stu-id="a0d49-195">Handles are valid only in the application domain in which they were obtained.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0d49-196"><paramref name="handle" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="a0d49-196"><paramref name="handle" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="a0d49-197">当通过 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />的机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="a0d49-197">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="a0d49-198">关联的枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-198">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle, valuetype System.RuntimeTypeHandle declaringType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodFromHandle (handle As RuntimeMethodHandle, declaringType As RuntimeTypeHandle) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberSignature Language="F#" Value="static member GetMethodFromHandle : RuntimeMethodHandle * RuntimeTypeHandle -&gt; System.Reflection.MethodBase" Usage="System.Reflection.MethodBase.GetMethodFromHandle (handle, declaringType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="declaringType" Type="System.RuntimeTypeHandle" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="a0d49-199">构造函数或方法的内部元数据表示形式的句柄。</span><span class="sxs-lookup"><span data-stu-id="a0d49-199">A handle to the internal metadata representation of a constructor or method.</span></span></param>
        <param name="declaringType"><span data-ttu-id="a0d49-200">定义构造函数或方法的泛型类型的句柄。</span><span class="sxs-lookup"><span data-stu-id="a0d49-200">A handle to the generic type that defines the constructor or method.</span></span></param>
        <summary><span data-ttu-id="a0d49-201">以指定泛型类型，获取指定句柄所表示的构造函数或方法的 <see cref="T:System.Reflection.MethodBase" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="a0d49-201">Gets a <see cref="T:System.Reflection.MethodBase" /> object for the constructor or method represented by the specified handle, for the specified generic type.</span></span></summary>
        <returns><span data-ttu-id="a0d49-202"><see cref="T:System.Reflection.MethodBase" /> 对象，表示由 <paramref name="handle" /> 指定的方法或构造函数，为由 <paramref name="declaringType" /> 指定的泛型类型。</span><span class="sxs-lookup"><span data-stu-id="a0d49-202">A <see cref="T:System.Reflection.MethodBase" /> object representing the method or constructor specified by <paramref name="handle" />, in the generic type specified by <paramref name="declaringType" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-203">句柄仅在获取它们的应用程序域中有效。</span><span class="sxs-lookup"><span data-stu-id="a0d49-203">Handles are valid only in the application domain in which they were obtained.</span></span>  
  
 <span data-ttu-id="a0d49-204">泛型类型的构造函数或方法的 <xref:System.RuntimeMethodHandle> 结构可以表示不同的 <xref:System.Reflection.MethodBase> 对象，具体取决于为泛型类型的类型参数指定的类型。</span><span class="sxs-lookup"><span data-stu-id="a0d49-204">A <xref:System.RuntimeMethodHandle> structure for a constructor or method of a generic type can represent different <xref:System.Reflection.MethodBase> objects, depending on the types specified for the type parameters of the generic type.</span></span> <span data-ttu-id="a0d49-205">例如，如果 `class G<T>` （中的`class G(Of T)` Visual Basic，`generic <T> ref class G` 中C++的）具有返回类型 `T`的方法，则构造类（如 <xref:System.Reflection.MethodBase>）中该方法的 `G<int>` 对象不同于泛型类型定义中该方法的 <xref:System.Reflection.MethodBase> 对象。</span><span class="sxs-lookup"><span data-stu-id="a0d49-205">For example, if `class G<T>` (`class G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) has a method that returns type `T`, the <xref:System.Reflection.MethodBase> object for that method in a constructed class such as `G<int>` is different from the <xref:System.Reflection.MethodBase> object for that method in the generic type definition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0d49-206"><paramref name="handle" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="a0d49-206"><paramref name="handle" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="a0d49-207">当通过 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />的机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="a0d49-207">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="a0d49-208">关联的枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-208">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="methodBase.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetMethodImplementationFlags</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a0d49-209">在派生的类中重写时，返回 <see cref="T:System.Reflection.MethodImplAttributes" /> 标志。</span><span class="sxs-lookup"><span data-stu-id="a0d49-209">When overridden in a derived class, returns the <see cref="T:System.Reflection.MethodImplAttributes" /> flags.</span></span></summary>
        <returns><span data-ttu-id="a0d49-210"><see langword="MethodImplAttributes" /> 标志。</span><span class="sxs-lookup"><span data-stu-id="a0d49-210">The <see langword="MethodImplAttributes" /> flags.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a0d49-211">下面的示例在动态程序集中定义了一个构造函数，然后使用 <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> 方法来显示默认设置的方法实现标志。</span><span class="sxs-lookup"><span data-stu-id="a0d49-211">The following example defines a constructor in a dynamic assembly and then uses the <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> method to display the method implementation flags that are set by default.</span></span>  
  
 [!code-cpp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CPP/constructorbuilder_getmodule_4.cpp#3)]
 [!code-csharp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CS/constructorbuilder_getmodule_4.cs#3)]
 [!code-vb[ConstructorBuilder_GetModule_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/VB/constructorbuilder_getmodule_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="a0d49-212">当通过 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />的机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="a0d49-212">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="a0d49-213">关联的枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-213">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Reflection.MethodImplAttributes" />
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="abstract member GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="methodBase.GetParameters " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a0d49-214">当在派生类中重写时，获取指定的方法或构造函数的参数。</span><span class="sxs-lookup"><span data-stu-id="a0d49-214">When overridden in a derived class, gets the parameters of the specified method or constructor.</span></span></summary>
        <returns><span data-ttu-id="a0d49-215"><see langword="ParameterInfo" /> 类型的数组，包含与此 <see langword="MethodBase" /> 实例所反射的方法（或构造函数）的签名匹配的信息。</span><span class="sxs-lookup"><span data-stu-id="a0d49-215">An array of type <see langword="ParameterInfo" /> containing information that matches the signature of the method (or constructor) reflected by this <see langword="MethodBase" /> instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a0d49-216">下面的示例使用 <xref:System.Reflection.MethodBase.GetParameters%2A> 方法检索委托的 `Invoke` 方法的参数。</span><span class="sxs-lookup"><span data-stu-id="a0d49-216">The following example uses the <xref:System.Reflection.MethodBase.GetParameters%2A> method to retrieve the parameters of the `Invoke` method of a delegate.</span></span>  
  
 <span data-ttu-id="a0d49-217">该示例定义一个名为 `MyDelegate` 的委托和一个 `MyDelegate`类型的名为 `ev` 的事件。</span><span class="sxs-lookup"><span data-stu-id="a0d49-217">The example defines a delegate named `MyDelegate` and an event named `ev` of type `MyDelegate`.</span></span> <span data-ttu-id="a0d49-218">`Main` 方法中的代码通过获取事件的委托类型，获取委托类型的 `Invoke` 方法，然后检索并显示参数来发现事件签名。</span><span class="sxs-lookup"><span data-stu-id="a0d49-218">The code in the `Main` method discovers the event signature by getting the delegate type of the event, getting the `Invoke` method of the delegate type, and then retrieving and displaying the parameters.</span></span>  
  
 [!code-cpp[eventarg#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventArg/CPP/eventarg.cpp#1)]
 [!code-csharp[eventarg#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventArg/CS/eventarg.cs#1)]
 [!code-vb[eventarg#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventArg/VB/eventarg.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="a0d49-219">当通过 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />的机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="a0d49-219">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="a0d49-220">关联的枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-220">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Reflection.ParameterInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="methodBase.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a0d49-221">调用由此 <see langword="MethodInfo" /> 实例反射的方法或构造函数。</span><span class="sxs-lookup"><span data-stu-id="a0d49-221">Invokes the method or constructor reflected by this <see langword="MethodInfo" /> instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public virtual object Invoke (object obj, object[] parameters);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, object[] parameters) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Invoke (obj As Object, parameters As Object()) As Object" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(System::Object ^ obj, cli::array &lt;System::Object ^&gt; ^ parameters);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Invoke : obj * obj[] -&gt; obj&#xA;override this.Invoke : obj * obj[] -&gt; obj" Usage="methodBase.Invoke (obj, parameters)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public object Invoke (object obj, object[] parameters);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(object obj, object[] parameters) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (obj As Object, parameters As Object()) As Object" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Object ^ obj, cli::array &lt;System::Object ^&gt; ^ parameters);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.Invoke : obj * obj[] -&gt; obj" Usage="methodBase.Invoke (obj, parameters)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="a0d49-222">在其上调用方法或构造函数的对象。</span><span class="sxs-lookup"><span data-stu-id="a0d49-222">The object on which to invoke the method or constructor.</span></span> <span data-ttu-id="a0d49-223">如果方法是静态的，则忽略此参数。</span><span class="sxs-lookup"><span data-stu-id="a0d49-223">If a method is static, this argument is ignored.</span></span> <span data-ttu-id="a0d49-224">如果构造函数是静态的，则此参数必须是 <see langword="null" /> 或定义构造函数的类的实例。</span><span class="sxs-lookup"><span data-stu-id="a0d49-224">If a constructor is static, this argument must be <see langword="null" /> or an instance of the class that defines the constructor.</span></span></param>
        <param name="parameters"><span data-ttu-id="a0d49-225">调用方法或构造函数的参数列表。</span><span class="sxs-lookup"><span data-stu-id="a0d49-225">An argument list for the invoked method or constructor.</span></span> <span data-ttu-id="a0d49-226">此对象数组在数量、顺序和类型方面与要调用的方法或构造函数的参数相同。</span><span class="sxs-lookup"><span data-stu-id="a0d49-226">This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</span></span> <span data-ttu-id="a0d49-227">如果不存在任何参数，则 <paramref name="parameters" /> 应为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-227">If there are no parameters, <paramref name="parameters" /> should be <see langword="null" />.</span></span>  
  
<span data-ttu-id="a0d49-228">如果由此实例表示的方法或构造函数采用了 <see langword="ref" /> 参数（在 Visual Basic 中为 <see langword="ByRef" />），那么此参数不需要特殊属性来通过此函数调用此方法或构造函数。</span><span class="sxs-lookup"><span data-stu-id="a0d49-228">If the method or constructor represented by this instance takes a <see langword="ref" /> parameter (<see langword="ByRef" /> in Visual Basic), no special attribute is required for that parameter in order to invoke the method or constructor using this function.</span></span> <span data-ttu-id="a0d49-229">此数组中未使用值显式初始化的任何对象都将包含该对象类型的默认值。</span><span class="sxs-lookup"><span data-stu-id="a0d49-229">Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</span></span> <span data-ttu-id="a0d49-230">对于引用类型元素，此值为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-230">For reference-type elements, this value is <see langword="null" />.</span></span> <span data-ttu-id="a0d49-231">对于值类型元素，此值为 0、0.0 或 <see langword="false" />，具体取决于特定的元素类型。</span><span class="sxs-lookup"><span data-stu-id="a0d49-231">For value-type elements, this value is 0, 0.0, or <see langword="false" />, depending on the specific element type.</span></span></param>
        <summary><span data-ttu-id="a0d49-232">使用指定参数调用由当前实例表示的方法或构造函数。</span><span class="sxs-lookup"><span data-stu-id="a0d49-232">Invokes the method or constructor represented by the current instance, using the specified parameters.</span></span></summary>
        <returns><span data-ttu-id="a0d49-233">一个包含已调用方法的返回值或包含已调用构造函数的 <see langword="null" /> 的对象。</span><span class="sxs-lookup"><span data-stu-id="a0d49-233">An object containing the return value of the invoked method, or <see langword="null" /> in the case of a constructor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-234">这是一种便捷的方法，它调用 <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> 方法重载，并为 `binder` 和 `culture`传递 `invokeAttr` 和 `null` 的 <xref:System.Reflection.BindingFlags.Default>。</span><span class="sxs-lookup"><span data-stu-id="a0d49-234">This is a convenience method that calls the <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> method overload, passing <xref:System.Reflection.BindingFlags.Default> for `invokeAttr` and `null` for `binder` and `culture`.</span></span>  
  
 <span data-ttu-id="a0d49-235">如果调用的方法引发异常，<xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType> 方法将返回异常。</span><span class="sxs-lookup"><span data-stu-id="a0d49-235">If the invoked method throws an exception, the <xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType> method returns the exception.</span></span>  
  
 <span data-ttu-id="a0d49-236">若要使用其 <xref:System.Reflection.MethodInfo> 对象调用静态方法，请为 `obj`传递 `null`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-236">To invoke a static method using its <xref:System.Reflection.MethodInfo> object, pass `null` for `obj`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0d49-237">如果此方法重载用于调用实例构造函数，则将重新初始化为 `obj` 提供的对象;也就是说，将执行所有实例初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="a0d49-237">If this method overload is used to invoke an instance constructor, the object supplied for `obj` is reinitialized; that is, all instance initializers are executed.</span></span> <span data-ttu-id="a0d49-238">返回值为 `null`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-238">The return value is `null`.</span></span> <span data-ttu-id="a0d49-239">如果调用类构造函数，则类将重新初始化;也就是说，执行所有类初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="a0d49-239">If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</span></span> <span data-ttu-id="a0d49-240">返回值为 `null`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-240">The return value is `null`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0d49-241">从 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]开始，此方法可用于访问非公共成员（如果已向调用方授予了 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 标记 <xref:System.Security.Permissions.ReflectionPermission>，以及非公共成员的授予集限制为调用方的授予集或其子集）。</span><span class="sxs-lookup"><span data-stu-id="a0d49-241">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="a0d49-242">（请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。）</span><span class="sxs-lookup"><span data-stu-id="a0d49-242">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="a0d49-243">若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="a0d49-243">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 <span data-ttu-id="a0d49-244">如果当前方法的参数是值类型，并且 `null``parameters` 中的相应参数，则运行时将传递值类型的零初始化实例。</span><span class="sxs-lookup"><span data-stu-id="a0d49-244">If a parameter of the current method is a value type, and the corresponding argument in `parameters` is `null`, the runtime passes a zero-initialized instance of the value type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0d49-245">下面的代码示例演示使用反射的动态方法查找。</span><span class="sxs-lookup"><span data-stu-id="a0d49-245">The following code example demonstrates dynamic method lookup using reflection.</span></span> <span data-ttu-id="a0d49-246">请注意，不能使用基类中的 <xref:System.Reflection.MethodInfo> 对象调用派生类中的重写方法，因为后期绑定无法解析重写。</span><span class="sxs-lookup"><span data-stu-id="a0d49-246">Note that you cannot use the <xref:System.Reflection.MethodInfo> object from the base class to invoke the overridden method in the derived class, because late binding cannot resolve overrides.</span></span>  
  
 [!code-cpp[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="a0d49-247">在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获 <see cref="T:System.Exception" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-247">In the<see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch <see cref="T:System.Exception" /> instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="a0d49-248"><paramref name="obj" /> 参数为 <see langword="null" />，且此方法不是静态方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-248">The <paramref name="obj" /> parameter is <see langword="null" /> and the method is not static.</span></span>  
  
<span data-ttu-id="a0d49-249">- 或 -</span><span class="sxs-lookup"><span data-stu-id="a0d49-249">-or-</span></span> 
<span data-ttu-id="a0d49-250">该方法不由 <paramref name="obj" /> 的类声明或继承。</span><span class="sxs-lookup"><span data-stu-id="a0d49-250">The method is not declared or inherited by the class of <paramref name="obj" />.</span></span>  
  
<span data-ttu-id="a0d49-251">- 或 -</span><span class="sxs-lookup"><span data-stu-id="a0d49-251">-or-</span></span> 
<span data-ttu-id="a0d49-252">调用静态构造函数，<paramref name="obj" /> 既不是 <see langword="null" />，也不是声明构造函数的类的实例。</span><span class="sxs-lookup"><span data-stu-id="a0d49-252">A static constructor is invoked, and <paramref name="obj" /> is neither <see langword="null" /> nor an instance of the class that declared the constructor.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0d49-253"><paramref name="parameters" /> 数组的元素与此实例反映的方法或构造函数的签名不匹配。</span><span class="sxs-lookup"><span data-stu-id="a0d49-253">The elements of the <paramref name="parameters" /> array do not match the signature of the method or constructor reflected by this instance.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="a0d49-254">调用的方法或构造函数引发异常。</span><span class="sxs-lookup"><span data-stu-id="a0d49-254">The invoked method or constructor throws an exception.</span></span>  
  
<span data-ttu-id="a0d49-255">- 或 -</span><span class="sxs-lookup"><span data-stu-id="a0d49-255">-or-</span></span> 
<span data-ttu-id="a0d49-256">当前实例是包含无法验证的代码的 <see cref="T:System.Reflection.Emit.DynamicMethod" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-256">The current instance is a <see cref="T:System.Reflection.Emit.DynamicMethod" /> that contains unverifiable code.</span></span> <span data-ttu-id="a0d49-257">请参阅“验证”部分中的 <see cref="T:System.Reflection.Emit.DynamicMethod" /> 注释。</span><span class="sxs-lookup"><span data-stu-id="a0d49-257">See the "Verification" section in Remarks for <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetParameterCountException"><span data-ttu-id="a0d49-258"><paramref name="parameters" /> 数组的参数数量不正确。</span><span class="sxs-lookup"><span data-stu-id="a0d49-258">The <paramref name="parameters" /> array does not have the correct number of arguments.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="a0d49-259">在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.MemberAccessException" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-259">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.MemberAccessException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="a0d49-260">调用方没有执行由当前实例表示的方法或构造函数的权限。</span><span class="sxs-lookup"><span data-stu-id="a0d49-260">The caller does not have permission to execute the method or constructor that is represented by the current instance.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a0d49-261">声明该方法的类型为开放式泛型类型。</span><span class="sxs-lookup"><span data-stu-id="a0d49-261">The type that declares the method is an open generic type.</span></span> <span data-ttu-id="a0d49-262">也就是说，<see cref="P:System.Type.ContainsGenericParameters" /> 属性为声明类型返回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-262">That is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" /> for the declaring type.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="a0d49-263">当前实例为 <see cref="T:System.Reflection.Emit.MethodBuilder" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-263">The current instance is a <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="a0d49-264">当通过 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />的机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="a0d49-264">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="a0d49-265">关联的枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-265">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Missing" />
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public abstract object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="methodBase.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="parameters" Type="System.Object[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="a0d49-266">在其上调用方法或构造函数的对象。</span><span class="sxs-lookup"><span data-stu-id="a0d49-266">The object on which to invoke the method or constructor.</span></span> <span data-ttu-id="a0d49-267">如果方法是静态的，则忽略此参数。</span><span class="sxs-lookup"><span data-stu-id="a0d49-267">If a method is static, this argument is ignored.</span></span> <span data-ttu-id="a0d49-268">如果构造函数是静态的，则此参数必须是 <see langword="null" /> 或定义构造函数的类的实例。</span><span class="sxs-lookup"><span data-stu-id="a0d49-268">If a constructor is static, this argument must be <see langword="null" /> or an instance of the class that defines the constructor.</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="a0d49-269">位屏蔽，它是 <see cref="T:System.Reflection.BindingFlags" /> 的 0 个或多个位标志的组合。</span><span class="sxs-lookup"><span data-stu-id="a0d49-269">A bitmask that is a combination of 0 or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span> <span data-ttu-id="a0d49-270">如果 <paramref name="binder" /> 为 <see langword="null" />，则此参数赋值为 <see cref="F:System.Reflection.BindingFlags.Default" />；因此，传入的任何值都被忽略。</span><span class="sxs-lookup"><span data-stu-id="a0d49-270">If <paramref name="binder" /> is <see langword="null" />, this parameter is assigned the value <see cref="F:System.Reflection.BindingFlags.Default" />; thus, whatever you pass in is ignored.</span></span></param>
        <param name="binder"><span data-ttu-id="a0d49-271">一个对象，它启用绑定、对自变量类型的强制、对成员的调用，以及通过反射对 <see langword="MemberInfo" /> 对象的检索。</span><span class="sxs-lookup"><span data-stu-id="a0d49-271">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects via reflection.</span></span> <span data-ttu-id="a0d49-272">如果 <paramref name="binder" /> 为 <see langword="null" />，则使用默认联编程序。</span><span class="sxs-lookup"><span data-stu-id="a0d49-272">If <paramref name="binder" /> is <see langword="null" />, the default binder is used.</span></span></param>
        <param name="parameters"><span data-ttu-id="a0d49-273">调用方法或构造函数的参数列表。</span><span class="sxs-lookup"><span data-stu-id="a0d49-273">An argument list for the invoked method or constructor.</span></span> <span data-ttu-id="a0d49-274">此对象数组在数量、顺序和类型方面与要调用的方法或构造函数的参数相同。</span><span class="sxs-lookup"><span data-stu-id="a0d49-274">This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</span></span> <span data-ttu-id="a0d49-275">如果没有参数，则此应为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-275">If there are no parameters, this should be <see langword="null" />.</span></span>  
  
<span data-ttu-id="a0d49-276">如果此实例表示的方法或构造函数采用 ByRef 参数，那么使用此函数调用该方法或构造函数时，对于该参数不需要特殊的特性。</span><span class="sxs-lookup"><span data-stu-id="a0d49-276">If the method or constructor represented by this instance takes a ByRef parameter, there is no special attribute required for that parameter in order to invoke the method or constructor using this function.</span></span> <span data-ttu-id="a0d49-277">此数组中未使用值显式初始化的任何对象都将包含该对象类型的默认值。</span><span class="sxs-lookup"><span data-stu-id="a0d49-277">Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</span></span> <span data-ttu-id="a0d49-278">对于引用类型元素，此值为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-278">For reference-type elements, this value is <see langword="null" />.</span></span> <span data-ttu-id="a0d49-279">对于值类型元素，此值为 0、0.0 或 <see langword="false" />，具体取决于特定的元素类型。</span><span class="sxs-lookup"><span data-stu-id="a0d49-279">For value-type elements, this value is 0, 0.0, or <see langword="false" />, depending on the specific element type.</span></span></param>
        <param name="culture"><span data-ttu-id="a0d49-280">用于控制类型强制的 <see langword="CultureInfo" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="a0d49-280">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span></span> <span data-ttu-id="a0d49-281">如果这是 <see langword="null" />，则使用当前线程的 <see langword="CultureInfo" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-281">If this is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span></span> <span data-ttu-id="a0d49-282">（例如，这对于将表示 1000 的 <see langword="String" /> 转换为 <see langword="Double" /> 值是必需的，因为不同的区域性以不同的方式表示 1000。）</span><span class="sxs-lookup"><span data-stu-id="a0d49-282">(This is necessary to convert a <see langword="String" /> that represents 1000 to a <see langword="Double" /> value, for example, since 1000 is represented differently by different cultures.)</span></span></param>
        <summary><span data-ttu-id="a0d49-283">当在派生类中重写时，调用具有给定参数的反射的方法或构造函数。</span><span class="sxs-lookup"><span data-stu-id="a0d49-283">When overridden in a derived class, invokes the reflected method or constructor with the given parameters.</span></span></summary>
        <returns><span data-ttu-id="a0d49-284"><see langword="Object" />，包含被调用方法的返回值；如果调用的是构造函数，则为 <see langword="null" />；如果方法的返回类型是 <see langword="null" />，则为 <see langword="void" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-284">An <see langword="Object" /> containing the return value of the invoked method, or <see langword="null" /> in the case of a constructor, or <see langword="null" /> if the method's return type is <see langword="void" />.</span></span> <span data-ttu-id="a0d49-285">在调用方法或构造函数之前，<see langword="Invoke" /> 检查用户是否有访问权限并验证参数是否有效。</span><span class="sxs-lookup"><span data-stu-id="a0d49-285">Before calling the method or constructor, <see langword="Invoke" /> checks to see if the user has access permission and verifies that the parameters are valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-286">在 `obj`上动态调用此实例反射的方法，并沿指定参数传递。</span><span class="sxs-lookup"><span data-stu-id="a0d49-286">Dynamically invokes the method reflected by this instance on `obj`, and passes along the specified parameters.</span></span> <span data-ttu-id="a0d49-287">如果该方法是静态的，则忽略 `obj` 参数。</span><span class="sxs-lookup"><span data-stu-id="a0d49-287">If the method is static, the `obj` parameter is ignored.</span></span> <span data-ttu-id="a0d49-288">对于非静态方法，`obj` 应是继承或声明方法并且必须与此类相同的类型的类的实例。</span><span class="sxs-lookup"><span data-stu-id="a0d49-288">For non-static methods, `obj` should be an instance of a class that inherits or declares the method and must be the same type as this class.</span></span> <span data-ttu-id="a0d49-289">如果该方法没有参数，则应 `null``parameters` 的值。</span><span class="sxs-lookup"><span data-stu-id="a0d49-289">If the method has no parameters, the value of `parameters` should be `null`.</span></span> <span data-ttu-id="a0d49-290">否则，`parameters` 中的元素的数量、类型和顺序应当与此实例所反射的方法的参数的数量、类型和顺序相同。</span><span class="sxs-lookup"><span data-stu-id="a0d49-290">Otherwise, the number, type, and order of elements in `parameters` should be identical to the number, type, and order of parameters for the method reflected by this instance.</span></span>  
  
 <span data-ttu-id="a0d49-291">在对 `Invoke`的调用中，不能省略可选参数。</span><span class="sxs-lookup"><span data-stu-id="a0d49-291">You may not omit optional parameters in calls to `Invoke`.</span></span> <span data-ttu-id="a0d49-292">若要调用省略可选参数的方法，应改为调用 `Type.InvokeMember`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-292">To invoke a method omitting optional parameters, you should call `Type.InvokeMember` instead.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0d49-293">如果此方法重载用于调用实例构造函数，则将重新初始化为 `obj` 提供的对象;也就是说，将执行所有实例初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="a0d49-293">If this method overload is used to invoke an instance constructor, the object supplied for `obj` is reinitialized; that is, all instance initializers are executed.</span></span> <span data-ttu-id="a0d49-294">返回值为 `null`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-294">The return value is `null`.</span></span> <span data-ttu-id="a0d49-295">如果调用类构造函数，则类将重新初始化;也就是说，执行所有类初始值设定项。</span><span class="sxs-lookup"><span data-stu-id="a0d49-295">If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</span></span> <span data-ttu-id="a0d49-296">返回值为 `null`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-296">The return value is `null`.</span></span>  
  
 <span data-ttu-id="a0d49-297">对于按值传递的基元参数，将执行正常扩展（例如 Int16 > Int32）。</span><span class="sxs-lookup"><span data-stu-id="a0d49-297">For pass-by-value primitive parameters, normal widening is performed (Int16 -> Int32, for example).</span></span> <span data-ttu-id="a0d49-298">对于按值传递引用参数，允许进行常规引用扩大（派生类到基类，并使用基类到接口类型）。</span><span class="sxs-lookup"><span data-stu-id="a0d49-298">For pass-by-value reference parameters, normal reference widening is allowed (derived class to base class, and base class to interface type).</span></span> <span data-ttu-id="a0d49-299">但是，对于按引用传递的基元参数，类型必须完全匹配。</span><span class="sxs-lookup"><span data-stu-id="a0d49-299">However, for pass-by-reference primitive parameters, the types must match exactly.</span></span> <span data-ttu-id="a0d49-300">对于按引用传递引用参数，正常扩展仍适用。</span><span class="sxs-lookup"><span data-stu-id="a0d49-300">For pass-by-reference reference parameters, the normal widening still applies.</span></span>  
  
 <span data-ttu-id="a0d49-301">例如，如果此实例反射的方法被声明为 `public boolean Compare(String a, String b)`，则 `parameters` 应为长度为2的 `Objects` 的数组，因此 `parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-301">For example, if the method reflected by this instance is declared as `public boolean Compare(String a, String b)`, then `parameters` should be an array of `Objects` with length 2 such that `parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`.</span></span>  
  
 <span data-ttu-id="a0d49-302">如果当前方法的参数是值类型，并且 `null``parameters` 中的相应参数，则运行时将传递值类型的零初始化实例。</span><span class="sxs-lookup"><span data-stu-id="a0d49-302">If a parameter of the current method is a value type, and the corresponding argument in `parameters` is `null`, the runtime passes a zero-initialized instance of the value type.</span></span>  
  
 <span data-ttu-id="a0d49-303">反射在调用虚方法时使用动态方法查找。</span><span class="sxs-lookup"><span data-stu-id="a0d49-303">Reflection uses dynamic method lookup when invoking virtual methods.</span></span> <span data-ttu-id="a0d49-304">例如，假设类 B 从类 A 继承，并实现名为 M 的虚拟方法。现在假设有一个表示类 A 上的 M 的 `MethodInfo` 对象。如果使用 `Invoke` 方法在 B 类型的对象上调用 M，则反射将使用由类 B 提供的实现。即使类型 B 的对象强制转换为，也会使用类 B 提供的实现（请参阅下面的代码示例）。</span><span class="sxs-lookup"><span data-stu-id="a0d49-304">For example, suppose that class B inherits from class A and both implement a virtual method named M. Now suppose that you have a `MethodInfo` object that represents M on class A. If you use the `Invoke` method to invoke M on an object of type B, then reflection will use the implementation given by class B. Even if the object of type B is cast to A, the implementation given by class B is used (see code sample below).</span></span>  
  
 <span data-ttu-id="a0d49-305">另一方面，如果方法是非虚拟的，则反射将使用从中获取 `MethodInfo` 的类型提供的实现，而不考虑作为目标传递的对象的类型。</span><span class="sxs-lookup"><span data-stu-id="a0d49-305">On the other hand, if the method is non-virtual, then reflection will use the implementation given by the type from which the `MethodInfo` was obtained, regardless of the type of the object passed as the target.</span></span>  
  
 <span data-ttu-id="a0d49-306">对于完全受信任的代码，将忽略访问限制。</span><span class="sxs-lookup"><span data-stu-id="a0d49-306">Access restrictions are ignored for fully trusted code.</span></span> <span data-ttu-id="a0d49-307">也就是说，只要代码完全受信任，就可以通过反射访问和调用私有构造函数、方法、字段和属性。</span><span class="sxs-lookup"><span data-stu-id="a0d49-307">That is, private constructors, methods, fields, and properties can be accessed and invoked via reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="a0d49-308">如果调用的方法引发异常，`TargetInvocationException.GetException` 将返回异常。</span><span class="sxs-lookup"><span data-stu-id="a0d49-308">If the invoked method throws an exception, `TargetInvocationException.GetException` returns the exception.</span></span> <span data-ttu-id="a0d49-309">此实现引发 `NotSupportedException`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-309">This implementation throws a `NotSupportedException`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0d49-310">从 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]开始，此方法可用于访问非公共成员（如果已向调用方授予了 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 标记 <xref:System.Security.Permissions.ReflectionPermission>，以及非公共成员的授予集限制为调用方的授予集或其子集）。</span><span class="sxs-lookup"><span data-stu-id="a0d49-310">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="a0d49-311">（请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。）</span><span class="sxs-lookup"><span data-stu-id="a0d49-311">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="a0d49-312">若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="a0d49-312">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0d49-313">下面的示例演示使用 <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>的重载 <xref:System.Reflection.Binder?displayProperty=nameWithType> 类的所有成员。</span><span class="sxs-lookup"><span data-stu-id="a0d49-313">The following example demonstrates all members of the <xref:System.Reflection.Binder?displayProperty=nameWithType> class using an overload of <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a0d49-314">私有方法 `CanConvertFrom` 查找给定类型的兼容类型。</span><span class="sxs-lookup"><span data-stu-id="a0d49-314">The private method `CanConvertFrom` finds compatible types for a given type.</span></span> <span data-ttu-id="a0d49-315">有关在自定义绑定方案中调用成员的另一个示例，请参阅[动态加载和使用类型](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md)。</span><span class="sxs-lookup"><span data-stu-id="a0d49-315">For another example of invoking members in a custom binding scenario, see [Dynamically Loading and Using Types](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md).</span></span>  
  
 [!code-cpp[Binder_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Binder_1/CPP/binder.cpp#1)]
 [!code-csharp[Binder_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Binder_1/CS/binder.cs#1)]
 [!code-vb[Binder_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Binder_1/VB/binder.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="a0d49-316"><paramref name="obj" /> 参数为 <see langword="null" />，且此方法不是静态方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-316">The <paramref name="obj" /> parameter is <see langword="null" /> and the method is not static.</span></span>  
  
<span data-ttu-id="a0d49-317">- 或 -</span><span class="sxs-lookup"><span data-stu-id="a0d49-317">-or-</span></span> 
<span data-ttu-id="a0d49-318">该方法不由 <paramref name="obj" /> 的类声明或继承。</span><span class="sxs-lookup"><span data-stu-id="a0d49-318">The method is not declared or inherited by the class of <paramref name="obj" />.</span></span>  
  
<span data-ttu-id="a0d49-319">- 或 -</span><span class="sxs-lookup"><span data-stu-id="a0d49-319">-or-</span></span> 
<span data-ttu-id="a0d49-320">调用静态构造函数，<paramref name="obj" /> 既不是 <see langword="null" />，也不是声明构造函数的类的实例。</span><span class="sxs-lookup"><span data-stu-id="a0d49-320">A static constructor is invoked, and <paramref name="obj" /> is neither <see langword="null" /> nor an instance of the class that declared the constructor.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0d49-321"><paramref name="parameters" /> 参数的类型与此实例所反射的方法或构造函数的签名不匹配。</span><span class="sxs-lookup"><span data-stu-id="a0d49-321">The type of the <paramref name="parameters" /> parameter does not match the signature of the method or constructor reflected by this instance.</span></span></exception>
        <exception cref="T:System.Reflection.TargetParameterCountException"><span data-ttu-id="a0d49-322"><paramref name="parameters" /> 数组的参数数量不正确。</span><span class="sxs-lookup"><span data-stu-id="a0d49-322">The <paramref name="parameters" /> array does not have the correct number of arguments.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="a0d49-323">调用的方法或构造函数引发异常。</span><span class="sxs-lookup"><span data-stu-id="a0d49-323">The invoked method or constructor throws an exception.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="a0d49-324">调用方没有执行由当前实例表示的方法或构造函数的权限。</span><span class="sxs-lookup"><span data-stu-id="a0d49-324">The caller does not have permission to execute the method or constructor that is represented by the current instance.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a0d49-325">声明该方法的类型为开放式泛型类型。</span><span class="sxs-lookup"><span data-stu-id="a0d49-325">The type that declares the method is an open generic type.</span></span> <span data-ttu-id="a0d49-326">也就是说，<see cref="P:System.Type.ContainsGenericParameters" /> 属性为声明类型返回 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-326">That is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" /> for the declaring type.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="a0d49-327">当通过 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />的机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="a0d49-327">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="a0d49-328">关联的枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-328">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md"><span data-ttu-id="a0d49-329">动态加载和使用类型</span><span class="sxs-lookup"><span data-stu-id="a0d49-329">Dynamically Loading and Using Types</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Reflection.MethodBase.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-330">获取一个值，该值指示此方法是否为抽象方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-330">Gets a value indicating whether the method is abstract.</span></span></summary>
        <value><span data-ttu-id="a0d49-331">如果该方法是抽象的，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-331"><see langword="true" /> if the method is abstract; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-332">抽象成员是在基类上声明的，未提供实现。</span><span class="sxs-lookup"><span data-stu-id="a0d49-332">An abstract member is declared on a base class and has no implementation supplied.</span></span>  
  
 <span data-ttu-id="a0d49-333">若要获取 <xref:System.Reflection.MethodBase>，请先获取类型。</span><span class="sxs-lookup"><span data-stu-id="a0d49-333">To get the <xref:System.Reflection.MethodBase>, first get the type.</span></span> <span data-ttu-id="a0d49-334">从类型中获取方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-334">From the type, get the method.</span></span> <span data-ttu-id="a0d49-335">从方法获取 `MethodBase`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-335">From the method, get the `MethodBase`.</span></span> <span data-ttu-id="a0d49-336">如果 `MethodBase` 或构造函数不是公共的，则它是受保护的，无法轻松访问。</span><span class="sxs-lookup"><span data-stu-id="a0d49-336">If the `MethodBase` or constructor is other than public, it is protected and cannot be readily accessed.</span></span> <span data-ttu-id="a0d49-337">若要访问非公共方法，请在 `GetMethod`中将 <xref:System.Reflection.BindingFlags> 掩码设置为 `NonPublic`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-337">To access a non-public method, set the <xref:System.Reflection.BindingFlags> mask to `NonPublic` in `GetMethod`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0d49-338">下面的示例确定指定方法是否为抽象方法并显示结果。</span><span class="sxs-lookup"><span data-stu-id="a0d49-338">The following example determines whether specified the method is abstract and displays the result.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsAssembly">
      <MemberSignature Language="C#" Value="public bool IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAssembly : bool" Usage="System.Reflection.MethodBase.IsAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-339">获取一个值，该值指示此方法或构造函数的潜在可见性是否由 <see cref="F:System.Reflection.MethodAttributes.Assembly" /> 描述；也就是说，此方法或构造函数只对同一程序集中的其他类型可见，而对该程序集以外的派生类型则不可见。</span><span class="sxs-lookup"><span data-stu-id="a0d49-339">Gets a value indicating whether the potential visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.Assembly" />; that is, the method or constructor is visible at most to other types in the same assembly, and is not visible to derived types outside the assembly.</span></span></summary>
        <value><span data-ttu-id="a0d49-340">如果此方法或构造函数的可见性由 <see langword="true" /> 准确描述，则为 <see cref="F:System.Reflection.MethodAttributes.Assembly" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-340"><see langword="true" /> if the visibility of this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.Assembly" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-341">方法的实际可见性受到其类型的可见性的限制。</span><span class="sxs-lookup"><span data-stu-id="a0d49-341">The actual visibility of a method is limited by the visibility of its type.</span></span> <span data-ttu-id="a0d49-342"><xref:System.Reflection.MethodBase.IsAssembly%2A> 属性可能为方法 `true`，但如果它是私有嵌套类型的方法，则该方法在包含类型外不可见。</span><span class="sxs-lookup"><span data-stu-id="a0d49-342">The <xref:System.Reflection.MethodBase.IsAssembly%2A> property might be `true` for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</span></span>  
  
 <span data-ttu-id="a0d49-343">方法或构造函数的可见性由 <xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType> 完全描述（如果仅 `internal` 可见性修饰符）（`Friend` Visual Basic 中）。</span><span class="sxs-lookup"><span data-stu-id="a0d49-343">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType> if the only visibility modifier is `internal` (`Friend` in Visual Basic).</span></span> <span data-ttu-id="a0d49-344">此属性是在中C# `protected internal` 的方法 `false` （`Protected Friend` Visual Basic 中 `protected public` C++）;使用 <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> 属性来标识此类方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-344">This property is `false` for methods that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property to identify such methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0d49-345">下面的代码示例定义具有不同级别的可见性的方法，并显示其 <xref:System.Reflection.MethodBase.IsAssembly%2A>、<xref:System.Reflection.MethodBase.IsFamily%2A>、<xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>和 <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> 属性的值。</span><span class="sxs-lookup"><span data-stu-id="a0d49-345">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0d49-346">Visual Basic 和C#语言不能 <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> 可见性定义方法;此访问级别仅出现在C++示例中。</span><span class="sxs-lookup"><span data-stu-id="a0d49-346">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsConstructedGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericMethod { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericMethod : bool" Usage="System.Reflection.MethodBase.IsConstructedGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructor">
      <MemberSignature Language="C#" Value="public bool IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsConstructor" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsConstructor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsConstructor { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructor : bool" Usage="System.Reflection.MethodBase.IsConstructor" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsConstructor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-347">获取一个值，该值指示此方法是否为构造函数。</span><span class="sxs-lookup"><span data-stu-id="a0d49-347">Gets a value indicating whether the method is a constructor.</span></span></summary>
        <value><span data-ttu-id="a0d49-348">如果此方法是 <see langword="true" /> 对象（参见"备注"中有关 <see cref="T:System.Reflection.ConstructorInfo" /> 对象的说明）所表示的构造函数，则为 <see cref="T:System.Reflection.Emit.ConstructorBuilder" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-348"><see langword="true" /> if this method is a constructor represented by a <see cref="T:System.Reflection.ConstructorInfo" /> object (see note in Remarks about <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> objects); otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="a0d49-349"><xref:System.Reflection.MethodBase.IsConstructor%2A> 属性返回动态类型中 <xref:System.Reflection.Emit.ConstructorBuilder> 对象的 `false`，除非在定义该构造函数时，`attributes` 参数中包含 <xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType> 标志。</span><span class="sxs-lookup"><span data-stu-id="a0d49-349">The <xref:System.Reflection.MethodBase.IsConstructor%2A> property returns `false` for a <xref:System.Reflection.Emit.ConstructorBuilder> object in a dynamic type, unless the <xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType> flag was included in the `attributes` parameter when the constructor was defined.</span></span> <span data-ttu-id="a0d49-350">省略 <xref:System.Reflection.MethodAttributes.RTSpecialName> 标志不会影响发出的构造函数的正确性。</span><span class="sxs-lookup"><span data-stu-id="a0d49-350">Omitting the <xref:System.Reflection.MethodAttributes.RTSpecialName> flag does not affect the correctness of the emitted constructor.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsFamily">
      <MemberSignature Language="C#" Value="public bool IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFamily : bool" Usage="System.Reflection.MethodBase.IsFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-351">获取一个值，该值指示此方法或构造函数的可见性是否由 <see cref="F:System.Reflection.MethodAttributes.Family" /> 描述；也就是说，此方法或构造函数仅在其类和派生类内可见。</span><span class="sxs-lookup"><span data-stu-id="a0d49-351">Gets a value indicating whether the visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.Family" />; that is, the method or constructor is visible only within its class and derived classes.</span></span></summary>
        <value><span data-ttu-id="a0d49-352">如果对此方法或构造函数的访问由 <see langword="true" /> 准确描述，则为 <see cref="F:System.Reflection.MethodAttributes.Family" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-352"><see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.Family" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-353">如果仅 `protected`了可见性修饰符，则 <xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType> 完全描述方法或构造函数的可见性。</span><span class="sxs-lookup"><span data-stu-id="a0d49-353">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType> if the only visibility modifier is `protected`.</span></span> <span data-ttu-id="a0d49-354">此属性是在中C# `protected internal` 的方法 `false` （`Protected Friend` Visual Basic 中 `protected public` C++）;使用 <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> 属性来标识此类方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-354">This property is `false` for methods that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property to identify such methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0d49-355">下面的代码示例定义具有不同级别的可见性的方法，并显示其 <xref:System.Reflection.MethodBase.IsAssembly%2A>、<xref:System.Reflection.MethodBase.IsFamily%2A>、<xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>和 <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> 属性的值。</span><span class="sxs-lookup"><span data-stu-id="a0d49-355">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0d49-356">Visual Basic 和C#语言不能 <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> 可见性定义方法;此访问级别仅出现在C++示例中。</span><span class="sxs-lookup"><span data-stu-id="a0d49-356">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyAndAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyAndAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFamilyAndAssembly : bool" Usage="System.Reflection.MethodBase.IsFamilyAndAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-357">获取一个值，该值指示此方法或构造函数的可见性是否由 <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /> 描述；也就是说，此方法或构造函数可由派生类调用，但仅当这些派生类在同一程序集中时。</span><span class="sxs-lookup"><span data-stu-id="a0d49-357">Gets a value indicating whether the visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; that is, the method or constructor can be called by derived classes, but only if they are in the same assembly.</span></span></summary>
        <value><span data-ttu-id="a0d49-358">如果对此方法或构造函数的访问由 <see langword="true" /> 准确描述，则为 <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-358"><see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-359">如果可见性修饰符在中C++`protected private`，则 <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> 完全描述方法或构造函数的可见性。</span><span class="sxs-lookup"><span data-stu-id="a0d49-359">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> if the visibility modifier is `protected private` in C++.</span></span> <span data-ttu-id="a0d49-360">具有此可见性的方法不能在 Visual Basic C#或中定义。</span><span class="sxs-lookup"><span data-stu-id="a0d49-360">Methods with this visibility cannot be defined in Visual Basic or C#.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0d49-361">下面的代码示例定义具有不同级别的可见性的方法，并显示其 <xref:System.Reflection.MethodBase.IsAssembly%2A>、<xref:System.Reflection.MethodBase.IsFamily%2A>、<xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>和 <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> 属性的值。</span><span class="sxs-lookup"><span data-stu-id="a0d49-361">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0d49-362">Visual Basic 和C#语言不能 <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> 可见性定义方法;此访问级别仅出现在C++示例中。</span><span class="sxs-lookup"><span data-stu-id="a0d49-362">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyOrAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyOrAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFamilyOrAssembly : bool" Usage="System.Reflection.MethodBase.IsFamilyOrAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-363">获取一个值，该值指示此方法或构造函数的潜在可见性是否由 <see cref="F:System.Reflection.MethodAttributes.FamORAssem" /> 描述；也就是说，此方法或构造函数可由派生类（无论其位置如何）和同一程序集中的类调用。</span><span class="sxs-lookup"><span data-stu-id="a0d49-363">Gets a value indicating whether the potential visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; that is, the method or constructor can be called by derived classes wherever they are, and by classes in the same assembly.</span></span></summary>
        <value><span data-ttu-id="a0d49-364">如果对此方法或构造函数的访问由 <see langword="true" /> 准确描述，则为 <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-364"><see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-365">如果某个类型成员具有 <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> 可见性，则可以从派生类中的任何成员或同一程序集中的任何成员（而不是任何其他类型）调用该成员。</span><span class="sxs-lookup"><span data-stu-id="a0d49-365">If a type member has <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> visibility, it can be called from any member in a derived class or any member in the same assembly, but not from any other type.</span></span>  
  
 <span data-ttu-id="a0d49-366">方法的实际可见性受到其类型的可见性的限制。</span><span class="sxs-lookup"><span data-stu-id="a0d49-366">The actual visibility of a method is limited by the visibility of its type.</span></span> <span data-ttu-id="a0d49-367"><xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> 属性可能为方法 `true`，但如果它是私有嵌套类型的方法，则该方法在包含类型外不可见。</span><span class="sxs-lookup"><span data-stu-id="a0d49-367">The <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property might be `true` for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</span></span>  
  
 <span data-ttu-id="a0d49-368">如果可见性修饰符在中C# `protected internal` （`Protected Friend` Visual Basic 中 `protected public` C++），则 <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> 完全描述方法或构造函数的可见性。</span><span class="sxs-lookup"><span data-stu-id="a0d49-368">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> if the visibility modifier is `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0d49-369">下面的代码示例定义具有不同级别的可见性的方法，并显示其 <xref:System.Reflection.MethodBase.IsAssembly%2A>、<xref:System.Reflection.MethodBase.IsFamily%2A>、<xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>和 <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> 属性的值。</span><span class="sxs-lookup"><span data-stu-id="a0d49-369">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0d49-370">Visual Basic 和C#语言不能 <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> 可见性定义方法;此访问级别仅出现在C++示例中。</span><span class="sxs-lookup"><span data-stu-id="a0d49-370">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFinal">
      <MemberSignature Language="C#" Value="public bool IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFinal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFinal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFinal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFinal : bool" Usage="System.Reflection.MethodBase.IsFinal" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFinal</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-371">获取一个值，该值指示此方法是否为 <see langword="final" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-371">Gets a value indicating whether this method is <see langword="final" />.</span></span></summary>
        <value><span data-ttu-id="a0d49-372">如果方法为 <see langword="true" />，则为 <see langword="final" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-372"><see langword="true" /> if this method is <see langword="final" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-373">若要确定某个方法是否可重写，则没有足够的检查 <xref:System.Reflection.MethodBase.IsVirtual%2A> 是否 `true`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-373">To determine if a method is overridable, it is not sufficient to check that <xref:System.Reflection.MethodBase.IsVirtual%2A> is `true`.</span></span> <span data-ttu-id="a0d49-374">要使方法具有可重写的，必须 `true` `IsVirtual` 并且 `IsFinal` 必须 `false`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-374">For a method to be overridable, `IsVirtual` must be `true` and `IsFinal` must be `false`.</span></span> <span data-ttu-id="a0d49-375">例如，方法可能是非虚拟的，但它实现接口方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-375">For example, a method might be non-virtual, but it implements an interface method.</span></span> <span data-ttu-id="a0d49-376">公共语言运行时要求实现接口成员的所有方法都必须标记为 `virtual`;因此，编译器会将方法标记 `virtual final`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-376">The common language runtime requires that all methods that implement interface members must be marked as `virtual`; therefore, the compiler marks the method `virtual final`.</span></span> <span data-ttu-id="a0d49-377">在某些情况下，方法被标记为 `virtual` 但仍不可重写。</span><span class="sxs-lookup"><span data-stu-id="a0d49-377">So there are cases where a method is marked as `virtual` but is still not overridable.</span></span>  
  
 <span data-ttu-id="a0d49-378">若要确定某个方法是否可重写，请使用如下所示的代码：</span><span class="sxs-lookup"><span data-stu-id="a0d49-378">To establish with certainty whether a method is overridable, use code such as this:</span></span>  
  
 `if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)`  
  
 <span data-ttu-id="a0d49-379">如果 `IsVirtual` `false` 或 `IsFinal` `true`，则不能重写此方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-379">If `IsVirtual` is `false` or `IsFinal` is `true`, then the method cannot be overridden.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0d49-380">下面的示例显示 `IsFinal``false`，这可能会导致你认为 MyMethod 是可重写的。</span><span class="sxs-lookup"><span data-stu-id="a0d49-380">The following example displays `false` for `IsFinal`, which might lead you to think that MyMethod is overridable.</span></span> <span data-ttu-id="a0d49-381">即使 MyMethod 未标记为 `virtual`，代码也会打印 `false`，因此不能重写。</span><span class="sxs-lookup"><span data-stu-id="a0d49-381">The code prints `false` even though MyMethod is not marked `virtual` and thus cannot be overridden.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethod { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethod : bool" Usage="System.Reflection.MethodBase.IsGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-382">获取一个值，该值指示方法是否为泛型方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-382">Gets a value indicating whether the method is generic.</span></span></summary>
        <value><span data-ttu-id="a0d49-383">如果当前 <see langword="true" /> 表示泛型方法，则为 <see cref="T:System.Reflection.MethodBase" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-383"><see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> represents a generic method; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-384">使用 <xref:System.Reflection.MethodBase.IsGenericMethod%2A> 属性来确定当前 <xref:System.Reflection.MethodBase> 对象是否表示泛型方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-384">Use the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property to determine whether the current <xref:System.Reflection.MethodBase> object represents a generic method.</span></span> <span data-ttu-id="a0d49-385">使用 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 属性来确定当前 <xref:System.Reflection.MethodBase> 对象是表示开放构造方法还是封闭式构造方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-385">Use the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property to determine whether the current <xref:System.Reflection.MethodBase> object represents an open constructed method or a closed constructed method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0d49-386">默认情况下不支持泛型;如果未在派生类中重写，此属性将返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-386">Generics are not supported by default; this property returns `false` if not overridden in a derived class.</span></span> <span data-ttu-id="a0d49-387">.NET Framework 版本2.0 中不支持泛型构造函数，因此，如果当前实例的类型为 <xref:System.Reflection.ConstructorInfo>，则此属性将返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-387">Generic constructors are not supported in the .NET Framework version 2.0, so this property returns `false` if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
<span data-ttu-id="a0d49-388">下表汇总了特定于泛型方法的术语的固定条件。</span><span class="sxs-lookup"><span data-stu-id="a0d49-388">The following table summarizes the invariant conditions for terms specific to generic methods.</span></span> <span data-ttu-id="a0d49-389">有关泛型反射中使用的其他术语（如*泛型类型参数*和*泛型类型*），请参阅 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="a0d49-389">For other terms used in generic reflection, such as *generic type parameter* and *generic type*, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>   

|<span data-ttu-id="a0d49-390">术语</span><span class="sxs-lookup"><span data-stu-id="a0d49-390">Term</span></span>|<span data-ttu-id="a0d49-391">固定条件</span><span class="sxs-lookup"><span data-stu-id="a0d49-391">Invariant condition</span></span>| 
|---|---| 
|<span data-ttu-id="a0d49-392">泛型方法定义</span><span class="sxs-lookup"><span data-stu-id="a0d49-392">generic method definition</span></span>| <span data-ttu-id="a0d49-393"><xref:System.Reflection.MethodBase.IsGenericMethodDefinition> 属性为 `true`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-393">The <xref:System.Reflection.MethodBase.IsGenericMethodDefinition> property is `true`.</span></span> <br /><span data-ttu-id="a0d49-394">定义泛型方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-394">Defines a generic method.</span></span> <span data-ttu-id="a0d49-395">构造方法是通过对 <xref:System.Reflection.MethodInfo> 对象调用 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> 方法来创建的，该对象表示泛型方法定义，并指定一个类型参数数组。</span><span class="sxs-lookup"><span data-stu-id="a0d49-395">A constructed method is created by calling the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> method on a <xref:System.Reflection.MethodInfo> object that represents a generic method definition, and specifying an array of type arguments.</span></span> <br /><span data-ttu-id="a0d49-396">只能对泛型方法定义调用 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-396">The <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method can be called only on generic method definitions.</span></span> <br/><span data-ttu-id="a0d49-397">任何泛型方法定义都是泛型方法，但反之不成立。</span><span class="sxs-lookup"><span data-stu-id="a0d49-397">Any generic method definition is a generic method, but the converse is not true.</span></span>|    
|<span data-ttu-id="a0d49-398">Generic Method — 泛型方法</span><span class="sxs-lookup"><span data-stu-id="a0d49-398">generic method</span></span>|<span data-ttu-id="a0d49-399">`IsGenericMethod` 属性为 `true`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-399">The `IsGenericMethod` property is `true`.</span></span> <br/> <span data-ttu-id="a0d49-400">可以是泛型方法定义、开放构造方法或封闭式构造方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-400">Can be a generic method definition, an open constructed method, or a closed constructed method.</span></span>| 
|<span data-ttu-id="a0d49-401">开放式构造方法</span><span class="sxs-lookup"><span data-stu-id="a0d49-401">open constructed method</span></span>|<span data-ttu-id="a0d49-402"><xref:System.Reflection.MethodBase.ContainsGenericParameters> 属性为 `true`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-402">The <xref:System.Reflection.MethodBase.ContainsGenericParameters> property is `true`.</span></span> <br/><span data-ttu-id="a0d49-403">不能调用开放构造方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-403">It is not possible to invoke an open constructed method.</span></span>|  
|<span data-ttu-id="a0d49-404">封闭式构造方法</span><span class="sxs-lookup"><span data-stu-id="a0d49-404">closed constructed method</span></span>|<span data-ttu-id="a0d49-405"><xref:System.Reflection.MethodBase.ContainsGenericParameters> 属性为 `false`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-405">The <xref:System.Reflection.MethodBase.ContainsGenericParameters> property is `false`.</span></span> <br/><span data-ttu-id="a0d49-406">递归检查时，该方法没有未分配的泛型参数。</span><span class="sxs-lookup"><span data-stu-id="a0d49-406">When examined recursively, the method has no unassigned generic parameters.</span></span> <span data-ttu-id="a0d49-407">包含类型没有泛型类型参数，任何类型参数都没有泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="a0d49-407">The containing type has no generic type parameters, and none of the type arguments have generic type parameters.</span></span> <br/><span data-ttu-id="a0d49-408">可以调用方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-408">The method can be invoked.</span></span>|   

 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodDefinition : bool" Usage="System.Reflection.MethodBase.IsGenericMethodDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-409">获取一个值，该值指示方法是否为泛型方法定义。</span><span class="sxs-lookup"><span data-stu-id="a0d49-409">Gets a value indicating whether the method is a generic method definition.</span></span></summary>
        <value><span data-ttu-id="a0d49-410">如果当前 <see langword="true" /> 对象表示泛型方法的定义，则为 <see cref="T:System.Reflection.MethodBase" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-410"><see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> object represents the definition of a generic method; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-411">如果当前 <xref:System.Reflection.MethodBase> 表示泛型方法定义，则：</span><span class="sxs-lookup"><span data-stu-id="a0d49-411">If the current <xref:System.Reflection.MethodBase> represents a generic method definition, then:</span></span>  
  
-   <span data-ttu-id="a0d49-412"><xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> 属性为 `true`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-412">The <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> property is `true`.</span></span>  
  
-   <span data-ttu-id="a0d49-413">对于 <xref:System.Reflection.MethodBase.GetGenericArguments%2A> 方法返回的数组中的每个 <xref:System.Type> 对象：</span><span class="sxs-lookup"><span data-stu-id="a0d49-413">For each <xref:System.Type> object in the array returned by the <xref:System.Reflection.MethodBase.GetGenericArguments%2A> method:</span></span>  
  
    -   <span data-ttu-id="a0d49-414"><xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType> 属性为 `true`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-414">The <xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType> property is `true`.</span></span>  
  
    -   <span data-ttu-id="a0d49-415"><xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType> 属性返回当前实例。</span><span class="sxs-lookup"><span data-stu-id="a0d49-415">The <xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType> property returns the current instance.</span></span>  
  
    -   <span data-ttu-id="a0d49-416"><xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType> 属性与 <xref:System.Type> 对象在数组中的位置相同。</span><span class="sxs-lookup"><span data-stu-id="a0d49-416">The <xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType> property is the same as the position of the <xref:System.Type> object in the array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0d49-417">默认情况下不支持泛型;如果未在派生类中重写，此属性将返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-417">Generics are not supported by default; this property returns `false` if not overridden in a derived class.</span></span> <span data-ttu-id="a0d49-418">.NET Framework 版本2.0 中不支持泛型构造函数，因此，如果当前实例的类型为 <xref:System.Reflection.ConstructorInfo>，则此属性将返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-418">Generic constructors are not supported in the .NET Framework version 2.0, so this property returns `false` if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 <span data-ttu-id="a0d49-419">有关特定于泛型方法的术语的固定条件列表，请参阅 <xref:System.Reflection.MethodBase.IsGenericMethod%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="a0d49-419">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="a0d49-420">有关泛型反射中使用的其他术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="a0d49-420">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsHideBySig">
      <MemberSignature Language="C#" Value="public bool IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsHideBySig" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHideBySig As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHideBySig { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHideBySig : bool" Usage="System.Reflection.MethodBase.IsHideBySig" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsHideBySig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-421">获取一个值，该值指示是否只有一个签名完全相同的同一种类的成员在派生类中是隐藏的。</span><span class="sxs-lookup"><span data-stu-id="a0d49-421">Gets a value indicating whether only a member of the same kind with exactly the same signature is hidden in the derived class.</span></span></summary>
        <value><span data-ttu-id="a0d49-422">如果此成员被签名隐藏，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-422"><see langword="true" /> if the member is hidden by signature; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-423">当使用C# `new` 修饰符或 Visual Basic `Shadows` 修饰符声明派生类中的成员时，它可以隐藏基类中具有相同名称的成员。</span><span class="sxs-lookup"><span data-stu-id="a0d49-423">When a member in a derived class is declared with the C# `new` modifier or the Visual Basic `Shadows` modifier, it can hide a member of the same name in the base class.</span></span> <span data-ttu-id="a0d49-424">C#按签名隐藏基类成员。</span><span class="sxs-lookup"><span data-stu-id="a0d49-424">C# hides base class members by signature.</span></span> <span data-ttu-id="a0d49-425">也就是说，如果基类成员具有多个重载，则只隐藏一个具有相同签名的重载。</span><span class="sxs-lookup"><span data-stu-id="a0d49-425">That is, if the base class member has multiple overloads, the only one that is hidden is the one that has the identical signature.</span></span> <span data-ttu-id="a0d49-426">与此相反，Visual Basic 隐藏了所有基类重载。</span><span class="sxs-lookup"><span data-stu-id="a0d49-426">By contrast, Visual Basic hides all the base class overloads.</span></span> <span data-ttu-id="a0d49-427">因此，<xref:System.Reflection.MethodBase.IsHideBySig%2A> 在使用 Visual Basic `Shadows` 修饰符声明的成员上返回 `false`，并在使用C# `true` 修饰符声明的成员上 `new`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-427">Thus, <xref:System.Reflection.MethodBase.IsHideBySig%2A> returns `false` on a member declared with the Visual Basic `Shadows` modifier, and `true` on a member declared with the C# `new` modifier.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="a0d49-428">此属性不确定方法是否具有 <xref:System.Reflection.MethodAttributes.NewSlot> 特性。</span><span class="sxs-lookup"><span data-stu-id="a0d49-428">This property does not determine whether a method has the <xref:System.Reflection.MethodAttributes.NewSlot> attribute.</span></span> <span data-ttu-id="a0d49-429">使用 `new` 或 `Shadows` 修饰符声明的方法将具有 <xref:System.Reflection.MethodAttributes.NewSlot> 特性，但仅使用 `new` （即，仅C#方法）声明的方法将 <xref:System.Reflection.MethodBase.IsHideBySig%2A> 属性设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-429">A method that is declared with either the `new` or the `Shadows` modifier will have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, but only methods declared with `new` (that is, only C# methods) will have the <xref:System.Reflection.MethodBase.IsHideBySig%2A> property set to `true`.</span></span>  <span data-ttu-id="a0d49-430">若要确定某个方法是否具有 <xref:System.Reflection.MethodAttributes.NewSlot> 特性，请使用与以下代码类似的代码： C#中的 `if ((myMethodInfo.Attributes & MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)` 或 Visual Basic 中的 `If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-430">To determine whether a method has the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, use code similar to the following: `if ((myMethodInfo.Attributes & MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)` in C# or `If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot` in Visual Basic.</span></span> <span data-ttu-id="a0d49-431">但请注意，尽管使用 `new` 或 `Shadows` 声明的所有方法都具有 <xref:System.Reflection.MethodAttributes.NewSlot> 属性，但并不是使用 `new` 或 `Shadows`声明所有具有 <xref:System.Reflection.MethodAttributes.NewSlot> 特性的方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-431">Note, however, that although all methods declared with `new` or `Shadows` have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, not all methods that have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute are declared with `new` or `Shadows`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0d49-432">下面的代码示例包含一个具有重载方法的基类和一个隐藏其中一个重载的派生类。</span><span class="sxs-lookup"><span data-stu-id="a0d49-432">The following code example contains a base class with an overloaded method, and a derived class that hides one of the overloads.</span></span> <span data-ttu-id="a0d49-433">在代码示例的 Visual Basic 版本中，<xref:System.Reflection.MethodBase.IsHideBySig%2A> 属性为派生类中的成员返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-433">In the Visual Basic version of the code example, the <xref:System.Reflection.MethodBase.IsHideBySig%2A> property returns `false` for the member in the derived class.</span></span> <span data-ttu-id="a0d49-434">在代码C#示例的版本中，属性为派生类中的成员返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-434">In the C# version of the code sample, the property returns `true` for the member in the derived class.</span></span>  
  
 [!code-cpp[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/cpp/hide.cpp#1)]
 [!code-csharp[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/CS/hide.cs#1)]
 [!code-vb[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/VB/hide.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrivate">
      <MemberSignature Language="C#" Value="public bool IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrivate : bool" Usage="System.Reflection.MethodBase.IsPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-435">获取一个值，该值指示此成员是否是私有的。</span><span class="sxs-lookup"><span data-stu-id="a0d49-435">Gets a value indicating whether this member is private.</span></span></summary>
        <value><span data-ttu-id="a0d49-436">如果对此方法的访问只限于该类本身的其他成员，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-436"><see langword="true" /> if access to this method is restricted to other members of the class itself; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-437">如果某个类型成员具有 `Private` 的级别可见性，则可以从同一类中的任何成员进行调用，而不能从其他任何成员进行调用。</span><span class="sxs-lookup"><span data-stu-id="a0d49-437">If a type member has `Private` level visibility, it can be called from any member in the same class and no others.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Reflection.MethodBase.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-438">获取一个值，该值指示这是否是一个公共方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-438">Gets a value indicating whether this is a public method.</span></span></summary>
        <value><span data-ttu-id="a0d49-439">如果此方法是公共的，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-439"><see langword="true" /> if this method is public; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-440">若要获取 <xref:System.Reflection.MethodBase>，请先获取类型。</span><span class="sxs-lookup"><span data-stu-id="a0d49-440">To get the <xref:System.Reflection.MethodBase>, first get the type.</span></span> <span data-ttu-id="a0d49-441">从类型中获取方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-441">From the type, get the method.</span></span> <span data-ttu-id="a0d49-442">从方法获取 `MethodBase`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-442">From the method, get the `MethodBase`.</span></span> <span data-ttu-id="a0d49-443">如果 `MethodBase` 或构造函数不是公共的，则它是受保护的，无法轻松访问。</span><span class="sxs-lookup"><span data-stu-id="a0d49-443">If the `MethodBase` or constructor is other than public, it is protected and cannot be readily accessed.</span></span> <span data-ttu-id="a0d49-444">若要访问非公共方法，请在 `GetMethod`中将 <xref:System.Reflection.BindingFlags> 掩码设置为 `NonPublic`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-444">To access a non-public method, set the <xref:System.Reflection.BindingFlags> mask to `NonPublic` in `GetMethod`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0d49-445">下面的示例使用 <xref:System.Reflection.MethodBase.IsPublic%2A> 属性来显示指示指定方法是否为公共方法的消息。</span><span class="sxs-lookup"><span data-stu-id="a0d49-445">The following example uses the <xref:System.Reflection.MethodBase.IsPublic%2A> property to display a message that indicates whether the specified method is public.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.MethodBase.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-446">获取一个值，该值指示当前方法或构造函数在当前信任级别上是安全关键的还是安全可靠关键的，因此可以执行关键操作。</span><span class="sxs-lookup"><span data-stu-id="a0d49-446">Gets a value that indicates whether the current method or constructor is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</span></span></summary>
        <value><span data-ttu-id="a0d49-447">如果当前方法或构造函数在当前信任级别上是安全关键的或安全可靠关键的，则为 <see langword="true" />；如果它是透明的，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-447"><see langword="true" /> if the current method or constructor is security-critical or security-safe-critical at the current trust level; <see langword="false" /> if it is transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-448"><xref:System.Reflection.MethodBase.IsSecurityCritical%2A>、<xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>和 <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> 属性按公共语言运行时（CLR）的确定，在其当前信任级别报告方法或构造函数的透明度级别。</span><span class="sxs-lookup"><span data-stu-id="a0d49-448">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="a0d49-449">下表显示了这些属性的组合：</span><span class="sxs-lookup"><span data-stu-id="a0d49-449">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="a0d49-450">安全级别</span><span class="sxs-lookup"><span data-stu-id="a0d49-450">Security level</span></span>|<span data-ttu-id="a0d49-451">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="a0d49-451">IsSecurityCritical</span></span>|<span data-ttu-id="a0d49-452">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="a0d49-452">IsSecuritySafeCritical</span></span>|<span data-ttu-id="a0d49-453">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="a0d49-453">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="a0d49-454">严重</span><span class="sxs-lookup"><span data-stu-id="a0d49-454">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="a0d49-455">安全关键</span><span class="sxs-lookup"><span data-stu-id="a0d49-455">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="a0d49-456">透明</span><span class="sxs-lookup"><span data-stu-id="a0d49-456">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="a0d49-457">使用这些属性比检查程序集及其类型和成员的安全批注、检查当前的信任级别以及尝试复制运行时的规则要简单得多。</span><span class="sxs-lookup"><span data-stu-id="a0d49-457">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0d49-458">对于部分信任的程序集，此属性的值取决于程序集的当前信任级别。</span><span class="sxs-lookup"><span data-stu-id="a0d49-458">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="a0d49-459">如果将程序集加载到部分受信任的应用程序域中（例如，在沙盒应用程序域中），则运行时将忽略程序集的安全注释。</span><span class="sxs-lookup"><span data-stu-id="a0d49-459">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="a0d49-460">程序集及其所有类型都被视为透明。</span><span class="sxs-lookup"><span data-stu-id="a0d49-460">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="a0d49-461">仅当程序集加载到完全受信任的应用程序域中时（例如，在桌面应用程序的默认应用程序域中），运行时才会注意到部分信任程序集的安全注释。</span><span class="sxs-lookup"><span data-stu-id="a0d49-461">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="a0d49-462">相反，受信任的程序集（即安装在全局程序集缓存中的强名称程序集）始终以完全信任方式加载，而不考虑应用程序域的信任级别，因此，其当前信任级别始终是完全受信任的。</span><span class="sxs-lookup"><span data-stu-id="a0d49-462">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="a0d49-463">您可以使用 "<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>" 和 "<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>" 属性来确定程序集和应用程序域的当前信任级别。</span><span class="sxs-lookup"><span data-stu-id="a0d49-463">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="a0d49-464">有关反射和透明度的详细信息，请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。</span><span class="sxs-lookup"><span data-stu-id="a0d49-464">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="a0d49-465">有关透明度的信息，请参阅[安全更改](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="a0d49-465">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="a0d49-466">反射的安全注意事项</span><span class="sxs-lookup"><span data-stu-id="a0d49-466">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="a0d49-467">.NET Framework 4.0 版中的安全性更改</span><span class="sxs-lookup"><span data-stu-id="a0d49-467">Security Changes in the .NET Framework Version 4.0</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.MethodBase.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-468">获取一个值，该值指示当前方法或构造函数在当前信任级别上是安全可靠关键的；即它是否可以执行关键操作并可以由透明代码访问。</span><span class="sxs-lookup"><span data-stu-id="a0d49-468">Gets a value that indicates whether the current method or constructor is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</span></span></summary>
        <value><span data-ttu-id="a0d49-469">如果方法或构造函数在当前信任级别上是安全可靠关键的，则为 <see langword="true" />；如果它是安全关键的或透明的，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-469"><see langword="true" /> if the method or constructor is security-safe-critical at the current trust level; <see langword="false" /> if it is security-critical or transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-470"><xref:System.Reflection.MethodBase.IsSecurityCritical%2A>、<xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>和 <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> 属性按公共语言运行时（CLR）的确定，在其当前信任级别报告方法或构造函数的透明度级别。</span><span class="sxs-lookup"><span data-stu-id="a0d49-470">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="a0d49-471">下表显示了这些属性的组合：</span><span class="sxs-lookup"><span data-stu-id="a0d49-471">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="a0d49-472">安全级别</span><span class="sxs-lookup"><span data-stu-id="a0d49-472">Security level</span></span>|<span data-ttu-id="a0d49-473">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="a0d49-473">IsSecurityCritical</span></span>|<span data-ttu-id="a0d49-474">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="a0d49-474">IsSecuritySafeCritical</span></span>|<span data-ttu-id="a0d49-475">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="a0d49-475">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="a0d49-476">严重</span><span class="sxs-lookup"><span data-stu-id="a0d49-476">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="a0d49-477">安全关键</span><span class="sxs-lookup"><span data-stu-id="a0d49-477">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="a0d49-478">透明</span><span class="sxs-lookup"><span data-stu-id="a0d49-478">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="a0d49-479">使用这些属性比检查程序集及其类型和成员的安全批注、检查当前的信任级别以及尝试复制运行时的规则要简单得多。</span><span class="sxs-lookup"><span data-stu-id="a0d49-479">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0d49-480">对于部分信任的程序集，此属性的值取决于程序集的当前信任级别。</span><span class="sxs-lookup"><span data-stu-id="a0d49-480">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="a0d49-481">如果将程序集加载到部分受信任的应用程序域中（例如，在沙盒应用程序域中），则运行时将忽略程序集的安全注释。</span><span class="sxs-lookup"><span data-stu-id="a0d49-481">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="a0d49-482">程序集及其所有类型都被视为透明。</span><span class="sxs-lookup"><span data-stu-id="a0d49-482">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="a0d49-483">仅当程序集加载到完全受信任的应用程序域中时（例如，在桌面应用程序的默认应用程序域中），运行时才会注意到部分信任程序集的安全注释。</span><span class="sxs-lookup"><span data-stu-id="a0d49-483">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="a0d49-484">相反，受信任的程序集（即安装在全局程序集缓存中的强名称程序集）始终以完全信任方式加载，而不考虑应用程序域的信任级别，因此，其当前信任级别始终是完全受信任的。</span><span class="sxs-lookup"><span data-stu-id="a0d49-484">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="a0d49-485">您可以使用 "<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>" 和 "<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>" 属性来确定程序集和应用程序域的当前信任级别。</span><span class="sxs-lookup"><span data-stu-id="a0d49-485">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="a0d49-486">有关反射和透明度的详细信息，请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。</span><span class="sxs-lookup"><span data-stu-id="a0d49-486">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="a0d49-487">有关透明度的信息，请参阅[安全更改](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="a0d49-487">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="a0d49-488">反射的安全注意事项</span><span class="sxs-lookup"><span data-stu-id="a0d49-488">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="a0d49-489">.NET Framework 4.0 版中的安全性更改</span><span class="sxs-lookup"><span data-stu-id="a0d49-489">Security Changes in the .NET Framework Version 4.0</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.MethodBase.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-490">获取一个值，该值指示当前方法或构造函数在当前信任级别上是透明的，因此无法执行关键操作。</span><span class="sxs-lookup"><span data-stu-id="a0d49-490">Gets a value that indicates whether the current method or constructor is transparent at the current trust level, and therefore cannot perform critical operations.</span></span></summary>
        <value><span data-ttu-id="a0d49-491">如果方法或构造函数在当前信任级别上是安全透明的，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-491"><see langword="true" /> if the method or constructor is security-transparent at the current trust level; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-492">如果此属性返回 `true`，则 <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> 和 <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> 属性返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-492">If this property returns `true`, the <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> and <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> properties return `false`.</span></span>  
  
 <span data-ttu-id="a0d49-493"><xref:System.Reflection.MethodBase.IsSecurityCritical%2A>、<xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>和 <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> 属性按公共语言运行时（CLR）的确定，在其当前信任级别报告方法或构造函数的透明度级别。</span><span class="sxs-lookup"><span data-stu-id="a0d49-493">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="a0d49-494">使用这些属性比检查程序集及其类型和成员的安全批注、检查当前的信任级别以及尝试复制运行时的规则要简单得多。</span><span class="sxs-lookup"><span data-stu-id="a0d49-494">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0d49-495">对于部分信任的程序集，此属性的值取决于程序集的当前信任级别。</span><span class="sxs-lookup"><span data-stu-id="a0d49-495">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="a0d49-496">如果将程序集加载到部分受信任的应用程序域中（例如，在沙盒应用程序域中），则运行时将忽略程序集的安全注释。</span><span class="sxs-lookup"><span data-stu-id="a0d49-496">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="a0d49-497">程序集及其所有类型都被视为透明。</span><span class="sxs-lookup"><span data-stu-id="a0d49-497">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="a0d49-498">仅当程序集加载到完全受信任的应用程序域中时（例如，在桌面应用程序的默认应用程序域中），运行时才会注意到部分信任程序集的安全注释。</span><span class="sxs-lookup"><span data-stu-id="a0d49-498">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="a0d49-499">相反，受信任的程序集（即安装在全局程序集缓存中的强名称程序集）始终以完全信任方式加载，而不考虑应用程序域的信任级别，因此，其当前信任级别始终是完全受信任的。</span><span class="sxs-lookup"><span data-stu-id="a0d49-499">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="a0d49-500">您可以使用 "<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>" 和 "<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>" 属性来确定程序集和应用程序域的当前信任级别。</span><span class="sxs-lookup"><span data-stu-id="a0d49-500">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="a0d49-501">有关反射和透明度的详细信息，请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。</span><span class="sxs-lookup"><span data-stu-id="a0d49-501">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="a0d49-502">有关透明度的信息，请参阅[安全更改](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="a0d49-502">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="a0d49-503">反射的安全注意事项</span><span class="sxs-lookup"><span data-stu-id="a0d49-503">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="a0d49-504">.NET Framework 4.0 版中的安全性更改</span><span class="sxs-lookup"><span data-stu-id="a0d49-504">Security Changes in the .NET Framework Version 4.0</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Reflection.MethodBase.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-505">获取一个值，该值指示此方法是否具有特殊名称。</span><span class="sxs-lookup"><span data-stu-id="a0d49-505">Gets a value indicating whether this method has a special name.</span></span></summary>
        <value><span data-ttu-id="a0d49-506">如果此方法具有特殊名称，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-506"><see langword="true" /> if this method has a special name; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-507">将 <xref:System.Reflection.MethodAttributes.SpecialName> 位设置为标记某些编译器以特殊方式处理的成员（如属性访问器和运算符重载方法）。</span><span class="sxs-lookup"><span data-stu-id="a0d49-507">The <xref:System.Reflection.MethodAttributes.SpecialName> bit is set to flag members that are treated in a special way by some compilers (such as property accessors and operator overloading methods).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0d49-508">此示例演示如何使用 <xref:System.Reflection.MethodBase.IsSpecialName%2A> 筛选出列表中的内部或私有成员。</span><span class="sxs-lookup"><span data-stu-id="a0d49-508">This example shows a use of <xref:System.Reflection.MethodBase.IsSpecialName%2A> to filter internal or private members out of a list.</span></span>  
  
 [!code-cpp[Classic Type.IsSpecialName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsSpecialName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsSpecialName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsStatic">
      <MemberSignature Language="C#" Value="public bool IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsStatic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStatic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStatic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStatic : bool" Usage="System.Reflection.MethodBase.IsStatic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-509">获取一个值，该值指示方法是否为 <see langword="static" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-509">Gets a value indicating whether the method is <see langword="static" />.</span></span></summary>
        <value><span data-ttu-id="a0d49-510">如果方法为 <see langword="true" />，则为 <see langword="static" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-510"><see langword="true" /> if this method is <see langword="static" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-511">静态成员不能隐式引用类中的实例数据。</span><span class="sxs-lookup"><span data-stu-id="a0d49-511">A static member cannot implicitly reference instance data in a class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsVirtual">
      <MemberSignature Language="C#" Value="public bool IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsVirtual" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVirtual As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVirtual { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVirtual : bool" Usage="System.Reflection.MethodBase.IsVirtual" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsVirtual</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-512">获取一个值，该值指示方法是否为 <see langword="virtual" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-512">Gets a value indicating whether the method is <see langword="virtual" />.</span></span></summary>
        <value><span data-ttu-id="a0d49-513">如果方法为 <see langword="true" />，则为 <see langword="virtual" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-513"><see langword="true" /> if this method is <see langword="virtual" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-514">虚拟成员可以引用类中的实例数据，并且必须通过类的实例进行引用。</span><span class="sxs-lookup"><span data-stu-id="a0d49-514">A virtual member may reference instance data in a class and must be referenced through an instance of the class.</span></span>  
  
 <span data-ttu-id="a0d49-515">若要确定某个方法是否可重写，则没有足够的检查 `IsVirtual` 是否 `true`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-515">To determine if a method is overridable, it is not sufficient to check that `IsVirtual` is `true`.</span></span> <span data-ttu-id="a0d49-516">要使方法具有可重写的，必须 `true` `IsVirtual` 并且 <xref:System.Reflection.MethodBase.IsFinal%2A> 必须 `false`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-516">For a method to be overridable, `IsVirtual` must be `true` and <xref:System.Reflection.MethodBase.IsFinal%2A> must be `false`.</span></span> <span data-ttu-id="a0d49-517">例如，方法可能是非虚拟的，但它实现接口方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-517">For example, a method might be non-virtual, but it implements an interface method.</span></span> <span data-ttu-id="a0d49-518">公共语言运行时要求实现接口成员的所有方法都必须标记为 `virtual`;因此，编译器会将方法标记 `virtual final`。</span><span class="sxs-lookup"><span data-stu-id="a0d49-518">The common language runtime requires that all methods that implement interface members must be marked as `virtual`; therefore, the compiler marks the method `virtual final`.</span></span> <span data-ttu-id="a0d49-519">在某些情况下，方法被标记为 `virtual` 但仍不可重写。</span><span class="sxs-lookup"><span data-stu-id="a0d49-519">So there are cases where a method is marked as `virtual` but is still not overridable.</span></span>  
  
 <span data-ttu-id="a0d49-520">若要确定某个方法是否可重写，请使用如下所示的代码：</span><span class="sxs-lookup"><span data-stu-id="a0d49-520">To establish with certainty whether a method is overridable, use code such as this:</span></span>  
  
```csharp  
if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)  
```  
  
```vb  
If MethodInfo.IsVirtual AndAlso Not MethodInfo.IsFinal Then  
```  
  
 <span data-ttu-id="a0d49-521">如果 `IsVirtual` `false` 或 `IsFinal` `true`，则不能重写此方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-521">If `IsVirtual` is `false` or `IsFinal` is `true`, then the method cannot be overridden.</span></span>  
  
 <span data-ttu-id="a0d49-522">您可以通过调用 <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType> 方法来确定当前方法是否重写基类中的方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-522">You can determine whether the current method overrides a method in a base class by calling the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="a0d49-523">下面的示例实现了一个执行此的 `IsOverride` 方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-523">The following example implements an `IsOverride` method that does this.</span></span>  
  
 [!code-csharp[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/cs/IsOverride1.cs#2)]
 [!code-vb[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/vb/IsOverride1.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="a0d49-524">下面的示例显示了 `IsFinal``false`，这可能会导致你认为 `MyMethod` 是可重写的。</span><span class="sxs-lookup"><span data-stu-id="a0d49-524">The following example displays `false` for `IsFinal`, which might lead you to think that `MyMethod` is overridable.</span></span> <span data-ttu-id="a0d49-525">即使 `MyMethod` 未标记为 `virtual`，代码仍 `false` 打印，因此不能重写。</span><span class="sxs-lookup"><span data-stu-id="a0d49-525">The code prints `false` even though `MyMethod` is not marked `virtual` and thus cannot be overridden.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public abstract RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.MethodBase.MethodHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.MethodHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-526">获取方法的内部元数据表示形式的句柄。</span><span class="sxs-lookup"><span data-stu-id="a0d49-526">Gets a handle to the internal metadata representation of a method.</span></span></summary>
        <value><span data-ttu-id="a0d49-527">一个 <see cref="T:System.RuntimeMethodHandle" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="a0d49-527">A <see cref="T:System.RuntimeMethodHandle" /> object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-528">句柄仅在获取它们的应用程序域中有效。</span><span class="sxs-lookup"><span data-stu-id="a0d49-528">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property MethodImplementationFlags As MethodImplAttributes" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.MethodBase.MethodImplementationFlags" />
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MethodImplementationFlags As MethodImplAttributes" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-529">获取指定方法实现特性的 <see cref="T:System.Reflection.MethodImplAttributes" /> 标志。</span><span class="sxs-lookup"><span data-stu-id="a0d49-529">Gets the <see cref="T:System.Reflection.MethodImplAttributes" /> flags that specify the attributes of a method implementation.</span></span></summary>
        <value><span data-ttu-id="a0d49-530">方法实现标志。</span><span class="sxs-lookup"><span data-stu-id="a0d49-530">The method implementation flags.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-531">有关更多信息，请参阅 <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="a0d49-531">See the <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> method for more information.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As MethodBase, right As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::MethodBase ^ left, System::Reflection::MethodBase ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.MethodBase * System.Reflection.MethodBase -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a0d49-532">要比较的第一个对象。</span><span class="sxs-lookup"><span data-stu-id="a0d49-532">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="a0d49-533">要比较的第二个对象。</span><span class="sxs-lookup"><span data-stu-id="a0d49-533">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="a0d49-534">指示两个 <see cref="T:System.Reflection.MethodBase" /> 对象是否相等。</span><span class="sxs-lookup"><span data-stu-id="a0d49-534">Indicates whether two <see cref="T:System.Reflection.MethodBase" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="a0d49-535">如果 <see langword="true" /> 等于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-535"><see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As MethodBase, right As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::MethodBase ^ left, System::Reflection::MethodBase ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.MethodBase * System.Reflection.MethodBase -&gt; bool" Usage="System.Reflection.MethodBase.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="a0d49-536">要比较的第一个对象。</span><span class="sxs-lookup"><span data-stu-id="a0d49-536">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="a0d49-537">要比较的第二个对象。</span><span class="sxs-lookup"><span data-stu-id="a0d49-537">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="a0d49-538">指示两个 <see cref="T:System.Reflection.MethodBase" /> 对象是否不相等。</span><span class="sxs-lookup"><span data-stu-id="a0d49-538">Indicates whether two <see cref="T:System.Reflection.MethodBase" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="a0d49-539">如果 <see langword="true" /> 不等于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-539"><see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodBase.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodBase.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodBase::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="a0d49-540">留待将来使用。</span><span class="sxs-lookup"><span data-stu-id="a0d49-540">Reserved for future use.</span></span> <span data-ttu-id="a0d49-541">必须为 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="a0d49-541">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="a0d49-542">要映射的名称的传入数组。</span><span class="sxs-lookup"><span data-stu-id="a0d49-542">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="a0d49-543">要映射的名称的计数。</span><span class="sxs-lookup"><span data-stu-id="a0d49-543">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="a0d49-544">要在其中解释名称的区域设置上下文。</span><span class="sxs-lookup"><span data-stu-id="a0d49-544">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="a0d49-545">调用方分配的数组，用于接收与名称对应的 ID。</span><span class="sxs-lookup"><span data-stu-id="a0d49-545">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="a0d49-546">将一组名称映射为对应的一组调度标识符。</span><span class="sxs-lookup"><span data-stu-id="a0d49-546">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-547">此方法用于从非托管代码访问托管类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="a0d49-547">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="a0d49-548">有关 `IDispatch::GetIDsOfNames`的详细信息，请参阅 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="a0d49-548">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="a0d49-549">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="a0d49-549">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetType">
      <MemberSignature Language="C#" Value="Type _MethodBase.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._MethodBase.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _MethodBase.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._MethodBase.GetType() = System::Runtime::InteropServices::_MethodBase::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a0d49-550">有关此成员的说明，请参阅 <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-550">For a description of this member, see <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span></span></summary>
        <returns><span data-ttu-id="a0d49-551">有关此成员的说明，请参阅 <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-551">For a description of this member, see <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-552">此成员是显式接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="a0d49-552">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="a0d49-553">它只能在 <xref:System.Reflection.MethodBase> 实例被强制转换为 <xref:System.Runtime.InteropServices._MethodBase> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="a0d49-553">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodBase.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodBase::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="a0d49-554">要返回的类型信息。</span><span class="sxs-lookup"><span data-stu-id="a0d49-554">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="a0d49-555">类型信息的区域设置标识符。</span><span class="sxs-lookup"><span data-stu-id="a0d49-555">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="a0d49-556">接收一个指针，指向请求的类型信息对象。</span><span class="sxs-lookup"><span data-stu-id="a0d49-556">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="a0d49-557">检索对象的类型信息，然后可以使用该信息获取接口的类型信息。</span><span class="sxs-lookup"><span data-stu-id="a0d49-557">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-558">此方法用于从非托管代码访问托管类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="a0d49-558">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="a0d49-559">有关 `IDispatch::GetTypeInfo`的详细信息，请参阅 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="a0d49-559">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="a0d49-560">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="a0d49-560">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodBase.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodBase::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="a0d49-561">指向一个位置，该位置接收对象提供的类型信息接口的数量。</span><span class="sxs-lookup"><span data-stu-id="a0d49-561">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="a0d49-562">检索对象提供的类型信息接口的数量（0 或 1）。</span><span class="sxs-lookup"><span data-stu-id="a0d49-562">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-563">此方法用于从非托管代码访问托管类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="a0d49-563">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="a0d49-564">有关 `IDispatch::GetTypeInfoCount`的详细信息，请参阅 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="a0d49-564">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="a0d49-565">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="a0d49-565">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.Invoke">
      <MemberSignature Language="C#" Value="void _MethodBase.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodBase.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodBase::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="a0d49-566">标识成员。</span><span class="sxs-lookup"><span data-stu-id="a0d49-566">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="a0d49-567">留待将来使用。</span><span class="sxs-lookup"><span data-stu-id="a0d49-567">Reserved for future use.</span></span> <span data-ttu-id="a0d49-568">必须为 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="a0d49-568">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="a0d49-569">要在其中解释自变量的区域设置上下文。</span><span class="sxs-lookup"><span data-stu-id="a0d49-569">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="a0d49-570">描述调用的上下文的标志。</span><span class="sxs-lookup"><span data-stu-id="a0d49-570">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="a0d49-571">指向一个结构的指针，该结构包含一个参数数组、一个命名参数的 DISPID 参数数组和数组中元素数的计数。</span><span class="sxs-lookup"><span data-stu-id="a0d49-571">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="a0d49-572">指向要存储结果的位置的指针。</span><span class="sxs-lookup"><span data-stu-id="a0d49-572">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="a0d49-573">指向一个包含异常信息的结构的指针。</span><span class="sxs-lookup"><span data-stu-id="a0d49-573">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="a0d49-574">第一个出错自变量的索引。</span><span class="sxs-lookup"><span data-stu-id="a0d49-574">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="a0d49-575">提供对某一对象公开的属性和方法的访问。</span><span class="sxs-lookup"><span data-stu-id="a0d49-575">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-576">此方法用于从非托管代码访问托管类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="a0d49-576">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="a0d49-577">有关 `IDispatch::Invoke`的详细信息，请参阅 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="a0d49-577">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="a0d49-578">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="a0d49-578">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAbstract">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsAbstract As Boolean Implements _MethodBase.IsAbstract" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-579">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-579">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span></span></summary>
        <value><span data-ttu-id="a0d49-580">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-580">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-581">此成员是显式接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="a0d49-581">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="a0d49-582">它只能在 <xref:System.Reflection.MethodBase> 实例被强制转换为 <xref:System.Runtime.InteropServices._MethodBase> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="a0d49-582">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsAssembly As Boolean Implements _MethodBase.IsAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsAssembly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-583">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-583">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span></span></summary>
        <value><span data-ttu-id="a0d49-584">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-584">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-585">此成员是显式接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="a0d49-585">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="a0d49-586">它只能在 <xref:System.Reflection.MethodBase> 实例被强制转换为 <xref:System.Runtime.InteropServices._MethodBase> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="a0d49-586">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsConstructor">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsConstructor As Boolean Implements _MethodBase.IsConstructor" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsConstructor { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsConstructor" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsConstructor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-587">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-587">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span></span></summary>
        <value><span data-ttu-id="a0d49-588">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-588">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-589">此成员是显式接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="a0d49-589">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="a0d49-590">它只能在 <xref:System.Reflection.MethodBase> 实例被强制转换为 <xref:System.Runtime.InteropServices._MethodBase> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="a0d49-590">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamily">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamily As Boolean Implements _MethodBase.IsFamily" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsFamily { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-591">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-591">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span></span></summary>
        <value><span data-ttu-id="a0d49-592">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-592">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-593">此成员是显式接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="a0d49-593">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="a0d49-594">它只能在 <xref:System.Reflection.MethodBase> 实例被强制转换为 <xref:System.Runtime.InteropServices._MethodBase> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="a0d49-594">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamilyAndAssembly As Boolean Implements _MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsFamilyAndAssembly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-595">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-595">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span></span></summary>
        <value><span data-ttu-id="a0d49-596">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-596">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-597">此成员是显式接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="a0d49-597">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="a0d49-598">它只能在 <xref:System.Reflection.MethodBase> 实例被强制转换为 <xref:System.Runtime.InteropServices._MethodBase> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="a0d49-598">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamilyOrAssembly As Boolean Implements _MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsFamilyOrAssembly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-599">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-599">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span></span></summary>
        <value><span data-ttu-id="a0d49-600">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-600">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-601">此成员是显式接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="a0d49-601">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="a0d49-602">它只能在 <xref:System.Reflection.MethodBase> 实例被强制转换为 <xref:System.Runtime.InteropServices._MethodBase> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="a0d49-602">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFinal">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFinal As Boolean Implements _MethodBase.IsFinal" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsFinal { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsFinal" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFinal</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-603">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-603">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span></span></summary>
        <value><span data-ttu-id="a0d49-604">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-604">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-605">此成员是显式接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="a0d49-605">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="a0d49-606">它只能在 <xref:System.Reflection.MethodBase> 实例被强制转换为 <xref:System.Runtime.InteropServices._MethodBase> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="a0d49-606">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsHideBySig">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsHideBySig As Boolean Implements _MethodBase.IsHideBySig" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsHideBySig { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsHideBySig" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsHideBySig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-607">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-607">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span></span></summary>
        <value><span data-ttu-id="a0d49-608">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-608">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-609">此成员是显式接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="a0d49-609">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="a0d49-610">它只能在 <xref:System.Reflection.MethodBase> 实例被强制转换为 <xref:System.Runtime.InteropServices._MethodBase> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="a0d49-610">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPrivate">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsPrivate As Boolean Implements _MethodBase.IsPrivate" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsPrivate { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-611">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-611">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span></span></summary>
        <value><span data-ttu-id="a0d49-612">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-612">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-613">此成员是显式接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="a0d49-613">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="a0d49-614">它只能在 <xref:System.Reflection.MethodBase> 实例被强制转换为 <xref:System.Runtime.InteropServices._MethodBase> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="a0d49-614">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPublic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsPublic As Boolean Implements _MethodBase.IsPublic" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-615">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-615">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span></span></summary>
        <value><span data-ttu-id="a0d49-616">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-616">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-617">此成员是显式接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="a0d49-617">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="a0d49-618">它只能在 <xref:System.Reflection.MethodBase> 实例被强制转换为 <xref:System.Runtime.InteropServices._MethodBase> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="a0d49-618">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsSpecialName">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSpecialName As Boolean Implements _MethodBase.IsSpecialName" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-619">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-619">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span></span></summary>
        <value><span data-ttu-id="a0d49-620">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-620">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-621">此成员是显式接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="a0d49-621">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="a0d49-622">它只能在 <xref:System.Reflection.MethodBase> 实例被强制转换为 <xref:System.Runtime.InteropServices._MethodBase> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="a0d49-622">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsStatic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsStatic As Boolean Implements _MethodBase.IsStatic" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsStatic { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsStatic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-623">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-623">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span></span></summary>
        <value><span data-ttu-id="a0d49-624">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-624">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-625">此成员是显式接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="a0d49-625">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="a0d49-626">它只能在 <xref:System.Reflection.MethodBase> 实例被强制转换为 <xref:System.Runtime.InteropServices._MethodBase> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="a0d49-626">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsVirtual">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsVirtual As Boolean Implements _MethodBase.IsVirtual" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsVirtual { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsVirtual" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsVirtual</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a0d49-627">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-627">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span></span></summary>
        <value><span data-ttu-id="a0d49-628">有关此成员的说明，请参阅 <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />。</span><span class="sxs-lookup"><span data-stu-id="a0d49-628">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0d49-629">此成员是显式接口成员实现。</span><span class="sxs-lookup"><span data-stu-id="a0d49-629">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="a0d49-630">它只能在 <xref:System.Reflection.MethodBase> 实例被强制转换为 <xref:System.Runtime.InteropServices._MethodBase> 接口时使用。</span><span class="sxs-lookup"><span data-stu-id="a0d49-630">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
