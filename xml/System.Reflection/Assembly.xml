<Type Name="Assembly" FullName="System.Reflection.Assembly">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d319523c20ecc6f4ea6fbffa78220fdd199a48ae" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75097789" /></Metadata><TypeSignature Language="C#" Value="public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Assembly, System.Runtime.Serialization.ISerializable, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Assembly extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Assembly, class System.Runtime.Serialization.ISerializable, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Assembly" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Assembly&#xA;Implements _Assembly, ICustomAttributeProvider, IEvidenceFactory, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Assembly abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Assembly, System::Runtime::Serialization::ISerializable, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type Assembly = class&#xA;    interface ICustomAttributeProvider&#xA;    interface _Assembly&#xA;    interface IEvidenceFactory&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Assembly</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Assembly))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="f0e7c-101">表示一个程序集，它是一个可重用、无版本冲突并且可自我描述的公共语言运行时应用程序构建基块。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-101">Represents an assembly, which is a reusable, versionable, and self-describing building block of a common language runtime application.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-102">使用 <xref:System.Reflection.Assembly> 类加载程序集、浏览程序集的元数据和构成部分、发现程序集中包含的类型以及创建这些类型的实例。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-102">Use the <xref:System.Reflection.Assembly> class to load assemblies, to explore the metadata and constituent parts of assemblies, to discover the types contained in assemblies, and to create instances of those types.</span></span>  
  
 <span data-ttu-id="f0e7c-103">若要获取表示当前加载到应用程序域中的程序集（例如，简单项目的默认应用程序域）的 <xref:System.Reflection.Assembly> 对象的数组，请使用 <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-103">To get an array of <xref:System.Reflection.Assembly> objects representing the assemblies currently loaded into an application domain (for example, the default application domain of a simple project), use the <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="f0e7c-104">若要动态加载程序集，<xref:System.Reflection.Assembly> 类提供以下静态方法（Visual Basic 中`Shared` 方法）。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-104">To load assemblies dynamically, the <xref:System.Reflection.Assembly> class provides the following static methods (`Shared` methods in Visual Basic).</span></span> <span data-ttu-id="f0e7c-105">将程序集加载到发生加载操作的应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-105">Assemblies are loaded into the application domain where the load operation occurs.</span></span>  
  
-   <span data-ttu-id="f0e7c-106">加载程序集的建议方法是使用 <xref:System.AppDomain.Load%2A> 方法，该方法标识要由其显示名称（例如 "b77a5c561934e089，Version = 2.0.0.0，Culture = 中立，PublicKeyToken ="）加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-106">The recommended way to load assemblies is to use the <xref:System.AppDomain.Load%2A> method, which identifies the assembly to be loaded by its display name (for example, "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089").</span></span> <span data-ttu-id="f0e7c-107">该程序集的搜索遵循[运行时如何定位程序集](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md)中所述的规则。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-107">The search for the assembly follows the rules described in [How the Runtime Locates Assemblies](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md).</span></span>  
  
-   <span data-ttu-id="f0e7c-108">利用 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 和 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 方法，你可以加载用于反射的程序集，但不能加载用于执行的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-108">The <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods enable you to load an assembly for reflection, but not for execution.</span></span> <span data-ttu-id="f0e7c-109">例如，可通过在32位平台上运行的代码来检查面向64位平台的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-109">For example, an assembly that targets a 64-bit platform can be examined by code that is running on a 32-bit platform.</span></span>  
  
-   <span data-ttu-id="f0e7c-110">对于程序集必须按路径标识的罕见方案，会提供 <xref:System.Reflection.Assembly.LoadFile%2A> 和 <xref:System.Reflection.Assembly.LoadFrom%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-110">The <xref:System.Reflection.Assembly.LoadFile%2A> and <xref:System.Reflection.Assembly.LoadFrom%2A> methods are provided for rare scenarios in which an assembly must be identified by path.</span></span>  
  
 <span data-ttu-id="f0e7c-111">若要获取当前正在执行的程序集的 <xref:System.Reflection.Assembly> 对象，请使用 <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-111">To get an <xref:System.Reflection.Assembly> object for the currently executing assembly, use the <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> method.</span></span>  
  
 <span data-ttu-id="f0e7c-112"><xref:System.Reflection.Assembly> 类的许多成员提供有关程序集的信息。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-112">Many members of the <xref:System.Reflection.Assembly> class provide information about an assembly.</span></span> <span data-ttu-id="f0e7c-113">例如：</span><span class="sxs-lookup"><span data-stu-id="f0e7c-113">For example:</span></span>  
  
-   <span data-ttu-id="f0e7c-114"><xref:System.Reflection.Assembly.GetName%2A> 方法返回一个 <xref:System.Reflection.AssemblyName> 对象，该对象提供对程序集显示名称的各个部分的访问。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-114">The <xref:System.Reflection.Assembly.GetName%2A> method returns an <xref:System.Reflection.AssemblyName> object that provides access to the parts of the assembly display name.</span></span>  
  
-   <span data-ttu-id="f0e7c-115"><xref:System.Reflection.Assembly.GetCustomAttributes%2A> 方法列出应用于程序集的特性。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-115">The <xref:System.Reflection.Assembly.GetCustomAttributes%2A> method lists the attributes applied to the assembly.</span></span>  
  
-   <span data-ttu-id="f0e7c-116"><xref:System.Reflection.Assembly.GetFiles%2A> 方法提供对程序集清单中的文件的访问。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-116">The <xref:System.Reflection.Assembly.GetFiles%2A> method provides access to the files in the assembly manifest.</span></span>  
  
-   <span data-ttu-id="f0e7c-117"><xref:System.Reflection.Assembly.GetManifestResourceNames%2A> 方法提供程序集清单中的资源的名称。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-117">The <xref:System.Reflection.Assembly.GetManifestResourceNames%2A> method provides the names of the resources in the assembly manifest.</span></span>  
  
 <span data-ttu-id="f0e7c-118"><xref:System.Reflection.Assembly.GetTypes%2A> 方法列出程序集中的所有类型。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-118">The <xref:System.Reflection.Assembly.GetTypes%2A> method lists all the types in the assembly.</span></span> <span data-ttu-id="f0e7c-119"><xref:System.Reflection.Assembly.GetExportedTypes%2A> 方法列出对程序集外部的调用方可见的类型。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-119">The <xref:System.Reflection.Assembly.GetExportedTypes%2A> method lists the types that are visible to callers outside the assembly.</span></span> <span data-ttu-id="f0e7c-120"><xref:System.Reflection.Assembly.GetType%2A> 方法可用于在程序集中搜索特定类型。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-120">The <xref:System.Reflection.Assembly.GetType%2A> method can be used to search for a particular type in the assembly.</span></span> <span data-ttu-id="f0e7c-121"><xref:System.Reflection.Assembly.CreateInstance%2A> 方法可用于在程序集中搜索和创建类型的实例。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-121">The <xref:System.Reflection.Assembly.CreateInstance%2A> method can be used to search for and create instances of types in the assembly.</span></span>  
  
 <span data-ttu-id="f0e7c-122">有关程序集的详细信息，请参阅[应用程序域](~/docs/framework/app-domains/application-domains.md)主题中的 "应用程序域和程序集" 一节。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-122">For more information on assemblies, see the "Application Domains and Assemblies" section in the [Application Domains](~/docs/framework/app-domains/application-domains.md) topic.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f0e7c-123">下面的代码示例演示如何获取当前正在执行的程序集、创建该程序集中包含的类型的实例，以及使用后期绑定调用类型的方法之一。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-123">The following code example shows how to obtain the currently executing assembly, create an instance of a type contained in that assembly, and invoke one of the type's methods with late binding.</span></span> <span data-ttu-id="f0e7c-124">为此，该代码示例定义了一个名为 `Example`的类，其中包含一个名为 `SampleMethod`的方法。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-124">For this purpose, the code example defines a class named `Example`, with a method named `SampleMethod`.</span></span> <span data-ttu-id="f0e7c-125">类的构造函数接受一个整数，该整数用于计算方法的返回值。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-125">The constructor of the class accepts an integer, which is used to compute the return value of the method.</span></span>  
  
 <span data-ttu-id="f0e7c-126">此代码示例还演示了如何使用 <xref:System.Reflection.Assembly.GetName%2A> 方法获取可用于分析程序集的全名的 <xref:System.Reflection.AssemblyName> 对象。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-126">The code example also demonstrates the use of the <xref:System.Reflection.Assembly.GetName%2A> method to obtain an <xref:System.Reflection.AssemblyName> object that can be used to parse the full name of the assembly.</span></span> <span data-ttu-id="f0e7c-127">该示例显示程序集的版本号、<xref:System.Reflection.Assembly.CodeBase%2A> 属性和 <xref:System.Reflection.Assembly.EntryPoint%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-127">The example displays the version number of the assembly, the <xref:System.Reflection.Assembly.CodeBase%2A> property, and the <xref:System.Reflection.Assembly.EntryPoint%2A> property.</span></span>  
  
 [!code-cpp[AssemblyClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyClass/cpp/source.cpp#1)]
 [!code-csharp[AssemblyClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyClass/cs/source.cs#1)]
 [!code-vb[AssemblyClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyClass/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="f0e7c-128">完全信任继承者。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-128">for full trust for inheritors.</span></span> <span data-ttu-id="f0e7c-129">此类不能由部分信任的代码继承。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-129">This class cannot be inherited by partially trusted code.</span></span></permission>
    <threadsafe><span data-ttu-id="f0e7c-130">此类型是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-130">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.AppDomain" />
    <altmember cref="T:System.Reflection.AssemblyName" />
    <related type="Article" href="~/docs/framework/app-domains/application-domains.md"><span data-ttu-id="f0e7c-131">应用程序域</span><span class="sxs-lookup"><span data-stu-id="f0e7c-131">Application Domains</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Assembly ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.#ctor" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Assembly();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f0e7c-132">初始化 <see cref="T:System.Reflection.Assembly" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-132">Initializes a new instance of the <see cref="T:System.Reflection.Assembly" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-133">此构造函数由派生类在构造 <xref:System.Reflection.Assembly> 对象的过程中调用。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-133">This constructor is invoked by derived classes during the construction of <xref:System.Reflection.Assembly> objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public virtual string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeBase : string" Usage="System.Reflection.Assembly.CodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.CodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f0e7c-134">获取最初指定的程序集的位置，例如，在 <see cref="T:System.Reflection.AssemblyName" /> 对象中指定的位置。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-134">Gets the location of the assembly as specified originally, for example, in an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span></summary>
        <value><span data-ttu-id="f0e7c-135">程序集的位置（按照最初的指定）。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-135">The location of the assembly as specified originally.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-136">若要获取已加载清单包含文件的绝对路径，请改用 <xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-136">To get the absolute path to the loaded manifest-containing file, use the <xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType> property instead.</span></span>  
  
 <span data-ttu-id="f0e7c-137">如果程序集是以字节数组的形式加载的，则使用采用字节数组的 <xref:System.Reflection.Assembly.Load%2A> 方法的重载，此属性返回方法调用方的位置，而不是已加载的程序集的位置。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-137">If the assembly was loaded as a byte array, using an overload of the <xref:System.Reflection.Assembly.Load%2A> method that takes an array of bytes, this property returns the location of the caller of the method, not the location of the loaded assembly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f0e7c-138">下面的示例使用 <xref:System.Reflection.Assembly.CodeBase%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-138">The following example uses the <xref:System.Reflection.Assembly.CodeBase%2A> property.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/codebase1.cpp#1)]
 [!code-csharp[System.Reflection.Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/codebase1.cs#1)]
 [!code-vb[System.Reflection.Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/codebase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="f0e7c-139">用于访问路径。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-139">for access to the path.</span></span> <span data-ttu-id="f0e7c-140">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-140">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f0e7c-141">从此程序集中查找某个类型，然后使用系统激活器创建它的实例。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-141">Locates a type from this assembly and creates an instance of it using the system activator.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstance(string typeName) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstance(System::String ^ typeName);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string -&gt; obj" Usage="assembly.CreateInstance typeName" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string -&gt; obj&#xA;override this.CreateInstance : string -&gt; obj" Usage="assembly.CreateInstance typeName" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="f0e7c-142">要查找类型的 <see cref="P:System.Type.FullName" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-142">The <see cref="P:System.Type.FullName" /> of the type to locate.</span></span></param>
        <summary><span data-ttu-id="f0e7c-143">使用区分大小写的搜索，从此程序集中查找指定的类型，然后使用系统激活器创建它的实例。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-143">Locates the specified type from this assembly and creates an instance of it using the system activator, using case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-144">使用无参数构造函数创建的指定类型的实例；如果未找到 <see langword="null" />，则为 <paramref name="typeName" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-144">An instance of the specified type created with the parameterless constructor; or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="f0e7c-145">该类型使用默认联编程序解析，而无需指定区域性或激活属性，并将 <see cref="T:System.Reflection.BindingFlags" /> 设置为 <see langword="Public" /> 或 <see langword="Instance" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-145">The type is resolved using the default binder, without specifying culture or activation attributes, and with <see cref="T:System.Reflection.BindingFlags" /> set to <see langword="Public" /> or <see langword="Instance" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-146">如果运行时在 <xref:System.Reflection.Assembly> 实例中找不到 `typeName`，则返回 `null`，而不是引发异常。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-146">If the runtime is unable to find `typeName` in the <xref:System.Reflection.Assembly> instance, it returns `null` instead of throwing an exception.</span></span> <span data-ttu-id="f0e7c-147">出现这种情况的原因可能是：</span><span class="sxs-lookup"><span data-stu-id="f0e7c-147">This might happen because:</span></span>  
  
-   <span data-ttu-id="f0e7c-148">尚未指定类型的完全限定名称。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-148">You haven't specified the fully qualified name of the type.</span></span>  
  
-   <span data-ttu-id="f0e7c-149">已指定完全限定的类型名称，但其大小写与类型的 <xref:System.Type.FullName%2A?displayProperty=nameWithType> 属性的大小写不匹配。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-149">You've specified the fully qualified type name, but its case doesn't match the case of the type's <xref:System.Type.FullName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="f0e7c-150">对于与类型的全名 `typeName` 不区分大小写的比较，请调用 <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> 重载，并为 `ignoreCase` 参数指定 `true`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-150">For a case-insensitive comparison of `typeName` with the type's full name, call the <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> overload and specify `true` for the `ignoreCase` argument.</span></span>  
  
-   <span data-ttu-id="f0e7c-151">当前 <xref:System.Reflection.Assembly> 实例中不存在该类型。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-151">The type doesn't exist in the current <xref:System.Reflection.Assembly> instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f0e7c-152">下面的示例定义了一个 `Person` 类，并调用 <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> 方法对其进行实例化。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-152">The following example defines a `Person` class and calls the <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> method to instantiate it.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance1.cs#1)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f0e7c-153"><paramref name="typeName" /> 为空字符串 ("") 或以空字符开头的字符串。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-153"><paramref name="typeName" /> is an empty string ("") or a string beginning with a null character.</span></span>  
  
<span data-ttu-id="f0e7c-154">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-154">-or-</span></span> 
<span data-ttu-id="f0e7c-155">当前程序集已加载到仅反射上下文中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-155">The current assembly was loaded into the reflection-only context.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-156"><paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-156"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="f0e7c-157">未找到匹配的构造函数。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-157">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-158"><paramref name="typeName" /> 所需的从属程序集无法找到。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-158"><paramref name="typeName" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-159"><paramref name="typeName" /> 所需的从属程序集已找到，但无法加载。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-159"><paramref name="typeName" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="f0e7c-160">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-160">-or-</span></span> 
<span data-ttu-id="f0e7c-161">当前程序集被加载到仅反射上下文中，并且 <paramref name="typeName" /> 所需的从属程序集未预先加载。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-161">The current assembly was loaded into the reflection-only context, and <paramref name="typeName" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-162"><paramref name="typeName" /> 需要一个从属程序集，但该文件不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-162"><paramref name="typeName" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="f0e7c-163">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-163">-or-</span></span> 
 <span data-ttu-id="f0e7c-164"><paramref name="typeName" /> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-164"><paramref name="typeName" /> requires a dependent assembly that was compiled for a version of the runtime that is later than the currently loaded version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="f0e7c-165">当通过 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />的机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-165">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="f0e7c-166">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-166">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstance(string typeName, bool ignoreCase) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String, ignoreCase As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * bool -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool -&gt; obj&#xA;override this.CreateInstance : string * bool -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="f0e7c-167">要查找类型的 <see cref="P:System.Type.FullName" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-167">The <see cref="P:System.Type.FullName" /> of the type to locate.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="f0e7c-168">如果为 <see langword="true" />，则忽略类型名的大小写；否则，为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-168"><see langword="true" /> to ignore the case of the type name; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f0e7c-169">使用可选的区分大小写搜索，从此程序集中查找指定的类型，然后使用系统激活器创建它的实例。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-169">Locates the specified type from this assembly and creates an instance of it using the system activator, with optional case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-170">使用无参数构造函数创建的指定类型的实例；如果未找到 <see langword="null" />，则为 <paramref name="typeName" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-170">An instance of the specified type created with the parameterless constructor; or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="f0e7c-171">该类型使用默认联编程序解析，而无需指定区域性或激活属性，并将 <see cref="T:System.Reflection.BindingFlags" /> 设置为 <see langword="Public" /> 或 <see langword="Instance" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-171">The type is resolved using the default binder, without specifying culture or activation attributes, and with <see cref="T:System.Reflection.BindingFlags" /> set to <see langword="Public" /> or <see langword="Instance" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-172">如果运行时在 <xref:System.Reflection.Assembly> 实例中找不到 `typeName`，则返回 `null`，而不是引发异常。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-172">If the runtime is unable to find `typeName` in the <xref:System.Reflection.Assembly> instance, it returns `null` instead of throwing an exception.</span></span> <span data-ttu-id="f0e7c-173">出现这种情况的原因可能是：</span><span class="sxs-lookup"><span data-stu-id="f0e7c-173">This might happen because:</span></span>  
  
-   <span data-ttu-id="f0e7c-174">尚未指定类型的完全限定名称。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-174">You haven't specified the fully qualified name of the type.</span></span>  
  
-   <span data-ttu-id="f0e7c-175">当前 <xref:System.Reflection.Assembly> 实例中不存在该类型。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-175">The type doesn't exist in the current <xref:System.Reflection.Assembly> instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f0e7c-176">下面的示例定义了一个 `Person` 类。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-176">The following example defines a `Person` class.</span></span> <span data-ttu-id="f0e7c-177">然后，它调用 <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> 方法对其进行实例化，但由于 `typeName` 参数的大小写与类型的 <xref:System.Type.FullName%2A> 属性的大小写不匹配，因此该方法返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-177">It then calls the <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> method to instantiate it, but because the casing of the `typeName` argument doesn't match that of the type's <xref:System.Type.FullName%2A> property, the method returns `null`.</span></span> <span data-ttu-id="f0e7c-178">当示例将同一字符串传递到 <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> 重载，并指定该比较应区分大小写时，将找到 `Person` 类，并且已成功实例化 `Person` 对象。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-178">When the example passes the same string to the <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> overload and specifies that the comparison should be case-insensitive, the `Person` class is found, and a `Person` object is successfully instantiated.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance2.cs#2)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f0e7c-179"><paramref name="typeName" /> 为空字符串 ("") 或以空字符开头的字符串。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-179"><paramref name="typeName" /> is an empty string ("") or a string beginning with a null character.</span></span>  
  
<span data-ttu-id="f0e7c-180">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-180">-or-</span></span> 
<span data-ttu-id="f0e7c-181">当前程序集已加载到仅反射上下文中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-181">The current assembly was loaded into the reflection-only context.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="f0e7c-182">未找到匹配的构造函数。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-182">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-183"><paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-183"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-184"><paramref name="typeName" /> 所需的从属程序集无法找到。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-184"><paramref name="typeName" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-185"><paramref name="typeName" /> 所需的从属程序集已找到，但无法加载。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-185"><paramref name="typeName" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="f0e7c-186">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-186">-or-</span></span> 
<span data-ttu-id="f0e7c-187">当前程序集被加载到仅反射上下文中，并且 <paramref name="typeName" /> 所需的从属程序集未预先加载。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-187">The current assembly was loaded into the reflection-only context, and <paramref name="typeName" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-188"><paramref name="typeName" /> 需要一个从属程序集，但该文件不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-188"><paramref name="typeName" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="f0e7c-189">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-189">-or-</span></span> 
 <span data-ttu-id="f0e7c-190"><paramref name="typeName" /> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-190"><paramref name="typeName" /> requires a dependent assembly that was compiled for a version of the runtime that is later than the currently loaded version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="f0e7c-191">当通过 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />的机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-191">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="f0e7c-192">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-192">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj&#xA;override this.CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="f0e7c-193">要查找类型的 <see cref="P:System.Type.FullName" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-193">The <see cref="P:System.Type.FullName" /> of the type to locate.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="f0e7c-194">如果为 <see langword="true" />，则忽略类型名的大小写；否则，为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-194"><see langword="true" /> to ignore the case of the type name; otherwise, <see langword="false" />.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="f0e7c-195">影响执行搜索的方式的位掩码。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-195">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="f0e7c-196">此值是 <see cref="T:System.Reflection.BindingFlags" /> 中的位标志的组合。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-196">The value is a combination of bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <param name="binder"><span data-ttu-id="f0e7c-197">一个对象，它启用绑定、对自变量类型的强制、对成员的调用，以及通过反射对 <see langword="MemberInfo" /> 对象的检索。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-197">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects via reflection.</span></span> <span data-ttu-id="f0e7c-198">如果 <paramref name="binder" /> 为 <see langword="null" />，则使用默认联编程序。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-198">If <paramref name="binder" /> is <see langword="null" />, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="f0e7c-199">包含要传递给构造函数的参数的数组。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-199">An array that contains the arguments to be passed to the constructor.</span></span> <span data-ttu-id="f0e7c-200">此参数数组在数量、顺序和类型方面必须与要调用的构造函数的参数匹配。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-200">This array of arguments must match in number, order, and type the parameters of the constructor to be invoked.</span></span> <span data-ttu-id="f0e7c-201">如果需要无参数构造函数，则 <paramref name="args" /> 必须是空数组或 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-201">If the parameterless constructor is desired, <paramref name="args" /> must be an empty array or <see langword="null" />.</span></span></param>
        <param name="culture"><span data-ttu-id="f0e7c-202">用于控制类型强制的 <see langword="CultureInfo" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-202">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span></span> <span data-ttu-id="f0e7c-203">如果这是 <see langword="null" />，则使用当前线程的 <see langword="CultureInfo" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-203">If this is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span></span> <span data-ttu-id="f0e7c-204">（例如，这对于将表示 1000 的 <see langword="String" /> 转换为 <see langword="Double" /> 值是必需的，因为不同的区域性以不同的方式表示 1000。）</span><span class="sxs-lookup"><span data-stu-id="f0e7c-204">(This is necessary to convert a <see langword="String" /> that represents 1000 to a <see langword="Double" /> value, for example, since 1000 is represented differently by different cultures.)</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="f0e7c-205">可参与激活的一个或多个属性的数组。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-205">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="f0e7c-206">通常，为包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组，该对象指定激活远程对象所需的 URL。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-206">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  <span data-ttu-id="f0e7c-207">此参数与客户端激活的对象相关。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-207">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="f0e7c-208">客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-208">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="f0e7c-209">应改用 Windows Communication Foundation 来开发分布式应用程序。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-209">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="f0e7c-210">使用可选的区分大小写搜索并具有指定的区域性、自变量和绑定及激活特性，从此程序集中查找指定的类型，并使用系统激活器创建它的实例。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-210">Locates the specified type from this assembly and creates an instance of it using the system activator, with optional case-sensitive search and having the specified culture, arguments, and binding and activation attributes.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-211">如果未找到 <see langword="null" />，则为指定的类型实例或 <paramref name="typeName" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-211">An instance of the specified type, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="f0e7c-212">所提供的参数用于解析类型，以及绑定用于创建实例的构造函数。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-212">The supplied arguments are used to resolve the type, and to bind the constructor that is used to create the instance.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f0e7c-213"><paramref name="typeName" /> 为空字符串 ("") 或以空字符开头的字符串。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-213"><paramref name="typeName" /> is an empty string ("") or a string beginning with a null character.</span></span>  
  
<span data-ttu-id="f0e7c-214">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-214">-or-</span></span> 
<span data-ttu-id="f0e7c-215">当前程序集已加载到仅反射上下文中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-215">The current assembly was loaded into the reflection-only context.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-216"><paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-216"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="f0e7c-217">未找到匹配的构造函数。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-217">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f0e7c-218">非空激活属性数组被传递给不是继承自 <see cref="T:System.MarshalByRefObject" /> 的类型。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-218">A non-empty activation attributes array is passed to a type that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-219"><paramref name="typeName" /> 所需的从属程序集无法找到。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-219"><paramref name="typeName" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-220"><paramref name="typeName" /> 所需的从属程序集已找到，但无法加载。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-220"><paramref name="typeName" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="f0e7c-221">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-221">-or-</span></span> 
<span data-ttu-id="f0e7c-222">当前程序集被加载到仅反射上下文中，并且 <paramref name="typeName" /> 所需的从属程序集未预先加载。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-222">The current assembly was loaded into the reflection-only context, and <paramref name="typeName" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-223"><paramref name="typeName" /> 需要一个从属程序集，但该文件不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-223"><paramref name="typeName" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="f0e7c-224">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-224">-or-</span></span> 
 <span data-ttu-id="f0e7c-225"><paramref name="typeName" /> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-225"><paramref name="typeName" /> requires a dependent assembly which that was compiled for a version of the runtime that is later than the currently loaded version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="f0e7c-226">当通过 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />的机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-226">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="f0e7c-227">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-227">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="f0e7c-228">创建委托的实例。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-228">to create an instance of a delegate.</span></span> <span data-ttu-id="f0e7c-229">关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-229">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateQualifiedName">
      <MemberSignature Language="C#" Value="public static string CreateQualifiedName (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateQualifiedName(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateQualifiedName (assemblyName As String, typeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CreateQualifiedName(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateQualifiedName : string * string -&gt; string" Usage="System.Reflection.Assembly.CreateQualifiedName (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="f0e7c-230">程序集的显示名称。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-230">The display name of an assembly.</span></span></param>
        <param name="typeName"><span data-ttu-id="f0e7c-231">类型的全名。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-231">The full name of a type.</span></span></param>
        <summary><span data-ttu-id="f0e7c-232">创建由类型的程序集的显示名称限定的类型的名称。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-232">Creates the name of a type qualified by the display name of its assembly.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-233">由程序集的显示名称限定的类型的完整名称。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-233">The full name of the type qualified by the display name of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-234">返回的字符串的格式为：</span><span class="sxs-lookup"><span data-stu-id="f0e7c-234">The format of the returned string is:</span></span>  
  
 <span data-ttu-id="f0e7c-235">\<FullTypeName >，\<AssemblyDisplayName ></span><span class="sxs-lookup"><span data-stu-id="f0e7c-235">\<FullTypeName>, \<AssemblyDisplayName></span></span>  
  
 <span data-ttu-id="f0e7c-236">有关程序集显示名称的格式的说明，请参阅 <xref:System.Reflection.AssemblyName>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-236">See <xref:System.Reflection.AssemblyName> for a description of the format of the display name of an assembly.</span></span>  
  
 <span data-ttu-id="f0e7c-237">若要在公共语言运行时的版本中适应更改，请使用此方法，而不是自己构造限定名称。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-237">To accommodate changes in versions of the common language runtime, use this method rather than constructing the qualified name yourself.</span></span>  <span data-ttu-id="f0e7c-238">有关限定的程序集名称的信息，请参阅 <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-238">For information about qualified assembly names, see <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CustomAttributes : seq&lt;System.Reflection.CustomAttributeData&gt;" Usage="System.Reflection.Assembly.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f0e7c-239">获取包含此程序集自定义属性的集合。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-239">Gets a collection that contains this assembly's custom attributes.</span></span></summary>
        <value><span data-ttu-id="f0e7c-240">包含此程序集自定义属性的集合。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-240">A collection that contains this assembly's custom attributes.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.DefinedTypes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property DefinedTypes As IEnumerable(Of TypeInfo)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ DefinedTypes { System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.DefinedTypes : seq&lt;System.Reflection.TypeInfo&gt;" Usage="System.Reflection.Assembly.DefinedTypes" />
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefinedTypes As IEnumerable(Of TypeInfo)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ DefinedTypes { System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f0e7c-241">获取定义在此程序集中的类型的集合。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-241">Gets a collection of the types defined in this assembly.</span></span></summary>
        <value><span data-ttu-id="f0e7c-242">定义在此程序集中的类型的集合。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-242">A collection of the types defined in this assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-243"><xref:System.Reflection.Assembly.DefinedTypes%2A> 属性相当于 <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> 方法，不同之处在于 <xref:System.Reflection.Assembly.DefinedTypes%2A> 属性返回 <xref:System.Reflection.TypeInfo> 对象的集合，而 <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> 方法返回 <xref:System.Type> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-243">The <xref:System.Reflection.Assembly.DefinedTypes%2A> property is comparable to the <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method, except that the <xref:System.Reflection.Assembly.DefinedTypes%2A> property returns a collection of <xref:System.Reflection.TypeInfo> objects, and the <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method returns an array of <xref:System.Type> objects.</span></span>  
  
 <span data-ttu-id="f0e7c-244">返回的数组包括嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-244">The returned array includes nested types.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Assembly.GetTypes" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EntryPoint As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ EntryPoint { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EntryPoint : System.Reflection.MethodInfo" Usage="System.Reflection.Assembly.EntryPoint" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EntryPoint</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f0e7c-245">获取此程序集的入口点。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-245">Gets the entry point of this assembly.</span></span></summary>
        <value><span data-ttu-id="f0e7c-246">表示此程序集入口点的对象。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-246">An object that represents the entry point of this assembly.</span></span> <span data-ttu-id="f0e7c-247">如果没有找到入口点（例如，此程序集是一个 DLL），则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-247">If no entry point is found (for example, the assembly is a DLL), <see langword="null" /> is returned.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="assembly.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="f0e7c-248">要与此实例比较的对象。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-248">The object to compare with this instance.</span></span></param>
        <summary><span data-ttu-id="f0e7c-249">确定此程序集和指定的对象是否相等。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-249">Determines whether this assembly and the specified object are equal.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-250">如果 <see langword="true" /> 与此实例相等，则为 <paramref name="o" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-250"><see langword="true" /> if <paramref name="o" /> is equal to this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-251"><xref:System.Reflection.Assembly.Equals%2A> 方法执行引用相等性测试，以确定当前实例和 `o` 是否相等。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-251">The <xref:System.Reflection.Assembly.Equals%2A> method performs a test for reference equality to determine whether the current instance and `o` are equal.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public virtual string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EscapedCodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EscapedCodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EscapedCodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EscapedCodeBase : string" Usage="System.Reflection.Assembly.EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EscapedCodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f0e7c-252">获取 URI，包括表示基本代码的转义符。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-252">Gets the URI, including escape characters, that represents the codebase.</span></span></summary>
        <value><span data-ttu-id="f0e7c-253">带有转义符的 URI。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-253">A URI with escape characters.</span></span></value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="f0e7c-254">用于访问路径。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-254">for access to the path.</span></span> <span data-ttu-id="f0e7c-255">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-255">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.Reflection.Assembly.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Evidence</InterfaceMember>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f0e7c-256">获取此程序集的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-256">Gets the evidence for this assembly.</span></span></summary>
        <value><span data-ttu-id="f0e7c-257">此程序集的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-257">The evidence for this assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-258">证据是输入安全策略决策的一组信息（如代码可授予哪些权限）。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-258">Evidence is the set of information that constitutes input to security policy decisions, such as what permissions can be granted to code.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="f0e7c-259">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-259">to load an assembly with evidence.</span></span> <span data-ttu-id="f0e7c-260">关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-260">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExportedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; ExportedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; ExportedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ExportedTypes As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ ExportedTypes { System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExportedTypes : seq&lt;Type&gt;" Usage="System.Reflection.Assembly.ExportedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f0e7c-261">获取此程序集中定义的公共类型的集合，这些公共类型在程序集外可见。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-261">Gets a collection of the public types defined in this assembly that are visible outside the assembly.</span></span></summary>
        <value><span data-ttu-id="f0e7c-262">此程序集中定义的公共类型的集合，这些公共类型在程序集外可见。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-262">A collection of the public types defined in this assembly that are visible outside the assembly.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public virtual string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.Assembly.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f0e7c-263">获取程序集的显示名称。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-263">Gets the display name of the assembly.</span></span></summary>
        <value><span data-ttu-id="f0e7c-264">程序集的显示名称。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-264">The display name of the assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-265">有关程序集显示名称的格式的说明，请参阅 <xref:System.Reflection.AssemblyName>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-265">See <xref:System.Reflection.AssemblyName> for a description of the format of the display name of an assembly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f0e7c-266">建议不要编写自己的代码来分析显示名称。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-266">Writing your own code to parse display names is not recommended.</span></span> <span data-ttu-id="f0e7c-267">而是将显示名称传递到 <xref:System.Reflection.AssemblyName.%23ctor%2A> 构造函数，该构造函数对其进行分析，并填充新 <xref:System.Reflection.AssemblyName>的相应字段。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-267">Instead, pass the display name to the <xref:System.Reflection.AssemblyName.%23ctor%2A> constructor, which parses it and populates the appropriate fields of the new <xref:System.Reflection.AssemblyName>.</span></span>  
  
 <span data-ttu-id="f0e7c-268">在 .NET Framework 版本2.0 中，处理器体系结构添加到程序集标识，并可指定为程序集名称字符串的一部分。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-268">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="f0e7c-269">不过，由于兼容性原因，它不包含在 <xref:System.Reflection.Assembly.FullName%2A> 属性返回的字符串中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-269">However, it is not included in the string returned by the <xref:System.Reflection.Assembly.FullName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="f0e7c-270">请参阅<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-270">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f0e7c-271">下面的示例检索当前正在执行的程序集的显示名称，以及包含 <xref:System.Int32> 类型的程序集的显示名称（`int` 在C#Visual Basic 中 `Integer`）。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-271">The following example retrieves the display name of the currently executing assembly, and the display name of the assembly that contains the <xref:System.Int32> type (`int` in C#, `Integer` in Visual Basic).</span></span>  
  
 [!code-cpp[Assembly.FullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.FullName/CPP/Example.cpp#1)]
 [!code-csharp[Assembly.FullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.FullName/CS/Example.cs#1)]
 [!code-vb[Assembly.FullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.FullName/VB/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="f0e7c-272">指定完全限定的类型名称</span><span class="sxs-lookup"><span data-stu-id="f0e7c-272">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetAssembly (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetAssembly(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetAssembly(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetAssembly : Type -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetAssembly type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="f0e7c-273">一个对象，该对象表示将返回的程序集中的类型。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-273">An object representing a type in the assembly that will be returned.</span></span></param>
        <summary><span data-ttu-id="f0e7c-274">获取在其中定义指定类型的当前加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-274">Gets the currently loaded assembly in which the specified type is defined.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-275">在其中定义指定类型的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-275">The assembly in which the specified type is defined.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-276">调用此方法等效于检索 <xref:System.Type.Assembly?displayProperty=nameWithType> 属性的值。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-276">Calling this method is equivalent to retrieving the value of the  <xref:System.Type.Assembly?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="f0e7c-277">不过，<xref:System.Type.Assembly?displayProperty=nameWithType> 属性通常提供优异的性能。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-277">However, the <xref:System.Type.Assembly?displayProperty=nameWithType> property typically offers superior performance.</span></span>  
  
 <span data-ttu-id="f0e7c-278">若要调用此方法，必须具有一个 <xref:System.Type> 对象，这意味着必须已加载定义该类的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-278">In order to call this method, you must have a <xref:System.Type> object, which means that the assembly in which the class is defined must already be loaded.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f0e7c-279">下面的示例检索包含 <xref:System.Int32> 类型的程序集，并显示其名称和文件位置。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-279">The following example retrieves the assembly that contains the <xref:System.Int32> type and displays its name and file location.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/GetAssembly1.cpp#12)]
 [!code-csharp[System.Reflection.Assembly#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/GetAssembly1.cs#12)]
 [!code-vb[System.Reflection.Assembly#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/GetAssembly1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-280"><paramref name="type" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-280"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="f0e7c-281">当通过 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />的机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-281">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="f0e7c-282">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-282">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCallingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCallingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCallingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCallingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCallingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCallingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetCallingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetCallingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f0e7c-283">返回方法（该方法调用当前正在执行的方法）的 <see cref="T:System.Reflection.Assembly" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-283">Returns the <see cref="T:System.Reflection.Assembly" /> of the method that invoked the currently executing method.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-284">方法（该方法调用当前正在执行的方法）的 <see langword="Assembly" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-284">The <see langword="Assembly" /> object of the method that invoked the currently executing method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-285">如果调用 <xref:System.Reflection.Assembly.GetCallingAssembly%2A> 方法的方法是由实时（JIT）编译器以内联方式展开的，或者如果其调用方展开内联，则 <xref:System.Reflection.Assembly.GetCallingAssembly%2A> 返回的程序集可能会意外地有所不同。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-285">If the method that calls the <xref:System.Reflection.Assembly.GetCallingAssembly%2A> method is expanded inline by the just-in-time (JIT) compiler, or if its caller is expanded inline, the assembly that is returned by <xref:System.Reflection.Assembly.GetCallingAssembly%2A> may differ unexpectedly.</span></span> <span data-ttu-id="f0e7c-286">例如，请考虑以下方法和程序集：</span><span class="sxs-lookup"><span data-stu-id="f0e7c-286">For example, consider the following methods and assemblies:</span></span>  
  
-   <span data-ttu-id="f0e7c-287">程序集中的方法 `M1` `A1` 调用 <xref:System.Reflection.Assembly.GetCallingAssembly%2A>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-287">Method `M1` in assembly `A1` calls <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.</span></span>  
  
-   <span data-ttu-id="f0e7c-288">程序集中的方法 `M2` `A2` 调用 `M1`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-288">Method `M2` in assembly `A2` calls `M1`.</span></span>  
  
-   <span data-ttu-id="f0e7c-289">程序集中的方法 `M3` `A3` 调用 `M2`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-289">Method `M3` in assembly `A3` calls `M2`.</span></span>  
  
 <span data-ttu-id="f0e7c-290">如果 `M1` 未内联，则 <xref:System.Reflection.Assembly.GetCallingAssembly%2A> 返回 `A2`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-290">When `M1` is not inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A2`.</span></span> <span data-ttu-id="f0e7c-291">内联 `M1` 时，<xref:System.Reflection.Assembly.GetCallingAssembly%2A> 返回 `A3`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-291">When `M1` is inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A3`.</span></span> <span data-ttu-id="f0e7c-292">同样，当 `M2` 不内联时，<xref:System.Reflection.Assembly.GetCallingAssembly%2A> 返回 `A2`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-292">Similarly, when `M2` is not inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A2`.</span></span> <span data-ttu-id="f0e7c-293">内联 `M2` 时，<xref:System.Reflection.Assembly.GetCallingAssembly%2A> 返回 `A3`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-293">When `M2` is inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A3`.</span></span>  
  
 <span data-ttu-id="f0e7c-294">当 `M1` 作为 `M2`的尾调用执行，或者 `M2` 作为来自 `M3`的尾调用执行时，也会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-294">This effect also occurs when `M1` executes as a tail call from `M2`, or when `M2` executes as a tail call from `M3`.</span></span> <span data-ttu-id="f0e7c-295">可以通过将 <xref:System.Runtime.CompilerServices.MethodImplAttribute> 属性应用于 <xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType> 标志来阻止 JIT 编译器内联调用 <xref:System.Reflection.Assembly.GetCallingAssembly%2A>的方法，但没有用于阻止尾调用的类似机制。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-295">You can prevent the JIT compiler from inlining the method that calls <xref:System.Reflection.Assembly.GetCallingAssembly%2A>, by applying the <xref:System.Runtime.CompilerServices.MethodImplAttribute> attribute with the <xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType> flag, but there is no similar mechanism for preventing tail calls.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f0e7c-296">下面的示例获取当前方法的调用程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-296">The following example gets the calling assembly of the current method.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/getcallingassembly1.cpp#4)]
 [!code-csharp[System.Reflection.Assembly#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/getcallingassembly1.cs#4)]
 [!code-vb[System.Reflection.Assembly#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/getcallingassembly1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f0e7c-297">获取此程序集的自定义属性。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-297">Gets the custom attributes for this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : bool -&gt; obj[]&#xA;override this.GetCustomAttributes : bool -&gt; obj[]" Usage="assembly.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="inherit"><span data-ttu-id="f0e7c-298">对于 <see cref="T:System.Reflection.Assembly" /> 类型的对象，将忽略此参数。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-298">This argument is ignored for objects of type <see cref="T:System.Reflection.Assembly" />.</span></span></param>
        <summary><span data-ttu-id="f0e7c-299">获取此程序集的所有自定义属性。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-299">Gets all the custom attributes for this assembly.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-300">包含此程序集自定义属性的数组。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-300">An array that contains the custom attributes for this assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-301">此方法实现相应的 <xref:System.Reflection.ICustomAttributeProvider> 接口方法。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-301">This method implements the corresponding <xref:System.Reflection.ICustomAttributeProvider> interface method.</span></span> <span data-ttu-id="f0e7c-302">因此，必须指定 `inherit` 参数，即使该参数被忽略。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-302">Therefore, the `inherit` parameter must be specified even though it is ignored.</span></span>  
  
 <span data-ttu-id="f0e7c-303">伪属性指示在属性存在时必须设置的核心元数据的位数。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-303">A pseudo-attribute indicates bits of the core metadata that must be set when the attribute is present.</span></span> <span data-ttu-id="f0e7c-304">与扩展类型的元数据的自定义特性不同，与类型一起保存时，伪特性会修改类型的元数据，然后被丢弃。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-304">Unlike a custom attribute that extends the metadata for a type and is saved along with the type, a pseudo-attribute modifies the metadata for the type and then is discarded.</span></span> <span data-ttu-id="f0e7c-305">某些生成的位无法使用现有的反射 Api 进行访问。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-305">Some of the resulting bits cannot be accessed using existing reflection APIs.</span></span>  
  
 <span data-ttu-id="f0e7c-306">下表总结了反射中可用的位的不同伪属性和访问器。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-306">The following table summarizes the different pseudo-attributes and the accessors for the bits that are available in reflection.</span></span>  
  
|<span data-ttu-id="f0e7c-307">伪特性</span><span class="sxs-lookup"><span data-stu-id="f0e7c-307">Pseudo-Attribute</span></span>|<span data-ttu-id="f0e7c-308">元数据位</span><span class="sxs-lookup"><span data-stu-id="f0e7c-308">Metadata Bits</span></span>|<span data-ttu-id="f0e7c-309">反射访问器</span><span class="sxs-lookup"><span data-stu-id="f0e7c-309">Reflection Accessor</span></span>|  
|-----------------------|-------------------|-------------------------|  
|<span data-ttu-id="f0e7c-310">Sub</span><span class="sxs-lookup"><span data-stu-id="f0e7c-310">DllImportAttribute</span></span>|<span data-ttu-id="f0e7c-311">CorPInvokeMap</span><span class="sxs-lookup"><span data-stu-id="f0e7c-311">CorPInvokeMap</span></span><br /><br /> <span data-ttu-id="f0e7c-312">DLL 名称</span><span class="sxs-lookup"><span data-stu-id="f0e7c-312">DLL name</span></span>|<span data-ttu-id="f0e7c-313">对于普通方法/全局方法特性，没有适用于 PInvokeMap 的访问器。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-313">No accessor for PInvokeMap for ordinary method/global method attributes.</span></span><br /><br /> <span data-ttu-id="f0e7c-314">没有 DLL 名称的访问器。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-314">No accessor for DLL name.</span></span>|  
|<span data-ttu-id="f0e7c-315">GuidAttribute</span><span class="sxs-lookup"><span data-stu-id="f0e7c-315">GuidAttribute</span></span>|<span data-ttu-id="f0e7c-316">存储为实际的自定义属性。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-316">Stored as a real custom attribute.</span></span>|<span data-ttu-id="f0e7c-317">作为真实的自定义属性进行访问。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-317">Accessed as a real custom attribute.</span></span>|  
|<span data-ttu-id="f0e7c-318">ComImportAttribute</span><span class="sxs-lookup"><span data-stu-id="f0e7c-318">ComImportAttribute</span></span>|<span data-ttu-id="f0e7c-319">CorTypeAttr.tdImport</span><span class="sxs-lookup"><span data-stu-id="f0e7c-319">CorTypeAttr.tdImport</span></span>|<span data-ttu-id="f0e7c-320">Type.Attributes.Import</span><span class="sxs-lookup"><span data-stu-id="f0e7c-320">Type.Attributes.Import</span></span>|  
|<span data-ttu-id="f0e7c-321">SerializableAttribute</span><span class="sxs-lookup"><span data-stu-id="f0e7c-321">SerializableAttribute</span></span>|<span data-ttu-id="f0e7c-322">CorTypeAttr.tdSerializable</span><span class="sxs-lookup"><span data-stu-id="f0e7c-322">CorTypeAttr.tdSerializable</span></span>|<span data-ttu-id="f0e7c-323">Type.Attributes.Serializable</span><span class="sxs-lookup"><span data-stu-id="f0e7c-323">Type.Attributes.Serializable</span></span>|  
|<span data-ttu-id="f0e7c-324">NonSerializedAttribute</span><span class="sxs-lookup"><span data-stu-id="f0e7c-324">NonSerializedAttribute</span></span>|<span data-ttu-id="f0e7c-325">CorFieldAttr.fdNotSerialized</span><span class="sxs-lookup"><span data-stu-id="f0e7c-325">CorFieldAttr.fdNotSerialized</span></span>|<span data-ttu-id="f0e7c-326">FieldInfo.Attributes.NotSerialized</span><span class="sxs-lookup"><span data-stu-id="f0e7c-326">FieldInfo.Attributes.NotSerialized</span></span>|  
|<span data-ttu-id="f0e7c-327">MethodImplAttribute</span><span class="sxs-lookup"><span data-stu-id="f0e7c-327">MethodImplAttribute</span></span>|<span data-ttu-id="f0e7c-328">CorMethodImpl</span><span class="sxs-lookup"><span data-stu-id="f0e7c-328">CorMethodImpl</span></span>|<span data-ttu-id="f0e7c-329">MethodInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="f0e7c-329">MethodInfo.GetMethodImplementationFlags()</span></span><br /><br /> <span data-ttu-id="f0e7c-330">ConstructorInfo. GetMethodImplementationFlags （）</span><span class="sxs-lookup"><span data-stu-id="f0e7c-330">ConstructorInfo.GetMethodImplementationFlags()</span></span>|  
|<span data-ttu-id="f0e7c-331">MarshalAsAttribute</span><span class="sxs-lookup"><span data-stu-id="f0e7c-331">MarshalAsAttribute</span></span>|<span data-ttu-id="f0e7c-332">各种位。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-332">Various bits.</span></span>|<span data-ttu-id="f0e7c-333">无访问器。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-333">No accessor.</span></span>|  
|<span data-ttu-id="f0e7c-334">PreserveSigAttribute</span><span class="sxs-lookup"><span data-stu-id="f0e7c-334">PreserveSigAttribute</span></span>|<span data-ttu-id="f0e7c-335">CorMethodImpl.miOLE</span><span class="sxs-lookup"><span data-stu-id="f0e7c-335">CorMethodImpl.miOLE</span></span>|<span data-ttu-id="f0e7c-336">GetMethodImplementationFlags （）。OLE</span><span class="sxs-lookup"><span data-stu-id="f0e7c-336">MethodInfo.GetMethodImplementationFlags().OLE</span></span><br /><br /> <span data-ttu-id="f0e7c-337">ConstructorInfo. GetMethodImplementationFlags （）。OLE</span><span class="sxs-lookup"><span data-stu-id="f0e7c-337">ConstructorInfo.GetMethodImplementationFlags().OLE</span></span>|  
|<span data-ttu-id="f0e7c-338">InAttribute</span><span class="sxs-lookup"><span data-stu-id="f0e7c-338">InAttribute</span></span>|<span data-ttu-id="f0e7c-339">CorParamAttr.pdIn</span><span class="sxs-lookup"><span data-stu-id="f0e7c-339">CorParamAttr.pdIn</span></span>|<span data-ttu-id="f0e7c-340">ParameterInfo.Attributes.In</span><span class="sxs-lookup"><span data-stu-id="f0e7c-340">ParameterInfo.Attributes.In</span></span>|  
|<span data-ttu-id="f0e7c-341">OutAttribute</span><span class="sxs-lookup"><span data-stu-id="f0e7c-341">OutAttribute</span></span>|<span data-ttu-id="f0e7c-342">CorParamAttr.pdOut</span><span class="sxs-lookup"><span data-stu-id="f0e7c-342">CorParamAttr.pdOut</span></span>|<span data-ttu-id="f0e7c-343">ParameterInfo.Attributes.Out</span><span class="sxs-lookup"><span data-stu-id="f0e7c-343">ParameterInfo.Attributes.Out</span></span>|  
|<span data-ttu-id="f0e7c-344">StructLayoutAttribute</span><span class="sxs-lookup"><span data-stu-id="f0e7c-344">StructLayoutAttribute</span></span>|<span data-ttu-id="f0e7c-345">CorTypeAttr.tdLayoutSequential</span><span class="sxs-lookup"><span data-stu-id="f0e7c-345">CorTypeAttr.tdLayoutSequential</span></span><br /><br /> <span data-ttu-id="f0e7c-346">CorTypeAttr.tdExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="f0e7c-346">CorTypeAttr.tdExplicitLayout</span></span><br /><br /> <span data-ttu-id="f0e7c-347">CorTypeAttr.tdAnsiClass</span><span class="sxs-lookup"><span data-stu-id="f0e7c-347">CorTypeAttr.tdAnsiClass</span></span><br /><br /> <span data-ttu-id="f0e7c-348">CorTypeAttr.tdUnicodeClass</span><span class="sxs-lookup"><span data-stu-id="f0e7c-348">CorTypeAttr.tdUnicodeClass</span></span><br /><br /> <span data-ttu-id="f0e7c-349">CorTypeAttr.tdAutoClass</span><span class="sxs-lookup"><span data-stu-id="f0e7c-349">CorTypeAttr.tdAutoClass</span></span><br /><br /> <span data-ttu-id="f0e7c-350">类打包。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-350">Class packing.</span></span>|<span data-ttu-id="f0e7c-351">Type.Attributes.LayoutSequential</span><span class="sxs-lookup"><span data-stu-id="f0e7c-351">Type.Attributes.LayoutSequential</span></span><br /><br /> <span data-ttu-id="f0e7c-352">Type.Attributes.ExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="f0e7c-352">Type.Attributes.ExplicitLayout</span></span><br /><br /> <span data-ttu-id="f0e7c-353">Type.Attributes.AnsiClass</span><span class="sxs-lookup"><span data-stu-id="f0e7c-353">Type.Attributes.AnsiClass</span></span><br /><br /> <span data-ttu-id="f0e7c-354">Type.Attributes.UnicodeClass</span><span class="sxs-lookup"><span data-stu-id="f0e7c-354">Type.Attributes.UnicodeClass</span></span><br /><br /> <span data-ttu-id="f0e7c-355">Type.Attributes.AutoClass</span><span class="sxs-lookup"><span data-stu-id="f0e7c-355">Type.Attributes.AutoClass</span></span><br /><br /> <span data-ttu-id="f0e7c-356">无访问器。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-356">No accessor.</span></span>|  
|<span data-ttu-id="f0e7c-357">FieldOffsetAttribute</span><span class="sxs-lookup"><span data-stu-id="f0e7c-357">FieldOffsetAttribute</span></span>|<span data-ttu-id="f0e7c-358">字段偏移量。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-358">Field offset.</span></span>|<span data-ttu-id="f0e7c-359">无访问器。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-359">No accessor.</span></span>|  
|<span data-ttu-id="f0e7c-360">AssemblyLoadAttribute</span><span class="sxs-lookup"><span data-stu-id="f0e7c-360">AssemblyLoadAttribute</span></span>|<span data-ttu-id="f0e7c-361">CorAssemblyFlags</span><span class="sxs-lookup"><span data-stu-id="f0e7c-361">CorAssemblyFlags</span></span>|<span data-ttu-id="f0e7c-362">无取值函数或枚举器。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-362">No accessor or enumerator.</span></span>|  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="f0e7c-363">当通过 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />的机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-363">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="f0e7c-364">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-364">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : Type * bool -&gt; obj[]&#xA;override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="assembly.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="f0e7c-365">要为其返回自定义属性的类型。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-365">The type for which the custom attributes are to be returned.</span></span></param>
        <param name="inherit"><span data-ttu-id="f0e7c-366">对于 <see cref="T:System.Reflection.Assembly" /> 类型的对象，将忽略此参数。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-366">This argument is ignored for objects of type <see cref="T:System.Reflection.Assembly" />.</span></span></param>
        <summary><span data-ttu-id="f0e7c-367">获取按类型指定的此程序集的自定义属性。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-367">Gets the custom attributes for this assembly as specified by type.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-368">一个数组，它包含由 <paramref name="attributeType" /> 指定的此程序集的自定义属性。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-368">An array that contains the custom attributes for this assembly as specified by <paramref name="attributeType" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-369">此方法实现相应的 <xref:System.Reflection.ICustomAttributeProvider> 接口方法。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-369">This method implements the corresponding <xref:System.Reflection.ICustomAttributeProvider> interface method.</span></span> <span data-ttu-id="f0e7c-370">因此，必须指定 `inherit` 参数，即使该参数被忽略。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-370">Therefore, the `inherit` parameter must be specified even though it is ignored.</span></span>  
  
 <span data-ttu-id="f0e7c-371">伪属性指示在属性存在时必须设置的核心元数据的位数。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-371">A pseudo-attribute indicates bits of the core metadata that must be set when the attribute is present.</span></span> <span data-ttu-id="f0e7c-372">与扩展类型的元数据的自定义特性不同，与类型一起保存时，伪特性会修改类型的元数据，然后被丢弃。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-372">Unlike a custom attribute that extends the metadata for a type and is saved along with the type, a pseudo-attribute modifies the metadata for the type and then is discarded.</span></span> <span data-ttu-id="f0e7c-373">某些生成的位无法使用现有的反射 Api 进行访问。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-373">Some of the resulting bits cannot be accessed using existing reflection APIs.</span></span>  
  
 <span data-ttu-id="f0e7c-374">下表总结了反射中可用的位的不同伪属性和访问器。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-374">The following table summarizes the different pseudo-attributes and the accessors for the bits that are available in reflection.</span></span>  
  
|<span data-ttu-id="f0e7c-375">伪特性</span><span class="sxs-lookup"><span data-stu-id="f0e7c-375">Pseudo-Attribute</span></span>|<span data-ttu-id="f0e7c-376">元数据位</span><span class="sxs-lookup"><span data-stu-id="f0e7c-376">Metadata Bits</span></span>|<span data-ttu-id="f0e7c-377">反射访问器</span><span class="sxs-lookup"><span data-stu-id="f0e7c-377">Reflection Accessor</span></span>|  
|-----------------------|-------------------|-------------------------|  
|<span data-ttu-id="f0e7c-378">Sub</span><span class="sxs-lookup"><span data-stu-id="f0e7c-378">DllImportAttribute</span></span>|<span data-ttu-id="f0e7c-379">CorPInvokeMap</span><span class="sxs-lookup"><span data-stu-id="f0e7c-379">CorPInvokeMap</span></span><br /><br /> <span data-ttu-id="f0e7c-380">DLL 名称</span><span class="sxs-lookup"><span data-stu-id="f0e7c-380">DLL name</span></span>|<span data-ttu-id="f0e7c-381">对于普通方法/全局方法特性，没有适用于 PInvokeMap 的访问器。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-381">No accessor for PInvokeMap for ordinary method/global method attributes.</span></span><br /><br /> <span data-ttu-id="f0e7c-382">没有 DLL 名称的访问器。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-382">No accessor for DLL name.</span></span>|  
|<span data-ttu-id="f0e7c-383">GuidAttribute</span><span class="sxs-lookup"><span data-stu-id="f0e7c-383">GuidAttribute</span></span>|<span data-ttu-id="f0e7c-384">存储为实际的自定义属性。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-384">Stored as a real custom attribute.</span></span>|<span data-ttu-id="f0e7c-385">作为真实的自定义属性进行访问。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-385">Accessed as a real custom attribute.</span></span>|  
|<span data-ttu-id="f0e7c-386">ComImportAttribute</span><span class="sxs-lookup"><span data-stu-id="f0e7c-386">ComImportAttribute</span></span>|<span data-ttu-id="f0e7c-387">CorTypeAttr.tdImport</span><span class="sxs-lookup"><span data-stu-id="f0e7c-387">CorTypeAttr.tdImport</span></span>|<span data-ttu-id="f0e7c-388">Type.Attributes.Import</span><span class="sxs-lookup"><span data-stu-id="f0e7c-388">Type.Attributes.Import</span></span>|  
|<span data-ttu-id="f0e7c-389">SerializableAttribute</span><span class="sxs-lookup"><span data-stu-id="f0e7c-389">SerializableAttribute</span></span>|<span data-ttu-id="f0e7c-390">CorTypeAttr.tdSerializable</span><span class="sxs-lookup"><span data-stu-id="f0e7c-390">CorTypeAttr.tdSerializable</span></span>|<span data-ttu-id="f0e7c-391">Type.Attributes.Serializable</span><span class="sxs-lookup"><span data-stu-id="f0e7c-391">Type.Attributes.Serializable</span></span>|  
|<span data-ttu-id="f0e7c-392">NonSerializedAttribute</span><span class="sxs-lookup"><span data-stu-id="f0e7c-392">NonSerializedAttribute</span></span>|<span data-ttu-id="f0e7c-393">CorFieldAttr.fdNotSerialized</span><span class="sxs-lookup"><span data-stu-id="f0e7c-393">CorFieldAttr.fdNotSerialized</span></span>|<span data-ttu-id="f0e7c-394">FieldInfo.Attributes.NotSerialized</span><span class="sxs-lookup"><span data-stu-id="f0e7c-394">FieldInfo.Attributes.NotSerialized</span></span>|  
|<span data-ttu-id="f0e7c-395">MethodImplAttribute</span><span class="sxs-lookup"><span data-stu-id="f0e7c-395">MethodImplAttribute</span></span>|<span data-ttu-id="f0e7c-396">CorMethodImpl</span><span class="sxs-lookup"><span data-stu-id="f0e7c-396">CorMethodImpl</span></span>|<span data-ttu-id="f0e7c-397">MethodInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="f0e7c-397">MethodInfo.GetMethodImplementationFlags()</span></span><br /><br /> <span data-ttu-id="f0e7c-398">ConstructorInfo. GetMethodImplementationFlags （）</span><span class="sxs-lookup"><span data-stu-id="f0e7c-398">ConstructorInfo.GetMethodImplementationFlags()</span></span>|  
|<span data-ttu-id="f0e7c-399">MarshalAsAttribute</span><span class="sxs-lookup"><span data-stu-id="f0e7c-399">MarshalAsAttribute</span></span>|<span data-ttu-id="f0e7c-400">各种位。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-400">Various bits.</span></span>|<span data-ttu-id="f0e7c-401">无访问器。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-401">No accessor.</span></span>|  
|<span data-ttu-id="f0e7c-402">PreserveSigAttribute</span><span class="sxs-lookup"><span data-stu-id="f0e7c-402">PreserveSigAttribute</span></span>|<span data-ttu-id="f0e7c-403">CorMethodImpl.miOLE</span><span class="sxs-lookup"><span data-stu-id="f0e7c-403">CorMethodImpl.miOLE</span></span>|<span data-ttu-id="f0e7c-404">GetMethodImplementationFlags （）。OLE</span><span class="sxs-lookup"><span data-stu-id="f0e7c-404">MethodInfo.GetMethodImplementationFlags().OLE</span></span><br /><br /> <span data-ttu-id="f0e7c-405">ConstructorInfo. GetMethodImplementationFlags （）。OLE</span><span class="sxs-lookup"><span data-stu-id="f0e7c-405">ConstructorInfo.GetMethodImplementationFlags().OLE</span></span>|  
|<span data-ttu-id="f0e7c-406">InAttribute</span><span class="sxs-lookup"><span data-stu-id="f0e7c-406">InAttribute</span></span>|<span data-ttu-id="f0e7c-407">CorParamAttr.pdIn</span><span class="sxs-lookup"><span data-stu-id="f0e7c-407">CorParamAttr.pdIn</span></span>|<span data-ttu-id="f0e7c-408">ParameterInfo.Attributes.In</span><span class="sxs-lookup"><span data-stu-id="f0e7c-408">ParameterInfo.Attributes.In</span></span>|  
|<span data-ttu-id="f0e7c-409">OutAttribute</span><span class="sxs-lookup"><span data-stu-id="f0e7c-409">OutAttribute</span></span>|<span data-ttu-id="f0e7c-410">CorParamAttr.pdOut</span><span class="sxs-lookup"><span data-stu-id="f0e7c-410">CorParamAttr.pdOut</span></span>|<span data-ttu-id="f0e7c-411">ParameterInfo.Attributes.Out</span><span class="sxs-lookup"><span data-stu-id="f0e7c-411">ParameterInfo.Attributes.Out</span></span>|  
|<span data-ttu-id="f0e7c-412">StructLayoutAttribute</span><span class="sxs-lookup"><span data-stu-id="f0e7c-412">StructLayoutAttribute</span></span>|<span data-ttu-id="f0e7c-413">CorTypeAttr.tdLayoutSequential</span><span class="sxs-lookup"><span data-stu-id="f0e7c-413">CorTypeAttr.tdLayoutSequential</span></span><br /><br /> <span data-ttu-id="f0e7c-414">CorTypeAttr.tdExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="f0e7c-414">CorTypeAttr.tdExplicitLayout</span></span><br /><br /> <span data-ttu-id="f0e7c-415">CorTypeAttr.tdAnsiClass</span><span class="sxs-lookup"><span data-stu-id="f0e7c-415">CorTypeAttr.tdAnsiClass</span></span><br /><br /> <span data-ttu-id="f0e7c-416">CorTypeAttr.tdUnicodeClass</span><span class="sxs-lookup"><span data-stu-id="f0e7c-416">CorTypeAttr.tdUnicodeClass</span></span><br /><br /> <span data-ttu-id="f0e7c-417">CorTypeAttr.tdAutoClass</span><span class="sxs-lookup"><span data-stu-id="f0e7c-417">CorTypeAttr.tdAutoClass</span></span><br /><br /> <span data-ttu-id="f0e7c-418">类打包。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-418">Class packing.</span></span>|<span data-ttu-id="f0e7c-419">Type.Attributes.LayoutSequential</span><span class="sxs-lookup"><span data-stu-id="f0e7c-419">Type.Attributes.LayoutSequential</span></span><br /><br /> <span data-ttu-id="f0e7c-420">Type.Attributes.ExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="f0e7c-420">Type.Attributes.ExplicitLayout</span></span><br /><br /> <span data-ttu-id="f0e7c-421">Type.Attributes.AnsiClass</span><span class="sxs-lookup"><span data-stu-id="f0e7c-421">Type.Attributes.AnsiClass</span></span><br /><br /> <span data-ttu-id="f0e7c-422">Type.Attributes.UnicodeClass</span><span class="sxs-lookup"><span data-stu-id="f0e7c-422">Type.Attributes.UnicodeClass</span></span><br /><br /> <span data-ttu-id="f0e7c-423">Type.Attributes.AutoClass</span><span class="sxs-lookup"><span data-stu-id="f0e7c-423">Type.Attributes.AutoClass</span></span><br /><br /> <span data-ttu-id="f0e7c-424">无访问器。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-424">No accessor.</span></span>|  
|<span data-ttu-id="f0e7c-425">FieldOffsetAttribute</span><span class="sxs-lookup"><span data-stu-id="f0e7c-425">FieldOffsetAttribute</span></span>|<span data-ttu-id="f0e7c-426">字段偏移量。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-426">Field offset.</span></span>|<span data-ttu-id="f0e7c-427">无访问器。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-427">No accessor.</span></span>|  
|<span data-ttu-id="f0e7c-428">AssemblyLoadAttribute</span><span class="sxs-lookup"><span data-stu-id="f0e7c-428">AssemblyLoadAttribute</span></span>|<span data-ttu-id="f0e7c-429">CorAssemblyFlags</span><span class="sxs-lookup"><span data-stu-id="f0e7c-429">CorAssemblyFlags</span></span>|<span data-ttu-id="f0e7c-430">无取值函数或枚举器。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-430">No accessor or enumerator.</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-431"><paramref name="attributeType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-431"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f0e7c-432"><paramref name="attributeType" /> 不是运行时类型。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-432"><paramref name="attributeType" /> is not a runtime type.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="f0e7c-433">当通过 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />的机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-433">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="f0e7c-434">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-434">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;&#xA;override this.GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;" Usage="assembly.GetCustomAttributesData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f0e7c-435">返回有关已应用于当前 <see cref="T:System.Reflection.Assembly" />（表示为 <see cref="T:System.Reflection.CustomAttributeData" /> 对象）的特性的信息。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-435">Returns information about the attributes that have been applied to the current <see cref="T:System.Reflection.Assembly" />, expressed as <see cref="T:System.Reflection.CustomAttributeData" /> objects.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-436"><see cref="T:System.Reflection.CustomAttributeData" /> 对象的泛型列表，这些对象表示有关已应用于当前程序集的特性的数据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-436">A generic list of <see cref="T:System.Reflection.CustomAttributeData" /> objects representing data about the attributes that have been applied to the current assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-437">如果自定义属性本身是在加载到仅反射上下文中的代码中定义的，则使用此方法在仅反射上下文中检查代码的自定义属性。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-437">Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</span></span> <span data-ttu-id="f0e7c-438">在这种情况下，不能使用诸如 <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> 和 <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> 这样的方法，因为它们会创建特性的实例。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-438">Methods like <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> and <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> cannot be used in such cases, because they create instances of the attributes.</span></span> <span data-ttu-id="f0e7c-439">仅反射上下文中的代码无法执行。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-439">Code in the reflection-only context cannot be executed.</span></span> <span data-ttu-id="f0e7c-440">有关详细信息和示例代码，请参阅 <xref:System.Reflection.CustomAttributeData> 类。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-440">For more information and for example code, see the <xref:System.Reflection.CustomAttributeData> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntryAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetEntryAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetEntryAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetEntryAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEntryAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetEntryAssembly();" />
      <MemberSignature Language="F#" Value="static member GetEntryAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetEntryAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f0e7c-441">获取默认应用程序域中的进程可执行文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-441">Gets the process executable in the default application domain.</span></span> <span data-ttu-id="f0e7c-442">在其他的应用程序域中，这是由 <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /> 执行的第一个可执行文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-442">In other application domains, this is the first executable that was executed by <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-443">程序集是默认应用程序域中的进程可执行文件，或是由 <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /> 执行的第一个可执行文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-443">The assembly that is the process executable in the default application domain, or the first executable that was executed by <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</span></span> <span data-ttu-id="f0e7c-444">当从非托管代码调用时可返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-444">Can return <see langword="null" /> when called from unmanaged code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-445">当托管程序集已从非托管应用程序加载时，<xref:System.Reflection.Assembly.GetEntryAssembly%2A> 方法可以返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-445">The <xref:System.Reflection.Assembly.GetEntryAssembly%2A> method can return `null` when a managed assembly has been loaded from an unmanaged application.</span></span> <span data-ttu-id="f0e7c-446">例如，如果非托管应用程序创建用编写的 COM 组件的实例C#，则从C#组件对 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> 方法的调用将返回 null，因为进程的入口点是非托管代码而不是托管程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-446">For example, if an unmanaged application creates an instance of a COM component written in C#, a call to the <xref:System.Reflection.Assembly.GetEntryAssembly%2A> method from the C# component returns null, because the entry point for the process was unmanaged code rather than a managed assembly.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExecutingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetExecutingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetExecutingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExecutingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExecutingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetExecutingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetExecutingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetExecutingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f0e7c-447">获取包含当前执行的代码的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-447">Gets the assembly that contains the code that is currently executing.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-448">包含当前执行的代码的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-448">The assembly that contains the code that is currently executing.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-449">出于性能方面的原因，只有在设计时不知道当前正在执行的程序集时，才应调用此方法。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-449">For performance reasons, you should call this method only when you do not know at design time what assembly is currently executing.</span></span> <span data-ttu-id="f0e7c-450">检索表示当前程序集的 <xref:System.Reflection.Assembly> 对象的建议方法是使用程序集中找到的类型的 <xref:System.Type.Assembly%2A?displayProperty=nameWithType> 属性，如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-450">The recommended way to retrieve an <xref:System.Reflection.Assembly> object that represents the current assembly is to use the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property of a type found in the assembly, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/assembly1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/assembly1.vb#1)]  
  
 <span data-ttu-id="f0e7c-451">若要获取包含调用当前正在执行的代码的方法的程序集，请使用 <xref:System.Reflection.Assembly.GetCallingAssembly%2A>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-451">To get the assembly that contains the method that called the currently executing code, use <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f0e7c-452">下面的示例使用 <xref:System.Type.Assembly%2A?displayProperty=nameWithType> 属性基于该程序集中包含的类型获取当前正在执行的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-452">The following example uses the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property to get the currently executing assembly based on a type contained in that assembly.</span></span> <span data-ttu-id="f0e7c-453">它还会调用 <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> 方法，以显示该方法返回表示同一程序集的 <xref:System.Reflection.Assembly> 对象。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-453">It also calls the <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> method to show that it returns an <xref:System.Reflection.Assembly> object that represents the same assembly.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cpp/getexecutingassembly1.cpp#5)]
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/getexecutingassembly1.cs#5)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/getexecutingassembly1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetExportedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetExportedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetExportedTypes : unit -&gt; Type[]&#xA;override this.GetExportedTypes : unit -&gt; Type[]" Usage="assembly.GetExportedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetExportedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f0e7c-454">获取此程序集中定义的公共类型，这些公共类型在程序集外可见。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-454">Gets the public types defined in this assembly that are visible outside the assembly.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-455">一个数组，表示此程序集中定义并在程序集外可见的类型。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-455">An array that represents the types defined in this assembly that are visible outside the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-456">仅在程序集外可见的类型为公共类型和嵌套在其他公共类型中的公共类型。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-456">The only types visible outside an assembly are public types and public types nested within other public types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f0e7c-457">下面的代码示例定义了多个具有不同访问级别的类，并调用 <xref:System.Reflection.Assembly.GetExportedTypes%2A> 显示从程序集外部可见的类。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-457">The following code sample defines a number of classes with various access levels, and calls <xref:System.Reflection.Assembly.GetExportedTypes%2A> to display the ones that are visible from outside the assembly.</span></span>  
  
 [!code-cpp[Assembly.GetExportedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.GetExportedTypes/CPP/source.cpp#1)]
 [!code-csharp[Assembly.GetExportedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.GetExportedTypes/CS/source.cs#1)]
 [!code-vb[Assembly.GetExportedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.GetExportedTypes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f0e7c-458">程序集是动态程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-458">The assembly is a dynamic assembly.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-459">无法加载从属程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-459">Unable to load a dependent assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFile (name As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::FileStream ^ GetFile(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetFile : string -&gt; System.IO.FileStream&#xA;override this.GetFile : string -&gt; System.IO.FileStream" Usage="assembly.GetFile name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFile(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="f0e7c-460">指定文件的名称。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-460">The name of the specified file.</span></span> <span data-ttu-id="f0e7c-461">不包括文件的路径。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-461">Do not include the path to the file.</span></span></param>
        <summary><span data-ttu-id="f0e7c-462">获取此程序集清单的文件表中指定文件的 <see cref="T:System.IO.FileStream" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-462">Gets a <see cref="T:System.IO.FileStream" /> for the specified file in the file table of the manifest of this assembly.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-463">包含指定文件的流，如果找不到文件则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-463">A stream that contains the specified file, or <see langword="null" /> if the file is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-464">此方法适用于公用和专用资源文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-464">This method works on both public and private resource files.</span></span>  
  
 <span data-ttu-id="f0e7c-465">`name` 不应包含文件的路径。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-465">The `name` should not include the path to the file.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-466">无法加载已找到的文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-466">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-467"><paramref name="name" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-467">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f0e7c-468"><paramref name="name" /> 参数为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-468">The <paramref name="name" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-469">未找到 <paramref name="name" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-469"><paramref name="name" /> was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-470"><paramref name="name" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-470"><paramref name="name" /> is not a valid assembly.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="f0e7c-471">用于访问路径和读取指定的文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-471">for access to the path and for reading the specified file.</span></span> <span data-ttu-id="f0e7c-472">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> 和 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-472">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f0e7c-473">获取程序集清单文件表中的文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-473">Gets the files in the file table of an assembly manifest.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles () As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles();" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : unit -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : unit -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f0e7c-474">获取程序集清单文件表中的文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-474">Gets the files in the file table of an assembly manifest.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-475">包含这些文件的流数组。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-475">An array of streams that contain the files.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-476">此方法适用于公用和专用资源文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-476">This method works on public and private resource files.</span></span>  
  
 <span data-ttu-id="f0e7c-477">此重载等效于调用 <xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29> 重载并指定 `false`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-477">This overload is equivalent to calling the <xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29> overload and specifying `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-478">无法加载已找到的文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-478">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-479">未找到文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-479">A file was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-480">文件不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-480">A file was not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles (getResourceModules As Boolean) As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : bool -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : bool -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="getResourceModules"><span data-ttu-id="f0e7c-481"><see langword="true" /> 则包括资源模块；否则，为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-481"><see langword="true" /> to include resource modules; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f0e7c-482">获取程序集清单的文件表中的文件，指定是否包括资源模块。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-482">Gets the files in the file table of an assembly manifest, specifying whether to include resource modules.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-483">包含这些文件的流数组。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-483">An array of streams that contain the files.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-484">此方法适用于公用和专用资源文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-484">This method works on public and private resource files.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-485">无法加载已找到的文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-485">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-486">未找到文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-486">A file was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-487">文件不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-487">A file was not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetForwardedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetForwardedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetForwardedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetForwardedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetForwardedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetForwardedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetForwardedTypes : unit -&gt; Type[]&#xA;override this.GetForwardedTypes : unit -&gt; Type[]" Usage="assembly.GetForwardedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="assembly.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f0e7c-488">返回此实例的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-488">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-489">32 位有符号整数哈希代码。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-489">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLoadedModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f0e7c-490">获取作为此程序集的一部分的所有加载模块。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-490">Gets all the loaded modules that are part of this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetLoadedModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Module[] GetLoadedModules() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLoadedModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.GetLoadedModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f0e7c-491">获取作为此程序集的一部分的所有加载模块。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-491">Gets all the loaded modules that are part of this assembly.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-492">模块的数组。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-492">An array of modules.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLoadedModules (getResourceModules As Boolean) As Module()" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules getResourceModules" />
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLoadedModules (getResourceModules As Boolean) As Module()" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="getResourceModules"><span data-ttu-id="f0e7c-493"><see langword="true" /> 则包括资源模块；否则，为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-493"><see langword="true" /> to include resource modules; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f0e7c-494">获取属于此程序集的所有已加载模块，同时指定是否包括资源模块。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-494">Gets all the loaded modules that are part of this assembly, specifying whether to include resource modules.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-495">模块的数组。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-495">An array of modules.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceInfo (resourceName As String) As ManifestResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ManifestResourceInfo ^ GetManifestResourceInfo(System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo&#xA;override this.GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo" Usage="assembly.GetManifestResourceInfo resourceName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceInfo(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName"><span data-ttu-id="f0e7c-496">区分大小写的资源名称。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-496">The case-sensitive name of the resource.</span></span></param>
        <summary><span data-ttu-id="f0e7c-497">返回关于给定资源如何保持的信息。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-497">Returns information about how the given resource has been persisted.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-498">用关于资源拓扑的信息填充的对象；如果未找到资源，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-498">An object that is populated with information about the resource's topology, or <see langword="null" /> if the resource is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-499">仅当资源对调用方可见，或调用方已 <xref:System.Security.Permissions.ReflectionPermission>时，才返回资源信息。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-499">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-500"><paramref name="resourceName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-500"><paramref name="resourceName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f0e7c-501"><paramref name="resourceName" /> 参数为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-501">The <paramref name="resourceName" /> parameter is an empty string ("").</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="f0e7c-502">当通过 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />的机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-502">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="f0e7c-503">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-503">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetManifestResourceNames();" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceNames : unit -&gt; string[]&#xA;override this.GetManifestResourceNames : unit -&gt; string[]" Usage="assembly.GetManifestResourceNames " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceNames</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f0e7c-504">返回此程序集中的所有资源的名称。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-504">Returns the names of all the resources in this assembly.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-505">包含所有资源名称的数组。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-505">An array that contains the names of all the resources.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-506">您可以使用此方法返回的数组中的每个资源名称，如下所示：</span><span class="sxs-lookup"><span data-stu-id="f0e7c-506">You can use each resource name in the array returned by this method as follows:</span></span>  
  
-   <span data-ttu-id="f0e7c-507">可以将资源名称传递到 <xref:System.Reflection.Assembly.GetManifestResourceInfo%2A> 方法，以获取有关资源的其他信息。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-507">You can pass the resource name to the <xref:System.Reflection.Assembly.GetManifestResourceInfo%2A> method to get additional information about the resource.</span></span>  
  
-   <span data-ttu-id="f0e7c-508">如果该名称标识一个二进制 .resources 文件，则可以删除其 .resources 文件扩展名，并将其传递给 <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType> 构造函数以实例化资源管理器。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-508">If the name identifies a binary .resources file, you can remove its .resources file extension and pass it to the <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType> constructor to instantiate the resource manager.</span></span>  
  
-   <span data-ttu-id="f0e7c-509">可以将资源名称传递到 <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> 方法，以检索 <xref:System.IO.Stream> 对象，然后可以将该对象传递到 <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> 构造函数。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-509">You can pass the resource name to the <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> method to retrieve a <xref:System.IO.Stream> object that you can then pass to the <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> constructor.</span></span>  
  
-   <span data-ttu-id="f0e7c-510">可以将资源名称传递到 <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> 方法，以检索 <xref:System.IO.Stream> 对象，然后可以将该对象传递到 <xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> 构造函数。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-510">You can pass the resource name to the <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> method to retrieve a <xref:System.IO.Stream> object that you can then pass to the <xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> constructor.</span></span>  
  
 <span data-ttu-id="f0e7c-511">仅当资源对调用方可见，或调用方已 <xref:System.Security.Permissions.ReflectionPermission>时，才返回资源信息。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-511">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="f0e7c-512">当通过 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />的机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-512">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="f0e7c-513">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-513">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetManifestResourceStream">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f0e7c-514">从此程序集加载指定的清单资源。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-514">Loads the specified manifest resource from this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceStream (name As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="f0e7c-515">所请求的清单资源的名称（区分大小写）。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-515">The case-sensitive name of the manifest resource being requested.</span></span></param>
        <summary><span data-ttu-id="f0e7c-516">从此程序集加载指定的清单资源。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-516">Loads the specified manifest resource from this assembly.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-517">如果在编译期间没有指定任何资源，或者资源对调用方不可见，则为清单资源或者为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-517">The manifest resource; or <see langword="null" /> if no resources were specified during compilation or if the resource is not visible to the caller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-518">清单资源是在编译时嵌入到程序集中的资源（如图像文件）。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-518">A manifest resource is a resource (such as an image file) that is embedded in the assembly at compile time.</span></span> <span data-ttu-id="f0e7c-519">有关清单资源的详细信息，请参阅 MSDN Library 中的[Microsoft .NET Framework 资源基础知识](https://go.microsoft.com/fwlink/?LinkId=204554)。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-519">For more information about manifest resources, see [Microsoft .NET Framework Resource Basics](https://go.microsoft.com/fwlink/?LinkId=204554) in the MSDN Library.</span></span>  
  
 <span data-ttu-id="f0e7c-520">仅当资源对调用方可见，或调用方已 <xref:System.Security.Permissions.ReflectionPermission>时，才返回资源信息。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-520">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f0e7c-521">如果访问另一个程序集中的私有资源，并且调用方没有具有 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission>，则此方法返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-521">This method returns `null` if a private resource in another assembly is accessed and the caller does not have <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="f0e7c-522">如果程序集清单列出了一个资源文件，即使在磁盘上找不到该资源文件，<xref:System.Reflection.Assembly.GetManifestResourceStream%2A> 也会返回一个 <xref:System.IO.Stream> 对象。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-522">If the assembly manifest lists a resource file, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> returns a <xref:System.IO.Stream> object even if the resource file cannot be found on disk at the time.</span></span> <span data-ttu-id="f0e7c-523">如果找不到资源文件，则将生成的 <xref:System.IO.Stream> 对象传递到 <xref:System.Resources.ResourceReader> 构造函数将导致 <xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-523">If the resource file is not found, passing the resulting <xref:System.IO.Stream> object to the <xref:System.Resources.ResourceReader> constructor causes an <xref:System.ArgumentException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-524"><paramref name="name" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-524">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f0e7c-525"><paramref name="name" /> 参数为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-525">The <paramref name="name" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="f0e7c-526">在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.IO.IOException" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-526">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="f0e7c-527">无法加载已找到的文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-527">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-528">未找到 <paramref name="name" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-528"><paramref name="name" /> was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-529"><paramref name="name" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-529"><paramref name="name" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="f0e7c-530">资源的长度大于 <see cref="F:System.Int64.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-530">Resource length is greater than <see cref="F:System.Int64.MaxValue" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="f0e7c-531">当通过 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />的机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-531">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="f0e7c-532">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-532">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/standard/assembly/manifest.md"><span data-ttu-id="f0e7c-533">程序集清单</span><span class="sxs-lookup"><span data-stu-id="f0e7c-533">Assembly Manifest</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : Type * string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : Type * string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream (type, name)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="f0e7c-534">其命名空间用于确定清单资源名的范围的类型。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-534">The type whose namespace is used to scope the manifest resource name.</span></span></param>
        <param name="name"><span data-ttu-id="f0e7c-535">所请求的清单资源的名称（区分大小写）。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-535">The case-sensitive name of the manifest resource being requested.</span></span></param>
        <summary><span data-ttu-id="f0e7c-536">从此程序集加载指定清单资源，清单资源的范围由指定类型的命名空间确定。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-536">Loads the specified manifest resource, scoped by the namespace of the specified type, from this assembly.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-537">如果在编译期间没有指定任何资源，或者资源对调用方不可见，则为清单资源或者为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-537">The manifest resource; or <see langword="null" /> if no resources were specified during compilation or if the resource is not visible to the caller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-538">例如，如果为 `type` 指定的全名是 "MyClasses"，而 `name` 是 "Net"，则此方法重载将搜索名为 "MyNameSpace.Net" 的资源。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-538">For example, if the full name specified for `type` is "MyNameSpace.MyClasses" and `name` is "Net", this method overload searches for a resource named "MyNameSpace.Net".</span></span>  
  
 <span data-ttu-id="f0e7c-539">清单资源是在编译时嵌入到程序集中的资源（如图像文件）。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-539">A manifest resource is a resource (such as an image file) that is embedded in the assembly at compile time.</span></span> <span data-ttu-id="f0e7c-540">有关清单资源的详细信息，请参阅 MSDN Library 中的[Microsoft .NET Framework 资源基础知识](https://go.microsoft.com/fwlink/?LinkId=204554)。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-540">For more information about manifest resources, see [Microsoft .NET Framework Resource Basics](https://go.microsoft.com/fwlink/?LinkId=204554) in the MSDN Library.</span></span>  
  
 <span data-ttu-id="f0e7c-541">仅当资源对调用方可见，或调用方已 <xref:System.Security.Permissions.ReflectionPermission>时，才返回资源信息。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-541">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f0e7c-542">如果访问另一个程序集中的私有资源，并且调用方没有具有 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 标志的 <xref:System.Security.Permissions.ReflectionPermission>，则此方法返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-542">This method returns `null` if a private resource in another assembly is accessed and the caller does not have <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="f0e7c-543">如果程序集清单列出了一个资源文件，即使在磁盘上找不到该资源文件，<xref:System.Reflection.Assembly.GetManifestResourceStream%2A> 也会返回一个 <xref:System.IO.Stream> 对象。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-543">If the assembly manifest lists a resource file, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> returns a <xref:System.IO.Stream> object even if the resource file cannot be found on disk at the time.</span></span> <span data-ttu-id="f0e7c-544">如果找不到资源文件，则将生成的 <xref:System.IO.Stream> 对象传递到 <xref:System.Resources.ResourceReader> 构造函数将导致 <xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-544">If the resource file is not found, passing the resulting <xref:System.IO.Stream> object to the <xref:System.Resources.ResourceReader> constructor causes an <xref:System.ArgumentException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-545"><paramref name="name" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-545">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f0e7c-546"><paramref name="name" /> 参数为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-546">The <paramref name="name" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-547">无法加载已找到的文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-547">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-548">未找到 <paramref name="name" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-548"><paramref name="name" /> was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-549"><paramref name="name" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-549"><paramref name="name" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="f0e7c-550">资源的长度大于 <see cref="F:System.Int64.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-550">Resource length is greater than <see cref="F:System.Int64.MaxValue" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="f0e7c-551">当通过 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />的机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-551">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="f0e7c-552">关联的枚举： <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-552">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/standard/assembly/manifest.md"><span data-ttu-id="f0e7c-553">程序集清单</span><span class="sxs-lookup"><span data-stu-id="f0e7c-553">Assembly Manifest</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module GetModule (string name);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModule(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModule (name As String) As Module" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ GetModule(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetModule : string -&gt; System.Reflection.Module&#xA;override this.GetModule : string -&gt; System.Reflection.Module" Usage="assembly.GetModule name" />
      <MemberSignature Language="C#" Value="public System.Reflection.Module GetModule (string name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModule (name As String) As Module" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModule(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="f0e7c-554">请求的模块的名称。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-554">The name of the module being requested.</span></span></param>
        <summary><span data-ttu-id="f0e7c-555">获取此程序集中的指定模块。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-555">Gets the specified module in this assembly.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-556">所请求的模块，若未找到该模块则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-556">The module being requested, or <see langword="null" /> if the module is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-557">此方法适用于文件名。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-557">This method works on file names.</span></span>  
  
 <span data-ttu-id="f0e7c-558">`Reflection.Emit` 命名空间中的类发出动态模块的范围名称。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-558">Classes in the `Reflection.Emit` namespace emit the scope name for a dynamic module.</span></span> <span data-ttu-id="f0e7c-559">作用域名称可由 <xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType> 属性确定。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-559">The scope name can be determined by the <xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="f0e7c-560">传递要 `Assembly.GetModule`的模块的类型。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-560">Pass the kind of module you want to `Assembly.GetModule`.</span></span> <span data-ttu-id="f0e7c-561">例如，如果你想要包含程序集清单的模块，请将模块的范围名称传递到 `GetModule`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-561">For example, if you want the module that contains the assembly manifest, pass the scope name of the module to `GetModule`.</span></span> <span data-ttu-id="f0e7c-562">否则，传递模块的文件名。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-562">Otherwise, pass the file name of the module.</span></span> <span data-ttu-id="f0e7c-563">由具有 byte [] 参数的 `Load` 方法之一加载的程序集只有一个模块，即清单模块。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-563">Assemblies loaded by one of the `Load` methods that have a byte[] parameter have only one module, and that is the manifest module.</span></span> <span data-ttu-id="f0e7c-564">始终使用作用域名称查找这些模块。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-564">Always seek these modules using the scope name.</span></span>  
  
 <span data-ttu-id="f0e7c-565">可使用 <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>从特定模块检索类型。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-565">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f0e7c-566">对包含清单的模块调用 `Module.GetType` 不会启动整个程序集的搜索。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-566">Calling `Module.GetType` on the module containing the manifest will not initiate a search of the entire assembly.</span></span> <span data-ttu-id="f0e7c-567">若要从程序集中检索某一类型，而不管它处于哪个模块，则必须调用 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-567">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-568"><paramref name="name" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-568">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f0e7c-569"><paramref name="name" /> 参数为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-569">The <paramref name="name" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-570">无法加载已找到的文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-570">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-571">未找到 <paramref name="name" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-571"><paramref name="name" /> was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-572"><paramref name="name" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-572"><paramref name="name" /> is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f0e7c-573">获取作为此程序集的一部分的所有模块。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-573">Gets all the modules that are part of this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Module[] GetModules() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.GetModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetModules " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetModules " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f0e7c-574">获取作为此程序集的一部分的所有模块。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-574">Gets all the modules that are part of this assembly.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-575">模块的数组。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-575">An array of modules.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-576">此方法适用于公用和专用资源文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-576">This method works on public and private resource files.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f0e7c-577">必须用文件扩展名发出模块。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-577">Modules must be emitted with file name extensions.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f0e7c-578">下面的示例显示返回的数组中包含程序集清单的模块的名称。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-578">The following example displays the name of the module in the returned array that contains the assembly manifest.</span></span>  
  
 [!code-cpp[Classic Assembly.GetModules Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Assembly.GetModules Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CS/source.cs#1)]
 [!code-vb[Classic Assembly.GetModules Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-579">要加载的模块未指定文件扩展名。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-579">The module to be loaded does not specify a file name extension.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetModules (bool getResourceModules);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModules (getResourceModules As Boolean) As Module()" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetModules getResourceModules" />
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetModules (bool getResourceModules);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModules (getResourceModules As Boolean) As Module()" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="getResourceModules"><span data-ttu-id="f0e7c-580"><see langword="true" /> 则包括资源模块；否则，为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-580"><see langword="true" /> to include resource modules; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f0e7c-581">获取属于此程序集的所有模块，同时指定是否包括资源模块。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-581">Gets all the modules that are part of this assembly, specifying whether to include resource modules.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-582">模块的数组。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-582">An array of modules.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-583">此方法适用于公用和专用资源文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-583">This method works on public and private resource files.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f0e7c-584">必须用文件扩展名发出模块。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-584">Modules must be emitted with file name extensions.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetName">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f0e7c-585">获取此程序集的 <see cref="T:System.Reflection.AssemblyName" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-585">Gets an <see cref="T:System.Reflection.AssemblyName" /> for this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName () As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName();" />
      <MemberSignature Language="F#" Value="abstract member GetName : unit -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : unit -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f0e7c-586">获取此程序集的 <see cref="T:System.Reflection.AssemblyName" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-586">Gets an <see cref="T:System.Reflection.AssemblyName" /> for this assembly.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-587">包含此程序集的完全分析的显示名称的对象。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-587">An object that contains the fully parsed display name for this assembly.</span></span></returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="f0e7c-588">用于访问程序集的路径。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-588">for access to the path of the assembly.</span></span> <span data-ttu-id="f0e7c-589">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-589">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName (copiedName As Boolean) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName(bool copiedName);" />
      <MemberSignature Language="F#" Value="abstract member GetName : bool -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : bool -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName copiedName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="copiedName"><span data-ttu-id="f0e7c-590">如果为 <see langword="true" />，则将 <see cref="P:System.Reflection.Assembly.CodeBase" /> 设置为程序集被影像复制后的位置；如果为 <see langword="false" />，则将 <see cref="P:System.Reflection.Assembly.CodeBase" /> 设置为原位置。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-590"><see langword="true" /> to set the <see cref="P:System.Reflection.Assembly.CodeBase" /> to the location of the assembly after it was shadow copied; <see langword="false" /> to set <see cref="P:System.Reflection.Assembly.CodeBase" /> to the original location.</span></span></param>
        <summary><span data-ttu-id="f0e7c-591">获取此程序集的 <see cref="T:System.Reflection.AssemblyName" />，并按 <paramref name="copiedName" /> 指定的那样设置基本代码。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-591">Gets an <see cref="T:System.Reflection.AssemblyName" /> for this assembly, setting the codebase as specified by <paramref name="copiedName" />.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-592">包含此程序集的完全分析的显示名称的对象。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-592">An object that contains the fully parsed display name for this assembly.</span></span></returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="f0e7c-593">用于访问程序集的路径。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-593">for access to the path of the assembly.</span></span> <span data-ttu-id="f0e7c-594">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-594">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="assembly.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="f0e7c-595">用序列化信息填充的对象。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-595">The object to be populated with serialization information.</span></span></param>
        <param name="context"><span data-ttu-id="f0e7c-596">序列化的目标上下文。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-596">The destination context of the serialization.</span></span></param>
        <summary><span data-ttu-id="f0e7c-597">获取序列化信息，其中包含重新实例化此程序集所需的所有数据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-597">Gets serialization information with all of the data needed to reinstantiate this assembly.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-598"><paramref name="info" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-598"><paramref name="info" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f0e7c-599">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-599">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="f0e7c-600">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-600">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies ();" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReferencedAssemblies () As AssemblyName()" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::AssemblyName ^&gt; ^ GetReferencedAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]&#xA;override this.GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]" Usage="assembly.GetReferencedAssemblies " />
      <MemberSignature Language="C#" Value="public System.Reflection.AssemblyName[] GetReferencedAssemblies ();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public Function GetReferencedAssemblies () As AssemblyName()" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetReferencedAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f0e7c-601">获取此程序集引用的所有程序集的 <see cref="T:System.Reflection.AssemblyName" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-601">Gets the <see cref="T:System.Reflection.AssemblyName" /> objects for all the assemblies referenced by this assembly.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-602">包含此程序集引用的所有程序集的完全分析的显示名称的数组。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-602">An array that contains the fully parsed display names of all the assemblies referenced by this assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="f0e7c-603">从 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]开始，如果所引用的程序集没有哈希算法，或者被引用程序集的哈希算法未由 <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> 枚举标识，则将 <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType> 此方法返回的 <xref:System.Reflection.AssemblyName> 对象的 <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-603">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> property of an <xref:System.Reflection.AssemblyName> object that is returned by this method is <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType> if there is no hash algorithm for the referenced assembly, or if the hash algorithm of the referenced assembly is not identified by the <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="f0e7c-604">在以前版本的 .NET Framework 中，<xref:System.Reflection.AssemblyName.HashAlgorithm%2A> 属性在这种情况下返回 <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-604">In previous versions of the .NET Framework, the <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> property returned <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType> in this situation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f0e7c-605">下面的代码示例演示如何调用 <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-605">The following code example demonstrates calling the <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A> method.</span></span> <span data-ttu-id="f0e7c-606">此代码示例是为 <xref:System.Reflection.Assembly> 类提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-606">This code example is part of a larger example provided for the <xref:System.Reflection.Assembly> class.</span></span>  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSatelliteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f0e7c-607">获取附属程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-607">Gets the satellite assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSatelliteAssembly (culture As CultureInfo) As Assembly" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly culture" />
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSatelliteAssembly (culture As CultureInfo) As Assembly" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="culture"><span data-ttu-id="f0e7c-608">指定的区域性。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-608">The specified culture.</span></span></param>
        <summary><span data-ttu-id="f0e7c-609">获取指定区域性的附属程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-609">Gets the satellite assembly for the specified culture.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-610">指定的附属程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-610">The specified satellite assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-611">附属程序集包含本地化资源，这与主应用程序程序集不同，后者包含为作为默认或非特定区域性的单个区域性提供的非本地化可执行代码和资源。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-611">Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.</span></span>  
  
 <span data-ttu-id="f0e7c-612">调用此方法以使用您的当前程序集版本。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-612">Call this method to use your current assembly version.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-613"><paramref name="culture" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-613"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-614">找不到此程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-614">The assembly cannot be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-615">找到了具有匹配文件名的附属程序集，但 <see langword="CultureInfo" /> 与所指定的不匹配。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-615">The satellite assembly with a matching file name was found, but the <see langword="CultureInfo" /> did not match the one specified.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-616">附属程序集不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-616">The satellite assembly is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture, Version ^ version);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly (culture, version)" />
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="version" Type="System.Version" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="culture"><span data-ttu-id="f0e7c-617">指定的区域性。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-617">The specified culture.</span></span></param>
        <param name="version"><span data-ttu-id="f0e7c-618">附属程序集的版本。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-618">The version of the satellite assembly.</span></span></param>
        <summary><span data-ttu-id="f0e7c-619">获取指定区域性的附属程序集的指定版本。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-619">Gets the specified version of the satellite assembly for the specified culture.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-620">指定的附属程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-620">The specified satellite assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-621">附属程序集包含本地化资源，这与主应用程序程序集不同，后者包含为作为默认或非特定区域性的单个区域性提供的非本地化可执行代码和资源。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-621">Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.</span></span>  
  
 <span data-ttu-id="f0e7c-622">调用 <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> 重载以使用当前程序集版本。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-622">Call the <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> overload to use your current assembly version.</span></span>  
  
 <span data-ttu-id="f0e7c-623">如果 `null``version`，则在对资源和主程序集进行签名时，将使用当前程序集版本。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-623">If `version` is `null`, the current assembly version is used if both the resource and main assemblies are signed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-624"><paramref name="culture" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-624"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-625">找到了具有匹配的文件名的附属程序集，但 <see langword="CultureInfo" /> 或版本与所指定的不匹配。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-625">The satellite assembly with a matching file name was found, but the <see langword="CultureInfo" /> or the version did not match the one specified.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-626">找不到此程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-626">The assembly cannot be found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-627">附属程序集不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-627">The satellite assembly is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f0e7c-628">获取表示指定类型的 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-628">Gets the <see cref="T:System.Type" /> object that represents the specified type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="assembly.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="assembly.GetType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="f0e7c-629">类型的全名。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-629">The full name of the type.</span></span></param>
        <summary><span data-ttu-id="f0e7c-630">获取程序集实例中具有指定名称的 <see cref="T:System.Type" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-630">Gets the <see cref="T:System.Type" /> object with the specified name in the assembly instance.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-631">表示指定类的对象，若未找到该类则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-631">An object that represents the specified class, or <see langword="null" /> if the class is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-632">此方法只搜索当前程序集实例。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-632">This method only searches the current assembly instance.</span></span> <span data-ttu-id="f0e7c-633">`name` 参数包括命名空间，但不包括程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-633">The `name` parameter includes the namespace but not the assembly.</span></span> <span data-ttu-id="f0e7c-634">若要搜索类型的其他程序集，请使用 <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> 方法重载，该重载可以选择包含程序集显示名称作为类型名称的一部分。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-634">To search other assemblies for a type, use the <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> method overload, which can optionally include an assembly display name as part of the type name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f0e7c-635">如果已将该类型转发给另一个程序集，则此方法仍将返回该程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-635">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="f0e7c-636">有关类型转发的信息，请参阅[公共语言运行时中的类型转发](~/docs/standard/assembly/type-forwarding.md)。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-636">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/standard/assembly/type-forwarding.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f0e7c-637">下面的示例在 `Transportation` 命名空间中定义抽象 `MeansOfTransportation` 类。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-637">The following example defines an abstract `MeansOfTransportation` class in the `Transportation` namespace.</span></span> <span data-ttu-id="f0e7c-638">它调用 <xref:System.Reflection.Assembly.GetType%28System.String%29> 方法检索其 <xref:System.Type> 对象，调用 <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> 方法获取表示该类型的属性的 <xref:System.Reflection.PropertyInfo> 对象的数组，然后显示有关该类型的抽象属性的信息。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-638">It calls the <xref:System.Reflection.Assembly.GetType%28System.String%29> method to retrieve its <xref:System.Type> object, calls the <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> method to get an array of <xref:System.Reflection.PropertyInfo> objects that represent the type's properties, and then displays information on the type's abstract properties.</span></span> <span data-ttu-id="f0e7c-639">请注意，对 <xref:System.Reflection.Assembly.GetType%28System.String%29> 方法的调用使用类型的完全限定名称（即其命名空间及其类型名称）。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-639">Note that the call to the <xref:System.Reflection.Assembly.GetType%28System.String%29> method uses the type's fully qualified name (that is, its namespace along with its type name).</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.gettype/vb/gettype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f0e7c-640"><paramref name="name" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-640"><paramref name="name" /> is invalid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-641"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-641"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-642"><paramref name="name" /> 所需的从属程序集无法找到。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-642"><paramref name="name" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="f0e7c-643">在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.IO.IOException" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-643">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block><span data-ttu-id="f0e7c-644">
          <paramref name="name" /> 所需的从属程序集已找到，但无法加载。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-644">
          <paramref name="name" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="f0e7c-645">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-645">-or-</span></span> 
<span data-ttu-id="f0e7c-646">当前程序集被加载到仅反射上下文中，并且 <paramref name="name" /> 所需的从属程序集未预先加载。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-646">The current assembly was loaded into the reflection-only context, and <paramref name="name" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-647"><paramref name="name" /> 需要一个从属程序集，但该文件不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-647"><paramref name="name" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="f0e7c-648">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-648">-or-</span></span> 
 <span data-ttu-id="f0e7c-649"><paramref name="name" /> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-649"><paramref name="name" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="f0e7c-650">类型的全名。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-650">The full name of the type.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="f0e7c-651"><see langword="true" /> 表示在找不到该类型时引发异常；<see langword="false" /> 则表示返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-651"><see langword="true" /> to throw an exception if the type is not found; <see langword="false" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="f0e7c-652">获取程序集实例中具有指定名称的 <see cref="T:System.Type" /> 对象，并选择在找不到该类型时引发异常。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-652">Gets the <see cref="T:System.Type" /> object with the specified name in the assembly instance and optionally throws an exception if the type is not found.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-653">表示指定类的对象。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-653">An object that represents the specified class.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-654">此方法只搜索当前程序集实例。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-654">This method only searches the current assembly instance.</span></span> <span data-ttu-id="f0e7c-655">`name` 参数包括命名空间，但不包括程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-655">The `name` parameter includes the namespace but not the assembly.</span></span> <span data-ttu-id="f0e7c-656">若要搜索类型的其他程序集，请使用 <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> 方法重载，该重载可以选择包含程序集显示名称作为类型名称的一部分。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-656">To search other assemblies for a type, use the <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> method overload, which can optionally include an assembly display name as part of the type name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f0e7c-657">如果已将该类型转发给另一个程序集，则此方法仍将返回该程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-657">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="f0e7c-658">有关类型转发的信息，请参阅[公共语言运行时中的类型转发](~/docs/standard/assembly/type-forwarding.md)。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-658">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/standard/assembly/type-forwarding.md).</span></span>  
  
 <span data-ttu-id="f0e7c-659">`throwOnError` 参数仅影响找不到该类型时所发生的情况。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-659">The `throwOnError` parameter only affects what happens when the type is not found.</span></span> <span data-ttu-id="f0e7c-660">它不会影响可能引发的任何其他异常。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-660">It does not affect any other exceptions that might be thrown.</span></span> <span data-ttu-id="f0e7c-661">具体而言，如果找到类型但无法加载，则即使 `throwOnError` `false`，也可能引发 <xref:System.TypeLoadException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-661">In particular, if the type is found but cannot be loaded, <xref:System.TypeLoadException> can be thrown even if `throwOnError` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f0e7c-662"><paramref name="name" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-662"><paramref name="name" /> is invalid.</span></span>  
  
<span data-ttu-id="f0e7c-663">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-663">-or-</span></span> 
<span data-ttu-id="f0e7c-664"><paramref name="name" /> 的长度超过 1024 个字符。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-664">The length of <paramref name="name" /> exceeds 1024 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-665"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-665"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="f0e7c-666"><paramref name="throwOnError" /> 为 <see langword="true" />，且找不到此类型。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-666"><paramref name="throwOnError" /> is <see langword="true" />, and the type cannot be found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-667"><paramref name="name" /> 所需的从属程序集无法找到。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-667"><paramref name="name" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-668"><paramref name="name" /> 所需的从属程序集已找到，但无法加载。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-668"><paramref name="name" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="f0e7c-669">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-669">-or-</span></span> 
<span data-ttu-id="f0e7c-670">当前程序集被加载到仅反射上下文中，并且 <paramref name="name" /> 所需的从属程序集未预先加载。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-670">The current assembly was loaded into the reflection-only context, and <paramref name="name" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-671"><paramref name="name" /> 需要一个从属程序集，但该文件不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-671"><paramref name="name" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="f0e7c-672">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-672">-or-</span></span> 
 <span data-ttu-id="f0e7c-673"><paramref name="name" /> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-673"><paramref name="name" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError, bool ignoreCase);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError, ignoreCase)" />
      <MemberSignature Language="C#" Value="public Type GetType (string name, bool throwOnError, bool ignoreCase);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType (name As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="f0e7c-674">类型的全名。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-674">The full name of the type.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="f0e7c-675"><see langword="true" /> 表示在找不到该类型时引发异常；<see langword="false" /> 则表示返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-675"><see langword="true" /> to throw an exception if the type is not found; <see langword="false" /> to return <see langword="null" />.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="f0e7c-676">如果为 <see langword="true" />，则忽略类型名的大小写；否则，为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-676"><see langword="true" /> to ignore the case of the type name; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f0e7c-677">获取程序集实例中具有指定名称的 <see cref="T:System.Type" /> 对象，带有忽略大小写和在找不到该类型时引发异常的选项。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-677">Gets the <see cref="T:System.Type" /> object with the specified name in the assembly instance, with the options of ignoring the case, and of throwing an exception if the type is not found.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-678">表示指定类的对象。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-678">An object that represents the specified class.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-679">此方法只搜索当前程序集实例。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-679">This method only searches the current assembly instance.</span></span> <span data-ttu-id="f0e7c-680">`name` 参数包括命名空间，但不包括程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-680">The `name` parameter includes the namespace but not the assembly.</span></span> <span data-ttu-id="f0e7c-681">若要搜索类型的其他程序集，请使用 <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> 方法重载，该重载可以选择包含程序集显示名称作为类型名称的一部分。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-681">To search other assemblies for a type, use the <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> method overload, which can optionally include an assembly display name as part of the type name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f0e7c-682">如果已将该类型转发给另一个程序集，则此方法仍将返回该程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-682">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="f0e7c-683">有关类型转发的信息，请参阅[公共语言运行时中的类型转发](~/docs/standard/assembly/type-forwarding.md)。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-683">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/standard/assembly/type-forwarding.md).</span></span>  
  
 <span data-ttu-id="f0e7c-684">`throwOnError` 参数仅影响找不到该类型时所发生的情况。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-684">The `throwOnError` parameter only affects what happens when the type is not found.</span></span> <span data-ttu-id="f0e7c-685">它不会影响可能引发的任何其他异常。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-685">It does not affect any other exceptions that might be thrown.</span></span> <span data-ttu-id="f0e7c-686">具体而言，如果找到类型但无法加载，则即使 `throwOnError` `false`，也可能引发 <xref:System.TypeLoadException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-686">In particular, if the type is found but cannot be loaded, <xref:System.TypeLoadException> can be thrown even if `throwOnError` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f0e7c-687"><paramref name="name" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-687"><paramref name="name" /> is invalid.</span></span>  
  
<span data-ttu-id="f0e7c-688">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-688">-or-</span></span> 
<span data-ttu-id="f0e7c-689"><paramref name="name" /> 的长度超过 1024 个字符。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-689">The length of <paramref name="name" /> exceeds 1024 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-690"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-690"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="f0e7c-691"><paramref name="throwOnError" /> 为 <see langword="true" />，且找不到此类型。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-691"><paramref name="throwOnError" /> is <see langword="true" />, and the type cannot be found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-692"><paramref name="name" /> 所需的从属程序集无法找到。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-692"><paramref name="name" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-693"><paramref name="name" /> 所需的从属程序集已找到，但无法加载。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-693"><paramref name="name" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="f0e7c-694">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-694">-or-</span></span> 
<span data-ttu-id="f0e7c-695">当前程序集被加载到仅反射上下文中，并且 <paramref name="name" /> 所需的从属程序集未预先加载。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-695">The current assembly was loaded into the reflection-only context, and <paramref name="name" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-696"><paramref name="name" /> 需要一个从属程序集，但该文件不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-696"><paramref name="name" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="f0e7c-697">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-697">-or-</span></span> 
 <span data-ttu-id="f0e7c-698"><paramref name="name" /> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-698"><paramref name="name" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetTypes : unit -&gt; Type[]&#xA;override this.GetTypes : unit -&gt; Type[]" Usage="assembly.GetTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f0e7c-699">获取此程序集中定义的类型。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-699">Gets the types defined in this assembly.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-700">一个数组，包含此程序集中定义的所有类型。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-700">An array that contains all the types that are defined in this assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-701">返回的数组包括嵌套类型。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-701">The returned array includes nested types.</span></span>  
  
 <span data-ttu-id="f0e7c-702">如果对程序集调用 <xref:System.Reflection.Assembly.GetTypes%2A> 方法，并且该程序集中的类型依赖于尚未加载的程序集中的类型（例如，如果它是从第二个程序集中的类型派生的），则会引发 <xref:System.Reflection.ReflectionTypeLoadException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-702">If the <xref:System.Reflection.Assembly.GetTypes%2A> method is called on an assembly and a type in that assembly is dependent on a type in an assembly that has not been loaded (for example, if it derives from a type in the second assembly), a <xref:System.Reflection.ReflectionTypeLoadException> is thrown.</span></span> <span data-ttu-id="f0e7c-703">例如，如果第一个程序集是用 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 或 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 方法加载的，但第二个程序集未加载，则可能会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-703">For example, this can happen if the first assembly was loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> or <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods, and the second assembly was not loaded.</span></span> <span data-ttu-id="f0e7c-704">如果在调用 <xref:System.Reflection.Assembly.GetTypes%2A> 方法时找不到第二个程序集 <xref:System.Reflection.Assembly.LoadFile%2A>，则使用 <xref:System.Reflection.Assembly.Load%2A> 加载的程序集也会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-704">It can also happen with assemblies loaded using the <xref:System.Reflection.Assembly.Load%2A> and <xref:System.Reflection.Assembly.LoadFile%2A> methods if the second assembly cannot be located when the <xref:System.Reflection.Assembly.GetTypes%2A> method is called.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f0e7c-705">如果类型已转发给另一个程序集，则它不会包含在返回的数组中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-705">If a type has been forwarded to another assembly, it is not included in the returned array.</span></span> <span data-ttu-id="f0e7c-706">有关类型转发的信息，请参阅[公共语言运行时中的类型转发](~/docs/standard/assembly/type-forwarding.md)。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-706">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/standard/assembly/type-forwarding.md).</span></span>  
  
 <span data-ttu-id="f0e7c-707">若要检索 <xref:System.Reflection.TypeInfo> 对象的集合而不是 <xref:System.Type> 对象的数组，请使用 <xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-707">To retrieve a collection of <xref:System.Reflection.TypeInfo> objects instead of an array of <xref:System.Type> objects, use the <xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f0e7c-708">下面的示例显示指定程序集中某一类型的方法的参数。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-708">The following example displays parameters of one method on a type in the specified assembly.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException"><span data-ttu-id="f0e7c-709">该程序集包含一个或多个无法加载的类型。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-709">The assembly contains one or more types that cannot be loaded.</span></span> <span data-ttu-id="f0e7c-710">此异常的 <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> 属性返回的数组针对已加载的每个类型包含一个 <see cref="T:System.Type" /> 对象，针对无法加载的每个类型包含一个 <see langword="null" />，而 <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> 属性针对无法加载的每个类型包含一个异常。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-710">The array returned by the <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> property of this exception contains a <see cref="T:System.Type" /> object for each type that was loaded and <see langword="null" /> for each type that could not be loaded, while the <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> property contains an exception for each type that could not be loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public virtual bool GlobalAssemblyCache { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GlobalAssemblyCache As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool GlobalAssemblyCache { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.GlobalAssemblyCache : bool" Usage="System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberSignature Language="C#" Value="public bool GlobalAssemblyCache { get; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalAssemblyCache As Boolean" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool GlobalAssemblyCache { bool get(); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.GlobalAssemblyCache</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f0e7c-711">获取一个值，该值指示程序集是否是从全局程序集缓存加载的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-711">Gets a value indicating whether the assembly was loaded from the global assembly cache.</span></span></summary>
        <value><span data-ttu-id="f0e7c-712">如果程序集是从全局程序集缓存加载的，则为<see langword="true" /> ；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-712"><see langword="true" /> if the assembly was loaded from the global assembly cache; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public virtual long HostContext { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.HostContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HostContext As Long" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long HostContext { long get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.HostContext : int64" Usage="System.Reflection.Assembly.HostContext" />
      <MemberSignature Language="C#" Value="public long HostContext { get; }" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HostContext As Long" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long HostContext { long get(); };" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f0e7c-713">获取用于加载程序集的主机上下文。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-713">Gets the host context with which the assembly was loaded.</span></span></summary>
        <value><span data-ttu-id="f0e7c-714">一个 <see cref="T:System.Int64" /> 值，指示用于加载程序集的主机上下文（如果有）。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-714">An <see cref="T:System.Int64" /> value that indicates the host context with which the assembly was loaded, if any.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public virtual string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImageRuntimeVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ImageRuntimeVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ImageRuntimeVersion : string" Usage="System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f0e7c-715">获取表示公共语言运行时 (CLR) 的版本的字符串，该信息保存在包含清单的文件中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-715">Gets a string representing the version of the common language runtime (CLR) saved in the file containing the manifest.</span></span></summary>
        <value><span data-ttu-id="f0e7c-716">CLR 版本的文件夹名。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-716">The CLR version folder name.</span></span> <span data-ttu-id="f0e7c-717">这不是完整路径。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-717">This is not a full path.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-718">例如，.NET Framework 版本1.1 的值为1.1.4322。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-718">For example, the value for the .NET Framework version 1.1 would be v1.1.4322.</span></span> <span data-ttu-id="f0e7c-719">该版本的二进制文件将位于%windir%\Microsoft.NET\Framework\v1.1.4322. 路径中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-719">The binary files for that version would be located in the path %windir%\Microsoft.NET\Framework\v1.1.4322.</span></span>  
  
 <span data-ttu-id="f0e7c-720">默认情况下，<xref:System.Reflection.Assembly.ImageRuntimeVersion%2A> 设置为用于生成程序集的 CLR 版本。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-720">By default, <xref:System.Reflection.Assembly.ImageRuntimeVersion%2A> is set to the version of the CLR used to build the assembly.</span></span> <span data-ttu-id="f0e7c-721">但在编译时，它可能已设置为另一个值。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-721">However, it might have been set to another value at compile time.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCollectible">
      <MemberSignature Language="C#" Value="public virtual bool IsCollectible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollectible" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsCollectible" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsCollectible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsCollectible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollectible : bool" Usage="System.Reflection.Assembly.IsCollectible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f0e7c-722">获取一个值，该值指示此程序集是否保留在可回收的 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-722">Gets a value that indicates whether this assembly is held in a collectible <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</span></span></summary>
        <value><span data-ttu-id="f0e7c-723">如果此程序集保存在可回收 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />中，则 <see langword="true" />;否则，<see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-723"><see langword="true" /> if this assembly is held in a collectible <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="f0e7c-724">有关详细信息，请参阅[如何在 .NET Core 中使用和调试程序集可卸载性](~/docs/standard/assembly/unloadability.md)。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-724">For more information, see [How to use and debug assembly unloadability in .NET Core](~/docs/standard/assembly/unloadability.md).</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member IsDefined : Type * bool -&gt; bool&#xA;override this.IsDefined : Type * bool -&gt; bool" Usage="assembly.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="f0e7c-725">要为此程序集检查的属性类型。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-725">The type of the attribute to be checked for this assembly.</span></span></param>
        <param name="inherit"><span data-ttu-id="f0e7c-726">对于该类型的对象，将忽略此参数。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-726">This argument is ignored for objects of this type.</span></span></param>
        <summary><span data-ttu-id="f0e7c-727">指示指定的属性是否已应用于该程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-727">Indicates whether or not a specified attribute has been applied to the assembly.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-728">如果已将该属性应用于程序集，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-728"><see langword="true" /> if the attribute has been applied to the assembly; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f0e7c-729">下面的代码示例将 <xref:System.Reflection.AssemblyTitleAttribute> 特性应用于程序集，然后使用 <xref:System.Reflection.Assembly.IsDefined%2A> 来指示它是否已应用。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-729">The following code example applies the <xref:System.Reflection.AssemblyTitleAttribute> attribute to an assembly and then uses <xref:System.Reflection.Assembly.IsDefined%2A> to indicate whether it was applied.</span></span> <span data-ttu-id="f0e7c-730">它还测试了未应用的属性。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-730">It also tests an attribute that was not applied.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/CS/isdefined.cs#1)]
 [!code-vb[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/VB/isdefined.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-731"><paramref name="attributeType" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-731"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f0e7c-732"><paramref name="attributeType" /> 使用的类型无效。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-732"><paramref name="attributeType" /> uses an invalid type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public virtual bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsDynamic" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDynamic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDynamic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDynamic : bool" Usage="System.Reflection.Assembly.IsDynamic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f0e7c-733">获取一个值，该值指示当前程序集是否是通过使用反射发出在当前进程中动态生成的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-733">Gets a value that indicates whether the current assembly was generated dynamically in the current process by using reflection emit.</span></span></summary>
        <value><span data-ttu-id="f0e7c-734">如果当前程序集是在当前进程中动态生成的，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-734"><see langword="true" /> if the current assembly was generated dynamically in the current process; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-735">动态程序集由 <xref:System.Reflection.Emit.AssemblyBuilder>的派生类表示。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-735">Dynamic assemblies are represented by the derived class <xref:System.Reflection.Emit.AssemblyBuilder>.</span></span>  
  
 <span data-ttu-id="f0e7c-736">将动态程序集保存到磁盘时，保存的程序集不是动态的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-736">When a dynamic assembly is saved to disk, the saved assembly is not dynamic.</span></span> <span data-ttu-id="f0e7c-737">如果将保存的程序集加载到另一个应用程序域或进程中，则 <xref:System.Reflection.Assembly.IsDynamic%2A> 属性将返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-737">If the saved assembly is loaded into another application domain or process, the <xref:System.Reflection.Assembly.IsDynamic%2A> property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.Reflection.Assembly.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f0e7c-738">获取一个值，该值指示当前程序集是否是以完全信任方式加载的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-738">Gets a value that indicates whether the current assembly is loaded with full trust.</span></span></summary>
        <value><span data-ttu-id="f0e7c-739">如果当前程序集是以完全信任方式加载的，则为 <see langword="true" />，否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-739"><see langword="true" /> if the current assembly is loaded with full trust; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f0e7c-740">加载程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-740">Loads an assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="f0e7c-741">字节数组，它是包含已发出程序集的基于 COFF 的映像。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-741">A byte array that is a COFF-based image containing an emitted assembly.</span></span></param>
        <summary><span data-ttu-id="f0e7c-742">加载带有基于通用对象文件格式 (COFF) 的映像的程序集，该映像包含已发出的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-742">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly.</span></span> <span data-ttu-id="f0e7c-743">此程序集将会加载到调用方的应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-743">The assembly is loaded into the application domain of the caller.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-744">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-744">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-745">使用此方法加载的程序集的信任级别与调用程序集的信任级别相同。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-745">The trust level of an assembly that is loaded by using this method is the same as the trust level of the calling assembly.</span></span> <span data-ttu-id="f0e7c-746">若要从具有应用程序域的信任级别的字节数组加载程序集，请使用 <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> 方法重载。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-746">To load an assembly from a byte array with the trust level of the application domain, use the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> method overload.</span></span> <span data-ttu-id="f0e7c-747">有关对采用字节数组的 <xref:System.Reflection.Assembly.Load%2A> 方法的重载使用证据的详细信息，请参阅 <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> 方法重载。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-747">For more information about the use of evidence with overloads of the <xref:System.Reflection.Assembly.Load%2A> method that take byte arrays, see the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> method overload.</span></span>  
  
 <span data-ttu-id="f0e7c-748">对C++可执行文件进行反射可能会引发 <xref:System.BadImageFormatException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-748">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="f0e7c-749">这很可能是由于C++编译器从可执行文件中去除重定位地址或 `.reloc` 部分导致的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-749">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="f0e7c-750">若要保留C++可执行文件的 `.reloc` 地址，请在链接时指定 `/fixed:no`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-750">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="f0e7c-751">请注意，此方法重载始终使用自己的映射创建一个新的 <xref:System.Reflection.Assembly> 对象。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-751">Note that this method overload always creates a new <xref:System.Reflection.Assembly> object with its own mapping.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-752"><paramref name="rawAssembly" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-752"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-753"><paramref name="rawAssembly" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-753"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="f0e7c-754">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-754">-or-</span></span> 
<span data-ttu-id="f0e7c-755">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="rawAssembly" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-755">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef"><span data-ttu-id="f0e7c-756">描述要加载的程序集的对象。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-756">The object that describes the assembly to be loaded.</span></span></param>
        <summary><span data-ttu-id="f0e7c-757">在给定程序集的 <see cref="T:System.Reflection.AssemblyName" /> 的情况下，加载程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-757">Loads an assembly given its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-758">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-758">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-759">如果 `assemblyRef` 指定完整的程序集名称，并且与简单名称匹配的第一个程序集具有不同的版本、区域性或公钥标记，则会引发 <xref:System.IO.FileLoadException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-759"><xref:System.IO.FileLoadException> is thrown if `assemblyRef` specifies the full assembly name and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="f0e7c-760">加载程序不会继续探测与简单名称匹配的其他程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-760">The loader does not continue probing for other assemblies that match the simple name.</span></span> <span data-ttu-id="f0e7c-761">从 .NET Framework 4 开始，因为在默认情况下禁用了远程程序集中的代码执行，因此，如果 `assemblyRef` 指定远程程序集，也会引发 <xref:System.IO.FileLoadException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-761">Starting with .NET Framework 4, because execution of code in remote assemblies is disabled by default, a <xref:System.IO.FileLoadException> is also thrown if `assemblyRef` specifies a remote assembly.</span></span> <span data-ttu-id="f0e7c-762">若要启用从远程位置加载的代码的执行，可以使用[`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)配置元素。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-762">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>     
  
> [!NOTE]
>  <span data-ttu-id="f0e7c-763">不要将 <xref:System.Reflection.AssemblyName> 仅用于 <xref:System.Reflection.AssemblyName.CodeBase%2A> 属性集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-763">Do not use an <xref:System.Reflection.AssemblyName> with only the <xref:System.Reflection.AssemblyName.CodeBase%2A> property set.</span></span> <span data-ttu-id="f0e7c-764"><xref:System.Reflection.AssemblyName.CodeBase%2A> 属性不提供程序集标识的任何元素（如名称或版本），因此不会根据按标识规则进行加载，如您从 <xref:System.Reflection.Assembly.Load%2A> 方法中所预期的那样。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-764">The <xref:System.Reflection.AssemblyName.CodeBase%2A> property does not supply any elements of the assembly identity (such as name or version), so loading does not occur according to load-by-identity rules, as you would expect from the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="f0e7c-765">而是使用加载 "规则" 加载程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-765">Instead, the assembly is loaded using load-from rules.</span></span> <span data-ttu-id="f0e7c-766">有关使用加载源上下文的缺点的信息，请参阅 <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> 方法重载或[程序集加载的最佳做法](~/docs/framework/deployment/best-practices-for-assembly-loading.md)。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-766">For information about the disadvantages of using the load-from context, see the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method overload or [Best Practices for Assembly Loading](~/docs/framework/deployment/best-practices-for-assembly-loading.md).</span></span>  
  
 <span data-ttu-id="f0e7c-767">是否将特定的权限授予程序集是基于证据的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-767">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="f0e7c-768">程序集和安全证据合并的规则如下所示：</span><span class="sxs-lookup"><span data-stu-id="f0e7c-768">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="f0e7c-769">使用不带 <xref:System.Security.Policy.Evidence> 参数的 <xref:System.Reflection.Assembly.Load%2A> 方法时，将使用加载程序提供的证据加载程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-769">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="f0e7c-770">将 <xref:System.Reflection.Assembly.Load%2A> 方法与 <xref:System.Security.Policy.Evidence> 参数一起使用时，会合并证据部分。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-770">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="f0e7c-771">作为 <xref:System.Reflection.Assembly.Load%2A> 方法的参数提供的证据将取代加载程序提供的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-771">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="f0e7c-772">当使用带有 `Byte[]` 参数的 <xref:System.Reflection.Assembly.Load%2A> 方法重载加载通用对象文件格式（COFF）图像时，将从调用程序集继承证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-772">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="f0e7c-773">这适用于 .NET Framework 版本 1.1 Service Pack 1 （SP1）和后续版本。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-773">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="f0e7c-774">在不带 SP1 的 .NET Framework 版本1.0 和版本1.1 中，当使用带有 `Byte[]` 参数的 <xref:System.Reflection.Assembly.Load%2A> 方法重载加载 COFF 图像时，会结合证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-774">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="f0e7c-775">`Zone`，`Url` 和 `Site` 继承自调用程序集，并从 COFF 程序集获取 `Hash` 和 `StrongName`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-775">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="f0e7c-776">将 <xref:System.Reflection.Assembly.Load%2A> 方法与 `Byte[]` 参数一起使用时，如果 <xref:System.Security.Policy.Evidence> 加载 COFF 图像，则只使用提供的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-776">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="f0e7c-777">将忽略调用程序集和 COFF 图像的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-777">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="f0e7c-778">对C++可执行文件进行反射可能会引发 <xref:System.BadImageFormatException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-778">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="f0e7c-779">这很可能是由于C++编译器从可执行文件中去除重定位地址或 `.reloc` 部分导致的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-779">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="f0e7c-780">若要保留C++可执行文件的 `.reloc` 地址，请在链接时指定 `/fixed:no`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-780">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f0e7c-781">如果同时设置了 <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> 属性和 <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> 属性，则第一次尝试加载程序集时将使用显示名称（包括版本、区域性等，如 <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> 属性返回）。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-781">If both the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> property and the <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property).</span></span> <span data-ttu-id="f0e7c-782">如果找不到该文件，则使用 <xref:System.Reflection.AssemblyName.CodeBase%2A> 搜索该程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-782">If the file is not found, <xref:System.Reflection.AssemblyName.CodeBase%2A> is used to search for the assembly.</span></span> <span data-ttu-id="f0e7c-783">如果使用 <xref:System.Reflection.AssemblyName.CodeBase%2A>找到程序集，则会将显示名称与程序集匹配。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-783">If the assembly is found using <xref:System.Reflection.AssemblyName.CodeBase%2A>, the display name is matched against the assembly.</span></span> <span data-ttu-id="f0e7c-784">如果匹配失败，则会引发 <xref:System.IO.FileLoadException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-784">If the match fails, a <xref:System.IO.FileLoadException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f0e7c-785">下面的示例实例化一个 <xref:System.Reflection.AssemblyName> 对象，并使用它来加载 `sysglobal.dll` 的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-785">The following example instantiates an <xref:System.Reflection.AssemblyName> object and uses it to load the `sysglobal.dll` assembly.</span></span> <span data-ttu-id="f0e7c-786">然后，该示例显示程序集的公共类型的全名。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-786">The example then displays the full name of the assembly's public types.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.Load#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/Load2.cs#2)]
 [!code-vb[System.Reflection.Assembly.Load#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/Load2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-787"><paramref name="assemblyRef" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-787"><paramref name="assemblyRef" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-788"><paramref name="assemblyRef" /> 未找到。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-788"><paramref name="assemblyRef" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="f0e7c-789">在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.IO.IOException" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-789">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="f0e7c-790">无法加载已找到的文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-790">A file that was found could not be loaded.</span></span>

<span data-ttu-id="f0e7c-791">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-791">-or-</span></span>

<span data-ttu-id="f0e7c-792"><paramref name="assemblyRef" /> 指定远程程序集，但在远程程序集中执行代码的功能已禁用。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-792"><paramref name="assemblyRef" /> specifies a remote assembly, but the ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="f0e7c-793">请参阅 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-793">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-794"><paramref name="assemblyRef" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-794"><paramref name="assemblyRef" /> is not a valid assembly.</span></span> <span data-ttu-id="f0e7c-795">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-795">-or-</span></span> 
<span data-ttu-id="f0e7c-796">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyRef" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-796">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="f0e7c-797">用于从文件或目录读取的访问权限，以及用于访问路径本身中的信息的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-797">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="f0e7c-798">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-798">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="f0e7c-799">用于读取不以 "file://" 开头的 URI。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-799">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="f0e7c-800">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-800">to load an assembly with evidence.</span></span> <span data-ttu-id="f0e7c-801">关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-801">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md"><span data-ttu-id="f0e7c-802">运行时如何定位程序集</span><span class="sxs-lookup"><span data-stu-id="f0e7c-802">How the Runtime Locates Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member Load : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="f0e7c-803">程序集名称的长格式或短格式。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-803">The long or short form of the assembly name.</span></span></param>
        <summary><span data-ttu-id="f0e7c-804">用指定的名称加载程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-804">Loads an assembly with the specified name.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-805">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-805">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
<span data-ttu-id="f0e7c-806">若要加载正确的程序集，建议通过传递程序集名称的长格式来调用 `Load` 方法。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-806">To load the correct assembly, it's recommended to call the `Load` method by passing the long form of the assembly name.</span></span> <span data-ttu-id="f0e7c-807">程序集名称的长格式包含其简单名称（如 System .dll 程序集的 "System"）及其版本、区域性、公钥标记，还可以是其处理器体系结构。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-807">The long form of an assembly name consists of its simple name (such as "System" for the System.dll assembly) along with its version, culture, public key token, and optionally its processor architecture.</span></span> <span data-ttu-id="f0e7c-808">它对应于程序集的 <xref:System.Reflection.Assembly.FullName%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-808">It corresponds to the assembly's <xref:System.Reflection.Assembly.FullName%2A> property.</span></span> <span data-ttu-id="f0e7c-809">下面的示例演示如何使用长名称加载 .NET Framework 4 的系统 .dll 程序集：</span><span class="sxs-lookup"><span data-stu-id="f0e7c-809">The following example illustrates the use of a long name to load the System.dll assembly for the .NET Framework 4:</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/load1.cs#1)]
 [!code-vb[System.Reflection.Assembly.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/load1.vb#1)]  
  
 <span data-ttu-id="f0e7c-810">如果 `assemblyString` 指定完整的程序集名称，并且与该简单名称匹配的第一个程序集具有不同的版本、区域性或公钥标记，则会引发 <xref:System.IO.FileLoadException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-810"><xref:System.IO.FileLoadException> is thrown if `assemblyString` specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="f0e7c-811">加载程序不会继续探测与简单名称匹配的其他程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-811">The loader does not continue probing for other assemblies that match the simple name.</span></span>  
  
 <span data-ttu-id="f0e7c-812">是否将特定的权限授予程序集是基于证据的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-812">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="f0e7c-813">程序集和安全证据合并的规则如下所示：</span><span class="sxs-lookup"><span data-stu-id="f0e7c-813">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="f0e7c-814">使用不带 <xref:System.Security.Policy.Evidence> 参数的 <xref:System.Reflection.Assembly.Load%2A> 方法时，将使用加载程序提供的证据加载程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-814">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="f0e7c-815">将 <xref:System.Reflection.Assembly.Load%2A> 方法与 <xref:System.Security.Policy.Evidence> 参数一起使用时，会合并证据部分。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-815">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="f0e7c-816">作为 <xref:System.Reflection.Assembly.Load%2A> 方法的参数提供的证据将取代加载程序提供的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-816">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="f0e7c-817">当使用带有 `Byte[]` 参数的 <xref:System.Reflection.Assembly.Load%2A> 方法重载加载通用对象文件格式（COFF）图像时，将从调用程序集继承证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-817">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="f0e7c-818">这适用于 .NET Framework 版本 1.1 Service Pack 1 （SP1）和后续版本。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-818">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="f0e7c-819">在不带 SP1 的 .NET Framework 版本1.0 和版本1.1 中，当使用带有 `Byte[]` 参数的 <xref:System.Reflection.Assembly.Load%2A> 方法重载加载 COFF 图像时，会结合证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-819">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="f0e7c-820">`Zone`，`Url` 和 `Site` 继承自调用程序集，并从 COFF 程序集获取 `Hash` 和 `StrongName`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-820">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="f0e7c-821">将 <xref:System.Reflection.Assembly.Load%2A> 方法与 `Byte[]` 参数一起使用时，如果 <xref:System.Security.Policy.Evidence> 加载 COFF 图像，则只使用提供的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-821">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="f0e7c-822">将忽略调用程序集和 COFF 图像的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-822">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="f0e7c-823">对C++可执行文件进行反射可能会引发 <xref:System.BadImageFormatException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-823">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="f0e7c-824">这很可能是由于C++编译器从可执行文件中去除重定位地址或 `.reloc` 部分导致的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-824">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="f0e7c-825">若要保留C++可执行文件的 `.reloc` 地址，请在链接时指定 `/fixed:no`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-825">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="f0e7c-826">在 .NET Framework 版本2.0 中，处理器体系结构添加到程序集标识，并可指定为程序集名称字符串的一部分。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-826">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="f0e7c-827">例如，"ProcessorArchitecture = msil"。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-827">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="f0e7c-828">但是，指定程序集名称的建议方法是创建一个 <xref:System.Reflection.AssemblyName> 对象并将其传递到 <xref:System.Reflection.Assembly.Load%2A> 方法的适当重载。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-828">However, the recommended way to specify an assembly name is to create an <xref:System.Reflection.AssemblyName> object and pass it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="f0e7c-829">请参阅<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-829">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f0e7c-830">下面的示例在给定程序集的完全限定名称的情况下加载程序集，并列出指定程序集中包含的所有类型。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-830">The following example loads an assembly given its fully qualified name, and lists all the types contained in the specified assembly.</span></span> <span data-ttu-id="f0e7c-831">有关如何获取完全限定的程序集名称的信息，请参阅[程序集名称](~/docs/standard/assembly/names.md)。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-831">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/standard/assembly/names.md).</span></span>  
  
 [!code-cpp[assembly.load1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.Load1/CPP/load1.cpp#1)]
 [!code-csharp[assembly.load1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.Load1/CS/load1.cs#1)]
 [!code-vb[assembly.load1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.Load1/VB/load1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-832"><paramref name="assemblyString" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-832"><paramref name="assemblyString" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f0e7c-833"><paramref name="assemblyString" /> 是一个长度为零的字符串。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-833"><paramref name="assemblyString" /> is a zero-length string.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-834"><paramref name="assemblyString" /> 未找到。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-834"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-835">无法加载已找到的文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-835">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-836"><paramref name="assemblyString" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-836"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="f0e7c-837">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-837">-or-</span></span> 
<span data-ttu-id="f0e7c-838">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyString" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-838">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="f0e7c-839">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-839">to load an assembly with evidence.</span></span> <span data-ttu-id="f0e7c-840">关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-840">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md"><span data-ttu-id="f0e7c-841">运行时如何定位程序集</span><span class="sxs-lookup"><span data-stu-id="f0e7c-841">How the Runtime Locates Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="f0e7c-842">字节数组，它是包含已发出程序集的基于 COFF 的映像。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-842">A byte array that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="f0e7c-843">包含表示程序集符号的原始字节的字节数组。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-843">A byte array that contains the raw bytes representing the symbols for the assembly.</span></span></param>
        <summary><span data-ttu-id="f0e7c-844">加载带有基于通用对象文件格式 (COFF) 的映像的程序集，此映像包含一个已发出的程序集，并且还可以选择包括程序集的符号。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-844">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols for the assembly.</span></span> <span data-ttu-id="f0e7c-845">此程序集将会加载到调用方的应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-845">The assembly is loaded into the application domain of the caller.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-846">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-846">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-847">使用此方法加载的程序集的信任级别与调用程序集的信任级别相同。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-847">The trust level of an assembly that is loaded by using this method is the same as the trust level of the calling assembly.</span></span> <span data-ttu-id="f0e7c-848">若要从具有应用程序域的信任级别的字节数组加载程序集，请使用 <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> 方法重载。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-848">To load an assembly from a byte array with the trust level of the application domain, use the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> method overload.</span></span> <span data-ttu-id="f0e7c-849">有关对采用字节数组的 <xref:System.Reflection.Assembly.Load%2A> 方法的重载使用证据的详细信息，请参阅 <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> 方法重载。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-849">For more information about the use of evidence with overloads of the <xref:System.Reflection.Assembly.Load%2A> method that take byte arrays, see the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> method overload.</span></span>  
  
 <span data-ttu-id="f0e7c-850">对C++可执行文件进行反射可能会引发 <xref:System.BadImageFormatException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-850">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="f0e7c-851">这很可能是由于C++编译器从可执行文件中去除重定位地址或 `.reloc` 部分导致的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-851">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="f0e7c-852">若要保留C++可执行文件的 `.reloc` 地址，请在链接时指定 `/fixed:no`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-852">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="f0e7c-853">请注意，此方法重载始终使用自己的映射创建一个新的 <xref:System.Reflection.Assembly> 对象。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-853">Note that this method overload always creates a new <xref:System.Reflection.Assembly> object with its own mapping.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-854"><paramref name="rawAssembly" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-854"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-855"><paramref name="rawAssembly" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-855"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="f0e7c-856">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-856">-or-</span></span> 
<span data-ttu-id="f0e7c-857">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="rawAssembly" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-857">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyRef"><span data-ttu-id="f0e7c-858">描述要加载的程序集的对象。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-858">The object that describes the assembly to be loaded.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="f0e7c-859">用于加载程序集的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-859">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="f0e7c-860">在给定程序集的 <see cref="T:System.Reflection.AssemblyName" /> 的情况下，加载程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-860">Loads an assembly given its <see cref="T:System.Reflection.AssemblyName" />.</span></span> <span data-ttu-id="f0e7c-861">使用提供的证据将该程序集加载到调用方的域中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-861">The assembly is loaded into the domain of the caller using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-862">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-862">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-863">如果 `assemblyRef` 指定完整的程序集名称，并且与该简单名称匹配的第一个程序集具有不同的版本、区域性或公钥标记，则会引发 <xref:System.IO.FileLoadException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-863"><xref:System.IO.FileLoadException> is thrown if `assemblyRef` specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="f0e7c-864">加载程序不会继续探测与简单名称匹配的其他程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-864">The loader does not continue probing for other assemblies that match the simple name.</span></span>  <span data-ttu-id="f0e7c-865">从 .NET Framework 4 开始，因为在默认情况下禁用了远程程序集中的代码执行，因此，如果 `assemblyRef` 指定远程程序集，也会引发 <xref:System.IO.FileLoadException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-865">Starting with .NET Framework 4, because execution of code in remote assemblies is disabled by default, a <xref:System.IO.FileLoadException> is also thrown if `assemblyRef` specifies a remote assembly.</span></span> <span data-ttu-id="f0e7c-866">若要启用从远程位置加载的代码的执行，可以使用[`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)配置元素。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-866">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>   
  
> [!NOTE]
>  <span data-ttu-id="f0e7c-867">不要将 <xref:System.Reflection.AssemblyName> 仅用于 <xref:System.Reflection.AssemblyName.CodeBase%2A> 属性集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-867">Do not use an <xref:System.Reflection.AssemblyName> with only the <xref:System.Reflection.AssemblyName.CodeBase%2A> property set.</span></span> <span data-ttu-id="f0e7c-868"><xref:System.Reflection.AssemblyName.CodeBase%2A> 属性不提供程序集标识的任何元素（如名称或版本），因此不会根据按标识规则进行加载，如您从 <xref:System.Reflection.Assembly.Load%2A> 方法中所预期的那样。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-868">The <xref:System.Reflection.AssemblyName.CodeBase%2A> property does not supply any elements of the assembly identity (such as name or version), so loading does not occur according to load-by-identity rules, as you would expect from the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="f0e7c-869">而是使用加载 "规则" 加载程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-869">Instead, the assembly is loaded using load-from rules.</span></span> <span data-ttu-id="f0e7c-870">有关使用加载源上下文的缺点的信息，请参阅 <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> 方法重载或[程序集加载的最佳做法](~/docs/framework/deployment/best-practices-for-assembly-loading.md)。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-870">For information about the disadvantages of using the load-from context, see the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method overload or [Best Practices for Assembly Loading](~/docs/framework/deployment/best-practices-for-assembly-loading.md).</span></span>  
  
 <span data-ttu-id="f0e7c-871">是否将特定的权限授予程序集是基于证据的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-871">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="f0e7c-872">程序集和安全证据合并的规则如下所示：</span><span class="sxs-lookup"><span data-stu-id="f0e7c-872">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="f0e7c-873">使用不带 <xref:System.Security.Policy.Evidence> 参数的 <xref:System.Reflection.Assembly.Load%2A> 方法时，将使用加载程序提供的证据加载程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-873">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="f0e7c-874">将 <xref:System.Reflection.Assembly.Load%2A> 方法与 <xref:System.Security.Policy.Evidence> 参数一起使用时，会合并证据部分。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-874">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="f0e7c-875">作为 <xref:System.Reflection.Assembly.Load%2A> 方法的参数提供的证据将取代加载程序提供的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-875">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="f0e7c-876">当使用带有 `Byte[]` 参数的 <xref:System.Reflection.Assembly.Load%2A> 方法重载加载通用对象文件格式（COFF）图像时，将从调用程序集继承证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-876">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="f0e7c-877">这适用于 .NET Framework 版本 1.1 Service Pack 1 （SP1）和后续版本。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-877">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="f0e7c-878">在不带 SP1 的 .NET Framework 版本1.0 和版本1.1 中，当使用带有 `Byte[]` 参数的 <xref:System.Reflection.Assembly.Load%2A> 方法重载加载 COFF 图像时，会结合证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-878">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="f0e7c-879">`Zone`，`Url` 和 `Site` 继承自调用程序集，并从 COFF 程序集获取 `Hash` 和 `StrongName`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-879">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="f0e7c-880">将 <xref:System.Reflection.Assembly.Load%2A> 方法与 `Byte[]` 参数一起使用时，如果 <xref:System.Security.Policy.Evidence> 加载 COFF 图像，则只使用提供的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-880">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="f0e7c-881">将忽略调用程序集和 COFF 图像的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-881">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="f0e7c-882">对C++可执行文件进行反射可能会引发 <xref:System.BadImageFormatException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-882">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="f0e7c-883">这很可能是由于C++编译器从可执行文件中去除重定位地址或 `.reloc` 部分导致的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-883">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="f0e7c-884">若要保留C++可执行文件的 `.reloc` 地址，请在链接时指定 `/fixed:no`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-884">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f0e7c-885">如果同时设置了 <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> 属性和 <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> 属性，则第一次尝试加载程序集时将使用显示名称（包括版本、区域性等，如 <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> 属性返回）。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-885">If both the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> property and the <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property).</span></span> <span data-ttu-id="f0e7c-886">如果找不到该文件，则使用 <xref:System.Reflection.AssemblyName.CodeBase%2A> 搜索该程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-886">If the file is not found, <xref:System.Reflection.AssemblyName.CodeBase%2A> is used to search for the assembly.</span></span> <span data-ttu-id="f0e7c-887">如果使用 <xref:System.Reflection.AssemblyName.CodeBase%2A>找到程序集，则会将显示名称与程序集匹配。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-887">If the assembly is found using <xref:System.Reflection.AssemblyName.CodeBase%2A>, the display name is matched against the assembly.</span></span> <span data-ttu-id="f0e7c-888">如果匹配失败，则会引发 <xref:System.IO.FileLoadException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-888">If the match fails, a <xref:System.IO.FileLoadException> is thrown.</span></span>  
  
 <span data-ttu-id="f0e7c-889">如果对同一程序集多次调用 <xref:System.Reflection.Assembly.Load%2A> 方法，但指定了不同的证据，则公共语言运行时将不会引发 <xref:System.IO.FileLoadException>，因为不能确定不同证据规范的相等性和完整性。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-889">If you call the <xref:System.Reflection.Assembly.Load%2A> method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="f0e7c-890">第一次成功的证据是使用的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-890">The evidence that first succeeds is the evidence that is used.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-891"><paramref name="assemblyRef" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-891"><paramref name="assemblyRef" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-892"><paramref name="assemblyRef" /> 未找到。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-892"><paramref name="assemblyRef" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-893"><paramref name="assemblyRef" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-893"><paramref name="assemblyRef" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="f0e7c-894">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-894">-or-</span></span> 
<span data-ttu-id="f0e7c-895">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyRef" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-895">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-896">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-896">An assembly or module was loaded twice with two different evidences.</span></span>

<span data-ttu-id="f0e7c-897">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-897">-or-</span></span>

<span data-ttu-id="f0e7c-898"><paramref name="assemblyRef" /> 指定远程程序集，但在远程程序集中执行代码的功能已禁用。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-898"><paramref name="assemblyRef" /> specifies a remote assembly, but the ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="f0e7c-899">请参阅 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-899">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="f0e7c-900">用于从文件或目录读取的访问权限，以及用于访问路径本身中的信息的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-900">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="f0e7c-901">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-901">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="f0e7c-902">用于读取不以 "file://" 开头的 URI。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-902">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="f0e7c-903">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-903">to load an assembly with evidence.</span></span> <span data-ttu-id="f0e7c-904">关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-904">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md"><span data-ttu-id="f0e7c-905">运行时如何定位程序集</span><span class="sxs-lookup"><span data-stu-id="f0e7c-905">How the Runtime Locates Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="f0e7c-906">程序集的显示名称。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-906">The display name of the assembly.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="f0e7c-907">用于加载程序集的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-907">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="f0e7c-908">通过给定的程序集的显示名称来加载程序集，使用提供的证据将程序集加载到调用方的域中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-908">Loads an assembly given its display name, loading the assembly into the domain of the caller using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-909">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-909">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-910">如果 `assemblyString` 指定完整的程序集名称，并且与该简单名称匹配的第一个程序集具有不同的版本、区域性或公钥标记，则会引发 <xref:System.IO.FileLoadException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-910"><xref:System.IO.FileLoadException> is thrown if `assemblyString` specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="f0e7c-911">加载程序不会继续探测与简单名称匹配的其他程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-911">The loader does not continue probing for other assemblies that match the simple name.</span></span>  
  
 <span data-ttu-id="f0e7c-912">是否将特定的权限授予程序集是基于证据的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-912">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="f0e7c-913">程序集和安全证据合并的规则如下所示：</span><span class="sxs-lookup"><span data-stu-id="f0e7c-913">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="f0e7c-914">使用不带 <xref:System.Security.Policy.Evidence> 参数的 <xref:System.Reflection.Assembly.Load%2A> 方法时，将使用加载程序提供的证据加载程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-914">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="f0e7c-915">将 <xref:System.Reflection.Assembly.Load%2A> 方法与 <xref:System.Security.Policy.Evidence> 参数一起使用时，会合并证据部分。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-915">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="f0e7c-916">作为 <xref:System.Reflection.Assembly.Load%2A> 方法的参数提供的证据将取代加载程序提供的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-916">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="f0e7c-917">当使用带有 `Byte[]` 参数的 <xref:System.Reflection.Assembly.Load%2A> 方法重载加载通用对象文件格式（COFF）图像时，将从调用程序集继承证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-917">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="f0e7c-918">这适用于 .NET Framework 版本 1.1 Service Pack 1 （SP1）和后续版本。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-918">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="f0e7c-919">在不带 SP1 的 .NET Framework 版本1.0 和版本1.1 中，当使用带有 `Byte[]` 参数的 <xref:System.Reflection.Assembly.Load%2A> 方法重载加载 COFF 图像时，会结合证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-919">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="f0e7c-920">`Zone`，`Url` 和 `Site` 继承自调用程序集，并从 COFF 程序集获取 `Hash` 和 `StrongName`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-920">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="f0e7c-921">将 <xref:System.Reflection.Assembly.Load%2A> 方法与 `Byte[]` 参数一起使用时，如果 <xref:System.Security.Policy.Evidence> 加载 COFF 图像，则只使用提供的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-921">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="f0e7c-922">将忽略调用程序集和 COFF 图像的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-922">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="f0e7c-923">对C++可执行文件进行反射可能会引发 <xref:System.BadImageFormatException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-923">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="f0e7c-924">这很可能是由于C++编译器从可执行文件中去除重定位地址或 `.reloc` 部分导致的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-924">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="f0e7c-925">若要保留C++可执行文件的 `.reloc` 地址，请在链接时指定 `/fixed:no`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-925">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="f0e7c-926">如果对同一程序集多次调用此方法，但指定了不同的证据，则公共语言运行时将不会引发 <xref:System.IO.FileLoadException>，因为无法确定不同证据规范的相等性和完整性。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-926">If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="f0e7c-927">第一次成功的证据是使用的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-927">The evidence that first succeeds is the evidence that is used.</span></span>  
  
 <span data-ttu-id="f0e7c-928">在 .NET Framework 版本2.0 中，处理器体系结构添加到程序集标识，并可指定为程序集名称字符串的一部分。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-928">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="f0e7c-929">例如，"ProcessorArchitecture = msil"。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-929">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="f0e7c-930">但是，指定程序集名称的建议方法是创建一个 <xref:System.Reflection.AssemblyName> 对象并将其传递到 <xref:System.Reflection.Assembly.Load%2A> 方法的适当重载。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-930">However, the recommended way to specify an assembly name is to create an <xref:System.Reflection.AssemblyName> object and pass it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="f0e7c-931">请参阅<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-931">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-932"><paramref name="assemblyString" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-932"><paramref name="assemblyString" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-933"><paramref name="assemblyString" /> 未找到。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-933"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-934"><paramref name="assemblyString" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-934"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="f0e7c-935">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-935">-or-</span></span> 
<span data-ttu-id="f0e7c-936">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyString" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-936">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-937">无法加载已找到的文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-937">A file that was found could not be loaded.</span></span>  
  
 <span data-ttu-id="f0e7c-938">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-938">-or-</span></span>  
  
 <span data-ttu-id="f0e7c-939">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-939">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="f0e7c-940">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-940">to load an assembly with evidence.</span></span> <span data-ttu-id="f0e7c-941">关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-941">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md"><span data-ttu-id="f0e7c-942">运行时如何定位程序集</span><span class="sxs-lookup"><span data-stu-id="f0e7c-942">How the Runtime Locates Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="f0e7c-943">字节数组，它是包含已发出程序集的基于 COFF 的映像。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-943">A byte array that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="f0e7c-944">包含表示程序集符号的原始字节的字节数组。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-944">A byte array that contains the raw bytes representing the symbols for the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="f0e7c-945">用于加载程序集的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-945">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="f0e7c-946">加载带有基于通用对象文件格式 (COFF) 的映像的程序集，此映像包含一个已发出的程序集，并且还可选择包括程序集的符号和证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-946">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols and evidence for the assembly.</span></span> <span data-ttu-id="f0e7c-947">此程序集将会加载到调用方的应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-947">The assembly is loaded into the application domain of the caller.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-948">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-948">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-949">使用提供的证据将该程序集加载到调用方的域中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-949">The assembly is loaded into the domain of the caller using the supplied evidence.</span></span> <span data-ttu-id="f0e7c-950">还会加载表示程序集符号的原始字节。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-950">The raw bytes representing the symbols for the assembly are also loaded.</span></span>  
  
 <span data-ttu-id="f0e7c-951">是否将特定的权限授予程序集是基于证据的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-951">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="f0e7c-952">程序集和安全证据合并的规则如下所示：</span><span class="sxs-lookup"><span data-stu-id="f0e7c-952">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="f0e7c-953">使用不带 <xref:System.Security.Policy.Evidence> 参数的 <xref:System.Reflection.Assembly.Load%2A> 方法时，将使用加载程序提供的证据加载程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-953">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="f0e7c-954">将 <xref:System.Reflection.Assembly.Load%2A> 方法与 <xref:System.Security.Policy.Evidence> 参数一起使用时，会合并证据部分。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-954">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="f0e7c-955">作为 <xref:System.Reflection.Assembly.Load%2A> 方法的参数提供的证据将取代加载程序提供的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-955">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="f0e7c-956">使用带有 `Byte[]` 参数的 <xref:System.Reflection.Assembly.Load%2A> 方法重载加载 COFF 图像时，将从调用程序集继承证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-956">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="f0e7c-957">这适用于 .NET Framework 版本 1.1 Service Pack 1 （SP1）和后续版本。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-957">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="f0e7c-958">在不带 SP1 的 .NET Framework 版本1.0 和版本1.1 中，当使用带有 `Byte[]` 参数的 <xref:System.Reflection.Assembly.Load%2A> 方法重载加载 COFF 图像时，会结合证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-958">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="f0e7c-959">`Zone`，`Url` 和 `Site` 继承自调用程序集，并从 COFF 程序集获取 `Hash` 和 `StrongName`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-959">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="f0e7c-960">将 <xref:System.Reflection.Assembly.Load%2A> 方法与 `Byte[]` 参数一起使用时，如果 <xref:System.Security.Policy.Evidence> 加载 COFF 图像，则只使用提供的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-960">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="f0e7c-961">将忽略调用程序集和 COFF 图像的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-961">Evidence of the calling assembly and evidence of the COFF image are ignored.</span></span>  
  
 <span data-ttu-id="f0e7c-962">对C++可执行文件进行反射可能会引发 <xref:System.BadImageFormatException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-962">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="f0e7c-963">这很可能是由于C++编译器从可执行文件中去除重定位地址或 `.reloc` 部分导致的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-963">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="f0e7c-964">若要保留C++可执行文件的 `.reloc` 地址，请在链接时指定 `/fixed:no`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-964">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="f0e7c-965">如果在同一程序集上多次调用 [\]、Byte\<x：% 2A > 方法，但指定了不同的证据，则公共语言运行时将不会引发 <xref:System.IO.FileLoadException>，因为无法确定不同证据规范的相等性和完整性。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-965">If you call the [\], Byte\<xref:System.Reflection.Assembly.Load%2A> method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="f0e7c-966">第一次成功的证据是使用的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-966">The evidence that first succeeds is the evidence that is used.</span></span>  
  
 <span data-ttu-id="f0e7c-967">请注意，此方法重载始终使用自己的映射创建一个新的 <xref:System.Reflection.Assembly> 对象。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-967">Note that this method overload always creates a new <xref:System.Reflection.Assembly> object with its own mapping.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-968"><paramref name="rawAssembly" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-968"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-969"><paramref name="rawAssembly" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-969"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="f0e7c-970">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-970">-or-</span></span> 
<span data-ttu-id="f0e7c-971">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="rawAssembly" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-971">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-972">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-972">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f0e7c-973"><paramref name="securityEvidence" /> 不是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-973"><paramref name="securityEvidence" /> is not <see langword="null" />.</span></span>  <span data-ttu-id="f0e7c-974">默认情况下，[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 中未启用旧版 CAS 策略；如果未启用，则 <paramref name="securityEvidence" /> 必须为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-974">By default, legacy CAS policy is not enabled in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; when it is not enabled, <paramref name="securityEvidence" /> must be <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="f0e7c-975">提供证据的能力。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-975">for the ability to supply evidence.</span></span> <span data-ttu-id="f0e7c-976">关联的枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-976">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span> <span data-ttu-id="f0e7c-977">安全操作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-977">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.SecurityContextSource -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="f0e7c-978">字节数组，它是包含已发出程序集的基于 COFF 的映像。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-978">A byte array that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="f0e7c-979">包含表示程序集符号的原始字节的字节数组。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-979">A byte array that contains the raw bytes representing the symbols for the assembly.</span></span></param>
        <param name="securityContextSource"><span data-ttu-id="f0e7c-980">安全上下文的源。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-980">The source of the security context.</span></span></param>
        <summary><span data-ttu-id="f0e7c-981">加载带有基于通用对象文件格式 (COFF) 的映像的程序集，此映像包含一个已发出的程序集，并且还可选择包括符号和指定安全上下文的源。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-981">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols and specifying the source for the security context.</span></span> <span data-ttu-id="f0e7c-982">此程序集将会加载到调用方的应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-982">The assembly is loaded into the application domain of the caller.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-983">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-983">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-984">使用安全上下文的指定源将程序集加载到调用方的应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-984">The assembly is loaded into the application domain of the caller using the specified source for the security context.</span></span> <span data-ttu-id="f0e7c-985">如果指定了 `rawSymbolStore`，则还会加载表示程序集符号的原始字节。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-985">If `rawSymbolStore` was specified, the raw bytes that represent the symbols for the assembly are also loaded.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-986"><paramref name="rawAssembly" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-986"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-987"><paramref name="rawAssembly" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-987"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="f0e7c-988">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-988">-or-</span></span> 
 <span data-ttu-id="f0e7c-989"><paramref name="rawAssembly" /> 使用高于当前所加载版本的公共语言运行时版本编译而成。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-989"><paramref name="rawAssembly" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f0e7c-990"><paramref name="securityContextSource" /> 的值不是枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-990">The value of <paramref name="securityContextSource" /> is not one of the enumeration values.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f0e7c-991">加载程序集文件的内容。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-991">Loads the contents of an assembly file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="f0e7c-992">要加载的文件的完全限定路径。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-992">The fully qualified path of the file to load.</span></span></param>
        <summary><span data-ttu-id="f0e7c-993">加载指定路径中程序集文件的内容。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-993">Loads the contents of an assembly file on the specified path.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-994">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-994">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-995">使用 <xref:System.Reflection.Assembly.LoadFile%2A> 方法加载和检查具有相同标识但位于不同路径中的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-995">Use the <xref:System.Reflection.Assembly.LoadFile%2A> method to load and examine assemblies that have the same identity, but are located in different paths.</span></span> <span data-ttu-id="f0e7c-996"><xref:System.Reflection.Assembly.LoadFile%2A> 不会将文件加载到加载源上下文中，也不会使用加载路径解析依赖项，因为 <xref:System.Reflection.Assembly.LoadFrom%2A> 方法这样做。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-996"><xref:System.Reflection.Assembly.LoadFile%2A> does not load files into the load-from  context, and does not resolve dependencies using the load path, as the <xref:System.Reflection.Assembly.LoadFrom%2A> method does.</span></span> <span data-ttu-id="f0e7c-997"><xref:System.Reflection.Assembly.LoadFile%2A> 在这种受限情况下非常有用，因为 <xref:System.Reflection.Assembly.LoadFrom%2A> 不能用于加载具有相同标识但路径不同的程序集;它将只加载第一个此类程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-997"><xref:System.Reflection.Assembly.LoadFile%2A> is useful in this limited scenario because <xref:System.Reflection.Assembly.LoadFrom%2A> cannot be used to load assemblies that have the same identities but different paths; it will load only the first such assembly.</span></span>  

<span data-ttu-id="f0e7c-998">从 .NET Framework 4 开始，如果 `path` 指定远程位置中的程序集，则默认情况下将禁用程序集加载，`LoadFile` 方法将引发 <xref:System.IO.FileLoadException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-998">Starting with .NET Framework 4, if `path` specifies an assembly in a remote location, assembly loading is disabled by default, and the `LoadFile` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="f0e7c-999">若要启用从远程位置加载的代码的执行，可以使用[`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)配置元素。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-999">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f0e7c-1000"><paramref name="path" /> 参数不是绝对路径。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1000">The <paramref name="path" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-1001"><paramref name="path" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1001">The <paramref name="path" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-1002">无法加载已找到的文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1002">A file that was found could not be loaded.</span></span>

<span data-ttu-id="f0e7c-1003">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1003">-or-</span></span>

<span data-ttu-id="f0e7c-1004">在远程程序集中执行代码的功能已禁用。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1004">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="f0e7c-1005">请参阅 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1005">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-1006"><paramref name="path" /> 参数为空字符串 ("") 或不存在。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1006">The <paramref name="path" /> parameter is an empty string ("") or does not exist.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-1007"><paramref name="path" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1007"><paramref name="path" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="f0e7c-1008">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1008">-or-</span></span> 
<span data-ttu-id="f0e7c-1009">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="path" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1009">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="path" /> was compiled with a later version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="f0e7c-1010">用于从文件或目录读取的访问权限，以及用于访问路径本身中的信息的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1010">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="f0e7c-1011">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-1011">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="f0e7c-1012">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1012">to load an assembly with evidence.</span></span> <span data-ttu-id="f0e7c-1013">关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-1013">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile (path, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFile which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="f0e7c-1014">程序集文件的完全限定路径。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1014">The fully qualified path of the assembly file.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="f0e7c-1015">用于加载程序集的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1015">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="f0e7c-1016">通过给定的程序集的路径来加载程序集，使用提供的证据将程序集加载到调用方的域中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1016">Loads an assembly given its path, loading the assembly into the domain of the caller using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-1017">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1017">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-1018">使用 <xref:System.Reflection.Assembly.LoadFile%2A> 方法加载和检查具有相同标识但位于不同路径中的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1018">Use the <xref:System.Reflection.Assembly.LoadFile%2A> method to load and examine assemblies that have the same identity, but are located in different paths.</span></span> <span data-ttu-id="f0e7c-1019"><xref:System.Reflection.Assembly.LoadFile%2A> 不会将文件加载到 <xref:System.Reflection.Assembly.LoadFrom%2A> 上下文中，并且不会使用加载路径解析依赖项，因为 <xref:System.Reflection.Assembly.LoadFrom%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1019"><xref:System.Reflection.Assembly.LoadFile%2A> does not load files into the <xref:System.Reflection.Assembly.LoadFrom%2A> context, and does not resolve dependencies using the load path, as the <xref:System.Reflection.Assembly.LoadFrom%2A> method does.</span></span> <span data-ttu-id="f0e7c-1020"><xref:System.Reflection.Assembly.LoadFile%2A> 在这种受限情况下非常有用，因为 <xref:System.Reflection.Assembly.LoadFrom%2A> 不能用于加载具有相同标识但路径不同的程序集;它将只加载第一个此类程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1020"><xref:System.Reflection.Assembly.LoadFile%2A> is useful in this limited scenario because <xref:System.Reflection.Assembly.LoadFrom%2A> cannot be used to load assemblies that have the same identities but different paths; it will load only the first such assembly.</span></span>  

<span data-ttu-id="f0e7c-1021">从 .NET Framework 4 开始，如果 `path` 指定远程位置中的程序集，则默认情况下将禁用程序集加载，`LoadFile` 方法将引发 <xref:System.IO.FileLoadException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1021">Starting with .NET Framework 4, if `path` specifies an assembly in a remote location, assembly loading is disabled by default, and the `LoadFile` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="f0e7c-1022">若要启用从远程位置加载的代码的执行，可以使用[`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)配置元素。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1022">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f0e7c-1023"><paramref name="path" /> 参数不是绝对路径。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1023">The <paramref name="path" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-1024"><paramref name="path" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1024">The <paramref name="path" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-1025"><paramref name="path" /> 参数为空字符串 ("") 或不存在。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1025">The <paramref name="path" /> parameter is an empty string ("") or does not exist.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-1026">无法加载已找到的文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1026">A file that was found could not be loaded.</span></span>

<span data-ttu-id="f0e7c-1027">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1027">-or-</span></span>

<span data-ttu-id="f0e7c-1028">在远程程序集中执行代码的功能已禁用。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1028">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="f0e7c-1029">请参阅 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1029">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-1030"><paramref name="path" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1030"><paramref name="path" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="f0e7c-1031">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1031">-or-</span></span> 
<span data-ttu-id="f0e7c-1032">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="path" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1032">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="path" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f0e7c-1033"><paramref name="securityEvidence" /> 不是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1033"><paramref name="securityEvidence" /> is not <see langword="null" />.</span></span> <span data-ttu-id="f0e7c-1034">默认情况下，[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 中未启用旧版 CAS 策略；如果未启用，则 <paramref name="securityEvidence" /> 必须为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1034">By default, legacy CAS policy is not enabled in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; when it is not enabled, <paramref name="securityEvidence" /> must be <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="f0e7c-1035">用于从文件或目录读取的访问权限，以及用于访问路径本身中的信息的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1035">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="f0e7c-1036">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-1036">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="f0e7c-1037">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1037">to load an assembly with evidence.</span></span> <span data-ttu-id="f0e7c-1038">关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-1038">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f0e7c-1039">加载程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1039">Loads an assembly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
             
## Remarks

<span data-ttu-id="f0e7c-1040">从 .NET Framework 4 开始，在默认情况下将禁用在从远程位置加载的程序集中执行代码的功能，并且对 `LoadFrom` 方法的调用将引发一个 <xref:System.IO.FileLoadException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1040">Starting with .NET Framework 4, the ability to execute code in assemblies loaded from remote locations is disabled by default, and the call to the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="f0e7c-1041">若要加载程序集并执行其代码，你必须：</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1041">To load the assembly and execute its code, you must either:</span></span>

- <span data-ttu-id="f0e7c-1042">为程序集显式创建沙盒。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1042">Explicitly create a sandbox for the assembly.</span></span> <span data-ttu-id="f0e7c-1043">（请参阅[如何：在沙盒中运行部分受信任的代码](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md)。）</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1043">(See [How to: Run Partially Trusted Code in a Sandbox](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).)</span></span>

- <span data-ttu-id="f0e7c-1044">通过将[`<loadFromRemoteSources>` 配置元素](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)的 `enabled` 特性设置为 `true`，在完全信任环境中运行程序集的代码。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1044">Run the assembly's code in full trust by setting the `enabled` attribute of the [`<loadFromRemoteSources>` configuration element](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) to `true`.</span></span> <span data-ttu-id="f0e7c-1045">有关详细信息，请参阅[`<loadFromRemoteSources>` 配置元素](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)一文。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1045">For more information, see the [`<loadFromRemoteSources>` configuration element](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) article.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="f0e7c-1046">包含程序集清单的文件的名称或路径。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1046">The name or path of the file that contains the manifest of the assembly.</span></span></param>
        <summary><span data-ttu-id="f0e7c-1047">已知程序集的文件名或路径，加载程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1047">Loads an assembly given its file name or path.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-1048">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1048">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-1049">`assemblyFile` 参数必须引用没有转义符的 URI。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1049">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="f0e7c-1050">此方法为 URI 中的所有无效字符提供转义符。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1050">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f0e7c-1051">文件传输协议（FTP）不受支持。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1051">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="f0e7c-1052">如果为 `assemblyFile` 提供的 URI 是 FTP 地址，则不会加载该程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1052">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="f0e7c-1053">不引发异常。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1053">No exception is thrown.</span></span>  
  
 <span data-ttu-id="f0e7c-1054">`assemblyFile` 可以是当前目录的绝对或相对路径，并且程序集将加载到调用方的域中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1054">`assemblyFile` may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="f0e7c-1055">可以将程序集加载到三个上下文中的一个，也可以在没有上下文的情况下加载：</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1055">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="f0e7c-1056">如果承载运行时，或在应用程序域的 <xref:System.AppDomainSetup.ApplicationBase%2A> 和 <xref:System.AppDomainSetup.PrivateBinPath%2A> 中，则加载上下文包含探测所发现的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1056">The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="f0e7c-1057"><xref:System.Reflection.Assembly.Load%2A> 方法的大多数重载都将程序集加载到此上下文中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1057">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="f0e7c-1058">加载自上下文包含的程序集，用户为其提供的路径未包含在通过探测搜索的目录中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1058">The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</span></span> <span data-ttu-id="f0e7c-1059"><xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A> 和 <xref:System.AppDomain.ExecuteAssembly%2A> 都是通过路径加载的方法的示例。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1059"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span> 

    <span data-ttu-id="f0e7c-1060">从 .NET Framework 4 开始，如果 `assemblyFile` 的 URI 指定远程位置，则默认情况下将禁用程序集加载，`LoadFrom` 方法将引发 <xref:System.IO.FileLoadException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1060">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="f0e7c-1061">若要启用从远程位置加载的代码的执行，可以使用[`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)配置元素。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1061">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="f0e7c-1062">仅反射上下文包含用 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 和 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 方法加载的程序集;这些上下文中的代码无法执行。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1062">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="f0e7c-1063">如果用户生成或找到了该程序集，则该程序集不在任何上下文中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1063">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="f0e7c-1064">这适用于使用 <xref:System.Reflection.Assembly.Load%2A> 方法的重载加载的程序集，该方法指定一个包含程序集的字节数组，并适用于使用反射发出创建但未保存到磁盘的暂时性动态程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1064">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="f0e7c-1065">加载源上下文允许从探测中未包含的路径加载程序集，并且还允许查找并加载该路径上的依赖项，因为路径信息由上下文维护。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1065">The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="f0e7c-1066"><xref:System.Reflection.Assembly.LoadFrom%2A> 方法具有以下缺点。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1066">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="f0e7c-1067">请考虑改用 <xref:System.Reflection.Assembly.Load%2A>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1067">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="f0e7c-1068">如果已加载一个具有相同标识的程序集，则即使指定了不同的路径，<xref:System.Reflection.Assembly.LoadFrom%2A> 仍返回已加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1068">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="f0e7c-1069">如果程序集是使用 <xref:System.Reflection.Assembly.LoadFrom%2A>加载的，并且稍后加载上下文中的程序集尝试按显示名称加载同一程序集，则加载尝试将失败。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1069">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="f0e7c-1070">对程序集进行反序列化时可能会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1070">This can occur when an assembly is de-serialized.</span></span>  
  
-   <span data-ttu-id="f0e7c-1071">如果程序集是使用 <xref:System.Reflection.Assembly.LoadFrom%2A>加载的，并且探测路径包含具有相同标识但不同位置的程序集，则可能会出现 <xref:System.InvalidCastException>、<xref:System.MissingMethodException>或其他意外行为。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1071">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="f0e7c-1072"><xref:System.Reflection.Assembly.LoadFrom%2A> 需要对指定路径的 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> 和 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 或 <xref:System.Net.WebPermission>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1072"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="f0e7c-1073">如果 `assemblyFile`存在本机映像，则不使用该映像。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1073">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="f0e7c-1074">无法将程序集加载为非特定域。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1074">The assembly cannot be loaded as domain neutral.</span></span>  
  
-   <span data-ttu-id="f0e7c-1075">在 .NET Framework 版本1.0 和1.1 中，不会应用策略。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1075">In the .NET Framework version 1.0 and 1.1, policy is not applied.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f0e7c-1076">下面的示例在给定程序集的文件名或路径的情况下加载该程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1076">The following example loads an assembly given its file name or path.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-1077"><paramref name="assemblyFile" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1077"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-1078">未找到 <paramref name="assemblyFile" />，或者你正在试图加载的模块未指定文件名扩展。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1078"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-1079">无法加载已找到的文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1079">A file that was found could not be loaded.</span></span>

<span data-ttu-id="f0e7c-1080">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1080">-or-</span></span>

<span data-ttu-id="f0e7c-1081">在远程程序集中执行代码的功能已禁用。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1081">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="f0e7c-1082">请参阅 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1082">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-1083"><paramref name="assemblyFile" /> 不是有效的程序集 ；例如 64 位进程中的 32 位程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1083"><paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span></span> <span data-ttu-id="f0e7c-1084">有关详细信息，请参阅异常主题。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1084">See the exception topic for more information.</span></span>  
  
<span data-ttu-id="f0e7c-1085">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1085">-or-</span></span> 
<span data-ttu-id="f0e7c-1086">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1086">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f0e7c-1087">指定了不以“file://”开头的基本代码，且没有所需的 <see cref="T:System.Net.WebPermission" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1087">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f0e7c-1088"><paramref name="assemblyFile" /> 参数为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1088">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="f0e7c-1089">程序集名称超过系统定义的最大长度。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1089">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="f0e7c-1090">用于读取以 "file://" 开头的 URI。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1090">for reading a URI that begins with "file://".</span></span> <span data-ttu-id="f0e7c-1091">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-1091">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="f0e7c-1092">用于读取不以 "file://" 开头的 URI。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1092">for reading a URI that does not begin with "file://".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="f0e7c-1093">包含程序集清单的文件的名称或路径。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1093">The name or path of the file that contains the manifest of the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="f0e7c-1094">用于加载程序集的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1094">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="f0e7c-1095">在给定程序集的文件名或路径并提供安全证据的情况下，加载程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1095">Loads an assembly given its file name or path and supplying security evidence.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-1096">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1096">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-1097">`assemblyFile` 参数必须引用没有转义符的 URI。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1097">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="f0e7c-1098">此方法为 URI 中的所有无效字符提供转义符。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1098">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f0e7c-1099">文件传输协议（FTP）不受支持。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1099">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="f0e7c-1100">如果为 `assemblyFile` 提供的 URI 是 FTP 地址，则不会加载该程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1100">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="f0e7c-1101">不引发异常。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1101">No exception is thrown.</span></span>  
  
 <span data-ttu-id="f0e7c-1102">`assemblyFile` 可以是当前目录的绝对或相对路径，并且程序集将加载到调用方的域中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1102">`assemblyFile` may be absolute or  relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="f0e7c-1103">可以将程序集加载到三个上下文中的一个，也可以在没有上下文的情况下加载：</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1103">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="f0e7c-1104">如果承载运行时，或在应用程序域的 <xref:System.AppDomainSetup.ApplicationBase%2A> 和 <xref:System.AppDomainSetup.PrivateBinPath%2A> 中，则加载上下文包含探测所发现的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1104">The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="f0e7c-1105"><xref:System.Reflection.Assembly.Load%2A> 方法的大多数重载都将程序集加载到此上下文中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1105">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="f0e7c-1106">加载自上下文包含的程序集，用户为其提供的路径未包含在通过探测搜索的目录中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1106">The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</span></span> <span data-ttu-id="f0e7c-1107"><xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A> 和 <xref:System.AppDomain.ExecuteAssembly%2A> 都是通过路径加载的方法的示例。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1107"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span>

    <span data-ttu-id="f0e7c-1108">从 .NET Framework 4 开始，如果 `assemblyFile` 的 URI 指定远程位置，则默认情况下将禁用程序集加载，`LoadFrom` 方法将引发 <xref:System.IO.FileLoadException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1108">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="f0e7c-1109">若要启用从远程位置加载的代码的执行，可以使用[`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)配置元素。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1109">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="f0e7c-1110">仅反射上下文包含用 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 和 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 方法加载的程序集;这些上下文中的代码无法执行。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1110">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="f0e7c-1111">如果用户生成或找到了该程序集，则该程序集不在任何上下文中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1111">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="f0e7c-1112">这适用于使用 <xref:System.Reflection.Assembly.Load%2A> 方法的重载加载的程序集，该方法指定一个包含程序集的字节数组，并适用于使用反射发出创建但未保存到磁盘的暂时性动态程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1112">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="f0e7c-1113">加载源上下文允许从探测中未包含的路径加载程序集，并且还允许查找并加载该路径上的依赖项，因为路径信息由上下文维护。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1113">The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="f0e7c-1114"><xref:System.Reflection.Assembly.LoadFrom%2A> 方法具有以下缺点。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1114">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="f0e7c-1115">请考虑改用 <xref:System.Reflection.Assembly.Load%2A>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1115">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="f0e7c-1116">如果已加载一个具有相同标识的程序集，则即使指定了不同的路径，<xref:System.Reflection.Assembly.LoadFrom%2A> 仍返回已加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1116">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="f0e7c-1117">如果程序集是使用 <xref:System.Reflection.Assembly.LoadFrom%2A>加载的，并且稍后加载上下文中的程序集尝试按显示名称加载同一程序集，则加载尝试将失败。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1117">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="f0e7c-1118">对程序集进行反序列化时，可能发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1118">This can occur when an assembly is deserialized.</span></span>  
  
-   <span data-ttu-id="f0e7c-1119">如果程序集是使用 <xref:System.Reflection.Assembly.LoadFrom%2A>加载的，并且探测路径包含具有相同标识但不同位置的程序集，则可能会出现 <xref:System.InvalidCastException>、<xref:System.MissingMethodException>或其他意外行为。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1119">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="f0e7c-1120"><xref:System.Reflection.Assembly.LoadFrom%2A> 需要对指定路径的 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> 和 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 或 <xref:System.Net.WebPermission>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1120"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="f0e7c-1121">如果 `assemblyFile`存在本机映像，则不使用该映像。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1121">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="f0e7c-1122">无法将程序集加载为非特定域。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1122">The assembly cannot be loaded as domain neutral.</span></span>  
  
-   <span data-ttu-id="f0e7c-1123">在 .NET Framework 版本1.0 和1.1 中，不会应用策略。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1123">In the .NET Framework version 1.0 and 1.1, policy is not applied.</span></span>  
  
 <span data-ttu-id="f0e7c-1124">是否将特定的权限授予程序集是基于证据的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1124">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="f0e7c-1125">程序集和安全证据合并的规则如下所示：</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1125">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="f0e7c-1126">使用不带 <xref:System.Security.Policy.Evidence> 参数的 <xref:System.Reflection.Assembly.LoadFrom%2A> 方法时，将使用加载程序提供的证据加载程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1126">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="f0e7c-1127">将 <xref:System.Reflection.Assembly.LoadFrom%2A> 方法与 <xref:System.Security.Policy.Evidence> 参数一起使用时，会合并证据部分。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1127">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="f0e7c-1128">作为 <xref:System.Reflection.Assembly.LoadFrom%2A> 方法的参数提供的证据将取代加载程序提供的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1128">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.LoadFrom%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="f0e7c-1129">如果对同一程序集多次调用此方法，但指定了不同的证据，则公共语言运行时将不会引发 <xref:System.IO.FileLoadException>，因为无法确定不同证据规范的相等性和完整性。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1129">If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="f0e7c-1130">第一次成功的证据是使用的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1130">The evidence that first succeeds is the evidence that is used.</span></span>  
  
-   <span data-ttu-id="f0e7c-1131">当使用带有 `Byte[]` 参数的 <xref:System.Reflection.Assembly.LoadFrom%2A> 方法加载通用对象文件格式（COFF）图像时，会结合证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1131">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is combined.</span></span> <span data-ttu-id="f0e7c-1132">`Zone`，`Url` 和 `Site` 继承自调用程序集，并从 COFF 程序集获取 `Hash` 和 `StrongName`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1132">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="f0e7c-1133">将 <xref:System.Reflection.Assembly.LoadFrom%2A> 方法与 `Byte[]` 参数一起使用时，如果 <xref:System.Security.Policy.Evidence> 加载 COFF 图像，则只使用提供的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1133">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="f0e7c-1134">将忽略调用程序集和 COFF 图像的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1134">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-1135"><paramref name="assemblyFile" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1135"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-1136">未找到 <paramref name="assemblyFile" />，或者你正在试图加载的模块未指定文件名扩展。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1136"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-1137">无法加载已找到的文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1137">A file that was found could not be loaded.</span></span>  
  
<span data-ttu-id="f0e7c-1138">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1138">-or-</span></span> 
<span data-ttu-id="f0e7c-1139"><paramref name="securityEvidence" /> 是明确的，但被确定为无效。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1139">The <paramref name="securityEvidence" /> is not ambiguous and is determined to be invalid.</span></span>

<span data-ttu-id="f0e7c-1140">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1140">-or-</span></span>

<span data-ttu-id="f0e7c-1141">在远程程序集中执行代码的功能已禁用。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1141">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="f0e7c-1142">请参阅 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1142">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-1143"><paramref name="assemblyFile" /> 不是有效的程序集 ；例如 64 位进程中的 32 位程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1143"><paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span></span> <span data-ttu-id="f0e7c-1144">有关详细信息，请参阅异常主题。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1144">See the exception topic for more information.</span></span>  
  
<span data-ttu-id="f0e7c-1145">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1145">-or-</span></span> 
<span data-ttu-id="f0e7c-1146">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1146">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f0e7c-1147">指定了不以“file://”开头的基本代码，且没有所需的 <see cref="T:System.Net.WebPermission" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1147">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f0e7c-1148"><paramref name="assemblyFile" /> 参数为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1148">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="f0e7c-1149">程序集名称超过系统定义的最大长度。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1149">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="f0e7c-1150">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1150">to load an assembly with evidence.</span></span> <span data-ttu-id="f0e7c-1151">关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-1151">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="f0e7c-1152">用于读取以 "file://" 开头的 URI。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1152">for reading a URI that begins with "file://".</span></span> <span data-ttu-id="f0e7c-1153">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-1153">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="f0e7c-1154">用于读取不以 "file://" 开头的 URI。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1154">for reading a URI that does not begin with "file://".</span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="f0e7c-1155">包含程序集清单的文件的名称或路径。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1155">The name or path of the file that contains the manifest of the assembly.</span></span></param>
        <param name="hashValue"><span data-ttu-id="f0e7c-1156">计算所得的哈希代码的值。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1156">The value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f0e7c-1157">用于对文件进行哈希处理并生成强名称的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1157">The hash algorithm used for hashing files and for generating the strong name.</span></span></param>
        <summary><span data-ttu-id="f0e7c-1158">通过给定程序集文件名或路径、哈希值及哈希算法来加载程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1158">Loads an assembly given its file name or path, hash value, and hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-1159">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1159">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-1160">`assemblyFile` 参数必须引用没有转义符的 URI。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1160">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="f0e7c-1161">此方法为 URI 中的所有无效字符提供转义符。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1161">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f0e7c-1162">文件传输协议（FTP）不受支持。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1162">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="f0e7c-1163">如果为 `assemblyFile` 提供的 URI 是 FTP 地址，则不会加载该程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1163">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="f0e7c-1164">不引发异常。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1164">No exception is thrown.</span></span>  
  
 <span data-ttu-id="f0e7c-1165">`assemblyFile` 可以是当前目录的绝对或相对路径，并且程序集将加载到调用方的域中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1165">`assemblyFile` may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="f0e7c-1166">可以将程序集加载到三个上下文中的一个，也可以在没有上下文的情况下加载：</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1166">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="f0e7c-1167">加载上下文包含探测发现的程序集：全局程序集缓存中的程序集（如果承载运行时）、或在应用程序域的 <xref:System.AppDomainSetup.ApplicationBase%2A> 和 <xref:System.AppDomainSetup.PrivateBinPath%2A> 中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1167">The load context contains assemblies found by probing: in the global assembly cache, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="f0e7c-1168"><xref:System.Reflection.Assembly.Load%2A> 方法的大多数重载都将程序集加载到此上下文中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1168">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="f0e7c-1169">加载内容上下文包含用户为其提供的路径未包含在探测中的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1169">The load-from context contains assemblies for which the user provided a path that is not included in probing.</span></span> <span data-ttu-id="f0e7c-1170"><xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A> 和 <xref:System.AppDomain.ExecuteAssembly%2A> 都是通过路径加载的方法的示例。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1170"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span>  

    <span data-ttu-id="f0e7c-1171">从 .NET Framework 4 开始，如果 `assemblyFile` 的 URI 指定远程位置，则默认情况下将禁用程序集加载，`LoadFrom` 方法将引发 <xref:System.IO.FileLoadException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1171">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="f0e7c-1172">若要启用从远程位置加载的代码的执行，可以使用[`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)配置元素。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1172">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="f0e7c-1173">仅反射上下文包含用 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 和 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 方法加载的程序集;这些上下文中的代码无法执行。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1173">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="f0e7c-1174">如果用户生成或找到了该程序集，则该程序集不在任何上下文中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1174">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="f0e7c-1175">这适用于使用 <xref:System.Reflection.Assembly.Load%2A> 方法的重载加载的程序集，该方法指定一个包含程序集的字节数组，并适用于使用反射发出创建但未保存到磁盘的暂时性动态程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1175">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="f0e7c-1176">加载源上下文允许从探测中未包含的路径加载程序集，并且还允许查找和加载该路径上的依赖项，因为路径信息由上下文维护。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1176">The load-from context allows an assembly to be loaded from a path that is not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="f0e7c-1177"><xref:System.Reflection.Assembly.LoadFrom%2A> 方法具有以下缺点。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1177">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="f0e7c-1178">请考虑改用 <xref:System.Reflection.Assembly.Load%2A>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1178">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="f0e7c-1179">如果已加载一个具有相同标识的程序集，则即使指定了不同的路径，<xref:System.Reflection.Assembly.LoadFrom%2A> 仍返回已加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1179">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="f0e7c-1180">如果程序集是使用 <xref:System.Reflection.Assembly.LoadFrom%2A>加载的，并且稍后加载上下文中的程序集尝试按显示名称加载同一程序集，则加载尝试将失败。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1180">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="f0e7c-1181">对程序集进行反序列化时，可能发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1181">This can occur when an assembly is deserialized.</span></span>  
  
-   <span data-ttu-id="f0e7c-1182">如果程序集是使用 <xref:System.Reflection.Assembly.LoadFrom%2A>加载的，并且探测路径包含具有相同标识但不同位置的程序集，则可能会出现 <xref:System.InvalidCastException>、<xref:System.MissingMethodException>或其他意外行为。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1182">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="f0e7c-1183"><xref:System.Reflection.Assembly.LoadFrom%2A> 需要对指定路径的 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> 和 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 或 <xref:System.Net.WebPermission>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1183"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="f0e7c-1184">如果 `assemblyFile`存在本机映像，则不使用该映像。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1184">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="f0e7c-1185">程序集不能以非特定于域的方式加载。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1185">The assembly cannot be loaded as domain-neutral.</span></span>  
  
 <span data-ttu-id="f0e7c-1186">该程序集与加载程序所提供的证据一起加载。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1186">The assembly is loaded with the evidence that the loader supplies.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-1187"><paramref name="assemblyFile" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1187"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-1188">未找到 <paramref name="assemblyFile" />，或者你正在试图加载的模块未指定文件扩展名。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1188"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a file name extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-1189">无法加载已找到的文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1189">A file that was found could not be loaded.</span></span>

<span data-ttu-id="f0e7c-1190">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1190">-or-</span></span>

<span data-ttu-id="f0e7c-1191">在远程程序集中执行代码的功能已禁用。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1191">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="f0e7c-1192">请参阅 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1192">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-1193"><paramref name="assemblyFile" /> 不是有效的程序集 ；例如 64 位进程中的 32 位程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1193"><paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span></span> <span data-ttu-id="f0e7c-1194">有关详细信息，请参阅异常主题。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1194">See the exception topic for more information.</span></span>  
  
<span data-ttu-id="f0e7c-1195">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1195">-or-</span></span> 
 <span data-ttu-id="f0e7c-1196"><paramref name="assemblyFile" /> 使用高于当前所加载版本的公共语言运行时版本编译而成。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1196"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f0e7c-1197">指定了不以“file://”开头的基本代码，且没有所需的 <see cref="T:System.Net.WebPermission" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1197">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f0e7c-1198"><paramref name="assemblyFile" /> 参数为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1198">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="f0e7c-1199">程序集名称超过系统定义的最大长度。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1199">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="f0e7c-1200">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1200">to load an assembly with evidence.</span></span> <span data-ttu-id="f0e7c-1201">关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-1201">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="f0e7c-1202">用于读取以 "file://" 开头的 URI。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1202">for reading a URI that begins with "file://".</span></span> <span data-ttu-id="f0e7c-1203">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-1203">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="f0e7c-1204">用于读取不以 "file://" 开头的 URI。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1204">for reading a URI that does not begin with "file://".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="f0e7c-1205">包含程序集清单的文件的名称或路径。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1205">The name or path of the file that contains the manifest of the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="f0e7c-1206">用于加载程序集的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1206">Evidence for loading the assembly.</span></span></param>
        <param name="hashValue"><span data-ttu-id="f0e7c-1207">计算所得的哈希代码的值。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1207">The value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="f0e7c-1208">用于对文件进行哈希处理并生成强名称的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1208">The hash algorithm used for hashing files and for generating the strong name.</span></span></param>
        <summary><span data-ttu-id="f0e7c-1209">通过给定程序集文件名或路径、安全证据、哈希值及哈希算法来加载程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1209">Loads an assembly given its file name or path, security evidence, hash value, and hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-1210">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1210">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-1211">`assemblyFile` 参数必须引用没有转义符的 URI。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1211">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="f0e7c-1212">此方法为 URI 中的所有无效字符提供转义符。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1212">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f0e7c-1213">文件传输协议（FTP）不受支持。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1213">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="f0e7c-1214">如果为 `assemblyFile` 提供的 URI 是 FTP 地址，则不会加载该程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1214">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="f0e7c-1215">不引发异常。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1215">No exception is thrown.</span></span>  
  
 <span data-ttu-id="f0e7c-1216">`assemblyFile` 可以是当前目录的绝对或相对路径，并且程序集将加载到调用方的域中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1216">`assemblyFile` may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="f0e7c-1217">可以将程序集加载到三个上下文中的一个，也可以在没有上下文的情况下加载：</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1217">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="f0e7c-1218">如果承载运行时，或在应用程序域的 <xref:System.AppDomainSetup.ApplicationBase%2A> 和 <xref:System.AppDomainSetup.PrivateBinPath%2A> 中，则加载上下文包含探测所发现的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1218">The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="f0e7c-1219"><xref:System.Reflection.Assembly.Load%2A> 方法的大多数重载都将程序集加载到此上下文中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1219">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="f0e7c-1220">加载自上下文包含的程序集，用户为其提供的路径未包含在通过探测搜索的目录中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1220">The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</span></span> <span data-ttu-id="f0e7c-1221"><xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A> 和 <xref:System.AppDomain.ExecuteAssembly%2A> 都是通过路径加载的方法的示例。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1221"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span>  

    <span data-ttu-id="f0e7c-1222">从 .NET Framework 4 开始，如果 `assemblyFile` 的 URI 指定远程位置，则默认情况下将禁用程序集加载，`LoadFrom` 方法将引发 <xref:System.IO.FileLoadException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1222">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="f0e7c-1223">若要启用从远程位置加载的代码的执行，可以使用[`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)配置元素。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1223">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="f0e7c-1224">仅反射上下文包含用 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 和 <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> 方法加载的程序集;这些上下文中的代码无法执行。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1224">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="f0e7c-1225">如果用户生成或找到了该程序集，则该程序集不在任何上下文中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1225">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="f0e7c-1226">这适用于使用 <xref:System.Reflection.Assembly.Load%2A> 方法的重载加载的程序集，该方法指定一个包含程序集的字节数组，并适用于使用反射发出创建但未保存到磁盘的暂时性动态程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1226">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="f0e7c-1227">加载源上下文允许从探测中未包含的路径加载程序集，并且还允许查找并加载该路径上的依赖项，因为路径信息由上下文维护。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1227">The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="f0e7c-1228"><xref:System.Reflection.Assembly.LoadFrom%2A> 方法具有以下缺点。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1228">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="f0e7c-1229">请考虑改用 <xref:System.Reflection.Assembly.Load%2A>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1229">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="f0e7c-1230">如果已加载一个具有相同标识的程序集，则即使指定了不同的路径，<xref:System.Reflection.Assembly.LoadFrom%2A> 仍返回已加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1230">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="f0e7c-1231">如果程序集是使用 <xref:System.Reflection.Assembly.LoadFrom%2A>加载的，并且稍后加载上下文中的程序集尝试按显示名称加载同一程序集，则加载尝试将失败。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1231">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="f0e7c-1232">对程序集进行反序列化时，可能发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1232">This can occur when an assembly is deserialized.</span></span>  
  
-   <span data-ttu-id="f0e7c-1233">如果程序集是使用 <xref:System.Reflection.Assembly.LoadFrom%2A>加载的，并且探测路径包含具有相同标识但不同位置的程序集，则可能会出现 <xref:System.InvalidCastException>、<xref:System.MissingMethodException>或其他意外行为。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1233">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="f0e7c-1234"><xref:System.Reflection.Assembly.LoadFrom%2A> 需要对指定路径的 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> 和 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 或 <xref:System.Net.WebPermission>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1234"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="f0e7c-1235">如果 `assemblyFile`存在本机映像，则不使用该映像。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1235">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="f0e7c-1236">无法将程序集加载为非特定域。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1236">The assembly cannot be loaded as domain neutral.</span></span>  
  
-   <span data-ttu-id="f0e7c-1237">在 .NET Framework 版本1.0 和1.1 中，不会应用策略。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1237">In the .NET Framework version 1.0 and 1.1, policy is not applied.</span></span>  
  
 <span data-ttu-id="f0e7c-1238">是否将特定的权限授予程序集是基于证据的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1238">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="f0e7c-1239">程序集和安全证据合并的规则如下所示：</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1239">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="f0e7c-1240">使用不带 <xref:System.Security.Policy.Evidence> 参数的 <xref:System.Reflection.Assembly.LoadFrom%2A> 方法时，将使用加载程序提供的证据加载程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1240">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="f0e7c-1241">将 <xref:System.Reflection.Assembly.LoadFrom%2A> 方法与 <xref:System.Security.Policy.Evidence> 参数一起使用时，会合并证据部分。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1241">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="f0e7c-1242">作为 <xref:System.Reflection.Assembly.LoadFrom%2A> 方法的参数提供的证据将取代加载程序提供的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1242">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.LoadFrom%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="f0e7c-1243">如果对同一程序集多次调用此方法，但指定了不同的证据，则公共语言运行时将不会引发 <xref:System.IO.FileLoadException>，因为无法确定不同证据规范的相等性和完整性。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1243">If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="f0e7c-1244">第一次成功的证据是使用的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1244">The evidence that first succeeds is the evidence that is used.</span></span>  
  
-   <span data-ttu-id="f0e7c-1245">当使用带有 `Byte[]` 参数的 <xref:System.Reflection.Assembly.LoadFrom%2A> 方法加载通用对象文件格式（COFF）图像时，会结合证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1245">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is combined.</span></span> <span data-ttu-id="f0e7c-1246">`Zone`，`Url` 和 `Site` 继承自调用程序集，并从 COFF 程序集获取 `Hash` 和 `StrongName`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1246">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="f0e7c-1247">将 <xref:System.Reflection.Assembly.LoadFrom%2A> 方法与 `Byte[]` 参数一起使用时，如果 <xref:System.Security.Policy.Evidence> 加载 COFF 图像，则只使用提供的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1247">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="f0e7c-1248">将忽略调用程序集和 COFF 图像的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1248">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-1249"><paramref name="assemblyFile" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1249"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-1250">未找到 <paramref name="assemblyFile" />，或者你正在试图加载的模块未指定文件名扩展。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1250"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-1251">无法加载已找到的文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1251">A file that was found could not be loaded.</span></span>  
  
<span data-ttu-id="f0e7c-1252">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1252">-or-</span></span> 
<span data-ttu-id="f0e7c-1253"><paramref name="securityEvidence" /> 是明确的，但被确定为无效。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1253">The <paramref name="securityEvidence" /> is not ambiguous and is determined to be invalid.</span></span>

<span data-ttu-id="f0e7c-1254">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1254">-or-</span></span>

<span data-ttu-id="f0e7c-1255">在远程程序集中执行代码的功能已禁用。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1255">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="f0e7c-1256">请参阅 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1256">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-1257"><paramref name="assemblyFile" /> 不是有效的程序集 ；例如 64 位进程中的 32 位程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1257"><paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span></span> <span data-ttu-id="f0e7c-1258">有关详细信息，请参阅异常主题。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1258">See the exception topic for more information.</span></span>  
  
<span data-ttu-id="f0e7c-1259">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1259">-or-</span></span> 
<span data-ttu-id="f0e7c-1260">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1260">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f0e7c-1261">指定了不以“file://”开头的基本代码，且没有所需的 <see cref="T:System.Net.WebPermission" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1261">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f0e7c-1262"><paramref name="assemblyFile" /> 参数为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1262">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="f0e7c-1263">程序集名称超过系统定义的最大长度。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1263">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="f0e7c-1264">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1264">to load an assembly with evidence.</span></span> <span data-ttu-id="f0e7c-1265">关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-1265">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="f0e7c-1266">用于读取以 "file://" 开头的 URI。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1266">for reading a URI that begins with "file://".</span></span> <span data-ttu-id="f0e7c-1267">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-1267">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="f0e7c-1268">用于读取不以 "file://" 开头的 URI。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1268">for reading a URI that does not begin with "file://".</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadModule">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f0e7c-1269">加载此程序集的内部模块。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1269">Loads the module internal to this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module LoadModule (string moduleName, byte[] rawModule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadModule (moduleName As String, rawModule As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.LoadModule : string * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="rawModule" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="moduleName"><span data-ttu-id="f0e7c-1270">模块的名称。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1270">The name of the module.</span></span> <span data-ttu-id="f0e7c-1271">此字符串必须与程序集清单中的文件名对应。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1271">This string must correspond to a file name in this assembly's manifest.</span></span></param>
        <param name="rawModule"><span data-ttu-id="f0e7c-1272">基于 COFF 映像的字节数组，该数组包含发送的模块或资源。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1272">A byte array that is a COFF-based image containing an emitted module, or a resource.</span></span></param>
        <summary><span data-ttu-id="f0e7c-1273">加载带有基于通用对象文件格式 (COFF) 的映像（包含已发出的模块）或资源文件的模块（该模块相对于此程序集是内部的）。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1273">Loads the module, internal to this assembly, with a common object file format (COFF)-based image containing an emitted module, or a resource file.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-1274">加载的模块。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1274">The loaded module.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-1275"><paramref name="moduleName" /> 或 <paramref name="rawModule" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1275"><paramref name="moduleName" /> or <paramref name="rawModule" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f0e7c-1276"><paramref name="moduleName" /> 与此程序集清单中的文件条目不匹配。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1276"><paramref name="moduleName" /> does not match a file entry in this assembly's manifest.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-1277"><paramref name="rawModule" /> 不是有效的模块。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1277"><paramref name="rawModule" /> is not a valid module.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-1278">无法加载已找到的文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1278">A file that was found could not be loaded.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="f0e7c-1279">提供证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1279">to provide evidence.</span></span> <span data-ttu-id="f0e7c-1280">关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-1280">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module LoadModule (string moduleName, byte[] rawModule, byte[] rawSymbolStore);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LoadModule (moduleName As String, rawModule As Byte(), rawSymbolStore As Byte()) As Module" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule, rawSymbolStore)" />
      <MemberSignature Language="C#" Value="public System.Reflection.Module LoadModule (string moduleName, byte[] rawModule, byte[] rawSymbolStore);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadModule (moduleName As String, rawModule As Byte(), rawSymbolStore As Byte()) As Module" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="rawModule" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="moduleName"><span data-ttu-id="f0e7c-1281">模块的名称。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1281">The name of the module.</span></span> <span data-ttu-id="f0e7c-1282">此字符串必须与程序集清单中的文件名对应。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1282">This string must correspond to a file name in this assembly's manifest.</span></span></param>
        <param name="rawModule"><span data-ttu-id="f0e7c-1283">基于 COFF 映像的字节数组，该数组包含发送的模块或资源。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1283">A byte array that is a COFF-based image containing an emitted module, or a resource.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="f0e7c-1284">一个字节数组，包含表示模块符号的原始字节。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1284">A byte array containing the raw bytes representing the symbols for the module.</span></span> <span data-ttu-id="f0e7c-1285">如果这是一个资源文件，则必须为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1285">Must be <see langword="null" /> if this is a resource file.</span></span></param>
        <summary><span data-ttu-id="f0e7c-1286">加载带有基于通用对象文件格式 (COFF) 的映像（包含已发出的模块）或资源文件的模块（该模块相对于此程序集是内部的）。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1286">Loads the module, internal to this assembly, with a common object file format (COFF)-based image containing an emitted module, or a resource file.</span></span> <span data-ttu-id="f0e7c-1287">还加载表示此模块的符号的原始字节。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1287">The raw bytes representing the symbols for the module are also loaded.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-1288">加载的模块。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1288">The loaded module.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-1289"><paramref name="moduleName" /> 或 <paramref name="rawModule" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1289"><paramref name="moduleName" /> or <paramref name="rawModule" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f0e7c-1290"><paramref name="moduleName" /> 与此程序集清单中的文件条目不匹配。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1290"><paramref name="moduleName" /> does not match a file entry in this assembly's manifest.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-1291"><paramref name="rawModule" /> 不是有效的模块。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1291"><paramref name="rawModule" /> is not a valid module.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-1292">无法加载已找到的文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1292">A file that was found could not be loaded.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="f0e7c-1293">提供证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1293">to provide evidence.</span></span> <span data-ttu-id="f0e7c-1294">关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-1294">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadWithPartialName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f0e7c-1295">使用部分名称从应用程序目录或从全局程序集缓存加载程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1295">Loads an assembly from the application directory or from the global assembly cache using a partial name.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="f0e7c-1296"><xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> 方法的重载已过时，已保留以实现向后兼容性。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1296">The overloads of the <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> method are obsolete and have been retained for backward compatibility.</span></span> <span data-ttu-id="f0e7c-1297">未过时的替代项为 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1297">The non-obsolete alternative is <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName partialName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="partialName"><span data-ttu-id="f0e7c-1298">程序集的显示名称。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1298">The display name of the assembly.</span></span></param>
        <summary><span data-ttu-id="f0e7c-1299">使用部分名称从应用程序目录或从全局程序集缓存加载程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1299">Loads an assembly from the application directory or from the global assembly cache using a partial name.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-1300">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1300">The loaded assembly.</span></span> <span data-ttu-id="f0e7c-1301">如果未找到 <paramref name="partialName" />，此方法将返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1301">If <paramref name="partialName" /> is not found, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="f0e7c-1302"><xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29> 方法已过时，已保留下来是为了向后兼容。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1302">The <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29> method is obsolete and has been retained for backward compatibility.</span></span> <span data-ttu-id="f0e7c-1303">未过时的替代项为 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1303">The non-obsolete alternative is <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f0e7c-1304">使用此方法加载程序集的应用程序将受到这些程序集升级的影响。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1304">Applications that load assemblies with this method will be affected by upgrades of those assemblies.</span></span> <span data-ttu-id="f0e7c-1305">因此，请不要使用此方法;重新设计应用程序以使用 <xref:System.Reflection.Assembly.Load%28System.String%29> 方法重载或 <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> 方法重载。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1305">Therefore, do not use this method; redesign the application to use the <xref:System.Reflection.Assembly.Load%28System.String%29> method overload or the <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> method overload.</span></span>  
  
 <span data-ttu-id="f0e7c-1306">此方法首先调用 <xref:System.Reflection.Assembly.Load%2A>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1306">This method first calls <xref:System.Reflection.Assembly.Load%2A>.</span></span> <span data-ttu-id="f0e7c-1307">如果未找到该程序集，则此方法将从具有相同简单名称和最高版本号的全局程序集缓存返回程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1307">If the assembly is not found, this method returns the assembly from the global assembly cache that has the same simple name, and the highest version number.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-1308"><paramref name="partialName" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1308">The <paramref name="partialName" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-1309"><paramref name="assemblyFile" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1309"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="f0e7c-1310">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1310">-or-</span></span> 
<span data-ttu-id="f0e7c-1311">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="partialName" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1311">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="partialName" /> was compiled with a later version.</span></span></exception>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName (partialName, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="partialName"><span data-ttu-id="f0e7c-1312">程序集的显示名称。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1312">The display name of the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="f0e7c-1313">用于加载程序集的证据。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1313">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="f0e7c-1314">使用部分名称从应用程序目录或从全局程序集缓存加载程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1314">Loads an assembly from the application directory or from the global assembly cache using a partial name.</span></span> <span data-ttu-id="f0e7c-1315">使用提供的证据将该程序集加载到调用方的域中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1315">The assembly is loaded into the domain of the caller using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-1316">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1316">The loaded assembly.</span></span> <span data-ttu-id="f0e7c-1317">如果未找到 <paramref name="partialName" />，此方法将返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1317">If <paramref name="partialName" /> is not found, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="f0e7c-1318"><xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29> 方法已过时，已保留下来是为了向后兼容。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1318">The <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29> method is obsolete and has been retained for backward compatibility.</span></span> <span data-ttu-id="f0e7c-1319">未过时的替代项为 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1319">The non-obsolete alternative is <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f0e7c-1320">证据是输入安全策略决策的一组信息（如代码可授予哪些权限）。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1320">Evidence is the set of information that constitutes input to security policy decisions, such as what permissions can be granted to code.</span></span>  
  
 <span data-ttu-id="f0e7c-1321">使用此方法加载程序集的应用程序将受到这些程序集升级的影响。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1321">Applications that load assemblies with this method will be affected by upgrades of those assemblies.</span></span> <span data-ttu-id="f0e7c-1322">因此，请不要使用此方法;重新设计应用程序以使用 <xref:System.Reflection.Assembly.Load%2A> 方法或 <xref:System.Reflection.Assembly.LoadFrom%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1322">Therefore, do not use this method; redesign the application to use the <xref:System.Reflection.Assembly.Load%2A> method or the <xref:System.Reflection.Assembly.LoadFrom%2A> method.</span></span>  
  
 <span data-ttu-id="f0e7c-1323">此方法首先调用 <xref:System.Reflection.Assembly.Load%2A>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1323">This method first calls <xref:System.Reflection.Assembly.Load%2A>.</span></span> <span data-ttu-id="f0e7c-1324">如果未找到该程序集，则此方法将从具有相同简单名称和最高版本号的全局程序集缓存返回程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1324">If the assembly is not found, this method returns the assembly from the global assembly cache that has the same simple name, and the highest version number.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-1325">一个程序集或模块用两个不同的证据集加载了两次。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1325">An assembly or module was loaded twice with two different sets of evidence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-1326"><paramref name="partialName" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1326">The <paramref name="partialName" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-1327"><paramref name="assemblyFile" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1327"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="f0e7c-1328">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1328">-or-</span></span> 
<span data-ttu-id="f0e7c-1329">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="partialName" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1329">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="partialName" /> was compiled with a later version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="f0e7c-1330">用于调用非托管代码和加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1330">for calling unmanaged code and to load an assembly with evidence.</span></span> <span data-ttu-id="f0e7c-1331">关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-1331">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public virtual string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Location" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Location As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Location { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Location : string" Usage="System.Reflection.Assembly.Location" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Location</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f0e7c-1332">获取包含清单的已加载文件的完整路径或 UNC 位置。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1332">Gets the full path or UNC location of the loaded file that contains the manifest.</span></span></summary>
        <value><span data-ttu-id="f0e7c-1333">包含清单的已加载文件的位置。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1333">The location of the loaded file that contains the manifest.</span></span> <span data-ttu-id="f0e7c-1334">如果已加载文件使用了影像复制，则该位置是该文件被影像复制后的位置。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1334">If the loaded file was shadow-copied, the location is that of the file after being shadow-copied.</span></span> <span data-ttu-id="f0e7c-1335">如果从字节数组加载程序集（如使用 <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /> 方法重载时），则返回值为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1335">If the assembly is loaded from a byte array, such as when using the <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /> method overload, the value returned is an empty string ("").</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-1336">若要在文件已进行卷影复制之前获取位置，请使用 <xref:System.Reflection.Assembly.CodeBase%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1336">To get the location before the file has been shadow-copied, use the <xref:System.Reflection.Assembly.CodeBase%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f0e7c-1337">下面的示例显示了包含清单的已加载文件的位置。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1337">The following example displays the location of the loaded file that contains the manifest.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#3)]
 [!code-csharp[System.Reflection.Assembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#3)]
 [!code-vb[System.Reflection.Assembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f0e7c-1338">当前的程序集是动态程序集，由 <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> 对象表示。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1338">The current assembly is a dynamic assembly, represented by an <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> object.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="f0e7c-1339">用于访问路径。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1339">for access to the path.</span></span> <span data-ttu-id="f0e7c-1340">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-1340">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="f0e7c-1341">卷影复制程序集</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1341">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module ManifestModule { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ManifestModule" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ManifestModule As Module" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ ManifestModule { System::Reflection::Module ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.ManifestModule : System.Reflection.Module" Usage="System.Reflection.Assembly.ManifestModule" />
      <MemberSignature Language="C#" Value="public System.Reflection.Module ManifestModule { get; }" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManifestModule As Module" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Module ^ ManifestModule { System::Reflection::Module ^ get(); };" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f0e7c-1342">获取包含当前程序集清单的模块。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1342">Gets the module that contains the manifest for the current assembly.</span></span></summary>
        <value><span data-ttu-id="f0e7c-1343">包含程序集清单的模块。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1343">The module that contains the manifest for the assembly.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleResolve">
      <MemberSignature Language="C#" Value="public virtual event System.Reflection.ModuleResolveEventHandler ModuleResolve;" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".event class System.Reflection.ModuleResolveEventHandler ModuleResolve" />
      <MemberSignature Language="DocId" Value="E:System.Reflection.Assembly.ModuleResolve" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Custom Event ModuleResolve As ModuleResolveEventHandler " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Reflection::ModuleResolveEventHandler ^ ModuleResolve;" />
      <MemberSignature Language="F#" Value="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " Usage="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " />
      <MemberSignature Language="C#" Value="public event System.Reflection.ModuleResolveEventHandler ModuleResolve;" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ModuleResolve As ModuleResolveEventHandler " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Runtime.InteropServices._Assembly.ModuleResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ModuleResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f0e7c-1344">当公共语言运行时类加载程序不能通过正常方法解析对程序集的内部模块的引用时发生。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1344">Occurs when the common language runtime class loader cannot resolve a reference to an internal module of an assembly through normal means.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-1345">此事件为回调提供一个机会来查找并加载模块本身并返回它。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1345">This event gives the callback a chance to find and load the module itself and return it.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f0e7c-1346">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1346">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="f0e7c-1347">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1347">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Modules" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Modules As IEnumerable(Of Module)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ Modules { System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.Modules : seq&lt;System.Reflection.Module&gt;" Usage="System.Reflection.Assembly.Modules" />
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Modules As IEnumerable(Of Module)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ Modules { System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f0e7c-1348">获取包含此程序集中模块的集合。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1348">Gets a collection that contains the modules in this assembly.</span></span></summary>
        <value><span data-ttu-id="f0e7c-1349">包含此程序集中模块的集合。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1349">A collection that contains the modules in this assembly.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="right" Type="System.Reflection.Assembly" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="f0e7c-1350">要与 <paramref name="right" /> 进行比较的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1350">The assembly to compare to <paramref name="right" />.</span></span></param>
        <param name="right"><span data-ttu-id="f0e7c-1351">要与 <paramref name="left" /> 进行比较的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1351">The assembly to compare to <paramref name="left" />.</span></span></param>
        <summary><span data-ttu-id="f0e7c-1352">指示两个 <see cref="T:System.Reflection.Assembly" /> 对象是否相等。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1352">Indicates whether two <see cref="T:System.Reflection.Assembly" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-1353">如果 <see langword="true" /> 等于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1353"><see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="System.Reflection.Assembly.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="right" Type="System.Reflection.Assembly" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="f0e7c-1354">要与 <paramref name="right" /> 进行比较的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1354">The assembly to compare to <paramref name="right" />.</span></span></param>
        <param name="right"><span data-ttu-id="f0e7c-1355">要与 <paramref name="left" /> 进行比较的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1355">The assembly to compare to <paramref name="left" />.</span></span></param>
        <summary><span data-ttu-id="f0e7c-1356">指示两个 <see cref="T:System.Reflection.Assembly" /> 对象是否不相等。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1356">Indicates whether two <see cref="T:System.Reflection.Assembly" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-1357">如果 <see langword="true" /> 不等于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1357"><see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.Reflection.Assembly.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f0e7c-1358">获取当前程序集的授予集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1358">Gets the grant set of the current assembly.</span></span></summary>
        <value><span data-ttu-id="f0e7c-1359">当前程序集的授予集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1359">The grant set of the current assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-1360"><xref:System.Security.PermissionSet> 对象可以包含敏感信息，如路径。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1360"><xref:System.Security.PermissionSet> objects can contain sensitive information such as paths.</span></span> <span data-ttu-id="f0e7c-1361">因此，访问这些对象需要完全信任。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1361">Therefore, full trust is required to access these objects.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f0e7c-1362">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1362">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f0e7c-1363">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1363">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public virtual bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ReflectionOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReflectionOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ReflectionOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnly : bool" Usage="System.Reflection.Assembly.ReflectionOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f0e7c-1364">获取 <see cref="T:System.Boolean" /> 值，该值指示此程序集是否被加载到只反射上下文中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1364">Gets a <see cref="T:System.Boolean" /> value indicating whether this assembly was loaded into the reflection-only context.</span></span></summary>
        <value><span data-ttu-id="f0e7c-1365">如果程序集被加载到只反射上下文而不是执行上下文中，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1365"><see langword="true" /> if the assembly was loaded into the reflection-only context, rather than the execution context; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-1366">如果已使用 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 方法将程序集加载到仅反射上下文中，则不能在该程序集中执行代码。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1366">If an assembly has been loaded into the reflection-only context, using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> method, you cannot execute code in the assembly.</span></span> <span data-ttu-id="f0e7c-1367">若要执行代码，必须将程序集加载到执行上下文中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1367">To execute code, the assembly must be loaded into the execution context.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReflectionOnlyLoad">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f0e7c-1368">将程序集加载到只反射上下文中，在只反射上下文中可以检查但不能执行程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1368">Loads an assembly into the reflection-only context, where it can be examined but not executed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="f0e7c-1369">字节数组，它是包含已发出程序集的基于 COFF 的映像。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1369">A byte array that is a COFF-based image containing an emitted assembly.</span></span></param>
        <summary><span data-ttu-id="f0e7c-1370">加载来自基于通用对象文件格式 (COFF) 的映像的程序集，该映像包含已发出的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1370">Loads the assembly from a common object file format (COFF)-based image containing an emitted assembly.</span></span> <span data-ttu-id="f0e7c-1371">程序集被加载到调用方的应用程序域的只反射上下文中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1371">The assembly is loaded into the reflection-only context of the caller's application domain.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-1372">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1372">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-1373">不能执行加载到仅反射上下文中的程序集的代码。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1373">You cannot execute code from an assembly loaded into the reflection-only context.</span></span> <span data-ttu-id="f0e7c-1374">若要执行代码，还必须使用 <xref:System.Reflection.Assembly.Load%2A> 方法将程序集加载到执行上下文中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1374">To execute code, the assembly must be loaded into the execution context as well, using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
 <span data-ttu-id="f0e7c-1375">仅反射上下文与其他上下文没有区别。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1375">The reflection-only context is no different from other contexts.</span></span> <span data-ttu-id="f0e7c-1376">只能通过卸载应用程序域来卸载加载到上下文中的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1376">Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-1377"><paramref name="rawAssembly" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1377"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-1378"><paramref name="rawAssembly" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1378"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="f0e7c-1379">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1379">-or-</span></span> 
<span data-ttu-id="f0e7c-1380">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="rawAssembly" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1380">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-1381">无法加载 <paramref name="rawAssembly" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1381"><paramref name="rawAssembly" /> cannot be loaded.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="f0e7c-1382">仅限 .NET Core：不支持此成员。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1382">.NET Core only: This member is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="f0e7c-1383">程序集的显示名称，由 <see cref="P:System.Reflection.AssemblyName.FullName" /> 属性返回。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1383">The display name of the assembly, as returned by the <see cref="P:System.Reflection.AssemblyName.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="f0e7c-1384">将给定显示名称的程序集加载到只反射上下文中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1384">Loads an assembly into the reflection-only context, given its display name.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-1385">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1385">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-1386">依赖项不会自动加载到仅反射上下文中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1386">Dependencies are not automatically loaded into the reflection-only context.</span></span>  
  
 <span data-ttu-id="f0e7c-1387">不能执行加载到仅反射上下文中的程序集的代码。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1387">You cannot execute code from an assembly loaded into the reflection-only context.</span></span> <span data-ttu-id="f0e7c-1388">若要执行代码，还必须使用 <xref:System.Reflection.Assembly.Load%2A> 方法将程序集加载到执行上下文中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1388">To execute code, the assembly must be loaded into the execution context as well, using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
 <span data-ttu-id="f0e7c-1389">是否将特定的权限授予程序集是基于证据的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1389">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="f0e7c-1390">程序集和安全证据合并的规则如下所示：</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1390">The rules for assembly and security evidence merging are as follows:</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f0e7c-1391">在中编译的可执行C++文件上进行反射可能会引发 <xref:System.IO.FileLoadException>。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1391">Reflecting on executable files compiled in C++ might throw a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="f0e7c-1392">这很可能是由于C++编译器从可执行文件中去除重定位地址或 .reloc 部分所致。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1392">This is most likely caused by the C++ compiler stripping the relocation addresses or the .reloc section from your executable file.</span></span> <span data-ttu-id="f0e7c-1393">若要保留 .reloc 地址，请在链接时指定 `/fixed:no`。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1393">To preserve the .reloc address, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="f0e7c-1394">仅反射上下文与其他上下文没有区别。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1394">The reflection-only context is no different from other contexts.</span></span> <span data-ttu-id="f0e7c-1395">只能通过卸载应用程序域来卸载加载到上下文中的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1395">Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-1396"><paramref name="assemblyString" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1396"><paramref name="assemblyString" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f0e7c-1397"><paramref name="assemblyString" /> 为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1397"><paramref name="assemblyString" /> is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-1398"><paramref name="assemblyString" /> 未找到。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1398"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-1399"><paramref name="assemblyString" /> 已找到，但无法加载。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1399"><paramref name="assemblyString" /> is found, but cannot be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-1400"><paramref name="assemblyString" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1400"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="f0e7c-1401">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1401">-or-</span></span> 
<span data-ttu-id="f0e7c-1402">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyString" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1402">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="f0e7c-1403">仅限 .NET Core：不支持此成员。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1403">.NET Core only: This member is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="f0e7c-1404">包含程序集清单的文件的路径。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1404">The path of the file that contains the manifest of the assembly.</span></span></param>
        <summary><span data-ttu-id="f0e7c-1405">将给定路径的程序集加载到只反射上下文中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1405">Loads an assembly into the reflection-only context, given its path.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-1406">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1406">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-1407">依赖项不会自动加载到仅反射上下文中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1407">Dependencies are not automatically loaded into the reflection-only context.</span></span> <span data-ttu-id="f0e7c-1408">若要自动加载依赖项，请处理 <xref:System.AppDomain.ReflectionOnlyAssemblyResolve> 事件，并在事件处理程序中加载依赖项。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1408">To automatically load dependencies, handle the <xref:System.AppDomain.ReflectionOnlyAssemblyResolve> event and load the dependency in the event handler.</span></span>  
  
 <span data-ttu-id="f0e7c-1409">不能执行已加载到仅反射上下文中的程序集的代码。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1409">You cannot execute code from an assembly that has been loaded into the reflection-only context.</span></span> <span data-ttu-id="f0e7c-1410">若要执行该代码，请加载具有 <xref:System.Reflection.Assembly.LoadFile%2A> 方法的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1410">To execute the code, load the assembly with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="f0e7c-1411">`assemblyFile` 参数必须引用没有转义符的 URI。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1411">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="f0e7c-1412">此方法为 URI 中的所有无效字符提供转义符。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1412">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
 <span data-ttu-id="f0e7c-1413">为 `assemblyFile` 指定的路径是相对于当前目录的路径。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1413">The path specified for `assemblyFile` is relative to the current directory.</span></span> <span data-ttu-id="f0e7c-1414">将程序集加载到调用方的域中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1414">The assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="f0e7c-1415">仅反射上下文与其他上下文没有区别。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1415">The reflection-only context is no different from other contexts.</span></span> <span data-ttu-id="f0e7c-1416">只能通过卸载应用程序域来卸载加载到上下文中的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1416">Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-1417"><paramref name="assemblyFile" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1417"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-1418">未找到 <paramref name="assemblyFile" />，或者你正在试图加载的模块未指定文件扩展名。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1418"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a file name extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-1419"><paramref name="assemblyFile" /> 已找到，但无法加载。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1419"><paramref name="assemblyFile" /> is found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-1420"><paramref name="assemblyFile" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1420"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="f0e7c-1421">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1421">-or-</span></span> 
<span data-ttu-id="f0e7c-1422">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1422">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f0e7c-1423">指定了不以“file://”开头的基本代码，且没有所需的 <see cref="T:System.Net.WebPermission" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1423">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="f0e7c-1424">程序集名称超过系统定义的最大长度。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1424">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f0e7c-1425"><paramref name="assemblyFile" /> 为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1425"><paramref name="assemblyFile" /> is an empty string ("").</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="f0e7c-1426">仅限 .NET Core：不支持此成员。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1426">.NET Core only: This member is not supported.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="f0e7c-1427">用于读取以 "file://" 开头的 URI。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1427">for reading a URI that begins with "file://".</span></span> <span data-ttu-id="f0e7c-1428">关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="f0e7c-1428">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="f0e7c-1429">用于读取不以 "file://" 开头的 URI。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1429">for reading a URI that does not begin with "file://".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.SecurityRuleSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SecurityRuleSet As SecurityRuleSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::SecurityRuleSet SecurityRuleSet { System::Security::SecurityRuleSet get(); };" />
      <MemberSignature Language="F#" Value="member this.SecurityRuleSet : System.Security.SecurityRuleSet" Usage="System.Reflection.Assembly.SecurityRuleSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f0e7c-1430">获取一个值，该值指示公共语言运行时 (CLR) 对此程序集强制执行的安全规则集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1430">Gets a value that indicates which set of security rules the common language runtime (CLR) enforces for this assembly.</span></span></summary>
        <value><span data-ttu-id="f0e7c-1431">CLR 对此程序集强制执行的安全规则集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1431">The security rule set that the CLR enforces for this assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-1432">默认情况下，使用 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 编译的程序集具有[2 级](~/docs/framework/misc/security-transparent-code-level-2.md)透明度，但你可以改为将其显式设为[1 级](~/docs/framework/misc/security-transparent-code-level-1.md)。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1432">By default, assemblies that you compile with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] have [level 2](~/docs/framework/misc/security-transparent-code-level-2.md) transparency, although you can explicitly make them [level 1](~/docs/framework/misc/security-transparent-code-level-1.md) instead.</span></span> <span data-ttu-id="f0e7c-1433">使用早期版本的 .NET Framework 编译的程序集具有1级透明度。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1433">Assemblies that were compiled with earlier versions of the .NET Framework have level 1 transparency.</span></span>  
  
 <span data-ttu-id="f0e7c-1434">请参阅[安全更改](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1434">See [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/misc/security-transparent-code.md"><span data-ttu-id="f0e7c-1435">安全透明的代码</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1435">Security-Transparent Code</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="f0e7c-1436">.NET Framework 4 中的安全更改</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1436">Security Changes in the .NET Framework 4</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.5;netstandard-1.6" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.5;netstandard-1.6" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Assembly.GetType">
      <MemberSignature Language="C#" Value="Type _Assembly.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._Assembly.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _Assembly.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._Assembly.GetType() = System::Runtime::InteropServices::_Assembly::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f0e7c-1437">返回当前实例的类型。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1437">Returns the type of the current instance.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-1438">表示 <see cref="T:System.Reflection.Assembly" /> 类型的对象。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1438">An object that represents the <see cref="T:System.Reflection.Assembly" /> type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="assembly.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f0e7c-1439">返回程序集的全名，即所谓的显示名称。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1439">Returns the full name of the assembly, also known as the display name.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-1440">程序集的全名；如果不能确定程序集的全名，则为类名。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1440">The full name of the assembly, or the class name if the full name of the assembly cannot be determined.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly UnsafeLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ UnsafeLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member UnsafeLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.UnsafeLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="f0e7c-1441">包含程序集清单的文件的名称或路径。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1441">The name or path of the file that contains the manifest of the assembly.</span></span></param>
        <summary><span data-ttu-id="f0e7c-1442">绕过某些安全检查，将程序集加载到加载源上下文中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1442">Loads an assembly into the load-from context, bypassing some security checks.</span></span></summary>
        <returns><span data-ttu-id="f0e7c-1443">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1443">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f0e7c-1444">使用此方法加载操作系统已标记为已从 Web 加载的本地程序集（例如，从 Internet 或 intranet 下载的临时文件）。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1444">Use this method to load a local assembly that the operating system has flagged as having been loaded from the Web (for example, a temporary file that was downloaded from the Internet or intranet).</span></span> <span data-ttu-id="f0e7c-1445">在 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]之前，此类程序集会自动加载到沙盒应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1445">Before the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], such assemblies were automatically loaded into a sandboxed application domain.</span></span> <span data-ttu-id="f0e7c-1446">从 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]开始，以完全信任方式加载它们。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1446">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], they are loaded with full trust.</span></span>  
  
 <span data-ttu-id="f0e7c-1447">作为使用此方法的替代方法，你可以在应用程序配置文件中应用[&lt;NetFx40_LegacySecurityPolicy&gt; 元素](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1447">As an alternative to using this method, you can apply the [&lt;NetFx40_LegacySecurityPolicy&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md) in your application configuration file.</span></span> <span data-ttu-id="f0e7c-1448">这会导致公共语言运行时还原到 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]的安全策略。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1448">This causes the common language runtime to revert to the security policy of the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f0e7c-1449">如果使用上述任一解决方案，则必须确保使用完全信任方式加载 `assemblyFile` 是安全的。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1449">If you use either of these solutions, you must be certain that it is safe to load `assemblyFile` with full trust.</span></span>  
  
 <span data-ttu-id="f0e7c-1450">有关加载上下文的讨论，包括加载源上下文，请参阅 <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> 方法重载。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1450">For a discussion of load contexts, including the load-from context, see the <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f0e7c-1451"><paramref name="assemblyFile" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1451"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f0e7c-1452">未找到 <paramref name="assemblyFile" />，或者你正在试图加载的模块未指定文件名扩展。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1452"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="f0e7c-1453">无法加载已找到的文件。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1453">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="f0e7c-1454"><paramref name="assemblyFile" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1454"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="f0e7c-1455">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1455">-or-</span></span> 
 <span data-ttu-id="f0e7c-1456"><paramref name="assemblyFile" /> 使用高于当前所加载版本的公共语言运行时版本编译而成。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1456"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f0e7c-1457">指定了不以“file://”开头的基本代码，且没有所需的 <see cref="T:System.Net.WebPermission" />。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1457">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f0e7c-1458"><paramref name="assemblyFile" /> 参数为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1458">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="f0e7c-1459">程序集名称超过系统定义的最大长度。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1459">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f0e7c-1460">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1460">requires full trust for the immediate caller.</span></span> <span data-ttu-id="f0e7c-1461">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="f0e7c-1461">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
  </Members>
</Type>
