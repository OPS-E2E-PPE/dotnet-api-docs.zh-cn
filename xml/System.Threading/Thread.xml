<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata><Meta Name="ms.openlocfilehash" Value="60346ad3a07581a8a491d1886d0f985ef99dacdc" /><Meta Name="ms.sourcegitcommit" Value="f9576bf8c61e3d46834aeeff50f858359f2a99ba" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="02/09/2020" /><Meta Name="ms.locfileid" Value="77101774" /></Metadata><TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <TypeSignature Language="F#" Value="type Thread = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface _Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="ae431-101">创建和控制线程，设置其优先级并获取其状态。</span><span class="sxs-lookup"><span data-stu-id="ae431-101">Creates and controls a thread, sets its priority, and gets its status.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-102">进程启动时，公共语言运行时将自动创建单个前台线程以执行应用程序代码。</span><span class="sxs-lookup"><span data-stu-id="ae431-102">When a process starts, the common language runtime automatically creates a single foreground thread to execute application code.</span></span> <span data-ttu-id="ae431-103">除了此主前台线程，进程还可以创建一个或多个线程来执行与进程关联的程序代码的一部分。</span><span class="sxs-lookup"><span data-stu-id="ae431-103">Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process.</span></span> <span data-ttu-id="ae431-104">这些线程可以在前台或后台执行。</span><span class="sxs-lookup"><span data-stu-id="ae431-104">These threads can execute either in the foreground or in the background.</span></span> <span data-ttu-id="ae431-105">此外，还可以使用 <xref:System.Threading.ThreadPool> 类来执行由公共语言运行时管理的工作线程上的代码。</span><span class="sxs-lookup"><span data-stu-id="ae431-105">In addition, you can use the <xref:System.Threading.ThreadPool> class to execute code on worker threads that are managed by the common language runtime.</span></span>  
  
 <span data-ttu-id="ae431-106">在本节中</span><span class="sxs-lookup"><span data-stu-id="ae431-106">In this section</span></span>  
  
 <span data-ttu-id="ae431-107">[启动线程](#Starting) </span><span class="sxs-lookup"><span data-stu-id="ae431-107">[Starting a thread](#Starting) </span></span>  
 <span data-ttu-id="ae431-108">[检索线程对象](#Retrieving) </span><span class="sxs-lookup"><span data-stu-id="ae431-108">[Retrieving Thread objects](#Retrieving) </span></span>  
 <span data-ttu-id="ae431-109">[前台和后台线程](#Foreground) </span><span class="sxs-lookup"><span data-stu-id="ae431-109">[Foreground and background threads](#Foreground) </span></span>  
 <span data-ttu-id="ae431-110">[区域性和线程](#Culture) </span><span class="sxs-lookup"><span data-stu-id="ae431-110">[Culture and threads](#Culture) </span></span>  
 [<span data-ttu-id="ae431-111">获取和控制线程的相关信息</span><span class="sxs-lookup"><span data-stu-id="ae431-111">Getting information about and controlling threads</span></span>](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a><span data-ttu-id="ae431-112">启动线程</span><span class="sxs-lookup"><span data-stu-id="ae431-112">Starting a thread</span></span>  
 <span data-ttu-id="ae431-113">您可以通过提供委托来启动线程，该委托表示线程在其类构造函数中执行的方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-113">You start a thread by supplying a delegate that represents the method the thread is to execute in its class constructor.</span></span> <span data-ttu-id="ae431-114">然后调用 <xref:System.Threading.Thread.Start%2A> 方法开始执行。</span><span class="sxs-lookup"><span data-stu-id="ae431-114">You then call the <xref:System.Threading.Thread.Start%2A> method to begin execution.</span></span>  
  
 <span data-ttu-id="ae431-115"><xref:System.Threading.Thread> 构造函数可以采用两种委托类型中的任意一种，具体取决于是否可以将参数传递给要执行的方法：</span><span class="sxs-lookup"><span data-stu-id="ae431-115">The <xref:System.Threading.Thread> constructors can take either of two delegate types, depending on whether you can pass an argument to the method to be executed:</span></span>  
  
-   <span data-ttu-id="ae431-116">如果该方法没有参数，则将 <xref:System.Threading.ThreadStart> 委托传递给构造函数。</span><span class="sxs-lookup"><span data-stu-id="ae431-116">If the method has no arguments, you pass a <xref:System.Threading.ThreadStart> delegate to  the constructor.</span></span> <span data-ttu-id="ae431-117">它具有签名：</span><span class="sxs-lookup"><span data-stu-id="ae431-117">It has the signature:</span></span>  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     <span data-ttu-id="ae431-118">下面的示例创建并启动一个线程来执行 `ExecuteInForeground` 方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-118">The following example creates and starts a thread that executes the `ExecuteInForeground` method.</span></span> <span data-ttu-id="ae431-119">方法显示有关某些线程属性的信息，然后执行循环，其中每半秒暂停一次，并显示已用的秒数。</span><span class="sxs-lookup"><span data-stu-id="ae431-119">The method displays  information about some thread properties, then executes a loop in which it pauses for half a second and displays the elapsed number of seconds.</span></span> <span data-ttu-id="ae431-120">当线程至少执行五秒后，循环结束，线程终止执行。</span><span class="sxs-lookup"><span data-stu-id="ae431-120">When the thread has executed for at least five seconds, the loop ends and the thread terminates execution.</span></span>  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   <span data-ttu-id="ae431-121">如果该方法具有参数，则将 <xref:System.Threading.ParameterizedThreadStart> 委托传递给构造函数。</span><span class="sxs-lookup"><span data-stu-id="ae431-121">If the method has an argument, you pass a <xref:System.Threading.ParameterizedThreadStart> delegate to the constructor.</span></span> <span data-ttu-id="ae431-122">它具有签名：</span><span class="sxs-lookup"><span data-stu-id="ae431-122">It has the signature:</span></span>  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     <span data-ttu-id="ae431-123">然后，由委托执行的方法可以将参数强制C#转换（在中）或将参数转换（Visual Basic）到相应的类型。</span><span class="sxs-lookup"><span data-stu-id="ae431-123">The method executed by the delegate can then cast (in C#) or convert (in Visual Basic) the parameter to the appropriate type.</span></span>  
  
     <span data-ttu-id="ae431-124">下面的示例与上一个示例相同，不同之处在于它调用 <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> 构造函数。</span><span class="sxs-lookup"><span data-stu-id="ae431-124">The following example is identical to the previous one, except that it calls the <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor.</span></span> <span data-ttu-id="ae431-125">此版本的 `ExecuteInForeground` 方法有一个参数，该参数表示执行循环的大约毫秒数。</span><span class="sxs-lookup"><span data-stu-id="ae431-125">This version of the `ExecuteInForeground` method has a single parameter that represents the approximate number of milliseconds the loop is to execute.</span></span>  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 <span data-ttu-id="ae431-126">启动线程后，不需要保留对 <xref:System.Threading.Thread> 对象的引用。</span><span class="sxs-lookup"><span data-stu-id="ae431-126">It is not necessary to retain a reference to a <xref:System.Threading.Thread> object once you have started the thread.</span></span> <span data-ttu-id="ae431-127">线程将继续执行，直到线程过程完成。</span><span class="sxs-lookup"><span data-stu-id="ae431-127">The thread continues to execute until the thread procedure is complete.</span></span>  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a><span data-ttu-id="ae431-128">检索线程对象</span><span class="sxs-lookup"><span data-stu-id="ae431-128">Retrieving Thread objects</span></span>  
 <span data-ttu-id="ae431-129">可以使用 static （`Shared` Visual Basic） <xref:System.Threading.Thread.CurrentThread%2A> 属性从线程正在执行的代码中检索对当前正在执行的线程的引用。</span><span class="sxs-lookup"><span data-stu-id="ae431-129">You can use the static (`Shared` in Visual Basic)  <xref:System.Threading.Thread.CurrentThread%2A> property to retrieve a reference to the currently executing thread from the code that the thread is executing.</span></span> <span data-ttu-id="ae431-130">下面的示例使用 <xref:System.Threading.Thread.CurrentThread%2A> 属性显示有关主应用程序线程、另一个前台线程、一个后台线程和一个线程池线程的信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-130">The following example uses the <xref:System.Threading.Thread.CurrentThread%2A> property to display information about the main application thread, another foreground thread, a background thread, and a thread pool thread.</span></span>  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a><span data-ttu-id="ae431-131">前台和后台线程</span><span class="sxs-lookup"><span data-stu-id="ae431-131">Foreground and background threads</span></span>  
 <span data-ttu-id="ae431-132"><xref:System.Threading.Thread> 类的实例表示前台线程或后台线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-132">Instances of the <xref:System.Threading.Thread> class represent either foreground threads or background threads.</span></span> <span data-ttu-id="ae431-133">后台线程与前台线程完全相同，但有一种例外情况：如果所有前台线程均已终止，后台线程并不会使进程保持运行。</span><span class="sxs-lookup"><span data-stu-id="ae431-133">Background threads are identical to foreground threads with one exception: a background thread does not keep a process running if all foreground threads have terminated.</span></span> <span data-ttu-id="ae431-134">所有前台线程停止后，运行时将停止所有后台线程并关闭。</span><span class="sxs-lookup"><span data-stu-id="ae431-134">Once all foreground threads have been stopped, the runtime stops all background threads and shuts down.</span></span>  
  
 <span data-ttu-id="ae431-135">默认情况下，以下线程在前台执行：</span><span class="sxs-lookup"><span data-stu-id="ae431-135">By default, the following threads execute in the foreground:</span></span>  
  
-   <span data-ttu-id="ae431-136">主应用程序线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-136">The main application thread.</span></span>  
  
-   <span data-ttu-id="ae431-137">通过调用 <xref:System.Threading.Thread> 类构造函数创建的所有线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-137">All threads created by calling a <xref:System.Threading.Thread> class constructor.</span></span>  
  
 <span data-ttu-id="ae431-138">默认情况下，以下线程在后台执行：</span><span class="sxs-lookup"><span data-stu-id="ae431-138">The following threads execute in the background by default:</span></span>  
  
-   <span data-ttu-id="ae431-139">线程池线程，线程池是由运行时维护的工作线程池。</span><span class="sxs-lookup"><span data-stu-id="ae431-139">Thread pool threads, which are a pool of worker threads maintained by the runtime.</span></span>  <span data-ttu-id="ae431-140">您可以使用 <xref:System.Threading.ThreadPool> 类配置线程池和计划线程池线程上的工作。</span><span class="sxs-lookup"><span data-stu-id="ae431-140">You can configure the thread pool and schedule work on thread pool threads by using the <xref:System.Threading.ThreadPool> class.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="ae431-141">基于任务的异步操作会在线程池线程上自动执行。</span><span class="sxs-lookup"><span data-stu-id="ae431-141">Task-based asynchronous operations automatically execute on thread pool threads.</span></span> <span data-ttu-id="ae431-142">基于任务的异步操作使用 <xref:System.Threading.Tasks.Task> 和 <xref:System.Threading.Tasks.Task%601> 类实现[基于任务的异步模式](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)。</span><span class="sxs-lookup"><span data-stu-id="ae431-142">Task-based asynchronous operations use the <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes to implement the [task-based asynchronous pattern](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).</span></span>  
  
-   <span data-ttu-id="ae431-143">从非托管代码进入托管执行环境的所有线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-143">All threads that enter the managed execution environment from unmanaged code.</span></span>  
  
 <span data-ttu-id="ae431-144">你可以随时通过设置 "<xref:System.Threading.Thread.IsBackground%2A>" 属性来更改要在后台中执行的线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-144">You can change a thread to execute in the background by setting the <xref:System.Threading.Thread.IsBackground%2A> property at any time.</span></span>  <span data-ttu-id="ae431-145">当应用程序正在运行但不应阻止应用程序终止时（如监视文件系统更改或传入套接字连接），后台线程适用于应该继续执行的任何操作。</span><span class="sxs-lookup"><span data-stu-id="ae431-145">Background threads are useful for any operation that should continue as long as an application is running but should not prevent the application from terminating, such as monitoring file system changes or incoming socket connections.</span></span>  
  
 <span data-ttu-id="ae431-146">下面的示例演示前台和后台线程之间的差异。</span><span class="sxs-lookup"><span data-stu-id="ae431-146">The following example illustrates the difference between foreground and background threads.</span></span> <span data-ttu-id="ae431-147">它类似于[启动线程](#Starting)部分中的第一个示例，只不过它会将线程设置为在后台执行，然后再启动它。</span><span class="sxs-lookup"><span data-stu-id="ae431-147">It is like the first example in the [Starting a thread](#Starting) section, except that it sets the thread to execute in the background before starting it.</span></span> <span data-ttu-id="ae431-148">如输出所示，循环在执行5秒之前中断。</span><span class="sxs-lookup"><span data-stu-id="ae431-148">As the output shows, the loop is interrupted before it executes for five seconds.</span></span>  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a><span data-ttu-id="ae431-149">区域性和线程</span><span class="sxs-lookup"><span data-stu-id="ae431-149">Culture and threads</span></span>  
 <span data-ttu-id="ae431-150">每个线程都具有由 <xref:System.Threading.Thread.CurrentCulture%2A> 属性表示的区域性，以及由 <xref:System.Threading.Thread.CurrentUICulture%2A> 属性表示的 UI 区域性。</span><span class="sxs-lookup"><span data-stu-id="ae431-150">Each thread has a culture, represented by the <xref:System.Threading.Thread.CurrentCulture%2A> property, and a UI culture, represented by the <xref:System.Threading.Thread.CurrentUICulture%2A> property.</span></span>  <span data-ttu-id="ae431-151">当前区域性支持诸如分析和格式化、字符串比较和排序等区分区域性的操作，还可控制线程使用的书写体系和日历。</span><span class="sxs-lookup"><span data-stu-id="ae431-151">The current culture supports such culture-sensitive  operations as parsing and formatting, string comparison and sorting, and also controls the writing system and calendar used by a thread.</span></span> <span data-ttu-id="ae431-152">当前 UI 区域性提供对资源文件中的资源进行区分区域性的检索。</span><span class="sxs-lookup"><span data-stu-id="ae431-152">The current UI culture provides for culture-sensitive retrieval of resources in resource files.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="ae431-153">与当前线程以外的任何线程一起使用时，<xref:System.Threading.Thread.CurrentCulture> 和 <xref:System.Threading.Thread.CurrentUICulture> 属性将无法可靠运行。</span><span class="sxs-lookup"><span data-stu-id="ae431-153">The <xref:System.Threading.Thread.CurrentCulture> and <xref:System.Threading.Thread.CurrentUICulture> properties don't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="ae431-154">在 .NET Framework 中，虽然为当前线程以外的线程设置这些属性，但读取这些属性是可靠的。</span><span class="sxs-lookup"><span data-stu-id="ae431-154">In .NET Framework, reading these properties is reliable, although setting these properties for a thread other than the current thread is not.</span></span> <span data-ttu-id="ae431-155">在 .NET Core 中，如果线程尝试在另一个线程上读取或写入这些属性，则会引发 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="ae431-155">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write these properties on a different thread.</span></span>
> <span data-ttu-id="ae431-156">建议使用 <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> 和 <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> 属性检索和设置当前区域性。</span><span class="sxs-lookup"><span data-stu-id="ae431-156">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> properties to retrieve and set the current culture.</span></span>

 <span data-ttu-id="ae431-157">实例化新线程时，其区域性和 UI 区域性由当前系统区域性和 UI 区域性定义，而不是由从中创建新线程的线程的区域性和 UI 区域性定义。</span><span class="sxs-lookup"><span data-stu-id="ae431-157">When a new thread is instantiated, its culture and UI culture are defined by the current system culture and UI culture, and not by the culture and UI culture of the thread from which the new thread is created.</span></span> <span data-ttu-id="ae431-158">这意味着，如果当前系统区域性为英语（美国）并且主应用程序线程的当前区域性为法语（法国），则通过从主线程调用 <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> 构造函数而创建的新线程的区域性为 "英语（美国）"，而不是 "法语（法国）"。</span><span class="sxs-lookup"><span data-stu-id="ae431-158">This means, for example, that if the current system culture is English (United States) and the current culture of the primary application thread is French (France), the culture of a new thread created by calling the   <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor from the primary thread is English (United States), and not French (France).</span></span> <span data-ttu-id="ae431-159">有关详细信息，请参阅 <xref:System.Globalization.CultureInfo> 类主题中的 "区域性和线程" 一节。</span><span class="sxs-lookup"><span data-stu-id="ae431-159">For more information, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ae431-160">对于面向 [!INCLUDE[net_v46](~/includes/net-v46-md.md)] 和更高版本的应用程序执行异步操作的线程，这种情况并不是如此，在这种情况下，区域性和 UI 区域性是异步操作的上下文的一部分;默认情况下，执行异步操作的线程继承从中启动异步操作的线程的区域性和 UI 区域性。</span><span class="sxs-lookup"><span data-stu-id="ae431-160">This is not true of threads that execute asynchronous operations for apps that target the [!INCLUDE[net_v46](~/includes/net-v46-md.md)] and later versions, In this case, the culture and UI culture is part of an asynchronous operations' context; the thread on which an asynchronous operation executes by default inherits the culture and UI culture of the thread from which the asynchronous operation was launched.</span></span> <span data-ttu-id="ae431-161">有关详细信息，请参阅 <xref:System.Globalization.CultureInfo> 类主题中的“区域性和基于任务的异步操作”一节。</span><span class="sxs-lookup"><span data-stu-id="ae431-161">For more information, see the "Culture and task-based asynchronous operations" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
 <span data-ttu-id="ae431-162">可以执行以下任一操作，以确保在应用程序中执行的所有线程共享相同的区域性和 UI 区域性：</span><span class="sxs-lookup"><span data-stu-id="ae431-162">You can do either of the following to ensure that all of the threads executing in an application share the same culture and UI culture:</span></span>  
  
-   <span data-ttu-id="ae431-163">可以向 <xref:System.Threading.ParameterizedThreadStart> 委托或 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> 方法传递表示区域性的 <xref:System.Globalization.CultureInfo> 对象。</span><span class="sxs-lookup"><span data-stu-id="ae431-163">You can pass a <xref:System.Globalization.CultureInfo> object that represents that culture to the <xref:System.Threading.ParameterizedThreadStart> delegate or the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="ae431-164">对于在 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 及更高版本上运行的应用，可以通过设置 <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> 和 <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> 属性的值，定义要分配给在应用程序域中创建的所有线程的区域性和 UI 区域性。</span><span class="sxs-lookup"><span data-stu-id="ae431-164">For apps running on the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] and later versions, you can define the culture and UI culture that is to be assigned to all threads created in an application domain by setting the value of the <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="ae431-165">请注意，这是每个应用程序的域设置。</span><span class="sxs-lookup"><span data-stu-id="ae431-165">Note that this is a per-application domain setting.</span></span>  

 <span data-ttu-id="ae431-166">有关详细信息和示例，请参阅 <xref:System.Globalization.CultureInfo> 类主题中的 "区域性和线程" 一节。</span><span class="sxs-lookup"><span data-stu-id="ae431-166">For more information and examples, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>

<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a><span data-ttu-id="ae431-167">获取和控制线程的相关信息</span><span class="sxs-lookup"><span data-stu-id="ae431-167">Getting information about and controlling threads</span></span>  
 <span data-ttu-id="ae431-168">您可以检索提供有关线程信息的多个属性值。</span><span class="sxs-lookup"><span data-stu-id="ae431-168">You can retrieve a number of property values that provide information about a thread.</span></span> <span data-ttu-id="ae431-169">在某些情况下，还可以设置这些属性值来控制线程的操作。</span><span class="sxs-lookup"><span data-stu-id="ae431-169">In some cases, you can also set these property values to control the operation of the thread.</span></span> <span data-ttu-id="ae431-170">这些线程属性包括：</span><span class="sxs-lookup"><span data-stu-id="ae431-170">These thread properties include:</span></span>  
  
-   <span data-ttu-id="ae431-171">名称。</span><span class="sxs-lookup"><span data-stu-id="ae431-171">A name.</span></span> <span data-ttu-id="ae431-172"><xref:System.Threading.Thread.Name%2A> 是一种只写的属性，可用于标识线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-172"><xref:System.Threading.Thread.Name%2A> is a write-once property that you can use to identify a thread.</span></span>  <span data-ttu-id="ae431-173">它的默认值为 `null`。</span><span class="sxs-lookup"><span data-stu-id="ae431-173">Its default value is `null`.</span></span>  
  
-   <span data-ttu-id="ae431-174">哈希代码，可以通过调用 <xref:System.Threading.Thread.GetHashCode%2A> 方法来检索。</span><span class="sxs-lookup"><span data-stu-id="ae431-174">A hash code, which you can retrieve by calling the <xref:System.Threading.Thread.GetHashCode%2A> method.</span></span> <span data-ttu-id="ae431-175">哈希代码可用于唯一标识线程;在线程的生存期内，无论从中获取值的应用程序域如何，其哈希代码都不会与其他任何线程的值相冲突。</span><span class="sxs-lookup"><span data-stu-id="ae431-175">The hash code can be used to uniquely identify a thread; for the lifetime of your thread, its hash code will not collide with the value from any other thread, regardless of the application domain from which you obtain the value.</span></span>  
  
-   <span data-ttu-id="ae431-176">线程 ID。</span><span class="sxs-lookup"><span data-stu-id="ae431-176">A thread ID.</span></span> <span data-ttu-id="ae431-177">只读 <xref:System.Threading.Thread.ManagedThreadId%2A> 属性的值由运行时分配并在其进程中唯一标识一个线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-177">The value of the read-only <xref:System.Threading.Thread.ManagedThreadId%2A> property is assigned by the runtime and uniquely identifies a thread within its process.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="ae431-178">因为非托管宿主可以控制托管线程和非托管线程之间的关系，所以操作系统 [ThreadId](/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadid) 与托管线程之间没有固定的关系。</span><span class="sxs-lookup"><span data-stu-id="ae431-178">An operating-system [ThreadId](/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadid) has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</span></span> <span data-ttu-id="ae431-179">具体而言，一个复杂的主机可以使用[CLR 宿主 API](~/docs/framework/unmanaged-api/hosting/index.md)为同一操作系统线程计划多个托管线程，或在不同的操作系统线程之间移动托管线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-179">Specifically, a sophisticated host can use the [CLR Hosting API](~/docs/framework/unmanaged-api/hosting/index.md) to schedule many managed threads against the same operating system thread, or to move a managed thread between different operating system threads.</span></span>  
  
-   <span data-ttu-id="ae431-180">线程的当前状态。</span><span class="sxs-lookup"><span data-stu-id="ae431-180">The thread's current state.</span></span> <span data-ttu-id="ae431-181">在其存在的持续时间内，线程始终处于由 <xref:System.Threading.ThreadState> 属性定义的一个或多个状态。</span><span class="sxs-lookup"><span data-stu-id="ae431-181">For the duration of its existence, a thread is always in one or more of the states defined by the <xref:System.Threading.ThreadState> property.</span></span>  
  
-   <span data-ttu-id="ae431-182">计划优先级级别，由 <xref:System.Threading.ThreadPriority> 属性定义。</span><span class="sxs-lookup"><span data-stu-id="ae431-182">A scheduling priority level, which is defined by the <xref:System.Threading.ThreadPriority> property.</span></span> <span data-ttu-id="ae431-183">虽然您可以将此值设置为请求线程的优先级，但并不保证操作系统接受此值。</span><span class="sxs-lookup"><span data-stu-id="ae431-183">Although you can set this value to request a thread's priority, it is not guaranteed to be honored by the operating system.</span></span>  
  
-   <span data-ttu-id="ae431-184">只读 <xref:System.Threading.Thread.IsThreadPoolThread%2A> 属性，指示线程是否为线程池线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-184">The read-only <xref:System.Threading.Thread.IsThreadPoolThread%2A> property, which indicates whether a thread is  a thread pool thread.</span></span>  
  
-   <span data-ttu-id="ae431-185"><xref:System.Threading.Thread.IsBackground%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="ae431-185">The <xref:System.Threading.Thread.IsBackground%2A> property.</span></span> <span data-ttu-id="ae431-186">有关详细信息，请参阅[前台和后台线程](#Foreground)部分。</span><span class="sxs-lookup"><span data-stu-id="ae431-186">For more information, see the [Foreground and background threads](#Foreground) section.</span></span>  
  
## Examples  
 <span data-ttu-id="ae431-187">下面的示例演示简单的线程处理功能。</span><span class="sxs-lookup"><span data-stu-id="ae431-187">The following example demonstrates simple threading functionality.</span></span>  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 <span data-ttu-id="ae431-188">此代码生成与下面类似的输出：</span><span class="sxs-lookup"><span data-stu-id="ae431-188">This code produces output similar to the following:</span></span>  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="ae431-189">此类型是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="ae431-189">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="ae431-190">线程与线程处理</span><span class="sxs-lookup"><span data-stu-id="ae431-190">Threads and Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md"><span data-ttu-id="ae431-191">使用线程和线程处理</span><span class="sxs-lookup"><span data-stu-id="ae431-191">Using Threads and Threading</span></span></related>
    <related type="ExternalDocumentation" href="https://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96"><span data-ttu-id="ae431-192">Thread 类的引用源</span><span class="sxs-lookup"><span data-stu-id="ae431-192">Reference Source for the Thread Class</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ae431-193">初始化 <see cref="T:System.Threading.Thread" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="ae431-193">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="ae431-194">一个委托，它表示此线程开始执行时要调用的方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-194">A delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <summary><span data-ttu-id="ae431-195">初始化 <see cref="T:System.Threading.Thread" /> 类的新实例，指定允许对象在线程启动时传递给线程的委托。</span><span class="sxs-lookup"><span data-stu-id="ae431-195">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-196">创建线程时，它不会开始执行。</span><span class="sxs-lookup"><span data-stu-id="ae431-196">A thread does not begin executing when it is created.</span></span> <span data-ttu-id="ae431-197">若要计划线程的执行，请调用 <xref:System.Threading.Thread.Start%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-197">To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method.</span></span> <span data-ttu-id="ae431-198">若要将数据对象传递到线程，请使用 <xref:System.Threading.Thread.Start%28System.Object%29> 方法重载。</span><span class="sxs-lookup"><span data-stu-id="ae431-198">To pass a data object to the thread, use the <xref:System.Threading.Thread.Start%28System.Object%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-199">Visual Basic 用户在创建线程时可以省略 <xref:System.Threading.ThreadStart> 构造函数。</span><span class="sxs-lookup"><span data-stu-id="ae431-199">Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread.</span></span> <span data-ttu-id="ae431-200">传递方法时，请使用 `AddressOf` 运算符，例如 `Dim t As New Thread(AddressOf ThreadProc)`。</span><span class="sxs-lookup"><span data-stu-id="ae431-200">Use the `AddressOf` operator when passing your method, for example `Dim t As New Thread(AddressOf ThreadProc)`.</span></span> <span data-ttu-id="ae431-201">Visual Basic 自动调用 <xref:System.Threading.ThreadStart> 构造函数。</span><span class="sxs-lookup"><span data-stu-id="ae431-201">Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-202">下面的示例演示了用静态方法和实例方法创建和使用 <xref:System.Threading.ParameterizedThreadStart> 委托的语法。</span><span class="sxs-lookup"><span data-stu-id="ae431-202">The following example shows the syntax for creating and using a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.</span></span>  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ae431-203"><paramref name="start" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-203"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="ae431-204">创建线程</span><span class="sxs-lookup"><span data-stu-id="ae431-204">Creating Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="ae431-205">表示开始执行此线程时要调用的方法的 <see cref="T:System.Threading.ThreadStart" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="ae431-205">A <see cref="T:System.Threading.ThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <summary><span data-ttu-id="ae431-206">初始化 <see cref="T:System.Threading.Thread" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="ae431-206">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-207">创建线程时，它不会开始执行。</span><span class="sxs-lookup"><span data-stu-id="ae431-207">A thread does not begin executing when it is created.</span></span> <span data-ttu-id="ae431-208">若要计划线程的执行，请调用 <xref:System.Threading.Thread.Start%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-208">To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-209">Visual Basic 用户在创建线程时可以省略 <xref:System.Threading.ThreadStart> 构造函数。</span><span class="sxs-lookup"><span data-stu-id="ae431-209">Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread.</span></span> <span data-ttu-id="ae431-210">传递方法时，请使用 `AddressOf` 运算符，例如 `Dim t As New Thread(AddressOf ThreadProc)`。</span><span class="sxs-lookup"><span data-stu-id="ae431-210">Use the `AddressOf` operator when passing your method for example `Dim t As New Thread(AddressOf ThreadProc)`.</span></span> <span data-ttu-id="ae431-211">Visual Basic 自动调用 <xref:System.Threading.ThreadStart> 构造函数。</span><span class="sxs-lookup"><span data-stu-id="ae431-211">Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-212">下面的代码示例演示如何创建执行静态方法的线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-212">The following code example shows how to create a thread that executes a static method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 <span data-ttu-id="ae431-213">下面的代码示例演示如何创建执行实例方法的线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-213">The following code example shows how to create a thread that executes an instance method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ae431-214"><paramref name="start" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-214">The <paramref name="start" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="ae431-215">创建线程</span><span class="sxs-lookup"><span data-stu-id="ae431-215">Creating Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="maxStackSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="ae431-216">表示开始执行此线程时要调用的方法的 <see cref="T:System.Threading.ParameterizedThreadStart" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="ae431-216">A <see cref="T:System.Threading.ParameterizedThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <param name="maxStackSize"><span data-ttu-id="ae431-217">线程要使用的最大堆栈大小（以字节为单位）；如果为 0，则使用可执行文件的文件头中指定的默认最大堆栈大小。</span><span class="sxs-lookup"><span data-stu-id="ae431-217">The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</span></span>  
  
<span data-ttu-id="ae431-218">重要事项：对于部分受信任的代码，如果 <paramref name="maxStackSize" /> 大于默认堆栈大小，则会将其忽略。</span><span class="sxs-lookup"><span data-stu-id="ae431-218">Important   For partially trusted code, <paramref name="maxStackSize" /> is ignored if it is greater than the default stack size.</span></span> <span data-ttu-id="ae431-219">不引发异常。</span><span class="sxs-lookup"><span data-stu-id="ae431-219">No exception is thrown.</span></span></param>
        <summary><span data-ttu-id="ae431-220">初始化 <see cref="T:System.Threading.Thread" /> 类的新实例，指定允许对象在线程启动时传递给线程的委托，并指定线程的最大堆栈大小。</span><span class="sxs-lookup"><span data-stu-id="ae431-220">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-221">避免使用此构造函数重载。</span><span class="sxs-lookup"><span data-stu-id="ae431-221">Avoid using this constructor overload.</span></span> <span data-ttu-id="ae431-222"><xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> 构造函数重载使用的默认堆栈大小是线程的建议堆栈大小。</span><span class="sxs-lookup"><span data-stu-id="ae431-222">The default stack size used by the <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor overload is the recommended stack size for threads.</span></span> <span data-ttu-id="ae431-223">如果线程存在内存问题，最可能的原因是编程错误，如无限递归。</span><span class="sxs-lookup"><span data-stu-id="ae431-223">If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ae431-224">从 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]开始，只有完全受信任的代码才能将 `maxStackSize` 设置为大于默认堆栈大小（1 mb）的值。</span><span class="sxs-lookup"><span data-stu-id="ae431-224">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], only fully trusted code can set `maxStackSize` to a value that is greater than the default stack size (1 megabyte).</span></span> <span data-ttu-id="ae431-225">如果为 `maxStackSize` 指定较大的值，则当代码在部分信任的情况下运行时，将忽略 `maxStackSize` 并使用默认堆栈大小。</span><span class="sxs-lookup"><span data-stu-id="ae431-225">If a larger value is specified for `maxStackSize` when code is running with partial trust, `maxStackSize` is ignored and the default stack size is used.</span></span> <span data-ttu-id="ae431-226">不引发异常。</span><span class="sxs-lookup"><span data-stu-id="ae431-226">No exception is thrown.</span></span> <span data-ttu-id="ae431-227">任何信任级别的代码都可以将 `maxStackSize` 设置为小于默认堆栈大小的值。</span><span class="sxs-lookup"><span data-stu-id="ae431-227">Code at any trust level can set `maxStackSize` to a value that is less than the default stack size.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-228">如果你正在开发将由部分信任的代码使用的完全受信任的库，并且你需要启动需要大型堆栈的线程，则必须在创建该线程之前断言完全信任，否则将使用默认堆栈大小。</span><span class="sxs-lookup"><span data-stu-id="ae431-228">If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</span></span> <span data-ttu-id="ae431-229">除非你完全控制在线程上运行的代码，否则不要执行此操作。</span><span class="sxs-lookup"><span data-stu-id="ae431-229">Do not do this unless you fully control the code that runs on the thread.</span></span>  
  
 <span data-ttu-id="ae431-230">如果 `maxStackSize` 小于最小堆栈大小，则使用最小堆栈大小。</span><span class="sxs-lookup"><span data-stu-id="ae431-230">If `maxStackSize` is less than the minimum stack size, the minimum stack size is used.</span></span> <span data-ttu-id="ae431-231">如果 `maxStackSize` 不是页面大小的倍数，则会将其舍入到页面大小的下一个较大倍数。</span><span class="sxs-lookup"><span data-stu-id="ae431-231">If `maxStackSize` is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</span></span> <span data-ttu-id="ae431-232">例如，如果你使用的是 Windows Vista 上的 .NET Framework 2.0 版，256KB （262144字节）是最小堆栈大小，而页面大小为64KB （65536个字节）。</span><span class="sxs-lookup"><span data-stu-id="ae431-232">For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-233">在 Windows XP 和 Windows Server 2003 之前的 Microsoft Windows 版本上，将忽略 `maxStackSize`，并使用可执行文件头中指定的堆栈大小。</span><span class="sxs-lookup"><span data-stu-id="ae431-233">On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, `maxStackSize` is ignored, and the stack size specified in the executable header is used.</span></span>  
  
 <span data-ttu-id="ae431-234">如果指定非常小的堆栈大小，则可能需要禁用堆栈溢出探测。</span><span class="sxs-lookup"><span data-stu-id="ae431-234">If you specify a very small stack size, you might need to disable stack-overflow probing.</span></span> <span data-ttu-id="ae431-235">当堆栈受到严格约束时，探测本身就会导致堆栈溢出。</span><span class="sxs-lookup"><span data-stu-id="ae431-235">When the stack is severely constrained, the probing can itself cause a stack overflow.</span></span> <span data-ttu-id="ae431-236">若要禁用堆栈溢出探测，请将以下项添加到应用程序配置文件中。</span><span class="sxs-lookup"><span data-stu-id="ae431-236">To disable stack overflow probing, add the following to your application configuration file.</span></span>  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ae431-237"><paramref name="start" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-237"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ae431-238"><paramref name="maxStackSize" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="ae431-238"><paramref name="maxStackSize" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="maxStackSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="ae431-239">表示开始执行此线程时要调用的方法的 <see cref="T:System.Threading.ThreadStart" /> 委托。</span><span class="sxs-lookup"><span data-stu-id="ae431-239">A <see cref="T:System.Threading.ThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <param name="maxStackSize"><span data-ttu-id="ae431-240">线程要使用的最大堆栈大小（以字节为单位）；如果为 0，则使用可执行文件的文件头中指定的默认最大堆栈大小。</span><span class="sxs-lookup"><span data-stu-id="ae431-240">The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</span></span>  
  
<span data-ttu-id="ae431-241">重要事项：对于部分受信任的代码，如果 <paramref name="maxStackSize" /> 大于默认堆栈大小，则会将其忽略。</span><span class="sxs-lookup"><span data-stu-id="ae431-241">Important   For partially trusted code, <paramref name="maxStackSize" /> is ignored if it is greater than the default stack size.</span></span> <span data-ttu-id="ae431-242">不引发异常。</span><span class="sxs-lookup"><span data-stu-id="ae431-242">No exception is thrown.</span></span></param>
        <summary><span data-ttu-id="ae431-243">初始化 <see cref="T:System.Threading.Thread" /> 类的新实例，指定线程的最大堆栈大小。</span><span class="sxs-lookup"><span data-stu-id="ae431-243">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying the maximum stack size for the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-244">避免使用此构造函数重载。</span><span class="sxs-lookup"><span data-stu-id="ae431-244">Avoid using this constructor overload.</span></span> <span data-ttu-id="ae431-245"><xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> 构造函数重载使用的默认堆栈大小是线程的建议堆栈大小。</span><span class="sxs-lookup"><span data-stu-id="ae431-245">The default stack size used by the <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> constructor overload is the recommended stack size for threads.</span></span> <span data-ttu-id="ae431-246">如果线程存在内存问题，最可能的原因是编程错误，如无限递归。</span><span class="sxs-lookup"><span data-stu-id="ae431-246">If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ae431-247">从 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]开始，只有完全受信任的代码才能将 `maxStackSize` 设置为大于默认堆栈大小（1 mb）的值。</span><span class="sxs-lookup"><span data-stu-id="ae431-247">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], only fully trusted code can set `maxStackSize` to a value that is greater than the default stack size (1 megabyte).</span></span> <span data-ttu-id="ae431-248">如果为 `maxStackSize` 指定较大的值，则当代码在部分信任的情况下运行时，将忽略 `maxStackSize` 并使用默认堆栈大小。</span><span class="sxs-lookup"><span data-stu-id="ae431-248">If a larger value is specified for `maxStackSize` when code is running with partial trust, `maxStackSize` is ignored and the default stack size is used.</span></span> <span data-ttu-id="ae431-249">不引发异常。</span><span class="sxs-lookup"><span data-stu-id="ae431-249">No exception is thrown.</span></span> <span data-ttu-id="ae431-250">任何信任级别的代码都可以将 `maxStackSize` 设置为小于默认堆栈大小的值。</span><span class="sxs-lookup"><span data-stu-id="ae431-250">Code at any trust level can set `maxStackSize` to a value that is less than the default stack size.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-251">如果你正在开发将由部分信任的代码使用的完全受信任的库，并且你需要启动需要大型堆栈的线程，则必须在创建该线程之前断言完全信任，否则将使用默认堆栈大小。</span><span class="sxs-lookup"><span data-stu-id="ae431-251">If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</span></span> <span data-ttu-id="ae431-252">除非你完全控制在线程上运行的代码，否则不要执行此操作。</span><span class="sxs-lookup"><span data-stu-id="ae431-252">Do not do this unless you fully control the code that runs on the thread.</span></span>  
  
 <span data-ttu-id="ae431-253">如果 `maxStackSize` 小于最小堆栈大小，则使用最小堆栈大小。</span><span class="sxs-lookup"><span data-stu-id="ae431-253">If `maxStackSize` is less than the minimum stack size, the minimum stack size is used.</span></span> <span data-ttu-id="ae431-254">如果 `maxStackSize` 不是页面大小的倍数，则会将其舍入到页面大小的下一个较大倍数。</span><span class="sxs-lookup"><span data-stu-id="ae431-254">If `maxStackSize` is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</span></span> <span data-ttu-id="ae431-255">例如，如果你使用的是 Windows Vista 上的 .NET Framework 2.0 版，256KB （262144字节）是最小堆栈大小，而页面大小为64KB （65536个字节）。</span><span class="sxs-lookup"><span data-stu-id="ae431-255">For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-256">在 Windows XP 和 Windows Server 2003 之前的 Microsoft Windows 版本上，将忽略 `maxStackSize`，并使用可执行文件头中指定的堆栈大小。</span><span class="sxs-lookup"><span data-stu-id="ae431-256">On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, `maxStackSize` is ignored, and the stack size specified in the executable header is used.</span></span>  
  
 <span data-ttu-id="ae431-257">如果指定非常小的堆栈大小，则可能需要禁用堆栈溢出探测。</span><span class="sxs-lookup"><span data-stu-id="ae431-257">If you specify a very small stack size, you might need to disable stack-overflow probing.</span></span> <span data-ttu-id="ae431-258">当堆栈受到严格约束时，探测本身就会导致堆栈溢出。</span><span class="sxs-lookup"><span data-stu-id="ae431-258">When the stack is severely constrained, the probing can itself cause a stack overflow.</span></span> <span data-ttu-id="ae431-259">若要禁用堆栈溢出探测，请将以下项添加到应用程序配置文件中。</span><span class="sxs-lookup"><span data-stu-id="ae431-259">To disable stack overflow probing, add the following to your application configuration file.</span></span>  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ae431-260"><paramref name="start" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-260"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ae431-261"><paramref name="maxStackSize" /> 小于零。</span><span class="sxs-lookup"><span data-stu-id="ae431-261"><paramref name="maxStackSize" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ae431-262">在调用此方法的线程上引发 <see cref="T:System.Threading.ThreadAbortException" />，以开始终止此线程的过程。</span><span class="sxs-lookup"><span data-stu-id="ae431-262">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread.</span></span> <span data-ttu-id="ae431-263">调用此方法通常会终止线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-263">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
> <span data-ttu-id="ae431-264">应谨慎使用 `Thread.Abort` 方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-264">The `Thread.Abort` method should be used with caution.</span></span> <span data-ttu-id="ae431-265">特别是当调用它来中止当前线程以外的线程时，您不知道在引发 <xref:System.Threading.ThreadAbortException> 时执行或未能执行的代码，也不知道您的应用程序的状态或者它负责保留的任何应用程序和用户状态。</span><span class="sxs-lookup"><span data-stu-id="ae431-265">Particularly when you call it to abort a thread other than the current thread, you do not know what code has executed or failed to execute when the <xref:System.Threading.ThreadAbortException> is thrown, nor can you be certain of the state of your application or any application and user state that it is responsible for preserving.</span></span> <span data-ttu-id="ae431-266">例如，调用 `Thread.Abort` 可能会阻止静态构造函数执行或防止释放非托管资源</span><span class="sxs-lookup"><span data-stu-id="ae431-266">For example, calling `Thread.Abort` may prevent static constructors from executing or prevent the release of unmanaged resources</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="thread.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ae431-267">在调用此方法的线程上引发 <see cref="T:System.Threading.ThreadAbortException" />，以开始终止此线程的过程。</span><span class="sxs-lookup"><span data-stu-id="ae431-267">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread.</span></span> <span data-ttu-id="ae431-268">调用此方法通常会终止线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-268">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-269">在线程上调用此方法时，系统将在线程中引发 <xref:System.Threading.ThreadAbortException> 来中止它。</span><span class="sxs-lookup"><span data-stu-id="ae431-269">When this method is invoked on a thread, the system throws a <xref:System.Threading.ThreadAbortException> in the thread to abort it.</span></span> <span data-ttu-id="ae431-270">`ThreadAbortException` 是一种特殊的异常，可由应用程序代码捕获，但会在 `catch` 块的末尾重新引发，除非调用 <xref:System.Threading.Thread.ResetAbort%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-270">`ThreadAbortException` is a special exception that can be caught by application code, but is re-thrown at the end of the `catch` block unless <xref:System.Threading.Thread.ResetAbort%2A> is called.</span></span> <span data-ttu-id="ae431-271">`ResetAbort` 取消中止请求，并阻止 `ThreadAbortException` 终止线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-271">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span> <span data-ttu-id="ae431-272">未执行 `finally` 块在线程中止之前执行。</span><span class="sxs-lookup"><span data-stu-id="ae431-272">Unexecuted `finally` blocks are executed before the thread is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-273">当线程自行调用 `Abort` 时，其效果类似于引发异常;<xref:System.Threading.ThreadAbortException> 立即发生，结果是可预测的。</span><span class="sxs-lookup"><span data-stu-id="ae431-273">When a thread calls `Abort` on itself, the effect is similar to throwing an exception; the <xref:System.Threading.ThreadAbortException> happens immediately, and the result is predictable.</span></span> <span data-ttu-id="ae431-274">但是，如果一个线程在另一个线程上调用 `Abort`，则中止会中断正在运行的任何代码。</span><span class="sxs-lookup"><span data-stu-id="ae431-274">However, if one thread calls `Abort` on another thread, the abort interrupts whatever code is running.</span></span> <span data-ttu-id="ae431-275">还有可能会中止静态构造函数。</span><span class="sxs-lookup"><span data-stu-id="ae431-275">There is also a chance that a static constructor could be aborted.</span></span> <span data-ttu-id="ae431-276">在极少数情况下，这可能会阻止在该应用程序域中创建该类的实例。</span><span class="sxs-lookup"><span data-stu-id="ae431-276">In rare cases, this might prevent instances of that class from being created in that application domain.</span></span> <span data-ttu-id="ae431-277">在 .NET Framework 版本1.0 和1.1 中，线程可能会在运行 `finally` 块时中止，在这种情况下，将中止 `finally` 块。</span><span class="sxs-lookup"><span data-stu-id="ae431-277">In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a `finally` block is running, in which case the `finally` block is aborted.</span></span>  
  
 <span data-ttu-id="ae431-278">该线程不能保证立即中止，或根本就中止。</span><span class="sxs-lookup"><span data-stu-id="ae431-278">The thread is not guaranteed to abort immediately, or at all.</span></span> <span data-ttu-id="ae431-279">如果线程在作为中止过程的一部分调用的 `finally` 块中进行了无限量的计算，从而导致无限期延迟中止，则会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-279">This situation can occur if a thread does an unbounded amount of computation in the `finally` blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</span></span> <span data-ttu-id="ae431-280">若要等到线程中止，可以在调用 <xref:System.Threading.Thread.Abort%2A> 方法后调用线程上的 <xref:System.Threading.Thread.Join%2A> 方法，但不保证等待将结束。</span><span class="sxs-lookup"><span data-stu-id="ae431-280">To wait until a thread has aborted, you can call the <xref:System.Threading.Thread.Join%2A> method on the thread after calling the <xref:System.Threading.Thread.Abort%2A> method, but there is no guarantee the wait will end.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-281">如果要中止的线程处于受保护的代码区域（如 `catch` 块、`finally` 块或受约束的执行区域），则调用 <xref:System.Threading.Thread.Abort%2A> 的线程可能会阻塞。</span><span class="sxs-lookup"><span data-stu-id="ae431-281">The thread that calls <xref:System.Threading.Thread.Abort%2A> might block if the thread that is being aborted is in a protected region of code, such as a `catch` block, `finally` block, or constrained execution region.</span></span> <span data-ttu-id="ae431-282">如果调用 <xref:System.Threading.Thread.Abort%2A> 的线程包含中止的线程所需的锁，则可能会发生死锁。</span><span class="sxs-lookup"><span data-stu-id="ae431-282">If the thread that calls <xref:System.Threading.Thread.Abort%2A> holds a lock that the aborted thread requires, a deadlock can occur.</span></span>  
  
 <span data-ttu-id="ae431-283">如果在未启动的线程上调用 `Abort`，则调用 <xref:System.Threading.Thread.Start%2A> 时，该线程将中止。</span><span class="sxs-lookup"><span data-stu-id="ae431-283">If `Abort` is called on a thread that has not been started, the thread will abort when <xref:System.Threading.Thread.Start%2A> is called.</span></span> <span data-ttu-id="ae431-284">如果在被阻止或处于休眠状态的线程上调用 `Abort`，则该线程将中断，然后中止。</span><span class="sxs-lookup"><span data-stu-id="ae431-284">If `Abort` is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</span></span>  
  
 <span data-ttu-id="ae431-285">如果在已挂起的线程上调用 `Abort`，则会在调用 <xref:System.Threading.Thread.Abort%2A>的线程中引发 <xref:System.Threading.ThreadStateException>，并 <xref:System.Threading.ThreadState.AbortRequested> 添加到要中止的线程的 <xref:System.Threading.Thread.ThreadState%2A> 属性中。</span><span class="sxs-lookup"><span data-stu-id="ae431-285">If `Abort` is called on a thread that has been suspended, a <xref:System.Threading.ThreadStateException> is thrown in the thread that called <xref:System.Threading.Thread.Abort%2A>, and <xref:System.Threading.ThreadState.AbortRequested> is added to the <xref:System.Threading.Thread.ThreadState%2A> property of the thread being aborted.</span></span> <span data-ttu-id="ae431-286">在调用 <xref:System.Threading.Thread.Resume%2A> 之前，不会在已挂起的线程中引发 <xref:System.Threading.ThreadAbortException>。</span><span class="sxs-lookup"><span data-stu-id="ae431-286">A <xref:System.Threading.ThreadAbortException> is not thrown in the suspended thread until <xref:System.Threading.Thread.Resume%2A> is called.</span></span>  
  
 <span data-ttu-id="ae431-287">如果在执行非托管代码时在托管线程上调用 `Abort`，则直到线程返回到托管代码，才会引发 `ThreadAbortException`。</span><span class="sxs-lookup"><span data-stu-id="ae431-287">If `Abort` is called on a managed thread while it is executing unmanaged code, a `ThreadAbortException` is not thrown until the thread returns to managed code.</span></span>  
  
 <span data-ttu-id="ae431-288">如果对 `Abort` 的两次调用同时出现，则可以通过调用设置状态信息和其他调用来执行 `Abort`。</span><span class="sxs-lookup"><span data-stu-id="ae431-288">If two calls to `Abort` come at the same time, it is possible for one call to set the state information and the other call to execute the `Abort`.</span></span> <span data-ttu-id="ae431-289">但是，应用程序无法检测到这种情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-289">However, an application cannot detect this situation.</span></span>  
  
 <span data-ttu-id="ae431-290">在线程上调用 `Abort` 后，线程的状态包括 <xref:System.Threading.ThreadState.AbortRequested>。</span><span class="sxs-lookup"><span data-stu-id="ae431-290">After `Abort` is invoked on a thread, the state of the thread includes <xref:System.Threading.ThreadState.AbortRequested>.</span></span> <span data-ttu-id="ae431-291">由于对 `Abort`的成功调用导致线程终止后，线程的状态将更改为 <xref:System.Threading.ThreadState.Stopped>。</span><span class="sxs-lookup"><span data-stu-id="ae431-291">After the thread has terminated as a result of a successful call to `Abort`, the state of the thread is changed to <xref:System.Threading.ThreadState.Stopped>.</span></span> <span data-ttu-id="ae431-292">如果具有足够的权限，则作为 `Abort` 目标的线程可以使用 `ResetAbort` 方法取消中止。</span><span class="sxs-lookup"><span data-stu-id="ae431-292">With sufficient permissions, a thread that is the target of an `Abort` can cancel the abort using the `ResetAbort` method.</span></span> <span data-ttu-id="ae431-293">有关演示如何调用 `ResetAbort` 方法的示例，请参见 `ThreadAbortException` 类。</span><span class="sxs-lookup"><span data-stu-id="ae431-293">For an example that demonstrates calling the `ResetAbort` method, see the `ThreadAbortException` class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="ae431-294">仅限 .NET Core：不支持此成员。</span><span class="sxs-lookup"><span data-stu-id="ae431-294">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="ae431-295">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="ae431-295">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="ae431-296">正在中止的线程当前已挂起。</span><span class="sxs-lookup"><span data-stu-id="ae431-296">The thread that is being aborted is currently suspended.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ae431-297">用于线程的高级操作。</span><span class="sxs-lookup"><span data-stu-id="ae431-297">for advanced operations on threads.</span></span> <span data-ttu-id="ae431-298">关联的枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-298">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="ae431-299">线程与线程处理</span><span class="sxs-lookup"><span data-stu-id="ae431-299">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md"><span data-ttu-id="ae431-300">使用线程和线程处理</span><span class="sxs-lookup"><span data-stu-id="ae431-300">Using threads and threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md"><span data-ttu-id="ae431-301">销毁线程</span><span class="sxs-lookup"><span data-stu-id="ae431-301">Destroying threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberSignature Language="F#" Value="member this.Abort : obj -&gt; unit" Usage="thread.Abort stateInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="stateInfo"><span data-ttu-id="ae431-302">一个对象，它包含应用程序特定的信息（如状态），该信息可供正被中止的线程使用。</span><span class="sxs-lookup"><span data-stu-id="ae431-302">An object that contains application-specific information, such as state, which can be used by the thread being aborted.</span></span></param>
        <summary><span data-ttu-id="ae431-303">引发在其上调用的线程中的 <see cref="T:System.Threading.ThreadAbortException" /> 以开始处理终止线程，同时提供有关线程终止的异常信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-303">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread while also providing exception information about the thread termination.</span></span> <span data-ttu-id="ae431-304">调用此方法通常会终止线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-304">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-305">在线程上调用此方法时，系统将在线程中引发 <xref:System.Threading.ThreadAbortException> 来中止它。</span><span class="sxs-lookup"><span data-stu-id="ae431-305">When this method is invoked on a thread, the system throws a <xref:System.Threading.ThreadAbortException> in the thread to abort it.</span></span> <span data-ttu-id="ae431-306">`ThreadAbortException` 是一种特殊的异常，可由应用程序代码捕获，但会在 `catch` 块的末尾重新引发，除非调用 <xref:System.Threading.Thread.ResetAbort%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-306">`ThreadAbortException` is a special exception that can be caught by application code, but is re-thrown at the end of the `catch` block unless <xref:System.Threading.Thread.ResetAbort%2A> is called.</span></span> <span data-ttu-id="ae431-307">`ResetAbort` 取消中止请求，并阻止 `ThreadAbortException` 终止线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-307">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span> <span data-ttu-id="ae431-308">未执行 `finally` 块在线程中止之前执行。</span><span class="sxs-lookup"><span data-stu-id="ae431-308">Unexecuted `finally` blocks are executed before the thread is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-309">当线程自行调用 `Abort` 时，其效果类似于引发异常;<xref:System.Threading.ThreadAbortException> 立即发生，结果是可预测的。</span><span class="sxs-lookup"><span data-stu-id="ae431-309">When a thread calls `Abort` on itself, the effect is similar to throwing an exception; the <xref:System.Threading.ThreadAbortException> happens immediately, and the result is predictable.</span></span> <span data-ttu-id="ae431-310">但是，如果一个线程在另一个线程上调用 `Abort`，则中止会中断正在运行的任何代码。</span><span class="sxs-lookup"><span data-stu-id="ae431-310">However, if one thread calls `Abort` on another thread, the abort interrupts whatever code is running.</span></span> <span data-ttu-id="ae431-311">可能会中止静态构造函数。</span><span class="sxs-lookup"><span data-stu-id="ae431-311">There is a chance that a static constructor could be aborted.</span></span> <span data-ttu-id="ae431-312">在极少数情况下，这可能会阻止在该应用程序域中创建该类的实例。</span><span class="sxs-lookup"><span data-stu-id="ae431-312">In rare cases, this might prevent instances of that class from being created in that application domain.</span></span> <span data-ttu-id="ae431-313">在 .NET Framework 版本1.0 和1.1 中，线程可能会在运行 `finally` 块时中止，在这种情况下，将中止 `finally` 块。</span><span class="sxs-lookup"><span data-stu-id="ae431-313">In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a `finally` block is running, in which case the `finally` block is aborted.</span></span>  
  
 <span data-ttu-id="ae431-314">该线程不能保证立即中止，或根本就中止。</span><span class="sxs-lookup"><span data-stu-id="ae431-314">The thread is not guaranteed to abort immediately, or at all.</span></span> <span data-ttu-id="ae431-315">如果线程在作为中止过程的一部分调用的 `finally` 块中进行了无限量的计算，从而导致无限期延迟中止，则会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-315">This situation can occur if a thread does an unbounded amount of computation in the `finally` blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</span></span> <span data-ttu-id="ae431-316">若要等到线程中止，可以在调用 <xref:System.Threading.Thread.Abort%2A> 方法后调用线程上的 <xref:System.Threading.Thread.Join%2A> 方法，但不能保证等待将结束。</span><span class="sxs-lookup"><span data-stu-id="ae431-316">To wait until a thread has aborted, you can call the <xref:System.Threading.Thread.Join%2A> method on the thread after calling the <xref:System.Threading.Thread.Abort%2A> method, but there is no guarantee that the wait will end.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-317">如果要中止的线程处于受保护的代码区域（如 `catch` 块、`finally` 块或受约束的执行区域），则调用 <xref:System.Threading.Thread.Abort%2A> 的线程可能会阻塞。</span><span class="sxs-lookup"><span data-stu-id="ae431-317">The thread that calls <xref:System.Threading.Thread.Abort%2A> might block if the thread that is being aborted is in a protected region of code, such as a `catch` block, `finally` block, or constrained execution region.</span></span> <span data-ttu-id="ae431-318">如果调用 <xref:System.Threading.Thread.Abort%2A> 的线程包含中止的线程所需的锁，则可能会发生死锁。</span><span class="sxs-lookup"><span data-stu-id="ae431-318">If the thread that calls <xref:System.Threading.Thread.Abort%2A> holds a lock that the aborted thread requires, a deadlock can occur.</span></span>  
  
 <span data-ttu-id="ae431-319">如果在未启动的线程上调用 `Abort`，则调用 <xref:System.Threading.Thread.Start%2A> 时，该线程将中止。</span><span class="sxs-lookup"><span data-stu-id="ae431-319">If `Abort` is called on a thread that has not been started, the thread will abort when <xref:System.Threading.Thread.Start%2A> is called.</span></span> <span data-ttu-id="ae431-320">如果在被阻止或处于休眠状态的线程上调用 `Abort`，则该线程将中断，然后中止。</span><span class="sxs-lookup"><span data-stu-id="ae431-320">If `Abort` is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</span></span>  
  
 <span data-ttu-id="ae431-321">如果在已挂起的线程上调用 `Abort`，则会在调用 <xref:System.Threading.Thread.Abort%2A>的线程中引发 <xref:System.Threading.ThreadStateException>，并 <xref:System.Threading.ThreadState.AbortRequested> 添加到要中止的线程的 <xref:System.Threading.Thread.ThreadState%2A> 属性中。</span><span class="sxs-lookup"><span data-stu-id="ae431-321">If `Abort` is called on a thread that has been suspended, a <xref:System.Threading.ThreadStateException> is thrown in the thread that called <xref:System.Threading.Thread.Abort%2A>, and <xref:System.Threading.ThreadState.AbortRequested> is added to the <xref:System.Threading.Thread.ThreadState%2A> property of the thread being aborted.</span></span> <span data-ttu-id="ae431-322">在调用 <xref:System.Threading.Thread.Resume%2A> 之前，不会在已挂起的线程中引发 <xref:System.Threading.ThreadAbortException>。</span><span class="sxs-lookup"><span data-stu-id="ae431-322">A <xref:System.Threading.ThreadAbortException> is not thrown in the suspended thread until <xref:System.Threading.Thread.Resume%2A> is called.</span></span>  
  
 <span data-ttu-id="ae431-323">如果在执行非托管代码时在托管线程上调用 `Abort`，则直到线程返回到托管代码，才会引发 `ThreadAbortException`。</span><span class="sxs-lookup"><span data-stu-id="ae431-323">If `Abort` is called on a managed thread while it is executing unmanaged code, a `ThreadAbortException` is not thrown until the thread returns to managed code.</span></span>  
  
 <span data-ttu-id="ae431-324">如果对 `Abort` 的两次调用同时出现，则可以通过调用设置状态信息和其他调用来执行 `Abort`。</span><span class="sxs-lookup"><span data-stu-id="ae431-324">If two calls to `Abort` come at the same time, it is possible for one call to set the state information and the other call to execute the `Abort`.</span></span> <span data-ttu-id="ae431-325">但是，应用程序无法检测到这种情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-325">However, an application cannot detect this situation.</span></span>  
  
 <span data-ttu-id="ae431-326">在线程上调用 `Abort` 后，线程的状态包括 <xref:System.Threading.ThreadState.AbortRequested>。</span><span class="sxs-lookup"><span data-stu-id="ae431-326">After `Abort` is invoked on a thread, the state of the thread includes <xref:System.Threading.ThreadState.AbortRequested>.</span></span> <span data-ttu-id="ae431-327">由于对 `Abort`的成功调用导致线程终止后，线程的状态将更改为 <xref:System.Threading.ThreadState.Stopped>。</span><span class="sxs-lookup"><span data-stu-id="ae431-327">After the thread has terminated as a result of a successful call to `Abort`, the state of the thread is changed to <xref:System.Threading.ThreadState.Stopped>.</span></span> <span data-ttu-id="ae431-328">如果具有足够的权限，则作为 `Abort` 目标的线程可以使用 `ResetAbort` 方法取消中止。</span><span class="sxs-lookup"><span data-stu-id="ae431-328">With sufficient permissions, a thread that is the target of an `Abort` can cancel the abort using the `ResetAbort` method.</span></span> <span data-ttu-id="ae431-329">有关演示如何调用 `ResetAbort` 方法的示例，请参见 `ThreadAbortException` 类。</span><span class="sxs-lookup"><span data-stu-id="ae431-329">For an example that demonstrates calling the `ResetAbort` method, see the `ThreadAbortException` class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-330">下面的代码示例演示如何将信息传递到正在中止的线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-330">The following code example shows how to pass information to a thread that is being aborted.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="ae431-331">仅限 .NET Core：不支持此成员。</span><span class="sxs-lookup"><span data-stu-id="ae431-331">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="ae431-332">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="ae431-332">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="ae431-333">正在中止的线程当前已挂起。</span><span class="sxs-lookup"><span data-stu-id="ae431-333">The thread that is being aborted is currently suspended.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ae431-334">用于线程的高级操作。</span><span class="sxs-lookup"><span data-stu-id="ae431-334">for advanced operations on threads.</span></span> <span data-ttu-id="ae431-335">关联的枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-335">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="ae431-336">线程与线程处理</span><span class="sxs-lookup"><span data-stu-id="ae431-336">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md"><span data-ttu-id="ae431-337">使用线程和线程处理</span><span class="sxs-lookup"><span data-stu-id="ae431-337">Using threads and threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md"><span data-ttu-id="ae431-338">销毁线程</span><span class="sxs-lookup"><span data-stu-id="ae431-338">Destroying threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberSignature Language="F#" Value="static member AllocateDataSlot : unit -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateDataSlot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ae431-339">在所有线程上分配未命名的数据槽。</span><span class="sxs-lookup"><span data-stu-id="ae431-339">Allocates an unnamed data slot on all the threads.</span></span> <span data-ttu-id="ae431-340">为了获得更好的性能，请改用以 <see cref="T:System.ThreadStaticAttribute" /> 特性标记的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-340">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="ae431-341">所有线程上已分配的命名数据槽。</span><span class="sxs-lookup"><span data-stu-id="ae431-341">The allocated named data slot on all threads.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="ae431-342">.NET Framework 提供了两种使用线程本地存储（TLS）的机制：线程相关的静态字段（即使用 <xref:System.ThreadStaticAttribute> 属性标记的字段）和数据槽。</span><span class="sxs-lookup"><span data-stu-id="ae431-342">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="ae431-343">线程相对静态字段比数据槽提供更好的性能，并启用编译时类型检查。</span><span class="sxs-lookup"><span data-stu-id="ae431-343">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="ae431-344">有关使用 TLS 的详细信息，请参阅[线程本地存储：线程相对静态字段和数据槽](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。</span><span class="sxs-lookup"><span data-stu-id="ae431-344">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="ae431-345">在所有线程上分配槽。</span><span class="sxs-lookup"><span data-stu-id="ae431-345">The slot is allocated on all threads.</span></span>  
  
 <span data-ttu-id="ae431-346">线程使用本地存储内存机制来存储线程特定的数据。</span><span class="sxs-lookup"><span data-stu-id="ae431-346">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="ae431-347">公共语言运行时在创建每个进程时将多槽数据存储数组分配给它。</span><span class="sxs-lookup"><span data-stu-id="ae431-347">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="ae431-348">线程可以在数据存储中分配数据槽，在槽中存储和检索数据值，并在线程过期后释放槽以供重新使用。</span><span class="sxs-lookup"><span data-stu-id="ae431-348">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="ae431-349">数据槽对于每个线程都是唯一的。</span><span class="sxs-lookup"><span data-stu-id="ae431-349">Data slots are unique per thread.</span></span> <span data-ttu-id="ae431-350">任何其他线程（甚至不是子线程）都无法获取该数据。</span><span class="sxs-lookup"><span data-stu-id="ae431-350">No other thread (not even a child thread) can get that data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-351">本部分包含两个代码示例。</span><span class="sxs-lookup"><span data-stu-id="ae431-351">This section contains two code examples.</span></span> <span data-ttu-id="ae431-352">第一个示例演示如何使用标记有 <xref:System.ThreadStaticAttribute> 特性的字段来保存特定于线程的信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-352">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="ae431-353">第二个示例演示如何使用数据槽来执行相同的操作。</span><span class="sxs-lookup"><span data-stu-id="ae431-353">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="ae431-354">**第一个示例**</span><span class="sxs-lookup"><span data-stu-id="ae431-354">**First Example**</span></span>  
  
 <span data-ttu-id="ae431-355">下面的示例演示如何使用标记有 <xref:System.ThreadStaticAttribute> 的字段来保存特定于线程的信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-355">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="ae431-356">与第二个示例中所示的方法相比，此方法提供的性能更好。</span><span class="sxs-lookup"><span data-stu-id="ae431-356">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="ae431-357">**第二个示例**</span><span class="sxs-lookup"><span data-stu-id="ae431-357">**Second Example**</span></span>  
  
 <span data-ttu-id="ae431-358">下面的代码示例演示如何使用数据槽存储特定于线程的信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-358">The following code example demonstrates how to use a data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="ae431-359">线程与线程处理</span><span class="sxs-lookup"><span data-stu-id="ae431-359">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="ae431-360">线程本地存储区：线程相关的静态字段和数据槽</span><span class="sxs-lookup"><span data-stu-id="ae431-360">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member AllocateNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="ae431-361">要分配的数据槽的名称。</span><span class="sxs-lookup"><span data-stu-id="ae431-361">The name of the data slot to be allocated.</span></span></param>
        <summary><span data-ttu-id="ae431-362">在所有线程上分配已命名的数据槽。</span><span class="sxs-lookup"><span data-stu-id="ae431-362">Allocates a named data slot on all threads.</span></span> <span data-ttu-id="ae431-363">为了获得更好的性能，请改用以 <see cref="T:System.ThreadStaticAttribute" /> 特性标记的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-363">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="ae431-364">所有线程上已分配的命名数据槽。</span><span class="sxs-lookup"><span data-stu-id="ae431-364">The allocated named data slot on all threads.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="ae431-365">.NET Framework 提供了两种使用线程本地存储（TLS）的机制：线程相关的静态字段（即使用 <xref:System.ThreadStaticAttribute> 属性标记的字段）和数据槽。</span><span class="sxs-lookup"><span data-stu-id="ae431-365">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="ae431-366">线程相对静态字段比数据槽提供更好的性能，并启用编译时类型检查。</span><span class="sxs-lookup"><span data-stu-id="ae431-366">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="ae431-367">有关使用 TLS 的详细信息，请参阅[线程本地存储：线程相对静态字段和数据槽](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。</span><span class="sxs-lookup"><span data-stu-id="ae431-367">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="ae431-368">线程使用本地存储内存机制来存储线程特定的数据。</span><span class="sxs-lookup"><span data-stu-id="ae431-368">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="ae431-369">公共语言运行时在创建每个进程时将多槽数据存储数组分配给它。</span><span class="sxs-lookup"><span data-stu-id="ae431-369">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="ae431-370">线程可以在数据存储中分配数据槽，在槽中存储和检索数据值，并在线程过期后释放槽以供重新使用。</span><span class="sxs-lookup"><span data-stu-id="ae431-370">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="ae431-371">数据槽对于每个线程都是唯一的。</span><span class="sxs-lookup"><span data-stu-id="ae431-371">Data slots are unique per thread.</span></span> <span data-ttu-id="ae431-372">任何其他线程（甚至不是子线程）都无法获取该数据。</span><span class="sxs-lookup"><span data-stu-id="ae431-372">No other thread (not even a child thread) can get that data.</span></span>  
  
 <span data-ttu-id="ae431-373">不需要使用 <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> 方法来分配已命名的数据槽，因为如果尚未分配槽，<xref:System.Threading.Thread.GetNamedDataSlot%2A> 方法会分配槽。</span><span class="sxs-lookup"><span data-stu-id="ae431-373">It is not necessary to use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method to allocate a named data slot, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-374">如果使用 <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> 方法，则应在程序启动时在主线程中调用该方法，因为如果已经分配了具有指定名称的槽，则该方法将引发异常。</span><span class="sxs-lookup"><span data-stu-id="ae431-374">If the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method is used, it should be called in the main thread at program startup, because it throws an exception if a slot with the specified name has already been allocated.</span></span> <span data-ttu-id="ae431-375">无法测试槽是否已分配。</span><span class="sxs-lookup"><span data-stu-id="ae431-375">There is no way to test whether a slot has already been allocated.</span></span>  
  
 <span data-ttu-id="ae431-376">必须通过 <xref:System.Threading.Thread.FreeNamedDataSlot%2A>释放用此方法分配的槽。</span><span class="sxs-lookup"><span data-stu-id="ae431-376">Slots allocated with this method must be freed with <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-377">本部分包含两个代码示例。</span><span class="sxs-lookup"><span data-stu-id="ae431-377">This section contains two code examples.</span></span> <span data-ttu-id="ae431-378">第一个示例演示如何使用标记有 <xref:System.ThreadStaticAttribute> 特性的字段来保存特定于线程的信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-378">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="ae431-379">第二个示例演示如何使用数据槽来执行相同的操作。</span><span class="sxs-lookup"><span data-stu-id="ae431-379">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="ae431-380">**第一个示例**</span><span class="sxs-lookup"><span data-stu-id="ae431-380">**First Example**</span></span>  
  
 <span data-ttu-id="ae431-381">下面的示例演示如何使用标记有 <xref:System.ThreadStaticAttribute> 的字段来保存特定于线程的信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-381">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="ae431-382">与第二个示例中所示的方法相比，此方法提供的性能更好。</span><span class="sxs-lookup"><span data-stu-id="ae431-382">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="ae431-383">**第二个示例**</span><span class="sxs-lookup"><span data-stu-id="ae431-383">**Second Example**</span></span>  
  
 <span data-ttu-id="ae431-384">下面的示例演示如何使用命名数据槽来存储特定于线程的信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-384">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-385">示例代码不使用 <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> 方法，因为如果尚未分配槽，<xref:System.Threading.Thread.GetNamedDataSlot%2A> 方法会分配槽。</span><span class="sxs-lookup"><span data-stu-id="ae431-385">The example code does not use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated.</span></span> <span data-ttu-id="ae431-386">如果使用 <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> 方法，则它应在程序启动时在主线程中调用。</span><span class="sxs-lookup"><span data-stu-id="ae431-386">If the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method is used, it should be called in the main thread at program startup.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ae431-387">已存在具有指定名称的命名的数据槽。</span><span class="sxs-lookup"><span data-stu-id="ae431-387">A named data slot with the specified name already exists.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="ae431-388">线程与线程处理</span><span class="sxs-lookup"><span data-stu-id="ae431-388">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="ae431-389">线程本地存储区：线程相关的静态字段和数据槽</span><span class="sxs-lookup"><span data-stu-id="ae431-389">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberSignature Language="F#" Value="member this.ApartmentState : System.Threading.ApartmentState with get, set" Usage="System.Threading.Thread.ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("The ApartmentState property has been deprecated.  Use GetApartmentState, SetApartmentState or TrySetApartmentState instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ae431-390">获取或设置此线程的单元状态。</span><span class="sxs-lookup"><span data-stu-id="ae431-390">Gets or sets the apartment state of this thread.</span></span></summary>
        <value><span data-ttu-id="ae431-391"><see cref="T:System.Threading.ApartmentState" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="ae431-391">One of the <see cref="T:System.Threading.ApartmentState" /> values.</span></span> <span data-ttu-id="ae431-392">初始值为 <see langword="Unknown" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-392">The initial value is <see langword="Unknown" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-393">**<xref:System.Threading.Thread.ApartmentState%2A> 属性已过时。**</span><span class="sxs-lookup"><span data-stu-id="ae431-393">**The <xref:System.Threading.Thread.ApartmentState%2A> property is obsolete.**</span></span>  <span data-ttu-id="ae431-394">未过时的替代项是检索单元状态的 <xref:System.Threading.Thread.GetApartmentState%2A> 方法，以及 <xref:System.Threading.Thread.SetApartmentState%2A> 方法来设置单元状态。</span><span class="sxs-lookup"><span data-stu-id="ae431-394">The non-obsolete alternatives are the <xref:System.Threading.Thread.GetApartmentState%2A> method to retrieve the apartment state and the   <xref:System.Threading.Thread.SetApartmentState%2A> method to set the apartment state.</span></span>  
  
 <span data-ttu-id="ae431-395">在 .NET Framework 版本1.0 和1.1 中，`ApartmentState` 属性标记一个线程以指示它将在单线程或多线程单元中执行。</span><span class="sxs-lookup"><span data-stu-id="ae431-395">In the .NET Framework versions 1.0 and 1.1, the `ApartmentState` property marks a thread to indicate that it will execute in a single-threaded or multithreaded apartment.</span></span> <span data-ttu-id="ae431-396">当线程处于 `Unstarted` 或 `Running` 线程状态时，可以设置此属性;但对于线程，只能设置一次。</span><span class="sxs-lookup"><span data-stu-id="ae431-396">This property can be set when the thread is in the `Unstarted` or `Running` thread state; however, it can be set only once for a thread.</span></span> <span data-ttu-id="ae431-397">如果尚未设置属性，则它将返回 `Unknown`。</span><span class="sxs-lookup"><span data-stu-id="ae431-397">If the property has not been set, it returns `Unknown`.</span></span>  
  
 <span data-ttu-id="ae431-398">尝试使用 <xref:System.Threading.Thread.ApartmentState%2A> 属性设置已设置了单元状态的线程的单元状态。</span><span class="sxs-lookup"><span data-stu-id="ae431-398">An attempt to use the <xref:System.Threading.Thread.ApartmentState%2A> property to set the apartment state of a thread whose apartment state has already been set is ignored.</span></span> <span data-ttu-id="ae431-399">但是，在这种情况下，<xref:System.Threading.Thread.SetApartmentState%2A> 方法会引发 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="ae431-399">However, the <xref:System.Threading.Thread.SetApartmentState%2A> method throws a <xref:System.InvalidOperationException> in this case.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ae431-400">在 .NET Framework 版本2.0 中，如果在启动新线程之前未设置其单元状态，则将其初始化为 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ae431-400">In the .NET Framework version 2.0, new threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="ae431-401">默认情况下，主应用程序线程初始化为 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ae431-401">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="ae431-402">你不能再通过设置第一行代码的 <xref:System.Threading.ApartmentState?displayProperty=nameWithType> 属性来将主应用程序线程设置为 <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ae431-402">You can no longer set the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> by setting the <xref:System.Threading.ApartmentState?displayProperty=nameWithType> property on the first line of code.</span></span> <span data-ttu-id="ae431-403">改用 <xref:System.STAThreadAttribute>。</span><span class="sxs-lookup"><span data-stu-id="ae431-403">Use the <xref:System.STAThreadAttribute> instead.</span></span>  
  
 <span data-ttu-id="ae431-404">在 .NET Framework 版本2.0 中，可以使用C++ [/CLRTHREADATTRIBUTE （设置 CLR 线程属性）](/cpp/build/reference/clrthreadattribute-set-clr-thread-attribute)链接器选项指定应用程序的 COM 线程模型。</span><span class="sxs-lookup"><span data-stu-id="ae431-404">In the .NET Framework version 2.0, you can specify the COM threading model for a C++ application using the [/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)](/cpp/build/reference/clrthreadattribute-set-clr-thread-attribute) linker option.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-405">下面的代码示例演示如何设置线程的单元状态。</span><span class="sxs-lookup"><span data-stu-id="ae431-405">The following code example demonstrates how to set the apartment state of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ae431-406">尝试将此属性设置为不是有效单元状态的状态 （单线程单元 (<see langword="STA" />) 或多线程单元 (<see langword="MTA" />) 以外的状态）。</span><span class="sxs-lookup"><span data-stu-id="ae431-406">An attempt is made to set this property to a state that is not a valid apartment state (a state other than single-threaded apartment (<see langword="STA" />) or multithreaded apartment (<see langword="MTA" />)).</span></span></exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member BeginCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.BeginCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ae431-407">通知宿主执行将要进入一个代码区域，在该代码区域内线程中止或未经处理异常的影响可能会危害应用程序域中的其他任务。</span><span class="sxs-lookup"><span data-stu-id="ae431-407">Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-408">公共语言运行时（CLR）的宿主（如 Microsoft SQL Server 2005）可为代码的关键和非关键区域中的故障建立不同的策略。</span><span class="sxs-lookup"><span data-stu-id="ae431-408">Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</span></span> <span data-ttu-id="ae431-409">关键区域是指线程中止或未经处理的异常的影响可能不会限制为当前任务。</span><span class="sxs-lookup"><span data-stu-id="ae431-409">A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</span></span> <span data-ttu-id="ae431-410">相反，非关键代码区域中的中止或失败只会影响发生错误的任务。</span><span class="sxs-lookup"><span data-stu-id="ae431-410">By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</span></span>  
  
 <span data-ttu-id="ae431-411">例如，假设某个任务在持有锁时尝试分配内存。</span><span class="sxs-lookup"><span data-stu-id="ae431-411">For example, consider a task that attempts to allocate memory while holding a lock.</span></span> <span data-ttu-id="ae431-412">如果内存分配失败，则中止当前任务不足以确保 <xref:System.AppDomain>的稳定性，因为域中的其他任务可能会等待相同的锁。</span><span class="sxs-lookup"><span data-stu-id="ae431-412">If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <xref:System.AppDomain>, because there can be other tasks in the domain waiting for the same lock.</span></span> <span data-ttu-id="ae431-413">如果当前任务已终止，则其他任务可能会死锁。</span><span class="sxs-lookup"><span data-stu-id="ae431-413">If the current task is terminated, other tasks could be deadlocked.</span></span>  
  
 <span data-ttu-id="ae431-414">当关键区域发生故障时，主机可能决定卸载整个 <xref:System.AppDomain> 而不是在可能不稳定的状态下继续执行的风险。</span><span class="sxs-lookup"><span data-stu-id="ae431-414">When a failure occurs in a critical region, the host might decide to unload the entire <xref:System.AppDomain> rather than take the risk of continuing execution in a potentially unstable state.</span></span> <span data-ttu-id="ae431-415">若要通知主机您的代码正在进入关键区域，请调用 <xref:System.Threading.Thread.BeginCriticalRegion%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-415">To inform the host that your code is entering a critical region, call <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span></span> <span data-ttu-id="ae431-416">当执行返回到非关键代码区域时调用 <xref:System.Threading.Thread.EndCriticalRegion%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-416">Call <xref:System.Threading.Thread.EndCriticalRegion%2A> when execution returns to a non-critical region of code.</span></span>  
  
 <span data-ttu-id="ae431-417">如果在 SQL Server 2005 下运行的代码中使用此方法，则需要在最高的主机保护级别上运行代码。</span><span class="sxs-lookup"><span data-stu-id="ae431-417">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-418">下面的示例演示如何使用 <xref:System.Threading.Thread.BeginCriticalRegion%2A> 和 <xref:System.Threading.Thread.EndCriticalRegion%2A> 方法将代码块分为关键区域和非关键区域。</span><span class="sxs-lookup"><span data-stu-id="ae431-418">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member BeginThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.BeginThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ae431-419">通知主机托管代码将要执行依赖于当前物理操作系统线程的标识的指令。</span><span class="sxs-lookup"><span data-stu-id="ae431-419">Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-420">公共语言运行时的某些宿主（如 Microsoft SQL Server 2005）提供其自己的线程管理。</span><span class="sxs-lookup"><span data-stu-id="ae431-420">Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</span></span> <span data-ttu-id="ae431-421">提供其自己的线程管理的主机可随时将正在执行的任务从一个物理操作系统线程移至另一个线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-421">A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</span></span> <span data-ttu-id="ae431-422">大多数任务不受此切换的影响。</span><span class="sxs-lookup"><span data-stu-id="ae431-422">Most tasks are not affected by this switching.</span></span> <span data-ttu-id="ae431-423">但是，某些任务具有线程关联，即它们依赖于物理操作系统线程的标识。</span><span class="sxs-lookup"><span data-stu-id="ae431-423">However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</span></span> <span data-ttu-id="ae431-424">这些任务在执行不应切换的代码时必须通知宿主。</span><span class="sxs-lookup"><span data-stu-id="ae431-424">These tasks must inform the host when they execute code that should not be switched.</span></span>  
  
 <span data-ttu-id="ae431-425">例如，如果应用程序调用系统 API 来获取具有线程关联的操作系统锁（如 Win32 CRITICAL_SECTION），则必须在获取锁之前调用 <xref:System.Threading.Thread.BeginThreadAffinity%2A>，并在释放锁后 <xref:System.Threading.Thread.EndThreadAffinity%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-425">For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <xref:System.Threading.Thread.BeginThreadAffinity%2A> before acquiring the lock, and <xref:System.Threading.Thread.EndThreadAffinity%2A> after releasing the lock.</span></span>  
  
 <span data-ttu-id="ae431-426">如果在 SQL Server 2005 下运行的代码中使用此方法，则需要在最高的主机保护级别上运行代码。</span><span class="sxs-lookup"><span data-stu-id="ae431-426">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-427">下面的示例演示如何使用 <xref:System.Threading.Thread.BeginThreadAffinity%2A> 和 <xref:System.Threading.Thread.EndThreadAffinity%2A> 方法，通知主机代码块取决于物理操作系统线程的标识。</span><span class="sxs-lookup"><span data-stu-id="ae431-427">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="ae431-428">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="ae431-428">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ae431-429">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="ae431-429">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="ae431-430">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="ae431-430">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContext : System.Runtime.Remoting.Contexts.Context" Usage="System.Threading.Thread.CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ae431-431">获取线程正在其中执行的当前上下文。</span><span class="sxs-lookup"><span data-stu-id="ae431-431">Gets the current context in which the thread is executing.</span></span></summary>
        <value><span data-ttu-id="ae431-432">表示当前线程上下文的 <see cref="T:System.Runtime.Remoting.Contexts.Context" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-432">A <see cref="T:System.Runtime.Remoting.Contexts.Context" /> representing the current thread context.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="ae431-433">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="ae431-433">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ae431-434">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="ae431-434">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="ae431-435">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="ae431-435">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ae431-436">获取或设置当前线程的区域性。</span><span class="sxs-lookup"><span data-stu-id="ae431-436">Gets or sets the culture for the current thread.</span></span></summary>
        <value><span data-ttu-id="ae431-437">表示当前线程的区域性的对象。</span><span class="sxs-lookup"><span data-stu-id="ae431-437">An object that represents the culture for the current thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-438">此属性返回的 <xref:System.Globalization.CultureInfo> 对象及其关联的对象，确定日期、时间、数字、货币值、文本的排序顺序、大小写约定和字符串比较的默认格式。</span><span class="sxs-lookup"><span data-stu-id="ae431-438">The <xref:System.Globalization.CultureInfo> object that is returned by this property, together with its associated objects, determine the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons.</span></span> <span data-ttu-id="ae431-439">请参阅 <xref:System.Globalization.CultureInfo> 类，了解区域性名称和标识符、固定、非特定区域性和特定区域性之间的差异，以及区域性信息影响线程和应用程序域的方式。</span><span class="sxs-lookup"><span data-stu-id="ae431-439">See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</span></span> <span data-ttu-id="ae431-440">请参阅 <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> 属性，了解如何确定如何确定线程的默认区域性，以及用户如何为其计算机设置区域性信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-440">See the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property to learn how a thread's default culture is determined, and how users set culture information for their computers.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="ae431-441">与当前线程以外的任何线程一起使用时，<xref:System.Threading.Thread.CurrentCulture> 属性不能可靠地工作。</span><span class="sxs-lookup"><span data-stu-id="ae431-441">The <xref:System.Threading.Thread.CurrentCulture> property doesn't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="ae431-442">在 .NET Framework 中，读取属性是可靠的，但对于除当前线程之外的其他线程，其设置是可靠的。</span><span class="sxs-lookup"><span data-stu-id="ae431-442">In .NET Framework, reading the property is reliable, although setting it for a thread other than the current thread is not.</span></span> <span data-ttu-id="ae431-443">在 .NET Core 中，如果某个线程尝试在另一个线程上读取或写入 <xref:System.Threading.Thread.CurrentCulture> 属性，则会引发 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="ae431-443">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write the <xref:System.Threading.Thread.CurrentCulture> property on a different thread.</span></span>
> <span data-ttu-id="ae431-444">建议使用 <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> 属性检索和设置当前区域性。</span><span class="sxs-lookup"><span data-stu-id="ae431-444">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> property to retrieve and set the current culture.</span></span>

 <span data-ttu-id="ae431-445">从 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]开始，可以将 <xref:System.Threading.Thread.CurrentCulture%2A> 属性设置为非特定区域性。</span><span class="sxs-lookup"><span data-stu-id="ae431-445">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], you can set the <xref:System.Threading.Thread.CurrentCulture%2A> property to a neutral culture.</span></span> <span data-ttu-id="ae431-446">这是因为 <xref:System.Globalization.CultureInfo> 类的行为已更改：当它表示非特定区域性时，其属性值（特别是 <xref:System.Globalization.CultureInfo.Calendar%2A>、<xref:System.Globalization.CultureInfo.CompareInfo%2A>、<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>、<xref:System.Globalization.CultureInfo.NumberFormat%2A>和 <xref:System.Globalization.CultureInfo.TextInfo%2A> 属性）现在反映与非特定区域性关联的特定区域性。</span><span class="sxs-lookup"><span data-stu-id="ae431-446">This is because the behavior of the <xref:System.Globalization.CultureInfo> class has changed: When it represents a neutral culture, its property values (in particular, the <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, and <xref:System.Globalization.CultureInfo.TextInfo%2A> properties) now reflect the specific culture that is associated with the neutral culture.</span></span> <span data-ttu-id="ae431-447">在 .NET Framework 的早期版本中，在分配非特定区域性时，<xref:System.Threading.Thread.CurrentCulture%2A> 属性将引发 <xref:System.NotSupportedException> 异常。</span><span class="sxs-lookup"><span data-stu-id="ae431-447">In earlier versions of the .NET Framework, the <xref:System.Threading.Thread.CurrentCulture%2A> property threw a <xref:System.NotSupportedException> exception when a neutral culture was assigned.</span></span>  
  
## Examples  
 <span data-ttu-id="ae431-448">下面的示例演示了线程语句，该语句允许 Windows 窗体应用程序的用户界面显示在控制面板中设置的区域性。</span><span class="sxs-lookup"><span data-stu-id="ae431-448">The following example shows the threading statement that allows the user interface of a Windows Forms application to display in the culture that is set in Control Panel.</span></span> <span data-ttu-id="ae431-449">需要其他代码。</span><span class="sxs-lookup"><span data-stu-id="ae431-449">Additional code is needed.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ae431-450">属性设置为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-450">The property is set to <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ae431-451">仅限 .NET Core：不支持从一个线程读取或写入另一个线程的区域性。</span><span class="sxs-lookup"><span data-stu-id="ae431-451">.NET Core only: Reading or writing the culture of a thread from another thread is not supported.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ae431-452">用于设置属性。</span><span class="sxs-lookup"><span data-stu-id="ae431-452">for setting the property.</span></span> <span data-ttu-id="ae431-453">关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="ae431-453">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPrincipal : System.Security.Principal.IPrincipal with get, set" Usage="System.Threading.Thread.CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ae431-454">获取或设置线程的当前负责人（对基于角色的安全性而言）。</span><span class="sxs-lookup"><span data-stu-id="ae431-454">Gets or sets the thread's current principal (for role-based security).</span></span></summary>
        <value><span data-ttu-id="ae431-455">表示安全上下文的 <see cref="T:System.Security.Principal.IPrincipal" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ae431-455">An <see cref="T:System.Security.Principal.IPrincipal" /> value representing the security context.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ae431-456">下面的代码示例演示如何设置和检索线程的主体。</span><span class="sxs-lookup"><span data-stu-id="ae431-456">The following code example shows how to set and retrieve the principal of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="ae431-457">调用方没有设置该主体所需的权限。</span><span class="sxs-lookup"><span data-stu-id="ae431-457">The caller does not have the permission required to set the principal.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ae431-458">操作主体对象。</span><span class="sxs-lookup"><span data-stu-id="ae431-458">to manipulate the principal object.</span></span> <span data-ttu-id="ae431-459">关联的枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-459">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentThread : System.Threading.Thread" Usage="System.Threading.Thread.CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ae431-460">获取当前正在运行的线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-460">Gets the currently running thread.</span></span></summary>
        <value><span data-ttu-id="ae431-461"><see cref="T:System.Threading.Thread" />，表示当前正在运行的线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-461">A <see cref="T:System.Threading.Thread" /> that is the representation of the currently running thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ae431-462">下面的示例创建一个任务，该任务又创建了20个子任务。</span><span class="sxs-lookup"><span data-stu-id="ae431-462">The following example creates a task that in turn creates 20 child tasks.</span></span> <span data-ttu-id="ae431-463">应用程序本身和每个任务都会调用 `ShowThreadInformation` 方法，该方法使用 <xref:System.Threading.Thread.CurrentThread%2A> 属性显示有关运行它的线程的信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-463">The application itself, as well as each task, calls the `ShowThreadInformation` method, which uses the <xref:System.Threading.Thread.CurrentThread%2A> property  to display information about the thread on which it is running.</span></span>  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 <span data-ttu-id="ae431-464">每个子任务在1到1000000之间生成1000000的随机数，并返回其平均值。</span><span class="sxs-lookup"><span data-stu-id="ae431-464">Each child task generates 1 million random numbers between 1 and 1 million and returns their mean.</span></span> <span data-ttu-id="ae431-465">父任务调用 <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> 方法，以确保子任务在显示每个任务返回的平均值之前完成，并计算平均值。</span><span class="sxs-lookup"><span data-stu-id="ae431-465">The parent task calls the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means.</span></span>  
  
 <span data-ttu-id="ae431-466">请注意，应用程序在前台线程上运行时，每个任务都在线程池线程上运行。</span><span class="sxs-lookup"><span data-stu-id="ae431-466">Note that while the application runs on a foreground thread, each task runs on a thread pool thread.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentUICulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ae431-467">获取或设置资源管理器使用的当前区域性以便在运行时查找区域性特定的资源。</span><span class="sxs-lookup"><span data-stu-id="ae431-467">Gets or sets the current culture used by the Resource Manager to look up culture-specific resources at run time.</span></span></summary>
        <value><span data-ttu-id="ae431-468">表示当前区域性的对象。</span><span class="sxs-lookup"><span data-stu-id="ae431-468">An object that represents the current culture.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-469">UI 区域性指定应用程序支持用户输入和输出所需的资源，默认情况下，它与操作系统区域性相同。</span><span class="sxs-lookup"><span data-stu-id="ae431-469">The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture.</span></span> <span data-ttu-id="ae431-470">请参阅 <xref:System.Globalization.CultureInfo> 类，了解区域性名称和标识符、固定、非特定区域性和特定区域性之间的差异，以及区域性信息影响线程和应用程序域的方式。</span><span class="sxs-lookup"><span data-stu-id="ae431-470">See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</span></span> <span data-ttu-id="ae431-471">请参阅 <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> 属性，了解如何确定线程的默认 UI 区域性。</span><span class="sxs-lookup"><span data-stu-id="ae431-471">See the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> property to learn how a thread's default UI culture is determined.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="ae431-472">与当前线程以外的任何线程一起使用时，<xref:System.Threading.Thread.CurrentUICulture> 属性不能可靠地工作。</span><span class="sxs-lookup"><span data-stu-id="ae431-472">The <xref:System.Threading.Thread.CurrentUICulture> property doesn't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="ae431-473">在 .NET Framework 中，读取属性是可靠的，但对于除当前线程之外的其他线程，其设置是可靠的。</span><span class="sxs-lookup"><span data-stu-id="ae431-473">In .NET Framework, reading the property is reliable, although setting it for a thread other than the current thread is not.</span></span> <span data-ttu-id="ae431-474">在 .NET Core 中，如果某个线程尝试在另一个线程上读取或写入 <xref:System.Threading.Thread.CurrentUICulture> 属性，则会引发 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="ae431-474">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write the <xref:System.Threading.Thread.CurrentUICulture> property on a different thread.</span></span>
> <span data-ttu-id="ae431-475">建议使用 <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> 属性检索和设置当前区域性。</span><span class="sxs-lookup"><span data-stu-id="ae431-475">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> property to retrieve and set the current culture.</span></span>

 <span data-ttu-id="ae431-476">此属性返回的 <xref:System.Globalization.CultureInfo> 可以是非特定区域性。</span><span class="sxs-lookup"><span data-stu-id="ae431-476">The <xref:System.Globalization.CultureInfo> returned by this property can be a neutral culture.</span></span> <span data-ttu-id="ae431-477">非特定区域性不应与格式设置方法一起使用，例如 <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>、<xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>和 <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ae431-477">Neutral cultures should not be used with formatting methods such as <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, and <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ae431-478">使用 <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> 方法可获取特定区域性，或使用 <xref:System.Threading.Thread.CurrentCulture%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="ae431-478">Use the <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> method to get a specific culture, or use the <xref:System.Threading.Thread.CurrentCulture%2A> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-479"><xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> 方法将引发非特定区域性 "zh-chs-Zh-hant" （"zh-chs-CHT"）和 "zh-chs-Hans" （"zh-chs"）的 <xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="ae431-479">The <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> method throws <xref:System.ArgumentException> for the neutral cultures "zh-Hant" ("zh-CHT") and "zh-Hans" ("zh-CHS").</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-480">下面的示例确定当前线程的 UI 区域性的语言是否为法语。</span><span class="sxs-lookup"><span data-stu-id="ae431-480">The following example determines whether the language of the current thread's UI culture is French.</span></span> <span data-ttu-id="ae431-481">如果不是，则将当前线程的 UI 区域性设置为 "英语（美国）"。</span><span class="sxs-lookup"><span data-stu-id="ae431-481">If it is not, it sets the UI culture of the current thread to English (United States).</span></span>  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 <span data-ttu-id="ae431-482">下面的代码示例演示了一个线程语句，该语句允许 Windows 窗体的用户界面显示在 "控制面板" 中设置的区域性。</span><span class="sxs-lookup"><span data-stu-id="ae431-482">The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel.</span></span> <span data-ttu-id="ae431-483">需要其他代码。</span><span class="sxs-lookup"><span data-stu-id="ae431-483">Additional code is needed.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ae431-484">属性设置为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-484">The property is set to <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ae431-485">该属性设置为不能用于定位资源文件的区域性名称。</span><span class="sxs-lookup"><span data-stu-id="ae431-485">The property is set to a culture name that cannot be used to locate a resource file.</span></span> <span data-ttu-id="ae431-486">资源文件名必须仅包含字母、数字、连字符或下划线。</span><span class="sxs-lookup"><span data-stu-id="ae431-486">Resource filenames must include only letters, numbers, hyphens or underscores.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ae431-487">仅限 .NET Core：不支持从一个线程读取或写入另一个线程的区域性。</span><span class="sxs-lookup"><span data-stu-id="ae431-487">.NET Core only: Reading or writing the culture of a thread from another thread is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberSignature Language="F#" Value="member this.DisableComObjectEagerCleanup : unit -&gt; unit" Usage="thread.DisableComObjectEagerCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ae431-488">对于当前线程关闭运行时可调用包装 (RCW) 的自动清理。</span><span class="sxs-lookup"><span data-stu-id="ae431-488">Turns off automatic cleanup of runtime callable wrappers (RCW) for the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-489">默认情况下，公共语言运行时（CLR）会自动清理运行时可调用包装器。</span><span class="sxs-lookup"><span data-stu-id="ae431-489">By default, the common language runtime (CLR) cleans up runtime callable wrappers automatically.</span></span> <span data-ttu-id="ae431-490">CLR 在清理过程中抽取消息，这可能会导致几个满足以下异常条件的应用程序的重入问题：</span><span class="sxs-lookup"><span data-stu-id="ae431-490">The CLR pumps messages during the cleanup, which might cause reentrancy problems for a few applications that meet the following unusual criteria:</span></span>  
  
-   <span data-ttu-id="ae431-491">应用程序执行其自身的消息泵。</span><span class="sxs-lookup"><span data-stu-id="ae431-491">The application does its own message pumping.</span></span>  
  
-   <span data-ttu-id="ae431-492">当发生消息泵时，应用程序需要精确地进行控制。</span><span class="sxs-lookup"><span data-stu-id="ae431-492">The application needs to control precisely when message pumping occurs.</span></span>  
  
 <span data-ttu-id="ae431-493">此类应用程序可使用 <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> 方法来防止 CLR 自动回收运行时可调用包装器。</span><span class="sxs-lookup"><span data-stu-id="ae431-493">Such applications can use the <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> method to prevent the CLR from doing automatic reclamation of runtime callable wrappers.</span></span>  
  
 <span data-ttu-id="ae431-494">在线程上调用此方法时，不能为该线程重新启用自动清除。</span><span class="sxs-lookup"><span data-stu-id="ae431-494">When this method has been called on a thread, automatic cleanup cannot be re-enabled for that thread.</span></span> <span data-ttu-id="ae431-495">当应用程序准备好清理运行时可调用包装时，请使用 <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> 方法指示运行时清理当前上下文中的所有运行时可调用包装器。</span><span class="sxs-lookup"><span data-stu-id="ae431-495">When your application is ready to clean up runtime callable wrappers, use the <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> method to instruct the runtime to clean up all runtime callable wrappers in the current context.</span></span> <span data-ttu-id="ae431-496">当方法执行时，将发生消息泵。</span><span class="sxs-lookup"><span data-stu-id="ae431-496">Message pumping occurs while the method executes.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ae431-497">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="ae431-497">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="ae431-498">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="ae431-498">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member EndCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.EndCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ae431-499">通知宿主执行将要进入一个代码区域，在该代码区域内线程中止或未经处理异常的影响限于当前任务。</span><span class="sxs-lookup"><span data-stu-id="ae431-499">Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-500">公共语言运行时（CLR）的宿主（如 Microsoft SQL Server 2005）可为代码的关键和非关键区域中的故障建立不同的策略。</span><span class="sxs-lookup"><span data-stu-id="ae431-500">Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</span></span> <span data-ttu-id="ae431-501">关键区域是指线程中止或未经处理的异常的影响可能不会限制为当前任务。</span><span class="sxs-lookup"><span data-stu-id="ae431-501">A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</span></span> <span data-ttu-id="ae431-502">相反，非关键代码区域中的中止或失败只会影响发生错误的任务。</span><span class="sxs-lookup"><span data-stu-id="ae431-502">By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</span></span>  
  
 <span data-ttu-id="ae431-503">例如，假设某个任务在持有锁时尝试分配内存。</span><span class="sxs-lookup"><span data-stu-id="ae431-503">For example, consider a task that attempts to allocate memory while holding a lock.</span></span> <span data-ttu-id="ae431-504">如果内存分配失败，则中止当前任务不足以确保 <xref:System.AppDomain>的稳定性，因为域中的其他任务可能会等待相同的锁。</span><span class="sxs-lookup"><span data-stu-id="ae431-504">If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <xref:System.AppDomain>, because there can be other tasks in the domain waiting for the same lock.</span></span> <span data-ttu-id="ae431-505">如果当前任务已终止，则其他任务可能会死锁。</span><span class="sxs-lookup"><span data-stu-id="ae431-505">If the current task is terminated, other tasks could be deadlocked.</span></span>  
  
 <span data-ttu-id="ae431-506">当关键区域发生故障时，主机可能决定卸载整个 <xref:System.AppDomain> 而不是在可能不稳定的状态下继续执行的风险。</span><span class="sxs-lookup"><span data-stu-id="ae431-506">When a failure occurs in a critical region, the host might decide to unload the entire <xref:System.AppDomain> rather than take the risk of continuing execution in a potentially unstable state.</span></span> <span data-ttu-id="ae431-507">若要通知主机您的代码正在进入关键区域，请调用 <xref:System.Threading.Thread.BeginCriticalRegion%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-507">To inform the host that your code is entering a critical region, call <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span></span> <span data-ttu-id="ae431-508">当执行返回到非关键代码区域时调用 <xref:System.Threading.Thread.EndCriticalRegion%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-508">Call <xref:System.Threading.Thread.EndCriticalRegion%2A> when execution returns to a non-critical region of code.</span></span>  
  
 <span data-ttu-id="ae431-509">如果在 SQL Server 2005 下运行的代码中使用此方法，则需要在最高的主机保护级别上运行代码。</span><span class="sxs-lookup"><span data-stu-id="ae431-509">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-510">下面的示例演示如何使用 <xref:System.Threading.Thread.BeginCriticalRegion%2A> 和 <xref:System.Threading.Thread.EndCriticalRegion%2A> 方法将代码块分为关键区域和非关键区域。</span><span class="sxs-lookup"><span data-stu-id="ae431-510">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member EndThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.EndThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ae431-511">通知主机托管代码已执行完依赖于当前物理操作系统线程的标识的指令。</span><span class="sxs-lookup"><span data-stu-id="ae431-511">Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-512">公共语言运行时的某些宿主（如 Microsoft SQL Server 2005）提供其自己的线程管理。</span><span class="sxs-lookup"><span data-stu-id="ae431-512">Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</span></span> <span data-ttu-id="ae431-513">提供其自己的线程管理的主机可随时将正在执行的任务从一个物理操作系统线程移至另一个线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-513">A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</span></span> <span data-ttu-id="ae431-514">大多数任务不受此切换的影响。</span><span class="sxs-lookup"><span data-stu-id="ae431-514">Most tasks are not affected by this switching.</span></span> <span data-ttu-id="ae431-515">但是，某些任务具有线程关联，即它们依赖于物理操作系统线程的标识。</span><span class="sxs-lookup"><span data-stu-id="ae431-515">However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</span></span> <span data-ttu-id="ae431-516">这些任务在执行不应切换的代码时必须通知宿主。</span><span class="sxs-lookup"><span data-stu-id="ae431-516">These tasks must inform the host when they execute code that should not be switched.</span></span>  
  
 <span data-ttu-id="ae431-517">例如，如果应用程序调用系统 API 来获取具有线程关联的操作系统锁（如 Win32 CRITICAL_SECTION），则必须在获取锁之前调用 <xref:System.Threading.Thread.BeginThreadAffinity%2A>，并在释放锁后 <xref:System.Threading.Thread.EndThreadAffinity%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-517">For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <xref:System.Threading.Thread.BeginThreadAffinity%2A> before acquiring the lock, and <xref:System.Threading.Thread.EndThreadAffinity%2A> after releasing the lock.</span></span>  
  
 <span data-ttu-id="ae431-518">如果在 SQL Server 2005 下运行的代码中使用此方法，则需要在最高的主机保护级别上运行代码。</span><span class="sxs-lookup"><span data-stu-id="ae431-518">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-519">下面的示例演示如何使用 <xref:System.Threading.Thread.BeginThreadAffinity%2A> 和 <xref:System.Threading.Thread.EndThreadAffinity%2A> 方法，通知主机代码块取决于物理操作系统线程的标识。</span><span class="sxs-lookup"><span data-stu-id="ae431-519">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="ae431-520">调用方没有所要求的权限。</span><span class="sxs-lookup"><span data-stu-id="ae431-520">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ae431-521">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="ae431-521">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="ae431-522">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="ae431-522">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutionContext : System.Threading.ExecutionContext" Usage="System.Threading.Thread.ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ae431-523">获取 <see cref="T:System.Threading.ExecutionContext" /> 对象，该对象包含有关当前线程的各种上下文的信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-523">Gets an <see cref="T:System.Threading.ExecutionContext" /> object that contains information about the various contexts of the current thread.</span></span></summary>
        <value><span data-ttu-id="ae431-524">一个 <see cref="T:System.Threading.ExecutionContext" /> 对象，包含当前线程的上下文信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-524">An <see cref="T:System.Threading.ExecutionContext" /> object that consolidates context information for the current thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-525"><xref:System.Threading.ExecutionContext> 类为与执行的逻辑线程相关的所有信息提供单个容器。</span><span class="sxs-lookup"><span data-stu-id="ae431-525">The <xref:System.Threading.ExecutionContext> class provides a single container for all information relevant to a logical thread of execution.</span></span> <span data-ttu-id="ae431-526">这包括安全上下文、调用上下文、同步上下文、本地化上下文和事务上下文。</span><span class="sxs-lookup"><span data-stu-id="ae431-526">This includes security context, call context, synchronization context, localization context, and transaction context.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="thread.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ae431-527">确保垃圾回收器回收 <see cref="T:System.Threading.Thread" /> 对象时释放资源并执行其他清理操作。</span><span class="sxs-lookup"><span data-stu-id="ae431-527">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see cref="T:System.Threading.Thread" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-528">当当前对象准备好完成时，垃圾回收器将调用 <xref:System.Threading.Thread.Finalize%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-528">The garbage collector calls <xref:System.Threading.Thread.Finalize%2A> when the current object is ready to be finalized.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member FreeNamedDataSlot : string -&gt; unit" Usage="System.Threading.Thread.FreeNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="ae431-529">要释放的数据槽的名称。</span><span class="sxs-lookup"><span data-stu-id="ae431-529">The name of the data slot to be freed.</span></span></param>
        <summary><span data-ttu-id="ae431-530">为进程中的所有线程消除名称与槽之间的关联。</span><span class="sxs-lookup"><span data-stu-id="ae431-530">Eliminates the association between a name and a slot, for all threads in the process.</span></span> <span data-ttu-id="ae431-531">为了获得更好的性能，请改用以 <see cref="T:System.ThreadStaticAttribute" /> 特性标记的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-531">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="ae431-532">.NET Framework 提供了两种使用线程本地存储（TLS）的机制：线程相关的静态字段（即使用 <xref:System.ThreadStaticAttribute> 属性标记的字段）和数据槽。</span><span class="sxs-lookup"><span data-stu-id="ae431-532">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="ae431-533">线程相对静态字段比数据槽提供更好的性能，并启用编译时类型检查。</span><span class="sxs-lookup"><span data-stu-id="ae431-533">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="ae431-534">有关使用 TLS 的详细信息，请参阅[线程本地存储：线程相对静态字段和数据槽](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。</span><span class="sxs-lookup"><span data-stu-id="ae431-534">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="ae431-535">`FreeNamedDataSlot`任何线程调用后，调用同名 <xref:System.Threading.Thread.GetNamedDataSlot%2A> 的任何其他线程都将分配一个与该名称关联的新槽。</span><span class="sxs-lookup"><span data-stu-id="ae431-535">After any thread calls `FreeNamedDataSlot`, any other thread that calls <xref:System.Threading.Thread.GetNamedDataSlot%2A> with the same name will allocate a new slot associated with the name.</span></span> <span data-ttu-id="ae431-536">对任何线程 `GetNamedDataSlot` 的后续调用将返回新槽。</span><span class="sxs-lookup"><span data-stu-id="ae431-536">Subsequent calls to `GetNamedDataSlot` by any thread will return the new slot.</span></span> <span data-ttu-id="ae431-537">但是，对 `GetNamedDataSlot` 的先前调用返回的任何 <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> 都可以继续使用旧槽。</span><span class="sxs-lookup"><span data-stu-id="ae431-537">However, any thread that still has a <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> returned by an earlier call to `GetNamedDataSlot` can continue to use the old slot.</span></span>  
  
 <span data-ttu-id="ae431-538">只有在调用 `FreeNamedDataSlot` 之前获得的每个 `LocalDataStoreSlot` 都已释放并进行了垃圾回收后，才会释放已与某个名称关联的槽。</span><span class="sxs-lookup"><span data-stu-id="ae431-538">A slot that has been associated with a name is released only when every `LocalDataStoreSlot` that was obtained prior to the call to `FreeNamedDataSlot` has been released and garbage-collected.</span></span>  
  
 <span data-ttu-id="ae431-539">线程使用本地存储内存机制来存储线程特定的数据。</span><span class="sxs-lookup"><span data-stu-id="ae431-539">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="ae431-540">公共语言运行时在创建每个进程时将多槽数据存储数组分配给它。</span><span class="sxs-lookup"><span data-stu-id="ae431-540">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="ae431-541">线程可以在数据存储中分配数据槽，在槽中存储和检索数据值，并在线程过期后释放槽以供重新使用。</span><span class="sxs-lookup"><span data-stu-id="ae431-541">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="ae431-542">数据槽对于每个线程都是唯一的。</span><span class="sxs-lookup"><span data-stu-id="ae431-542">Data slots are unique per thread.</span></span> <span data-ttu-id="ae431-543">任何其他线程（甚至不是子线程）都无法获取该数据。</span><span class="sxs-lookup"><span data-stu-id="ae431-543">No other thread (not even a child thread) can get that data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-544">本部分包含两个代码示例。</span><span class="sxs-lookup"><span data-stu-id="ae431-544">This section contains two code examples.</span></span> <span data-ttu-id="ae431-545">第一个示例演示如何使用标记有 <xref:System.ThreadStaticAttribute> 特性的字段来保存特定于线程的信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-545">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="ae431-546">第二个示例演示如何使用数据槽来执行相同的操作。</span><span class="sxs-lookup"><span data-stu-id="ae431-546">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="ae431-547">**第一个示例**</span><span class="sxs-lookup"><span data-stu-id="ae431-547">**First Example**</span></span>  
  
 <span data-ttu-id="ae431-548">下面的示例演示如何使用标记有 <xref:System.ThreadStaticAttribute> 的字段来保存特定于线程的信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-548">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="ae431-549">与第二个示例中所示的方法相比，此方法提供的性能更好。</span><span class="sxs-lookup"><span data-stu-id="ae431-549">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="ae431-550">**第二个示例**</span><span class="sxs-lookup"><span data-stu-id="ae431-550">**Second Example**</span></span>  
  
 <span data-ttu-id="ae431-551">下面的示例演示如何使用命名数据槽来存储特定于线程的信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-551">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="ae431-552">线程与线程处理</span><span class="sxs-lookup"><span data-stu-id="ae431-552">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="ae431-553">线程本地存储区：线程相关的静态字段和数据槽</span><span class="sxs-lookup"><span data-stu-id="ae431-553">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberSignature Language="F#" Value="member this.GetApartmentState : unit -&gt; System.Threading.ApartmentState" Usage="thread.GetApartmentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ae431-554">返回表示单元状态的 <see cref="T:System.Threading.ApartmentState" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ae431-554">Returns an <see cref="T:System.Threading.ApartmentState" /> value indicating the apartment state.</span></span></summary>
        <returns><span data-ttu-id="ae431-555">其中一个表示托管线程的单元状态的 <see cref="T:System.Threading.ApartmentState" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ae431-555">One of the <see cref="T:System.Threading.ApartmentState" /> values indicating the apartment state of the managed thread.</span></span> <span data-ttu-id="ae431-556">默认为 <see cref="F:System.Threading.ApartmentState.Unknown" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-556">The default is <see cref="F:System.Threading.ApartmentState.Unknown" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-557">此方法连同 <xref:System.Threading.Thread.SetApartmentState%2A> 方法和 <xref:System.Threading.Thread.TrySetApartmentState%2A> 方法替换 <xref:System.Threading.Thread.ApartmentState%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="ae431-557">This method, along with the <xref:System.Threading.Thread.SetApartmentState%2A> method and the <xref:System.Threading.Thread.TrySetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-558">下面的代码示例演示 <xref:System.Threading.Thread.GetApartmentState%2A>、<xref:System.Threading.Thread.SetApartmentState%2A>和 <xref:System.Threading.Thread.TrySetApartmentState%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-558">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="ae431-559">此代码示例创建一个线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-559">The code example creates a thread.</span></span> <span data-ttu-id="ae431-560">启动线程之前，<xref:System.Threading.Thread.GetApartmentState%2A> 显示初始 <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> 状态，<xref:System.Threading.Thread.SetApartmentState%2A> 将状态更改为 <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ae431-560">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ae431-561">当尝试将状态更改为 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> 时，<xref:System.Threading.Thread.TrySetApartmentState%2A> 方法返回 `false`，因为已设置了单元状态。</span><span class="sxs-lookup"><span data-stu-id="ae431-561">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="ae431-562">如果已尝试 <xref:System.Threading.Thread.SetApartmentState%2A>相同的操作，则会引发 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="ae431-562">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="ae431-563">线程启动后，将再次使用 <xref:System.Threading.Thread.TrySetApartmentState%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-563">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="ae431-564">这次会引发 <xref:System.Threading.ThreadStateException>，因为该线程已启动。</span><span class="sxs-lookup"><span data-stu-id="ae431-564">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberSignature Language="F#" Value="member this.GetCompressedStack : unit -&gt; System.Threading.CompressedStack" Usage="thread.GetCompressedStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ae431-565">返回 <see cref="T:System.Threading.CompressedStack" /> 对象，此对象可用于获取当前线程的堆栈。</span><span class="sxs-lookup"><span data-stu-id="ae431-565">Returns a <see cref="T:System.Threading.CompressedStack" /> object that can be used to capture the stack for the current thread.</span></span></summary>
        <returns><span data-ttu-id="ae431-566">无。</span><span class="sxs-lookup"><span data-stu-id="ae431-566">None.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-567">不再支持此方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-567">This method is no longer supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ae431-568">在所有情况下。</span><span class="sxs-lookup"><span data-stu-id="ae431-568">In all cases.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ae431-569">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="ae431-569">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="ae431-570">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="ae431-570">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcessorId : unit -&gt; int" Usage="System.Threading.Thread.GetCurrentProcessorId " FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ae431-571">获取用于指示当前线程正在哪个处理器上执行的 ID。</span><span class="sxs-lookup"><span data-stu-id="ae431-571">Gets an ID used to indicate on which processor the current thread is executing.</span></span></summary>
        <returns><span data-ttu-id="ae431-572">表示缓存的处理器 ID 的整数。</span><span class="sxs-lookup"><span data-stu-id="ae431-572">An integer representing the cached processor ID.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="ae431-573">此值将被缓存并定期刷新。</span><span class="sxs-lookup"><span data-stu-id="ae431-573">This value is cached and periodically refreshed.</span></span> <span data-ttu-id="ae431-574">它在使用时可能已过时：使用代码不得依赖于其正确性。</span><span class="sxs-lookup"><span data-stu-id="ae431-574">It may be stale by the time it's used: consuming code must not rely on its accuracy for correctness.</span></span>

<span data-ttu-id="ae431-575">此值不一定是从零开始的处理器号。</span><span class="sxs-lookup"><span data-stu-id="ae431-575">The value is not guaranteed to be a zero-based processor number.</span></span>

           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberSignature Language="F#" Value="static member GetData : LocalDataStoreSlot -&gt; obj" Usage="System.Threading.Thread.GetData slot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="slot"><span data-ttu-id="ae431-576">要从其获取值的 <see cref="T:System.LocalDataStoreSlot" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-576">The <see cref="T:System.LocalDataStoreSlot" /> from which to get the value.</span></span></param>
        <summary><span data-ttu-id="ae431-577">在当前线程的当前域中从当前线程上指定的槽中检索值。</span><span class="sxs-lookup"><span data-stu-id="ae431-577">Retrieves the value from the specified slot on the current thread, within the current thread's current domain.</span></span> <span data-ttu-id="ae431-578">为了获得更好的性能，请改用以 <see cref="T:System.ThreadStaticAttribute" /> 特性标记的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-578">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="ae431-579">检索到的值。</span><span class="sxs-lookup"><span data-stu-id="ae431-579">The retrieved value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="ae431-580">.NET Framework 提供了两种使用线程本地存储（TLS）的机制：线程相关的静态字段（即使用 <xref:System.ThreadStaticAttribute> 属性标记的字段）和数据槽。</span><span class="sxs-lookup"><span data-stu-id="ae431-580">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="ae431-581">线程相对静态字段比数据槽提供更好的性能，并启用编译时类型检查。</span><span class="sxs-lookup"><span data-stu-id="ae431-581">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="ae431-582">有关使用 TLS 的详细信息，请参阅[线程本地存储：线程相对静态字段和数据槽](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。</span><span class="sxs-lookup"><span data-stu-id="ae431-582">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="ae431-583">线程使用本地存储内存机制来存储线程特定的数据。</span><span class="sxs-lookup"><span data-stu-id="ae431-583">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="ae431-584">公共语言运行时在创建每个进程时将多槽数据存储数组分配给它。</span><span class="sxs-lookup"><span data-stu-id="ae431-584">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="ae431-585">线程可以在数据存储中分配数据槽，在槽中存储和检索数据值，并在线程过期后释放槽以供重新使用。</span><span class="sxs-lookup"><span data-stu-id="ae431-585">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="ae431-586">数据槽对于每个线程都是唯一的。</span><span class="sxs-lookup"><span data-stu-id="ae431-586">Data slots are unique per thread.</span></span> <span data-ttu-id="ae431-587">任何其他线程（甚至不是子线程）都无法获取该数据。</span><span class="sxs-lookup"><span data-stu-id="ae431-587">No other thread (not even a child thread) can get that data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-588"><xref:System.Threading.Thread.GetData%2A> 是始终应用于当前正在执行的线程的 `Shared` 方法，即使使用引用另一个线程的变量调用它也是如此。</span><span class="sxs-lookup"><span data-stu-id="ae431-588"><xref:System.Threading.Thread.GetData%2A> is a `Shared` method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</span></span> <span data-ttu-id="ae431-589">若要避免混淆，请在调用 `Shared` 方法时使用类名： `Dim test As Object = Thread.GetData(testSlot)`。</span><span class="sxs-lookup"><span data-stu-id="ae431-589">To avoid confusion, use the class name when calling `Shared` methods: `Dim test As Object = Thread.GetData(testSlot)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-590">本部分包含两个代码示例。</span><span class="sxs-lookup"><span data-stu-id="ae431-590">This section contains two code examples.</span></span> <span data-ttu-id="ae431-591">第一个示例演示如何使用标记有 <xref:System.ThreadStaticAttribute> 特性的字段来保存特定于线程的信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-591">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="ae431-592">第二个示例演示如何使用数据槽来执行相同的操作。</span><span class="sxs-lookup"><span data-stu-id="ae431-592">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="ae431-593">**第一个示例**</span><span class="sxs-lookup"><span data-stu-id="ae431-593">**First Example**</span></span>  
  
 <span data-ttu-id="ae431-594">下面的示例演示如何使用标记有 <xref:System.ThreadStaticAttribute> 的字段来保存特定于线程的信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-594">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="ae431-595">与第二个示例中所示的方法相比，此方法提供的性能更好。</span><span class="sxs-lookup"><span data-stu-id="ae431-595">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="ae431-596">**第二个示例**</span><span class="sxs-lookup"><span data-stu-id="ae431-596">**Second Example**</span></span>  
  
 <span data-ttu-id="ae431-597">下面的示例演示如何使用数据槽存储特定于线程的信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-597">The following example demonstrates how to use a data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="ae431-598">线程与线程处理</span><span class="sxs-lookup"><span data-stu-id="ae431-598">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="ae431-599">线程本地存储区：线程相关的静态字段和数据槽</span><span class="sxs-lookup"><span data-stu-id="ae431-599">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberSignature Language="F#" Value="static member GetDomain : unit -&gt; AppDomain" Usage="System.Threading.Thread.GetDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ae431-600">返回当前线程正在其中运行的当前域。</span><span class="sxs-lookup"><span data-stu-id="ae431-600">Returns the current domain in which the current thread is running.</span></span></summary>
        <returns><span data-ttu-id="ae431-601">表示正在运行的线程的当前应用程序域的 <see cref="T:System.AppDomain" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-601">An <see cref="T:System.AppDomain" /> representing the current application domain of the running thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ae431-602">下面的代码示例演示如何检索正在运行线程的 `AppDomain` 的名称和 ID。</span><span class="sxs-lookup"><span data-stu-id="ae431-602">The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberSignature Language="F#" Value="static member GetDomainID : unit -&gt; int" Usage="System.Threading.Thread.GetDomainID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ae431-603">返回唯一的应用程序域标识符。</span><span class="sxs-lookup"><span data-stu-id="ae431-603">Returns a unique application domain identifier.</span></span></summary>
        <returns><span data-ttu-id="ae431-604">唯一标识应用程序域的 32 位有符号整数。</span><span class="sxs-lookup"><span data-stu-id="ae431-604">A 32-bit signed integer uniquely identifying the application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ae431-605">下面的代码示例演示如何检索正在运行线程的 `AppDomain` 的名称和 ID。</span><span class="sxs-lookup"><span data-stu-id="ae431-605">The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="thread.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ae431-606">返回当前线程的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="ae431-606">Returns a hash code for the current thread.</span></span></summary>
        <returns><span data-ttu-id="ae431-607">整数哈希代码值。</span><span class="sxs-lookup"><span data-stu-id="ae431-607">An integer hash code value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-608">哈希代码不一定是唯一的。</span><span class="sxs-lookup"><span data-stu-id="ae431-608">The hash code is not guaranteed to be unique.</span></span> <span data-ttu-id="ae431-609">如果需要托管线程的唯一标识符，请使用 <xref:System.Threading.Thread.ManagedThreadId%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="ae431-609">Use the <xref:System.Threading.Thread.ManagedThreadId%2A> property if you need a unique identifier for a managed thread.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.GetNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="ae431-610">本地数据槽的名称。</span><span class="sxs-lookup"><span data-stu-id="ae431-610">The name of the local data slot.</span></span></param>
        <summary><span data-ttu-id="ae431-611">查找命名的数据槽。</span><span class="sxs-lookup"><span data-stu-id="ae431-611">Looks up a named data slot.</span></span> <span data-ttu-id="ae431-612">为了获得更好的性能，请改用以 <see cref="T:System.ThreadStaticAttribute" /> 特性标记的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-612">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="ae431-613">为此线程分配的 <see cref="T:System.LocalDataStoreSlot" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-613">A <see cref="T:System.LocalDataStoreSlot" /> allocated for this thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="ae431-614">.NET Framework 提供了两种使用线程本地存储（TLS）的机制：线程相关的静态字段（即使用 <xref:System.ThreadStaticAttribute> 属性标记的字段）和数据槽。</span><span class="sxs-lookup"><span data-stu-id="ae431-614">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="ae431-615">线程相对静态字段比数据槽提供更好的性能，并启用编译时类型检查。</span><span class="sxs-lookup"><span data-stu-id="ae431-615">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="ae431-616">有关使用 TLS 的详细信息，请参阅[线程本地存储：线程相对静态字段和数据槽](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。</span><span class="sxs-lookup"><span data-stu-id="ae431-616">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="ae431-617">线程使用本地存储内存机制来存储线程特定的数据。</span><span class="sxs-lookup"><span data-stu-id="ae431-617">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="ae431-618">公共语言运行时在创建每个进程时将多槽数据存储数组分配给它。</span><span class="sxs-lookup"><span data-stu-id="ae431-618">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="ae431-619">线程可以在数据存储中分配数据槽，在槽中存储和检索数据值，并在线程过期后释放槽以供重新使用。</span><span class="sxs-lookup"><span data-stu-id="ae431-619">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="ae431-620">数据槽对于每个线程都是唯一的。</span><span class="sxs-lookup"><span data-stu-id="ae431-620">Data slots are unique per thread.</span></span> <span data-ttu-id="ae431-621">任何其他线程（甚至不是子线程）都无法获取该数据。</span><span class="sxs-lookup"><span data-stu-id="ae431-621">No other thread (not even a child thread) can get that data.</span></span>  
  
 <span data-ttu-id="ae431-622">如果命名槽不存在，则分配一个新槽。</span><span class="sxs-lookup"><span data-stu-id="ae431-622">If the named slot does not exist, a new slot is allocated.</span></span> <span data-ttu-id="ae431-623">命名的数据槽是公共的，可供任何人操作。</span><span class="sxs-lookup"><span data-stu-id="ae431-623">Named data slots are public and can be manipulated by anyone.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-624">本部分包含两个代码示例。</span><span class="sxs-lookup"><span data-stu-id="ae431-624">This section contains two code examples.</span></span> <span data-ttu-id="ae431-625">第一个示例演示如何使用标记有 <xref:System.ThreadStaticAttribute> 特性的字段来保存特定于线程的信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-625">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="ae431-626">第二个示例演示如何使用数据槽来执行相同的操作。</span><span class="sxs-lookup"><span data-stu-id="ae431-626">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="ae431-627">**第一个示例**</span><span class="sxs-lookup"><span data-stu-id="ae431-627">**First Example**</span></span>  
  
 <span data-ttu-id="ae431-628">下面的示例演示如何使用标记有 <xref:System.ThreadStaticAttribute> 的字段来保存特定于线程的信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-628">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="ae431-629">与第二个示例中所示的方法相比，此方法提供的性能更好。</span><span class="sxs-lookup"><span data-stu-id="ae431-629">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="ae431-630">**第二个示例**</span><span class="sxs-lookup"><span data-stu-id="ae431-630">**Second Example**</span></span>  
  
 <span data-ttu-id="ae431-631">下面的示例演示如何使用命名数据槽来存储特定于线程的信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-631">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="ae431-632">线程与线程处理</span><span class="sxs-lookup"><span data-stu-id="ae431-632">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="ae431-633">线程本地存储区：线程相关的静态字段和数据槽</span><span class="sxs-lookup"><span data-stu-id="ae431-633">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberSignature Language="F#" Value="member this.Interrupt : unit -&gt; unit" Usage="thread.Interrupt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ae431-634">中断处于 <see cref="F:System.Threading.ThreadState.WaitSleepJoin" /> 线程状态的线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-634">Interrupts a thread that is in the <see cref="F:System.Threading.ThreadState.WaitSleepJoin" /> thread state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-635">如果此线程当前在等待、睡眠或联接状态下未被阻止，则它将在下一次开始阻止时中断。</span><span class="sxs-lookup"><span data-stu-id="ae431-635">If this thread is not currently blocked in a wait, sleep, or join state, it will be interrupted when it next begins to block.</span></span>  
  
 <span data-ttu-id="ae431-636"><xref:System.Threading.ThreadInterruptedException> 在中断的线程中引发，但在线程阻塞之前不会引发。</span><span class="sxs-lookup"><span data-stu-id="ae431-636"><xref:System.Threading.ThreadInterruptedException> is thrown in the interrupted thread, but not until the thread blocks.</span></span> <span data-ttu-id="ae431-637">如果线程永远不会阻塞，则永远不会引发异常，因此线程可能会在不中断的情况下完成。</span><span class="sxs-lookup"><span data-stu-id="ae431-637">If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-638">下面的代码示例演示正在运行的线程在中断后会被阻止的行为。</span><span class="sxs-lookup"><span data-stu-id="ae431-638">The following code example shows the behavior of a running thread when it is interrupted and subsequently gets blocked.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="ae431-639">调用方没有适当的 <see cref="T:System.Security.Permissions.SecurityPermission" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-639">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ae431-640">用于线程的高级操作。</span><span class="sxs-lookup"><span data-stu-id="ae431-640">for advanced operations on threads.</span></span> <span data-ttu-id="ae431-641">关联的枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-641">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadState" />
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md"><span data-ttu-id="ae431-642">暂停和中断线程</span><span class="sxs-lookup"><span data-stu-id="ae431-642">Pausing and interrupting threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAlive : bool" Usage="System.Threading.Thread.IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ae431-643">获取指示当前线程的执行状态的值。</span><span class="sxs-lookup"><span data-stu-id="ae431-643">Gets a value indicating the execution status of the current thread.</span></span></summary>
        <value><span data-ttu-id="ae431-644">如果此线程已启动并且尚未正常终止或中止，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-644"><see langword="true" /> if this thread has been started and has not terminated normally or aborted; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBackground : bool with get, set" Usage="System.Threading.Thread.IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ae431-645">获取或设置一个值，该值指示某个线程是否为后台线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-645">Gets or sets a value indicating whether or not a thread is a background thread.</span></span></summary>
        <value><span data-ttu-id="ae431-646">如果此线程为或将成为后台线程，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-646"><see langword="true" /> if this thread is or is to become a background thread; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-647">线程是后台线程或前台线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-647">A thread is either a background thread or a foreground thread.</span></span> <span data-ttu-id="ae431-648">后台线程与前台线程相同，不同之处在于后台线程不会阻止进程终止。</span><span class="sxs-lookup"><span data-stu-id="ae431-648">Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating.</span></span> <span data-ttu-id="ae431-649">属于某个进程的所有前台线程终止后，公共语言运行时将结束该进程。</span><span class="sxs-lookup"><span data-stu-id="ae431-649">Once all foreground threads belonging to a process have terminated, the common language runtime ends the process.</span></span> <span data-ttu-id="ae431-650">剩余的后台线程将停止，并且不会完成。</span><span class="sxs-lookup"><span data-stu-id="ae431-650">Any remaining background threads are stopped and do not complete.</span></span>  
  
 <span data-ttu-id="ae431-651">默认情况下，以下线程在前台执行（即，其 <xref:System.Threading.Thread.IsBackground%2A> 属性返回 `false`）：</span><span class="sxs-lookup"><span data-stu-id="ae431-651">By default, the following threads execute in the foreground (that is, their <xref:System.Threading.Thread.IsBackground%2A> property returns `false`):</span></span>  
  
-   <span data-ttu-id="ae431-652">主线程（或主应用程序线程）。</span><span class="sxs-lookup"><span data-stu-id="ae431-652">The primary thread (or main application thread).</span></span>  
  
-   <span data-ttu-id="ae431-653">通过调用 <xref:System.Threading.Thread> 类构造函数创建的所有线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-653">All threads created by calling a <xref:System.Threading.Thread> class constructor.</span></span>  
  
 <span data-ttu-id="ae431-654">默认情况下，以下线程在后台执行（也就是说，它们的 <xref:System.Threading.Thread.IsBackground%2A> 属性返回 `true`）：</span><span class="sxs-lookup"><span data-stu-id="ae431-654">By default, the following threads execute in the background  (that is, their <xref:System.Threading.Thread.IsBackground%2A> property returns `true`):</span></span>  
  
-   <span data-ttu-id="ae431-655">线程池线程，线程池是由运行时维护的工作线程池。</span><span class="sxs-lookup"><span data-stu-id="ae431-655">Thread pool threads, which are a pool of worker threads maintained by the runtime.</span></span> <span data-ttu-id="ae431-656">您可以使用 <xref:System.Threading.ThreadPool> 类配置线程池和计划线程池线程上的工作。</span><span class="sxs-lookup"><span data-stu-id="ae431-656">You can configure the thread pool and schedule work on thread pool threads by using the <xref:System.Threading.ThreadPool> class.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="ae431-657">基于任务的异步操作会在线程池线程上自动执行。</span><span class="sxs-lookup"><span data-stu-id="ae431-657">Task-based asynchronous operations automatically execute on thread pool threads.</span></span>  
  
-   <span data-ttu-id="ae431-658">从非托管代码进入托管执行环境的所有线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-658">All threads that enter the managed execution environment from unmanaged code.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-659">下面的示例对比了前台和后台线程的行为。</span><span class="sxs-lookup"><span data-stu-id="ae431-659">The following example contrasts the behavior of foreground and background threads.</span></span> <span data-ttu-id="ae431-660">它创建前台线程和后台线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-660">It creates a foreground thread and a background thread.</span></span> <span data-ttu-id="ae431-661">前台线程会使进程保持运行，直到完成其 `for` 循环，然后终止。</span><span class="sxs-lookup"><span data-stu-id="ae431-661">The foreground thread keeps the process running until completes its `for` loop and terminates.</span></span> <span data-ttu-id="ae431-662">但是，如示例的输出所示，由于前台线程已完成执行，因此进程在后台线程完成执行之前终止。</span><span class="sxs-lookup"><span data-stu-id="ae431-662">However, as the output from the example shows, because the foreground thread has finished execution, the process is terminated before the background thread has completed execution.</span></span>  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="ae431-663">线程终止。</span><span class="sxs-lookup"><span data-stu-id="ae431-663">The thread is dead.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/foreground-and-background-threads.md"><span data-ttu-id="ae431-664">前台和后台线程</span><span class="sxs-lookup"><span data-stu-id="ae431-664">Foreground and Background Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadPoolThread : bool" Usage="System.Threading.Thread.IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ae431-665">获取指示线程是否属于托管线程池的值。</span><span class="sxs-lookup"><span data-stu-id="ae431-665">Gets a value indicating whether or not a thread belongs to the managed thread pool.</span></span></summary>
        <value><span data-ttu-id="ae431-666">如果此线程属于托管线程池，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-666"><see langword="true" /> if this thread belongs to the managed thread pool; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-667">有关详细信息，请参阅[托管线程池](~/docs/standard/threading/the-managed-thread-pool.md)。</span><span class="sxs-lookup"><span data-stu-id="ae431-667">For more information see [The managed thread pool](~/docs/standard/threading/the-managed-thread-pool.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-668">下面的代码示例演示如何确定线程是否来自线程池。</span><span class="sxs-lookup"><span data-stu-id="ae431-668">The following code example shows how to determine whether a thread is from the thread pool.</span></span>  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="ae431-669">托管线程池</span><span class="sxs-lookup"><span data-stu-id="ae431-669">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ae431-670">在此实例表示的线程终止前，阻止调用线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-670">Blocks the calling thread until the thread represented by this instance terminates.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberSignature Language="F#" Value="member this.Join : unit -&gt; unit" Usage="thread.Join " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ae431-671">在继续执行标准的 COM 和 <see langword="SendMessage" /> 消息泵处理期间，阻止调用线程，直到由该实例表示的线程终止。</span><span class="sxs-lookup"><span data-stu-id="ae431-671">Blocks the calling thread until the thread represented by this instance terminates, while continuing to perform standard COM and <see langword="SendMessage" /> pumping.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-672"><xref:System.Threading.Thread.Join%2A> 是一种同步方法，用于阻止调用线程（即调用方法的线程），直到调用了 <xref:System.Threading.Thread.Join%2A> 方法的线程完成。</span><span class="sxs-lookup"><span data-stu-id="ae431-672"><xref:System.Threading.Thread.Join%2A> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed.</span></span> <span data-ttu-id="ae431-673">使用此方法可以确保线程已终止。</span><span class="sxs-lookup"><span data-stu-id="ae431-673">Use this method to ensure that a thread has been terminated.</span></span> <span data-ttu-id="ae431-674">如果线程未终止，调用方将无限期阻止。</span><span class="sxs-lookup"><span data-stu-id="ae431-674">The caller will block indefinitely if the thread does not terminate.</span></span> <span data-ttu-id="ae431-675">在下面的示例中，`Thread1` 线程调用 `Thread2`的 <xref:System.Threading.Thread.Join> 方法，这将导致 `Thread1` 在 `Thread2` 完成之前一直阻止。</span><span class="sxs-lookup"><span data-stu-id="ae431-675">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block until `Thread2` has completed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 <span data-ttu-id="ae431-676">如果在调用 <xref:System.Threading.Thread.Join%2A> 时线程已终止，则该方法将立即返回。</span><span class="sxs-lookup"><span data-stu-id="ae431-676">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="ae431-677">绝不应从当前线程调用表示当前线程的 <xref:System.Threading.Thread> 对象的 <xref:System.Threading.Thread.Join%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-677">You should never call the <xref:System.Threading.Thread.Join%2A> method of the <xref:System.Threading.Thread> object that represents the current thread from the current thread.</span></span> <span data-ttu-id="ae431-678">这会导致应用程序无响应，因为当前线程会无限期地等待，</span><span class="sxs-lookup"><span data-stu-id="ae431-678">This causes your app to become unresponsive because the current thread waits upon itself indefinitely,</span></span>  
  
 <span data-ttu-id="ae431-679">此方法更改调用线程的状态以包括 <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ae431-679">This method changes the state of the calling thread to include <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ae431-680">不能对处于 <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> 状态的线程调用 `Join`。</span><span class="sxs-lookup"><span data-stu-id="ae431-680">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="ae431-681">调用方尝试加入处于 <see cref="F:System.Threading.ThreadState.Unstarted" /> 状态的线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-681">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="ae431-682">线程在等待时中断。</span><span class="sxs-lookup"><span data-stu-id="ae431-682">The thread is interrupted while waiting.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Join : int -&gt; bool" Usage="thread.Join millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="ae431-683">等待线程终止的毫秒数。</span><span class="sxs-lookup"><span data-stu-id="ae431-683">The number of milliseconds to wait for the thread to terminate.</span></span></param>
        <summary><span data-ttu-id="ae431-684">在继续执行标准的 COM 和 SendMessage 消息泵处理期间，阻止调用线程，直到由该实例表示的线程终止或经过了指定时间为止。</span><span class="sxs-lookup"><span data-stu-id="ae431-684">Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</span></span></summary>
        <returns><span data-ttu-id="ae431-685">如果线程已终止，则为 <see langword="true" />；如果 <see langword="false" /> 参数指定的时间量已过之后还未终止线程，则为 <paramref name="millisecondsTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-685"><see langword="true" /> if the thread has terminated; <see langword="false" /> if the thread has not terminated after the amount of time specified by the <paramref name="millisecondsTimeout" /> parameter has elapsed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-686"><xref:System.Threading.Thread.Join%28System.Int32%29> 是一种同步方法，该方法阻止调用线程（即调用方法的线程），直到调用了 <xref:System.Threading.Thread.Join%2A> 方法的线程已完成或超时间隔已过。</span><span class="sxs-lookup"><span data-stu-id="ae431-686"><xref:System.Threading.Thread.Join%28System.Int32%29> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed or the time-out interval has elapsed.</span></span> <span data-ttu-id="ae431-687">在下面的示例中，`Thread1` 线程调用 `Thread2`的 <xref:System.Threading.Thread.Join> 方法，这将导致 `Thread1` 在 `Thread2` 完成之前或在2秒之前被阻止。</span><span class="sxs-lookup"><span data-stu-id="ae431-687">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block either until `Thread2` has completed or 2 seconds have elapsed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 <span data-ttu-id="ae431-688">如果为 `millisecondsTimeout` 参数指定了 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>，则此方法的行为与 <xref:System.Threading.Thread.Join> 方法重载相同，返回值除外。</span><span class="sxs-lookup"><span data-stu-id="ae431-688">If <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> is specified for the `millisecondsTimeout` parameter, this method behaves identically to the <xref:System.Threading.Thread.Join> method overload, except for the return value.</span></span>  
  
 <span data-ttu-id="ae431-689">如果在调用 <xref:System.Threading.Thread.Join%2A> 时线程已终止，则该方法将立即返回。</span><span class="sxs-lookup"><span data-stu-id="ae431-689">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
 <span data-ttu-id="ae431-690">此方法更改调用线程的状态以包括 <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ae431-690">This method changes the state of the calling thread to include <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ae431-691">不能对处于 <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> 状态的线程调用 `Join`。</span><span class="sxs-lookup"><span data-stu-id="ae431-691">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ae431-692"><paramref name="millisecondsTimeout" /> 的值为负数，且不等于 <see cref="F:System.Threading.Timeout.Infinite" />（以毫秒为单位）。</span><span class="sxs-lookup"><span data-stu-id="ae431-692">The value of <paramref name="millisecondsTimeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="ae431-693">该线程尚未启动。</span><span class="sxs-lookup"><span data-stu-id="ae431-693">The thread has not been started.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ae431-694"><paramref name="millisecondsTimeout" /> 小于 -1 (Timeout.Infinite)。</span><span class="sxs-lookup"><span data-stu-id="ae431-694"><paramref name="millisecondsTimeout" /> is less than -1 (Timeout.Infinite).</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="ae431-695">线程在等待时中断。</span><span class="sxs-lookup"><span data-stu-id="ae431-695">The thread was interrupted while waiting.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Join : TimeSpan -&gt; bool" Usage="thread.Join timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="ae431-696">设置等待线程终止的时间量的 <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-696">A <see cref="T:System.TimeSpan" /> set to the amount of time to wait for the thread to terminate.</span></span></param>
        <summary><span data-ttu-id="ae431-697">在继续执行标准的 COM 和 SendMessage 消息泵处理期间，阻止调用线程，直到由该实例表示的线程终止或经过了指定时间为止。</span><span class="sxs-lookup"><span data-stu-id="ae431-697">Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</span></span></summary>
        <returns><span data-ttu-id="ae431-698">如果线程已终止，则为 <see langword="true" />；如果 <see langword="false" /> 参数指定的时间量已过之后还未终止线程，则为 <paramref name="timeout" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-698"><see langword="true" /> if the thread terminated; <see langword="false" /> if the thread has not terminated after the amount of time specified by the <paramref name="timeout" /> parameter has elapsed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-699"><xref:System.Threading.Thread.Join%28System.TimeSpan%29> 是一种同步方法，该方法阻止调用线程（即调用方法的线程），直到调用了 <xref:System.Threading.Thread.Join%2A> 方法的线程已完成或超时间隔已过。</span><span class="sxs-lookup"><span data-stu-id="ae431-699"><xref:System.Threading.Thread.Join%28System.TimeSpan%29> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed or the time-out interval has elapsed.</span></span> <span data-ttu-id="ae431-700">在下面的示例中，`Thread1` 线程调用 `Thread2`的 <xref:System.Threading.Thread.Join> 方法，这将导致 `Thread1` 在 `Thread2` 完成之前或在2秒之前被阻止。</span><span class="sxs-lookup"><span data-stu-id="ae431-700">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block either until `Thread2` has completed or 2 seconds have elapsed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 <span data-ttu-id="ae431-701">如果为 `timeout`指定了 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>，则此方法的行为与 <xref:System.Threading.Thread.Join> 方法重载相同，返回值除外。</span><span class="sxs-lookup"><span data-stu-id="ae431-701">If <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> is specified for `timeout`, this method behaves identically to the <xref:System.Threading.Thread.Join> method overload, except for the return value.</span></span>  
  
 <span data-ttu-id="ae431-702">如果在调用 <xref:System.Threading.Thread.Join%2A> 时线程已终止，则该方法将立即返回。</span><span class="sxs-lookup"><span data-stu-id="ae431-702">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
 <span data-ttu-id="ae431-703">此方法更改当前线程的状态以包括 <xref:System.Threading.ThreadState.WaitSleepJoin>。</span><span class="sxs-lookup"><span data-stu-id="ae431-703">This method changes the state of the current thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span> <span data-ttu-id="ae431-704">不能对处于 <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> 状态的线程调用 `Join`。</span><span class="sxs-lookup"><span data-stu-id="ae431-704">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-705">下面的代码示例演示如何将 `TimeSpan` 值与 `Join` 方法一起使用。</span><span class="sxs-lookup"><span data-stu-id="ae431-705">The following code example demonstrates how to use a `TimeSpan` value with the `Join` method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ae431-706"><paramref name="timeout" /> 的值为负数，且不等于 <see cref="F:System.Threading.Timeout.Infinite" />（以毫秒为单位），或大于 <see cref="F:System.Int32.MaxValue" /> 毫秒。</span><span class="sxs-lookup"><span data-stu-id="ae431-706">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="ae431-707">调用方尝试加入处于 <see cref="F:System.Threading.ThreadState.Unstarted" /> 状态的线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-707">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ManagedThreadId : int" Usage="System.Threading.Thread.ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ae431-708">获取当前托管线程的唯一标识符。</span><span class="sxs-lookup"><span data-stu-id="ae431-708">Gets a unique identifier for the current managed thread.</span></span></summary>
        <value><span data-ttu-id="ae431-709">一个整数，表示此托管线程的唯一标识符。</span><span class="sxs-lookup"><span data-stu-id="ae431-709">An integer that represents a unique identifier for this managed thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-710">线程的 <xref:System.Threading.Thread.ManagedThreadId%2A> 属性值用于唯一标识该线程在其进程中。</span><span class="sxs-lookup"><span data-stu-id="ae431-710">A thread's <xref:System.Threading.Thread.ManagedThreadId%2A> property value serves to uniquely identify that thread within its process.</span></span>  
  
 <span data-ttu-id="ae431-711"><xref:System.Threading.Thread.ManagedThreadId%2A> 属性的值不会随时间而变化，即使托管公共语言运行时的非托管代码将线程作为纤程实现。</span><span class="sxs-lookup"><span data-stu-id="ae431-711">The value of the <xref:System.Threading.Thread.ManagedThreadId%2A> property does not vary over time, even if unmanaged code that hosts the common language runtime implements the thread as a fiber.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Thread.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ae431-712">按如下方式同步内存访问：执行当前线程的处理器在对指令重新排序时，不能采用先执行 <see cref="M:System.Threading.Thread.MemoryBarrier" /> 调用之后的内存存取，再执行 <see cref="M:System.Threading.Thread.MemoryBarrier" /> 调用之前的内存存取的方式。</span><span class="sxs-lookup"><span data-stu-id="ae431-712">Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to <see cref="M:System.Threading.Thread.MemoryBarrier" /> execute after memory accesses that follow the call to <see cref="M:System.Threading.Thread.MemoryBarrier" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-713">仅在具有弱内存排序的多处理器系统上需要 <xref:System.Threading.Thread.MemoryBarrier%2A> （例如，使用多个 Intel Itanium 处理器的系统）。</span><span class="sxs-lookup"><span data-stu-id="ae431-713"><xref:System.Threading.Thread.MemoryBarrier%2A> is required only on multiprocessor systems with weak memory ordering (for example, a system employing multiple Intel Itanium processors).</span></span>  
  
 <span data-ttu-id="ae431-714">大多数情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句或 <xref:System.Threading.Monitor> 类提供更简单的方法来同步数据。</span><span class="sxs-lookup"><span data-stu-id="ae431-714">For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Threading.Thread.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ae431-715">获取或设置线程的名称。</span><span class="sxs-lookup"><span data-stu-id="ae431-715">Gets or sets the name of the thread.</span></span></summary>
        <value><span data-ttu-id="ae431-716">包含线程名称的字符串或 <see langword="null" />（如果未设置名称）。</span><span class="sxs-lookup"><span data-stu-id="ae431-716">A string containing the name of the thread, or <see langword="null" /> if no name was set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-717">此属性为写入一次。</span><span class="sxs-lookup"><span data-stu-id="ae431-717">This property is write-once.</span></span> <span data-ttu-id="ae431-718">由于线程的 <xref:System.Threading.Thread.Name%2A> 属性的默认值为 `null`，因此你可以通过将其与 `null`进行比较来确定是否已将名称显式分配给该线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-718">Because the default value of a thread's <xref:System.Threading.Thread.Name%2A> property is `null`, you can determine whether a name has already been explicitly assigned to the thread by comparing it with `null`.</span></span>  
  
 <span data-ttu-id="ae431-719">分配给 <xref:System.Threading.Thread.Name%2A> 属性的字符串可包含任何 Unicode 字符。</span><span class="sxs-lookup"><span data-stu-id="ae431-719">The string assigned to the <xref:System.Threading.Thread.Name%2A> property can include any Unicode character.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-720">下面的示例演示如何命名一个线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-720">The following example shows how to name a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ae431-721">已请求集运算，但 <see langword="Name" /> 属性已设置。</span><span class="sxs-lookup"><span data-stu-id="ae431-721">A set operation was requested, but the <see langword="Name" /> property has already been set.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Threading.ThreadPriority with get, set" Usage="System.Threading.Thread.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ae431-722">获取或设置指示线程的调度优先级的值。</span><span class="sxs-lookup"><span data-stu-id="ae431-722">Gets or sets a value indicating the scheduling priority of a thread.</span></span></summary>
        <value><span data-ttu-id="ae431-723"><see cref="T:System.Threading.ThreadPriority" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="ae431-723">One of the <see cref="T:System.Threading.ThreadPriority" /> values.</span></span> <span data-ttu-id="ae431-724">默认值是 <see cref="F:System.Threading.ThreadPriority.Normal" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-724">The default value is <see cref="F:System.Threading.ThreadPriority.Normal" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-725">可以为线程分配以下任一优先级 <xref:System.Threading.ThreadPriority> 值：</span><span class="sxs-lookup"><span data-stu-id="ae431-725">A thread can be assigned any one of the following priority <xref:System.Threading.ThreadPriority> values:</span></span>  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 <span data-ttu-id="ae431-726">操作系统不需要遵循线程的优先级。</span><span class="sxs-lookup"><span data-stu-id="ae431-726">Operating systems are not required to honor the priority of a thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-727">下面的示例演示更改线程优先级的结果。</span><span class="sxs-lookup"><span data-stu-id="ae431-727">The following example shows the result of changing the priority of a thread.</span></span> <span data-ttu-id="ae431-728">创建三个线程，一个线程的优先级设置为 <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>，另一个线程的优先级设置为 <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ae431-728">Three threads are created, the priority of one thread is set to <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, and the priority of a second is set to <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ae431-729">每个线程在 `while` 循环中递增变量，并在设置的时间内运行。</span><span class="sxs-lookup"><span data-stu-id="ae431-729">Each thread increments a variable in a `while` loop and runs for a set time.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="ae431-730">线程已到达最终状态，如 <see cref="F:System.Threading.ThreadState.Aborted" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-730">The thread has reached a final state, such as <see cref="F:System.Threading.ThreadState.Aborted" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ae431-731">为集运算指定的值不是有效的 <see cref="T:System.Threading.ThreadPriority" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ae431-731">The value specified for a set operation is not a valid <see cref="T:System.Threading.ThreadPriority" /> value.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
        <related type="Article" href="~/docs/standard/threading/scheduling-threads.md"><span data-ttu-id="ae431-732">计划线程</span><span class="sxs-lookup"><span data-stu-id="ae431-732">Scheduling threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberSignature Language="F#" Value="static member ResetAbort : unit -&gt; unit" Usage="System.Threading.Thread.ResetAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ae431-733">取消当前线程所请求的 <see cref="M:System.Threading.Thread.Abort(System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-733">Cancels an <see cref="M:System.Threading.Thread.Abort(System.Object)" /> requested for the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-734">只有具有适当权限的代码才能调用此方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-734">This method can only be called by code with the proper permissions.</span></span>  
  
 <span data-ttu-id="ae431-735">调用 `Abort` 终止线程时，系统将引发 <xref:System.Threading.ThreadAbortException>。</span><span class="sxs-lookup"><span data-stu-id="ae431-735">When a call is made to `Abort` to terminate a thread, the system throws a <xref:System.Threading.ThreadAbortException>.</span></span> <span data-ttu-id="ae431-736">`ThreadAbortException` 是一种特殊的异常，可由应用程序代码捕获，但会在 catch 块的末尾重新引发，除非调用 `ResetAbort`。</span><span class="sxs-lookup"><span data-stu-id="ae431-736">`ThreadAbortException` is a special exception that can be caught by application code, but is rethrown at the end of the catch block unless `ResetAbort` is called.</span></span> <span data-ttu-id="ae431-737">`ResetAbort` 取消中止请求，并阻止 `ThreadAbortException` 终止线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-737">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span>  
  
 <span data-ttu-id="ae431-738">有关演示如何调用 `ResetAbort` 方法的示例，请参阅 <xref:System.Threading.ThreadAbortException>。</span><span class="sxs-lookup"><span data-stu-id="ae431-738">See <xref:System.Threading.ThreadAbortException> for an example that demonstrates calling the `ResetAbort` method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="ae431-739">仅限 .NET Core：不支持此成员。</span><span class="sxs-lookup"><span data-stu-id="ae431-739">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="ae431-740">未在当前线程上调用 <see langword="Abort" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-740"><see langword="Abort" /> was not invoked on the current thread.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="ae431-741">调用方没有当前线程要求的安全权限。</span><span class="sxs-lookup"><span data-stu-id="ae431-741">The caller does not have the required security permission for the current thread.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ae431-742">用于线程的高级操作。</span><span class="sxs-lookup"><span data-stu-id="ae431-742">for advanced operations on threads.</span></span> <span data-ttu-id="ae431-743">关联的枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-743">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md"><span data-ttu-id="ae431-744">销毁线程</span><span class="sxs-lookup"><span data-stu-id="ae431-744">Destroying threads</span></span></related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="thread.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ae431-745">继续已挂起的线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-745">Resumes a thread that has been suspended.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <span data-ttu-id="ae431-746">不要使用 <xref:System.Threading.Thread.Suspend%2A> 和 <xref:System.Threading.Thread.Resume%2A> 方法来同步线程的活动。</span><span class="sxs-lookup"><span data-stu-id="ae431-746">Do not use the <xref:System.Threading.Thread.Suspend%2A> and <xref:System.Threading.Thread.Resume%2A> methods to synchronize the activities of threads.</span></span> <span data-ttu-id="ae431-747">您无法知道线程在挂起时正在执行的代码。</span><span class="sxs-lookup"><span data-stu-id="ae431-747">You have no way of knowing what code a thread is executing when you suspend it.</span></span> <span data-ttu-id="ae431-748">如果在安全权限评估过程中挂起一个处于锁定状态的线程，则 <xref:System.AppDomain> 中的其他线程可能会被阻止。</span><span class="sxs-lookup"><span data-stu-id="ae431-748">If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked.</span></span> <span data-ttu-id="ae431-749">如果在线程执行类构造函数时挂起线程，则会阻止 <xref:System.AppDomain> 中尝试使用该类的其他线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-749">If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked.</span></span> <span data-ttu-id="ae431-750">死锁可能会非常简单。</span><span class="sxs-lookup"><span data-stu-id="ae431-750">Deadlocks can occur very easily.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="ae431-751">仅限 .NET Core：不支持此成员。</span><span class="sxs-lookup"><span data-stu-id="ae431-751">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="ae431-752">该线程尚未启动、 已死或未处于挂起状态。</span><span class="sxs-lookup"><span data-stu-id="ae431-752">The thread has not been started, is dead, or is not in the suspended state.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="ae431-753">调用方没有适当的 <see cref="T:System.Security.Permissions.SecurityPermission" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-753">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ae431-754">用于线程的高级操作。</span><span class="sxs-lookup"><span data-stu-id="ae431-754">for advanced operations on threads.</span></span> <span data-ttu-id="ae431-755">关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="ae431-755">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md"><span data-ttu-id="ae431-756">暂停和中断线程</span><span class="sxs-lookup"><span data-stu-id="ae431-756">Pausing and interrupting threads</span></span></related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.SetApartmentState : System.Threading.ApartmentState -&gt; unit" Usage="thread.SetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="state"><span data-ttu-id="ae431-757">新的单元状态。</span><span class="sxs-lookup"><span data-stu-id="ae431-757">The new apartment state.</span></span></param>
        <summary><span data-ttu-id="ae431-758">在线程启动前设置其单元状态。</span><span class="sxs-lookup"><span data-stu-id="ae431-758">Sets the apartment state of a thread before it is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-759">如果新线程的单元状态在启动之前尚未设置，则会将其初始化为 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ae431-759">New threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="ae431-760">必须在启动线程之前设置单元状态。</span><span class="sxs-lookup"><span data-stu-id="ae431-760">Apartment state must be set before a thread is started.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-761">默认情况下，主应用程序线程初始化为 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ae431-761">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="ae431-762">将主应用程序线程的单元状态设置为 <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> 的唯一方法是将 <xref:System.STAThreadAttribute> 属性应用于入口点方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-762">The only way to set the apartment state of the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> is to apply the <xref:System.STAThreadAttribute> attribute to the entry point method.</span></span>  
  
 <span data-ttu-id="ae431-763"><xref:System.Threading.Thread.SetApartmentState%2A> 方法与 <xref:System.Threading.Thread.GetApartmentState%2A> 方法和 <xref:System.Threading.Thread.TrySetApartmentState%2A> 方法一起替换 <xref:System.Threading.Thread.ApartmentState%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="ae431-763">The <xref:System.Threading.Thread.SetApartmentState%2A> method, along with the <xref:System.Threading.Thread.GetApartmentState%2A> method and the <xref:System.Threading.Thread.TrySetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-764">下面的代码示例演示 <xref:System.Threading.Thread.GetApartmentState%2A>、<xref:System.Threading.Thread.SetApartmentState%2A>和 <xref:System.Threading.Thread.TrySetApartmentState%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-764">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="ae431-765">此代码示例创建一个线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-765">The code example creates a thread.</span></span> <span data-ttu-id="ae431-766">启动线程之前，<xref:System.Threading.Thread.GetApartmentState%2A> 显示初始 <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> 状态，<xref:System.Threading.Thread.SetApartmentState%2A> 将状态更改为 <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ae431-766">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ae431-767">当尝试将状态更改为 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> 时，<xref:System.Threading.Thread.TrySetApartmentState%2A> 方法返回 `false`，因为已设置了单元状态。</span><span class="sxs-lookup"><span data-stu-id="ae431-767">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="ae431-768">如果已尝试 <xref:System.Threading.Thread.SetApartmentState%2A>相同的操作，则会引发 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="ae431-768">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="ae431-769">线程启动后，将再次使用 <xref:System.Threading.Thread.TrySetApartmentState%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-769">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="ae431-770">这次会引发 <xref:System.Threading.ThreadStateException>，因为该线程已启动。</span><span class="sxs-lookup"><span data-stu-id="ae431-770">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="ae431-771">仅限 .NET Core：macOS 和 Linux 平台上不支持此成员。</span><span class="sxs-lookup"><span data-stu-id="ae431-771">.NET Core only: This member is not supported on the macOS and Linux platforms.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ae431-772"><paramref name="state" /> 不是有效的单元状态。</span><span class="sxs-lookup"><span data-stu-id="ae431-772"><paramref name="state" /> is not a valid apartment state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="ae431-773">线程已启动。</span><span class="sxs-lookup"><span data-stu-id="ae431-773">The thread has already been started.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ae431-774">已初始化单元状态。</span><span class="sxs-lookup"><span data-stu-id="ae431-774">The apartment state has already been initialized.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberSignature Language="F#" Value="member this.SetCompressedStack : System.Threading.CompressedStack -&gt; unit" Usage="thread.SetCompressedStack stack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="stack"><span data-ttu-id="ae431-775">将被应用到当前线程的 <see cref="T:System.Threading.CompressedStack" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="ae431-775">The <see cref="T:System.Threading.CompressedStack" /> object to be applied to the current thread.</span></span></param>
        <summary><span data-ttu-id="ae431-776">将捕获的 <see cref="T:System.Threading.CompressedStack" /> 应用到当前线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-776">Applies a captured <see cref="T:System.Threading.CompressedStack" /> to the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-777">不再支持此方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-777">This method is no longer supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ae431-778">在所有情况下。</span><span class="sxs-lookup"><span data-stu-id="ae431-778">In all cases.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ae431-779">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="ae431-779">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="ae431-780">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="ae431-780">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member SetData : LocalDataStoreSlot * obj -&gt; unit" Usage="System.Threading.Thread.SetData (slot, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="data" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="slot"><span data-ttu-id="ae431-781">在其中设置值的 <see cref="T:System.LocalDataStoreSlot" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-781">The <see cref="T:System.LocalDataStoreSlot" /> in which to set the value.</span></span></param>
        <param name="data"><span data-ttu-id="ae431-782">要设置的值。</span><span class="sxs-lookup"><span data-stu-id="ae431-782">The value to be set.</span></span></param>
        <summary><span data-ttu-id="ae431-783">在当前正在运行的线程上为此线程的当前域在指定槽中设置数据。</span><span class="sxs-lookup"><span data-stu-id="ae431-783">Sets the data in the specified slot on the currently running thread, for that thread's current domain.</span></span> <span data-ttu-id="ae431-784">为了提高性能，请改用用 <see cref="T:System.ThreadStaticAttribute" /> 属性标记的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-784">For better performance, use fields marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="ae431-785">.NET Framework 提供了两种使用线程本地存储（TLS）的机制：线程相关的静态字段（即使用 <xref:System.ThreadStaticAttribute> 属性标记的字段）和数据槽。</span><span class="sxs-lookup"><span data-stu-id="ae431-785">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="ae431-786">线程相对静态字段比数据槽提供更好的性能，并启用编译时类型检查。</span><span class="sxs-lookup"><span data-stu-id="ae431-786">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="ae431-787">有关使用 TLS 的详细信息，请参阅[线程本地存储：线程相对静态字段和数据槽](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。</span><span class="sxs-lookup"><span data-stu-id="ae431-787">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="ae431-788">线程使用本地存储内存机制来存储线程特定的数据。</span><span class="sxs-lookup"><span data-stu-id="ae431-788">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="ae431-789">公共语言运行时在创建每个进程时将多槽数据存储数组分配给它。</span><span class="sxs-lookup"><span data-stu-id="ae431-789">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="ae431-790">线程可以在数据存储中分配数据槽，在槽中存储和检索数据值，并在线程过程结束并通过垃圾回收来回收 <xref:System.Threading.Thread> 对象之后释放槽以供重新使用。</span><span class="sxs-lookup"><span data-stu-id="ae431-790">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread procedure ends and the <xref:System.Threading.Thread> object has been reclaimed by garbage collection.</span></span> <span data-ttu-id="ae431-791">数据槽对于每个线程都是唯一的。</span><span class="sxs-lookup"><span data-stu-id="ae431-791">Data slots are unique per thread.</span></span> <span data-ttu-id="ae431-792">任何其他线程（甚至不是子线程）都无法获取该数据。</span><span class="sxs-lookup"><span data-stu-id="ae431-792">No other thread (not even a child thread) can get that data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-793"><xref:System.Threading.Thread.SetData%2A> 是始终应用于当前正在执行的线程的 `Shared` 方法，即使使用引用另一个线程的变量调用它也是如此。</span><span class="sxs-lookup"><span data-stu-id="ae431-793"><xref:System.Threading.Thread.SetData%2A> is a `Shared` method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</span></span> <span data-ttu-id="ae431-794">若要避免混淆，请在调用 `Shared` 方法时使用类名： `Thread.SetData(testSlot, "test data")`。</span><span class="sxs-lookup"><span data-stu-id="ae431-794">To avoid confusion, use the class name when calling `Shared` methods: `Thread.SetData(testSlot, "test data")`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-795">本部分包含两个代码示例。</span><span class="sxs-lookup"><span data-stu-id="ae431-795">This section contains two code examples.</span></span> <span data-ttu-id="ae431-796">第一个示例演示如何使用标记有 <xref:System.ThreadStaticAttribute> 特性的字段来保存特定于线程的信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-796">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="ae431-797">第二个示例演示如何使用数据槽来执行相同的操作。</span><span class="sxs-lookup"><span data-stu-id="ae431-797">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="ae431-798">**第一个示例**</span><span class="sxs-lookup"><span data-stu-id="ae431-798">**First Example**</span></span>  
  
 <span data-ttu-id="ae431-799">下面的示例演示如何使用标记有 <xref:System.ThreadStaticAttribute> 的字段来保存特定于线程的信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-799">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="ae431-800">与第二个示例中所示的方法相比，此方法提供的性能更好。</span><span class="sxs-lookup"><span data-stu-id="ae431-800">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="ae431-801">**第二个示例**</span><span class="sxs-lookup"><span data-stu-id="ae431-801">**Second Example**</span></span>  
  
 <span data-ttu-id="ae431-802">下面的示例演示如何使用命名数据槽来存储特定于线程的信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-802">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="ae431-803">线程与线程处理</span><span class="sxs-lookup"><span data-stu-id="ae431-803">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="ae431-804">线程本地存储区：线程相关的静态字段和数据槽</span><span class="sxs-lookup"><span data-stu-id="ae431-804">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ae431-805">将当前线程挂起指定的时间。</span><span class="sxs-lookup"><span data-stu-id="ae431-805">Suspends the current thread for the specified amount of time.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : int -&gt; unit" Usage="System.Threading.Thread.Sleep millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="ae431-806">挂起线程的毫秒数。</span><span class="sxs-lookup"><span data-stu-id="ae431-806">The number of milliseconds for which the thread is suspended.</span></span> <span data-ttu-id="ae431-807">如果 <paramref name="millisecondsTimeout" /> 参数的值为零，则该线程会将其时间片的剩余部分让给任何已经准备好运行的、具有同等优先级的线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-807">If the value of the <paramref name="millisecondsTimeout" /> argument is zero, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</span></span> <span data-ttu-id="ae431-808">如果没有其他已经准备好运行的、具有同等优先级的线程，则不会挂起当前线程的执行。</span><span class="sxs-lookup"><span data-stu-id="ae431-808">If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</span></span></param>
        <summary><span data-ttu-id="ae431-809">将当前线程挂起指定的毫秒数。</span><span class="sxs-lookup"><span data-stu-id="ae431-809">Suspends the current thread for the specified number of milliseconds.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-810">在指定的时间内，将不会将线程计划为由操作系统执行。</span><span class="sxs-lookup"><span data-stu-id="ae431-810">The thread will not be scheduled for execution by the operating system for the amount of time specified.</span></span> <span data-ttu-id="ae431-811">此方法更改线程的状态以包括 <xref:System.Threading.ThreadState.WaitSleepJoin>。</span><span class="sxs-lookup"><span data-stu-id="ae431-811">This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span>  
  
 <span data-ttu-id="ae431-812">可以指定 `millisecondsTimeout` 参数 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>，以无限期挂起线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-812">You can specify <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the `millisecondsTimeout` parameter to suspend the thread indefinitely.</span></span> <span data-ttu-id="ae431-813">但是，我们建议你改为使用其他 <xref:System.Threading?displayProperty=nameWithType> 类，如 <xref:System.Threading.Mutex>、<xref:System.Threading.Monitor>、<xref:System.Threading.EventWaitHandle>或 <xref:System.Threading.Semaphore>，以同步线程或管理资源。</span><span class="sxs-lookup"><span data-stu-id="ae431-813">However, we recommend that you use other <xref:System.Threading?displayProperty=nameWithType> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to synchronize threads or manage resources.</span></span>  
  
 <span data-ttu-id="ae431-814">系统时钟计时周期，按特定速率称为时钟解析。</span><span class="sxs-lookup"><span data-stu-id="ae431-814">The system clock ticks at a specific rate called the clock resolution.</span></span> <span data-ttu-id="ae431-815">实际超时可能不是精确到指定的超时值，因为将调整指定的超时值，使其与时钟计时周期一致。</span><span class="sxs-lookup"><span data-stu-id="ae431-815">The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks.</span></span> <span data-ttu-id="ae431-816">有关时钟解析和等待时间的详细信息，请参阅 Windows 系统 Api 中的[休眠功能](/windows/win32/api/synchapi/nf-synchapi-sleep)。</span><span class="sxs-lookup"><span data-stu-id="ae431-816">For more information on clock resolution and the waiting time, see the [Sleep function](/windows/win32/api/synchapi/nf-synchapi-sleep) from the Windows system APIs.</span></span>  
  
 <span data-ttu-id="ae431-817">此方法不执行标准的 COM 和 SendMessage 泵。</span><span class="sxs-lookup"><span data-stu-id="ae431-817">This method does not perform standard COM and SendMessage pumping.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-818">如果需要在具有 <xref:System.STAThreadAttribute>的线程上睡眠，但要执行标准的 COM 和 SendMessage 泵泵，请考虑使用指定超时间隔的 <xref:System.Threading.Thread.Join%2A> 方法的重载之一。</span><span class="sxs-lookup"><span data-stu-id="ae431-818">If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-819">下面的示例使用 <xref:System.Threading.Thread.Sleep%2A> 方法来阻止应用程序的主线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-819">The following example uses the <xref:System.Threading.Thread.Sleep%2A> method to block the application's main thread.</span></span>  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ae431-820">超时值为负且不等于 <see cref="F:System.Threading.Timeout.Infinite" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-820">The time-out value is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : TimeSpan -&gt; unit" Usage="System.Threading.Thread.Sleep timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="ae431-821">挂起线程的时间量。</span><span class="sxs-lookup"><span data-stu-id="ae431-821">The amount of time for which the thread is suspended.</span></span> <span data-ttu-id="ae431-822">如果 <paramref name="millisecondsTimeout" /> 参数的值为 <see cref="F:System.TimeSpan.Zero" />，则该线程会将其时间片的剩余部分让给任何已经准备好运行的、具有同等优先级的线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-822">If the value of the <paramref name="millisecondsTimeout" /> argument is <see cref="F:System.TimeSpan.Zero" />, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</span></span> <span data-ttu-id="ae431-823">如果没有其他已经准备好运行的、具有同等优先级的线程，则不会挂起当前线程的执行。</span><span class="sxs-lookup"><span data-stu-id="ae431-823">If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</span></span></param>
        <summary><span data-ttu-id="ae431-824">将当前线程挂起指定的时间。</span><span class="sxs-lookup"><span data-stu-id="ae431-824">Suspends the current thread for the specified amount of time.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-825">在指定的时间内，将不会将线程计划为由操作系统执行。</span><span class="sxs-lookup"><span data-stu-id="ae431-825">The thread will not be scheduled for execution by the operating system for the amount of time specified.</span></span> <span data-ttu-id="ae431-826">此方法更改线程的状态以包括 <xref:System.Threading.ThreadState.WaitSleepJoin>。</span><span class="sxs-lookup"><span data-stu-id="ae431-826">This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span>  
  
 <span data-ttu-id="ae431-827">可以指定 `timeout` 参数 <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType>，以无限期挂起线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-827">You can specify <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> for the `timeout` parameter to suspend the thread indefinitely.</span></span> <span data-ttu-id="ae431-828">但是，我们建议你改为使用其他 <xref:System.Threading?displayProperty=nameWithType> 类，如 <xref:System.Threading.Mutex>、<xref:System.Threading.Monitor>、<xref:System.Threading.EventWaitHandle>或 <xref:System.Threading.Semaphore>，以同步线程或管理资源。</span><span class="sxs-lookup"><span data-stu-id="ae431-828">However, we recommend that you use other <xref:System.Threading?displayProperty=nameWithType> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to synchronize threads or manage resources.</span></span>  
  
 <span data-ttu-id="ae431-829"><xref:System.Threading.Thread.Sleep%2A> 的此重载使用 `timeout`中的总毫秒数。</span><span class="sxs-lookup"><span data-stu-id="ae431-829">This overload of <xref:System.Threading.Thread.Sleep%2A> uses the total number of whole milliseconds in `timeout`.</span></span> <span data-ttu-id="ae431-830">丢弃毫秒的小数部分。</span><span class="sxs-lookup"><span data-stu-id="ae431-830">Fractional milliseconds are discarded.</span></span>  
  
 <span data-ttu-id="ae431-831">此方法不执行标准的 COM 和 SendMessage 泵。</span><span class="sxs-lookup"><span data-stu-id="ae431-831">This method does not perform standard COM and SendMessage pumping.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-832">如果需要在具有 <xref:System.STAThreadAttribute>的线程上睡眠，但要执行标准的 COM 和 SendMessage 泵泵，请考虑使用指定超时间隔的 <xref:System.Threading.Thread.Join%2A> 方法的重载之一。</span><span class="sxs-lookup"><span data-stu-id="ae431-832">If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-833">下面的示例使用 <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> 方法重载来阻止应用程序的主线程5次，每次执行两秒钟。</span><span class="sxs-lookup"><span data-stu-id="ae431-833">The following example uses the <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> method overload to block the application's main thread five times, for two seconds each time.</span></span>  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ae431-834"><paramref name="timeout" /> 的值为负数，且不等于 <see cref="F:System.Threading.Timeout.Infinite" />（以毫秒为单位），或大于 <see cref="F:System.Int32.MaxValue" /> 毫秒。</span><span class="sxs-lookup"><span data-stu-id="ae431-834">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberSignature Language="F#" Value="static member SpinWait : int -&gt; unit" Usage="System.Threading.Thread.SpinWait iterations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="iterations"><span data-ttu-id="ae431-835">定义线程等待的时间长短的 32 位有符号整数。</span><span class="sxs-lookup"><span data-stu-id="ae431-835">A 32-bit signed integer that defines how long a thread is to wait.</span></span></param>
        <summary><span data-ttu-id="ae431-836">导致线程等待由 <paramref name="iterations" /> 参数定义的时间量。</span><span class="sxs-lookup"><span data-stu-id="ae431-836">Causes a thread to wait the number of times defined by the <paramref name="iterations" /> parameter.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-837"><xref:System.Threading.Thread.SpinWait%2A> 方法对于实现锁定很有用。</span><span class="sxs-lookup"><span data-stu-id="ae431-837">The <xref:System.Threading.Thread.SpinWait%2A> method is useful for implementing locks.</span></span> <span data-ttu-id="ae431-838">.NET Framework 中的类（如 <xref:System.Threading.Monitor> 和 <xref:System.Threading.ReaderWriterLock>）在内部使用此方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-838">Classes in the .NET Framework, such as <xref:System.Threading.Monitor> and <xref:System.Threading.ReaderWriterLock>, use this method internally.</span></span> <span data-ttu-id="ae431-839"><xref:System.Threading.Thread.SpinWait%2A> 实质上是将处理器放入非常紧密的循环，并使用 `iterations` 参数指定的循环计数。</span><span class="sxs-lookup"><span data-stu-id="ae431-839"><xref:System.Threading.Thread.SpinWait%2A> essentially puts the processor into a very tight loop, with the loop count specified by the `iterations` parameter.</span></span> <span data-ttu-id="ae431-840">因此，等待时间取决于处理器的速度。</span><span class="sxs-lookup"><span data-stu-id="ae431-840">The duration of the wait therefore depends on the speed of the processor.</span></span>  
  
 <span data-ttu-id="ae431-841">与 <xref:System.Threading.Thread.Sleep%2A> 方法对比。</span><span class="sxs-lookup"><span data-stu-id="ae431-841">Contrast this with the <xref:System.Threading.Thread.Sleep%2A> method.</span></span> <span data-ttu-id="ae431-842">调用 <xref:System.Threading.Thread.Sleep%2A> 的线程将生成其处理器时间的当前切片的其余部分（即使指定的间隔为零）。</span><span class="sxs-lookup"><span data-stu-id="ae431-842">A thread that calls <xref:System.Threading.Thread.Sleep%2A> yields the rest of its current slice of processor time, even if the specified interval is zero.</span></span> <span data-ttu-id="ae431-843">为 <xref:System.Threading.Thread.Sleep%2A> 指定一个非零间隔后，线程计划程序将从线程计划程序中删除线程，直到时间间隔结束。</span><span class="sxs-lookup"><span data-stu-id="ae431-843">Specifying a non-zero interval for <xref:System.Threading.Thread.Sleep%2A> removes the thread from consideration by the thread scheduler until the time interval has elapsed.</span></span>  
  
 <span data-ttu-id="ae431-844">对于普通的应用程序，<xref:System.Threading.Thread.SpinWait%2A> 通常不起作用。</span><span class="sxs-lookup"><span data-stu-id="ae431-844"><xref:System.Threading.Thread.SpinWait%2A> is not generally useful for ordinary applications.</span></span> <span data-ttu-id="ae431-845">在大多数情况下，应使用 .NET Framework 提供的同步类;例如，调用 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 或包装 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 的语句（在 Visual Basic 中`lock` C#或 `SyncLock`。</span><span class="sxs-lookup"><span data-stu-id="ae431-845">In most cases, you should use the synchronization classes provided by the .NET Framework; for example, call <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> or a statement that wraps <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` in C# or `SyncLock` in Visual Basic).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ae431-846">在极少数情况下，避免使用上下文切换很有用，例如，当你知道状态更改即将发生时，请在循环中调用 <xref:System.Threading.Thread.SpinWait%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-846">In the rare case where it is advantageous to avoid a context switch, such as when you know that a state change is imminent, make a call to the <xref:System.Threading.Thread.SpinWait%2A> method in your loop.</span></span> <span data-ttu-id="ae431-847"><xref:System.Threading.Thread.SpinWait%2A> 执行的代码旨在防止具有多个处理器的计算机上出现的问题。</span><span class="sxs-lookup"><span data-stu-id="ae431-847">The code <xref:System.Threading.Thread.SpinWait%2A> executes is designed to prevent problems that can occur on computers with multiple processors.</span></span> <span data-ttu-id="ae431-848">例如，在具有多个采用超线程技术的 Intel 处理器的计算机上，<xref:System.Threading.Thread.SpinWait%2A> 在某些情况下防止处理器不足。</span><span class="sxs-lookup"><span data-stu-id="ae431-848">For example, on computers with multiple Intel processors employing Hyper-Threading technology, <xref:System.Threading.Thread.SpinWait%2A> prevents processor starvation in certain situations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ae431-849">使线程得以按计划执行。</span><span class="sxs-lookup"><span data-stu-id="ae431-849">Causes a thread to be scheduled for execution.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="thread.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ae431-850">导致操作系统将当前实例的状态更改为 <see cref="F:System.Threading.ThreadState.Running" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-850">Causes the operating system to change the state of the current instance to <see cref="F:System.Threading.ThreadState.Running" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-851">线程处于 <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> 状态后，操作系统就可以将其计划为执行。</span><span class="sxs-lookup"><span data-stu-id="ae431-851">Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, the operating system can schedule it for execution.</span></span> <span data-ttu-id="ae431-852">线程开始在由提供给线程构造函数的 <xref:System.Threading.ThreadStart> 或 <xref:System.Threading.ParameterizedThreadStart> 委托表示的方法的第一行执行。</span><span class="sxs-lookup"><span data-stu-id="ae431-852">The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor.</span></span> <span data-ttu-id="ae431-853">请注意，对 <xref:System.Threading.Thread.Start%2A> 的调用不会阻止调用线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-853">Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-854">如果此重载与使用 <xref:System.Threading.ParameterizedThreadStart> 委托创建的线程一起使用，则 `null` 会传递到线程执行的方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-854">If this overload is used with a thread created using a <xref:System.Threading.ParameterizedThreadStart> delegate, `null` is passed to the method executed by the thread.</span></span>  
  
 <span data-ttu-id="ae431-855">线程终止后，不能再次调用 `Start`。</span><span class="sxs-lookup"><span data-stu-id="ae431-855">Once the thread terminates, it cannot be restarted with another call to `Start`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-856">下面的示例创建并启动一个线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-856">The following example creates and starts a thread.</span></span>  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="ae431-857">线程已启动。</span><span class="sxs-lookup"><span data-stu-id="ae431-857">The thread has already been started.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="ae431-858">内存不足，无法启动此线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-858">There is not enough memory available to start this thread.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="ae431-859">线程与线程处理</span><span class="sxs-lookup"><span data-stu-id="ae431-859">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="ae431-860">启动时创建线程并传递数据</span><span class="sxs-lookup"><span data-stu-id="ae431-860">Creating Threads and Passing Data at Start Time</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.Start : obj -&gt; unit" Usage="thread.Start parameter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="parameter"><span data-ttu-id="ae431-861">一个对象，包含线程执行的方法要使用的数据。</span><span class="sxs-lookup"><span data-stu-id="ae431-861">An object that contains data to be used by the method the thread executes.</span></span></param>
        <summary><span data-ttu-id="ae431-862">导致操作系统将当前实例的状态更改为 <see cref="F:System.Threading.ThreadState.Running" />，并选择提供包含线程执行的方法要使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="ae431-862">Causes the operating system to change the state of the current instance to <see cref="F:System.Threading.ThreadState.Running" />, and optionally supplies an object containing data to be used by the method the thread executes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-863">线程处于 <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> 状态后，操作系统就可以将其计划为执行。</span><span class="sxs-lookup"><span data-stu-id="ae431-863">Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, the operating system can schedule it for execution.</span></span> <span data-ttu-id="ae431-864">线程开始在由提供给线程构造函数的 <xref:System.Threading.ThreadStart> 或 <xref:System.Threading.ParameterizedThreadStart> 委托表示的方法的第一行执行。</span><span class="sxs-lookup"><span data-stu-id="ae431-864">The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor.</span></span> <span data-ttu-id="ae431-865">请注意，对 <xref:System.Threading.Thread.Start%2A> 的调用不会阻止调用线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-865">Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.</span></span>  
  
 <span data-ttu-id="ae431-866">线程终止后，不能再次调用 `Start`。</span><span class="sxs-lookup"><span data-stu-id="ae431-866">Once the thread terminates, it cannot be restarted with another call to `Start`.</span></span>  
  
 <span data-ttu-id="ae431-867">利用此重载和 <xref:System.Threading.ParameterizedThreadStart> 委托，可以轻松地将数据传递给线程过程，但该方法不是类型安全的，因为任何对象都可以传递到此重载。</span><span class="sxs-lookup"><span data-stu-id="ae431-867">This overload and the <xref:System.Threading.ParameterizedThreadStart> delegate make it easy to pass data to a thread procedure, but the technique is not type safe because any object can be passed to this overload.</span></span> <span data-ttu-id="ae431-868">将数据传递给线程过程的一种更可靠的方法是将线程过程和数据字段放入辅助角色对象。</span><span class="sxs-lookup"><span data-stu-id="ae431-868">A more robust way to pass data to a thread procedure is to put both the thread procedure and the data fields into a worker object.</span></span> <span data-ttu-id="ae431-869">有关详细信息，请参阅[在启动时创建线程和传递数据](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md)。</span><span class="sxs-lookup"><span data-stu-id="ae431-869">For more information, see [Creating Threads and Passing Data at Start Time](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-870">下面的示例使用静态方法和实例方法创建 <xref:System.Threading.ParameterizedThreadStart> 委托。</span><span class="sxs-lookup"><span data-stu-id="ae431-870">The following example creates a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.</span></span>  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="ae431-871">线程已启动。</span><span class="sxs-lookup"><span data-stu-id="ae431-871">The thread has already been started.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="ae431-872">内存不足，无法启动此线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-872">There is not enough memory available to start this thread.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ae431-873">该线程是使用 <see cref="T:System.Threading.ThreadStart" /> 委托而不是 <see cref="T:System.Threading.ParameterizedThreadStart" /> 委托创建的。</span><span class="sxs-lookup"><span data-stu-id="ae431-873">This thread was created using a <see cref="T:System.Threading.ThreadStart" /> delegate instead of a <see cref="T:System.Threading.ParameterizedThreadStart" /> delegate.</span></span></exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="ae431-874">创建线程</span><span class="sxs-lookup"><span data-stu-id="ae431-874">Creating Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberSignature Language="F#" Value="member this.Suspend : unit -&gt; unit" Usage="thread.Suspend " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ae431-875">挂起线程，或者如果线程已挂起，则不起作用。</span><span class="sxs-lookup"><span data-stu-id="ae431-875">Either suspends the thread, or if the thread is already suspended, has no effect.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-876">如果该线程已挂起，则此方法不起作用。</span><span class="sxs-lookup"><span data-stu-id="ae431-876">If the thread is already suspended, this method has no effect.</span></span>  
  
> [!CAUTION]
> <span data-ttu-id="ae431-877">不要使用 <xref:System.Threading.Thread.Suspend%2A> 和 <xref:System.Threading.Thread.Resume%2A> 方法来同步线程的活动。</span><span class="sxs-lookup"><span data-stu-id="ae431-877">Do not use the <xref:System.Threading.Thread.Suspend%2A> and <xref:System.Threading.Thread.Resume%2A> methods to synchronize the activities of threads.</span></span> <span data-ttu-id="ae431-878">您无法知道线程在挂起时正在执行的代码。</span><span class="sxs-lookup"><span data-stu-id="ae431-878">You have no way of knowing what code a thread is executing when you suspend it.</span></span> <span data-ttu-id="ae431-879">如果在安全权限评估过程中挂起一个处于锁定状态的线程，则 <xref:System.AppDomain> 中的其他线程可能会被阻止。</span><span class="sxs-lookup"><span data-stu-id="ae431-879">If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked.</span></span> <span data-ttu-id="ae431-880">如果在线程执行类构造函数时挂起线程，则会阻止 <xref:System.AppDomain> 中尝试使用该类的其他线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-880">If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked.</span></span> <span data-ttu-id="ae431-881">死锁可能会非常简单。</span><span class="sxs-lookup"><span data-stu-id="ae431-881">Deadlocks can occur very easily.</span></span>

<span data-ttu-id="ae431-882">当您对线程调用 `Suspend` 方法时，系统会注意到已请求线程挂起，并允许线程在实际挂起线程之前进入安全点之前执行。</span><span class="sxs-lookup"><span data-stu-id="ae431-882">When you call the `Suspend` method on a thread, the system notes that a thread suspension has been requested and allows the thread to execute until it reaches a safe point before actually suspending the thread.</span></span> <span data-ttu-id="ae431-883">线程的安全点是可以执行垃圾回收的执行点。</span><span class="sxs-lookup"><span data-stu-id="ae431-883">A safe point for a thread is a point in its execution at which garbage collection can be performed.</span></span> <span data-ttu-id="ae431-884">一旦达到安全点，运行时就会确保暂停的线程在托管代码中不会进一步取得任何进展。</span><span class="sxs-lookup"><span data-stu-id="ae431-884">Once a safe point is reached, the runtime guarantees that the suspended thread will not make any further progress in managed code.</span></span> <span data-ttu-id="ae431-885">在托管代码外部执行的线程始终都可以安全执行垃圾回收，并继续执行到尝试恢复执行托管代码。</span><span class="sxs-lookup"><span data-stu-id="ae431-885">A thread executing outside managed code is always safe for garbage collection, and its execution continues until it attempts to resume execution of managed code.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="ae431-886">仅限 .NET Core：不支持此成员。</span><span class="sxs-lookup"><span data-stu-id="ae431-886">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="ae431-887">线程尚未启动或已终止。</span><span class="sxs-lookup"><span data-stu-id="ae431-887">The thread has not been started or is dead.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="ae431-888">调用方没有适当的 <see cref="T:System.Security.Permissions.SecurityPermission" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-888">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ae431-889">用于线程的高级操作。</span><span class="sxs-lookup"><span data-stu-id="ae431-889">for advanced operations on threads.</span></span> <span data-ttu-id="ae431-890">关联的枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-890">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md"><span data-ttu-id="ae431-891">暂停和中断线程</span><span class="sxs-lookup"><span data-stu-id="ae431-891">Pausing and interrupting threads</span></span></related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="ae431-892">保留供将来使用。</span><span class="sxs-lookup"><span data-stu-id="ae431-892">Reserved for future use.</span></span> <span data-ttu-id="ae431-893">必须为 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="ae431-893">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="ae431-894">要映射的名称的传入数组。</span><span class="sxs-lookup"><span data-stu-id="ae431-894">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="ae431-895">要映射的名称的计数。</span><span class="sxs-lookup"><span data-stu-id="ae431-895">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="ae431-896">要在其中解释名称的区域设置上下文。</span><span class="sxs-lookup"><span data-stu-id="ae431-896">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="ae431-897">调用方分配的数组，用于接收与名称对应的 ID。</span><span class="sxs-lookup"><span data-stu-id="ae431-897">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="ae431-898">将一组名称映射为对应的一组调度标识符。</span><span class="sxs-lookup"><span data-stu-id="ae431-898">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-899">此方法用于从非托管代码访问托管类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="ae431-899">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="ae431-900">有关详细信息，请参阅[IDispatch：： idispatch.getidsofnames](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames)。</span><span class="sxs-lookup"><span data-stu-id="ae431-900">For more information, see [IDispatch::GetIDsOfNames](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="ae431-901">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-901">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="ae431-902">要返回的类型信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-902">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="ae431-903">类型信息的区域设置标识符。</span><span class="sxs-lookup"><span data-stu-id="ae431-903">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="ae431-904">接收一个指针，指向请求的类型信息对象。</span><span class="sxs-lookup"><span data-stu-id="ae431-904">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="ae431-905">检索对象的类型信息，然后可以使用该信息获取接口的类型信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-905">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-906">此方法用于从非托管代码访问托管类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="ae431-906">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="ae431-907">有关详细信息，请参阅[IDispatch：： GetTypeInfo](/windows/win32/api/oaidl/nf-oaidl-idispatch-gettypeinfo)。</span><span class="sxs-lookup"><span data-stu-id="ae431-907">For more information, see [IDispatch::GetTypeInfo](/windows/win32/api/oaidl/nf-oaidl-idispatch-gettypeinfo).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="ae431-908">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-908">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="ae431-909">指向一个位置，该位置接收对象提供的类型信息接口的数量。</span><span class="sxs-lookup"><span data-stu-id="ae431-909">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="ae431-910">检索对象提供的类型信息接口的数量（0 或 1）。</span><span class="sxs-lookup"><span data-stu-id="ae431-910">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-911">此方法用于从非托管代码访问托管类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="ae431-911">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="ae431-912">有关详细信息，请参阅[IDispatch：： GetTypeInfoCount](/windows/win32/api/oaidl/nf-oaidl-idispatch-gettypeinfocount)。</span><span class="sxs-lookup"><span data-stu-id="ae431-912">For more information, see [IDispatch::GetTypeInfoCount](/windows/win32/api/oaidl/nf-oaidl-idispatch-gettypeinfocount).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="ae431-913">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-913">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="ae431-914">标识成员。</span><span class="sxs-lookup"><span data-stu-id="ae431-914">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="ae431-915">保留供将来使用。</span><span class="sxs-lookup"><span data-stu-id="ae431-915">Reserved for future use.</span></span> <span data-ttu-id="ae431-916">必须为 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="ae431-916">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="ae431-917">要在其中解释自变量的区域设置上下文。</span><span class="sxs-lookup"><span data-stu-id="ae431-917">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="ae431-918">描述调用的上下文的标志。</span><span class="sxs-lookup"><span data-stu-id="ae431-918">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="ae431-919">指向一个结构的指针，该结构包含一个参数数组、一个命名参数的 DISPID 参数数组和数组中元素数的计数。</span><span class="sxs-lookup"><span data-stu-id="ae431-919">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="ae431-920">指向要存储结果的位置的指针。</span><span class="sxs-lookup"><span data-stu-id="ae431-920">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="ae431-921">指向一个包含异常信息的结构的指针。</span><span class="sxs-lookup"><span data-stu-id="ae431-921">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="ae431-922">第一个出错自变量的索引。</span><span class="sxs-lookup"><span data-stu-id="ae431-922">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="ae431-923">提供对某一对象公开的属性和方法的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-923">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-924">此方法用于从非托管代码访问托管类，不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="ae431-924">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="ae431-925">有关详细信息，请参阅[IDispatch：： Invoke](/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke)。</span><span class="sxs-lookup"><span data-stu-id="ae431-925">For more information, see [IDispatch::Invoke](/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="ae431-926">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-926">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Threading.ThreadState" Usage="System.Threading.Thread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ae431-927">获取一个值，该值包含当前线程的状态。</span><span class="sxs-lookup"><span data-stu-id="ae431-927">Gets a value containing the states of the current thread.</span></span></summary>
        <value><span data-ttu-id="ae431-928">其中一个表示当前线程的状态的 <see cref="T:System.Threading.ThreadState" /> 值。</span><span class="sxs-lookup"><span data-stu-id="ae431-928">One of the <see cref="T:System.Threading.ThreadState" /> values indicating the state of the current thread.</span></span> <span data-ttu-id="ae431-929">初始值为 <see cref="F:System.Threading.ThreadState.Unstarted" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-929">The initial value is <see cref="F:System.Threading.ThreadState.Unstarted" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-930"><xref:System.Threading.Thread.ThreadState%2A> 属性提供比 <xref:System.Threading.Thread.IsAlive%2A> 属性更具体的信息。</span><span class="sxs-lookup"><span data-stu-id="ae431-930">The <xref:System.Threading.Thread.ThreadState%2A> property provides more specific information than the <xref:System.Threading.Thread.IsAlive%2A> property.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ae431-931">线程状态仅对调试方案很有用。</span><span class="sxs-lookup"><span data-stu-id="ae431-931">Thread state is only of interest in debugging scenarios.</span></span> <span data-ttu-id="ae431-932">因此，始终不应在代码中使用线程状态来同步线程活动。</span><span class="sxs-lookup"><span data-stu-id="ae431-932">Your code should never use thread state to synchronize the activities of threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-933">下面的代码示例演示如何访问线程的 `ThreadState`。</span><span class="sxs-lookup"><span data-stu-id="ae431-933">The following code example demonstrates accessing the `ThreadState` of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.TrySetApartmentState : System.Threading.ApartmentState -&gt; bool" Usage="thread.TrySetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="state"><span data-ttu-id="ae431-934">新的单元状态。</span><span class="sxs-lookup"><span data-stu-id="ae431-934">The new apartment state.</span></span></param>
        <summary><span data-ttu-id="ae431-935">在线程启动前设置其单元状态。</span><span class="sxs-lookup"><span data-stu-id="ae431-935">Sets the apartment state of a thread before it is started.</span></span></summary>
        <returns><span data-ttu-id="ae431-936">如果设置了单元状态，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-936"><see langword="true" /> if the apartment state is set; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-937">如果新线程的单元状态在启动之前尚未设置，则会将其初始化为 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ae431-937">New threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="ae431-938">必须在启动线程之前设置单元状态。</span><span class="sxs-lookup"><span data-stu-id="ae431-938">Apartment state must be set before a thread is started.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-939">默认情况下，主应用程序线程初始化为 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ae431-939">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="ae431-940">将主应用程序线程的单元状态设置为 <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> 的唯一方法是将 <xref:System.STAThreadAttribute> 属性应用于入口点方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-940">The only way to set the apartment state of the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> is to apply the <xref:System.STAThreadAttribute> attribute to the entry point method.</span></span>  
  
 <span data-ttu-id="ae431-941"><xref:System.Threading.Thread.TrySetApartmentState%2A> 方法与 <xref:System.Threading.Thread.GetApartmentState%2A> 方法和 <xref:System.Threading.Thread.SetApartmentState%2A> 方法一起替换 <xref:System.Threading.Thread.ApartmentState%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="ae431-941">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method, along with the <xref:System.Threading.Thread.GetApartmentState%2A> method and the <xref:System.Threading.Thread.SetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ae431-942">下面的代码示例演示 <xref:System.Threading.Thread.GetApartmentState%2A>、<xref:System.Threading.Thread.SetApartmentState%2A>和 <xref:System.Threading.Thread.TrySetApartmentState%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-942">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="ae431-943">此代码示例创建一个线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-943">The code example creates a thread.</span></span> <span data-ttu-id="ae431-944">启动线程之前，<xref:System.Threading.Thread.GetApartmentState%2A> 显示初始 <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> 状态，<xref:System.Threading.Thread.SetApartmentState%2A> 将状态更改为 <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ae431-944">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ae431-945">当尝试将状态更改为 <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> 时，<xref:System.Threading.Thread.TrySetApartmentState%2A> 方法返回 `false`，因为已设置了单元状态。</span><span class="sxs-lookup"><span data-stu-id="ae431-945">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="ae431-946">如果已尝试 <xref:System.Threading.Thread.SetApartmentState%2A>相同的操作，则会引发 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="ae431-946">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="ae431-947">线程启动后，将再次使用 <xref:System.Threading.Thread.TrySetApartmentState%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-947">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="ae431-948">这次会引发 <xref:System.Threading.ThreadStateException>，因为该线程已启动。</span><span class="sxs-lookup"><span data-stu-id="ae431-948">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="ae431-949">仅限 .NET Core：macOS 和 Linux 平台上不支持此成员。</span><span class="sxs-lookup"><span data-stu-id="ae431-949">.NET Core only: This member is not supported on the macOS and Linux platforms.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ae431-950"><paramref name="state" /> 不是有效的单元状态。</span><span class="sxs-lookup"><span data-stu-id="ae431-950"><paramref name="state" /> is not a valid apartment state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="ae431-951">线程曾启动但已终止，或未在线程运行时从线程的上下文中进行调用。</span><span class="sxs-lookup"><span data-stu-id="ae431-951">The thread was started and has terminated, or the call is not being made from the thread's context while the thread is running.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ae431-952">读取字段值。</span><span class="sxs-lookup"><span data-stu-id="ae431-952">Reads the value of a field.</span></span> <span data-ttu-id="ae431-953">无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-953">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : byte -&gt; byte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-954">要读取的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-954">The field to be read.</span></span></param>
        <summary><span data-ttu-id="ae431-955">读取字段值。</span><span class="sxs-lookup"><span data-stu-id="ae431-955">Reads the value of a field.</span></span> <span data-ttu-id="ae431-956">无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-956">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="ae431-957">由任何处理器写入字段的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-957">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-958"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-958"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-959">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-959">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-960">在多处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 获取由任何处理器写入内存位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-960">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="ae431-961">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-961">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-962">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-962">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-963">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-963">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-964">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-964">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-965">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-965">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-966">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-966">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : double -&gt; double" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-967">要读取的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-967">The field to be read.</span></span></param>
        <summary><span data-ttu-id="ae431-968">读取字段值。</span><span class="sxs-lookup"><span data-stu-id="ae431-968">Reads the value of a field.</span></span> <span data-ttu-id="ae431-969">无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-969">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="ae431-970">由任何处理器写入字段的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-970">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-971"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-971"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-972">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-972">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-973">在多处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 获取由任何处理器写入内存位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-973">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="ae431-974">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-974">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-975">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-975">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-976">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-976">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-977">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-977">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-978">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-978">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-979">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-979">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : int16 -&gt; int16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-980">要读取的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-980">The field to be read.</span></span></param>
        <summary><span data-ttu-id="ae431-981">读取字段值。</span><span class="sxs-lookup"><span data-stu-id="ae431-981">Reads the value of a field.</span></span> <span data-ttu-id="ae431-982">无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-982">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="ae431-983">由任何处理器写入字段的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-983">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-984"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-984"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-985">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-985">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-986">在多处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 获取由任何处理器写入内存位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-986">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="ae431-987">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-987">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-988">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-988">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-989">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-989">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-990">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-990">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-991">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-991">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-992">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-992">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : int -&gt; int" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-993">要读取的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-993">The field to be read.</span></span></param>
        <summary><span data-ttu-id="ae431-994">读取字段值。</span><span class="sxs-lookup"><span data-stu-id="ae431-994">Reads the value of a field.</span></span> <span data-ttu-id="ae431-995">无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-995">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="ae431-996">由任何处理器写入字段的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-996">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-997"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-997"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-998">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-998">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-999">在多处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 获取由任何处理器写入内存位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-999">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="ae431-1000">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-1000">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-1001">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-1001">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-1002">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1002">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-1003">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1003">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-1004">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1004">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-1005">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1005">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : int64 -&gt; int64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-1006">要读取的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-1006">The field to be read.</span></span></param>
        <summary><span data-ttu-id="ae431-1007">读取字段值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1007">Reads the value of a field.</span></span> <span data-ttu-id="ae431-1008">无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1008">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="ae431-1009">由任何处理器写入字段的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1009">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-1010"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-1010"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-1011">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-1011">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-1012">在多处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 获取由任何处理器写入内存位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1012">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="ae431-1013">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-1013">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-1014">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-1014">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-1015">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1015">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-1016">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1016">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-1017">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1017">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-1018">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1018">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : nativeint -&gt; nativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-1019">要读取的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-1019">The field to be read.</span></span></param>
        <summary><span data-ttu-id="ae431-1020">读取字段值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1020">Reads the value of a field.</span></span> <span data-ttu-id="ae431-1021">无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1021">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="ae431-1022">由任何处理器写入字段的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1022">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-1023"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-1023"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-1024">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-1024">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-1025">在多处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 获取由任何处理器写入内存位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1025">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="ae431-1026">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-1026">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-1027">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-1027">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-1028">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1028">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-1029">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1029">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-1030">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1030">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-1031">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1031">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : obj -&gt; obj" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-1032">要读取的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-1032">The field to be read.</span></span></param>
        <summary><span data-ttu-id="ae431-1033">读取字段值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1033">Reads the value of a field.</span></span> <span data-ttu-id="ae431-1034">无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1034">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="ae431-1035">由任何处理器写入字段的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1035">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-1036"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-1036"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-1037">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-1037">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-1038">在多处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 获取由任何处理器写入内存位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1038">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="ae431-1039">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-1039">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-1040">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-1040">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-1041">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1041">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-1042">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1042">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-1043">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1043">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-1044">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1044">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : sbyte -&gt; sbyte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-1045">要读取的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-1045">The field to be read.</span></span></param>
        <summary><span data-ttu-id="ae431-1046">读取字段值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1046">Reads the value of a field.</span></span> <span data-ttu-id="ae431-1047">无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1047">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="ae431-1048">由任何处理器写入字段的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1048">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-1049"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-1049"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-1050">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-1050">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-1051">在多处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 获取由任何处理器写入内存位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1051">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="ae431-1052">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-1052">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-1053">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-1053">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-1054">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1054">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-1055">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1055">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-1056">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1056">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-1057">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1057">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : single -&gt; single" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-1058">要读取的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-1058">The field to be read.</span></span></param>
        <summary><span data-ttu-id="ae431-1059">读取字段值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1059">Reads the value of a field.</span></span> <span data-ttu-id="ae431-1060">无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1060">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="ae431-1061">由任何处理器写入字段的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1061">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-1062"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-1062"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-1063">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-1063">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-1064">在多处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 获取由任何处理器写入内存位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1064">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="ae431-1065">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-1065">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-1066">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-1066">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-1067">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1067">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-1068">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1068">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-1069">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1069">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-1070">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1070">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : uint16 -&gt; uint16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-1071">要读取的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-1071">The field to be read.</span></span></param>
        <summary><span data-ttu-id="ae431-1072">读取字段值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1072">Reads the value of a field.</span></span> <span data-ttu-id="ae431-1073">无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1073">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="ae431-1074">由任何处理器写入字段的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1074">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-1075"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-1075"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-1076">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-1076">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-1077">在多处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 获取由任何处理器写入内存位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1077">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="ae431-1078">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-1078">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-1079">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-1079">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-1080">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1080">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-1081">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1081">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-1082">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1082">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-1083">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1083">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : uint32 -&gt; uint32" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-1084">要读取的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-1084">The field to be read.</span></span></param>
        <summary><span data-ttu-id="ae431-1085">读取字段值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1085">Reads the value of a field.</span></span> <span data-ttu-id="ae431-1086">无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1086">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="ae431-1087">由任何处理器写入字段的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1087">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-1088"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-1088"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-1089">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-1089">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-1090">在多处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 获取由任何处理器写入内存位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1090">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="ae431-1091">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-1091">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-1092">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-1092">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-1093">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1093">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-1094">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1094">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-1095">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1095">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-1096">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1096">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : uint64 -&gt; uint64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-1097">要读取的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-1097">The field to be read.</span></span></param>
        <summary><span data-ttu-id="ae431-1098">读取字段值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1098">Reads the value of a field.</span></span> <span data-ttu-id="ae431-1099">无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1099">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="ae431-1100">由任何处理器写入字段的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1100">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-1101"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-1101"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-1102">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-1102">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-1103">在多处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 获取由任何处理器写入内存位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1103">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="ae431-1104">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-1104">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-1105">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-1105">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-1106">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1106">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-1107">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1107">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-1108">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1108">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-1109">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1109">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : unativeint -&gt; unativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-1110">要读取的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-1110">The field to be read.</span></span></param>
        <summary><span data-ttu-id="ae431-1111">读取字段值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1111">Reads the value of a field.</span></span> <span data-ttu-id="ae431-1112">无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1112">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="ae431-1113">由任何处理器写入字段的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1113">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-1114"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-1114"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-1115">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-1115">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-1116">在多处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 获取由任何处理器写入内存位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1116">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="ae431-1117">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-1117">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-1118">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-1118">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-1119">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1119">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-1120">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1120">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-1121">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1121">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-1122">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1122">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ae431-1123">立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1123">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : byte * byte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Byte" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-1124">将向其中写入值的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-1124">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="ae431-1125">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1125">The value to be written.</span></span></param>
        <summary><span data-ttu-id="ae431-1126">立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1126">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-1127"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-1127"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-1128">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-1128">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-1129">在多处理器系统上，<xref:System.Threading.Thread.VolatileWrite%2A> 确保写入内存位置的值立即对所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1129">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="ae431-1130">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-1130">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-1131">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-1131">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-1132">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1132">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-1133">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1133">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-1134">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1134">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-1135">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1135">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : double * double -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-1136">将向其中写入值的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-1136">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="ae431-1137">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1137">The value to be written.</span></span></param>
        <summary><span data-ttu-id="ae431-1138">立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1138">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-1139"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-1139"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-1140">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-1140">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-1141">在多处理器系统上，<xref:System.Threading.Thread.VolatileWrite%2A> 确保写入内存位置的值立即对所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1141">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="ae431-1142">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-1142">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-1143">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-1143">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-1144">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1144">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-1145">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1145">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-1146">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1146">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-1147">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1147">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : int16 * int16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Int16" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-1148">将向其中写入值的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-1148">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="ae431-1149">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1149">The value to be written.</span></span></param>
        <summary><span data-ttu-id="ae431-1150">立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1150">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-1151"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-1151"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-1152">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-1152">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-1153">在多处理器系统上，<xref:System.Threading.Thread.VolatileWrite%2A> 确保写入内存位置的值立即对所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1153">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="ae431-1154">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-1154">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-1155">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-1155">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-1156">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1156">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-1157">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1157">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-1158">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1158">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-1159">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1159">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : int * int -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-1160">将向其中写入值的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-1160">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="ae431-1161">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1161">The value to be written.</span></span></param>
        <summary><span data-ttu-id="ae431-1162">立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1162">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-1163"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-1163"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-1164">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-1164">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-1165">在多处理器系统上，<xref:System.Threading.Thread.VolatileWrite%2A> 确保写入内存位置的值立即对所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1165">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="ae431-1166">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-1166">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-1167">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-1167">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-1168">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1168">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-1169">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1169">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-1170">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1170">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-1171">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1171">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : int64 * int64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-1172">将向其中写入值的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-1172">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="ae431-1173">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1173">The value to be written.</span></span></param>
        <summary><span data-ttu-id="ae431-1174">立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1174">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-1175"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-1175"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-1176">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-1176">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-1177">在多处理器系统上，<xref:System.Threading.Thread.VolatileWrite%2A> 确保写入内存位置的值立即对所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1177">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="ae431-1178">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-1178">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-1179">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-1179">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-1180">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1180">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-1181">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1181">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-1182">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1182">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-1183">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1183">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : nativeint * nativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.IntPtr" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-1184">将向其中写入值的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-1184">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="ae431-1185">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1185">The value to be written.</span></span></param>
        <summary><span data-ttu-id="ae431-1186">立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1186">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-1187"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-1187"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-1188">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-1188">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-1189">在多处理器系统上，<xref:System.Threading.Thread.VolatileWrite%2A> 确保写入内存位置的值立即对所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1189">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="ae431-1190">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-1190">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-1191">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-1191">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-1192">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1192">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-1193">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1193">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-1194">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1194">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-1195">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1195">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : obj * obj -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-1196">将向其中写入值的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-1196">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="ae431-1197">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1197">The value to be written.</span></span></param>
        <summary><span data-ttu-id="ae431-1198">立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1198">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-1199"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-1199"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-1200">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-1200">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-1201">在多处理器系统上，<xref:System.Threading.Thread.VolatileWrite%2A> 确保写入内存位置的值立即对所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1201">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="ae431-1202">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-1202">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-1203">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-1203">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-1204">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1204">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-1205">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1205">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-1206">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1206">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-1207">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1207">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : sbyte * sbyte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.SByte" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-1208">将向其中写入值的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-1208">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="ae431-1209">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1209">The value to be written.</span></span></param>
        <summary><span data-ttu-id="ae431-1210">立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1210">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-1211"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-1211"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-1212">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-1212">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-1213">在多处理器系统上，<xref:System.Threading.Thread.VolatileWrite%2A> 确保写入内存位置的值立即对所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1213">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="ae431-1214">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-1214">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-1215">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-1215">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-1216">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1216">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-1217">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1217">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-1218">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1218">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-1219">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1219">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : single * single -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-1220">将向其中写入值的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-1220">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="ae431-1221">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1221">The value to be written.</span></span></param>
        <summary><span data-ttu-id="ae431-1222">立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1222">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-1223"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-1223"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-1224">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-1224">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-1225">在多处理器系统上，<xref:System.Threading.Thread.VolatileWrite%2A> 确保写入内存位置的值立即对所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1225">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="ae431-1226">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-1226">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-1227">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-1227">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-1228">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1228">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-1229">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1229">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-1230">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1230">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-1231">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1231">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : uint16 * uint16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.UInt16" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-1232">将向其中写入值的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-1232">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="ae431-1233">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1233">The value to be written.</span></span></param>
        <summary><span data-ttu-id="ae431-1234">立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1234">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-1235"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-1235"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-1236">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-1236">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-1237">在多处理器系统上，<xref:System.Threading.Thread.VolatileWrite%2A> 确保写入内存位置的值立即对所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1237">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="ae431-1238">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-1238">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-1239">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-1239">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-1240">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1240">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-1241">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1241">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-1242">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1242">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-1243">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1243">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : uint32 * uint32 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.UInt32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-1244">将向其中写入值的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-1244">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="ae431-1245">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1245">The value to be written.</span></span></param>
        <summary><span data-ttu-id="ae431-1246">立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1246">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-1247"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-1247"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-1248">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-1248">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-1249">在多处理器系统上，<xref:System.Threading.Thread.VolatileWrite%2A> 确保写入内存位置的值立即对所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1249">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="ae431-1250">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-1250">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-1251">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-1251">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-1252">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1252">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-1253">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1253">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-1254">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1254">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-1255">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1255">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : uint64 * uint64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.UInt64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-1256">将向其中写入值的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-1256">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="ae431-1257">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1257">The value to be written.</span></span></param>
        <summary><span data-ttu-id="ae431-1258">立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1258">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-1259"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-1259"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-1260">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-1260">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-1261">在多处理器系统上，<xref:System.Threading.Thread.VolatileWrite%2A> 确保写入内存位置的值立即对所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1261">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="ae431-1262">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-1262">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-1263">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-1263">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-1264">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1264">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-1265">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1265">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-1266">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1266">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-1267">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1267">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : unativeint * unativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.UIntPtr" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="ae431-1268">将向其中写入值的字段。</span><span class="sxs-lookup"><span data-stu-id="ae431-1268">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="ae431-1269">要写入的值。</span><span class="sxs-lookup"><span data-stu-id="ae431-1269">The value to be written.</span></span></param>
        <summary><span data-ttu-id="ae431-1270">立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1270">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-1271"><xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 适用于同步的特殊情况。</span><span class="sxs-lookup"><span data-stu-id="ae431-1271"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="ae431-1272">正常情况下， C# `lock` 语句、Visual Basic `SyncLock` 语句和 <xref:System.Threading.Monitor> 类提供更简单的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ae431-1272">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="ae431-1273">在多处理器系统上，<xref:System.Threading.Thread.VolatileWrite%2A> 确保写入内存位置的值立即对所有处理器都可见。</span><span class="sxs-lookup"><span data-stu-id="ae431-1273">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="ae431-1274">这可能需要刷新处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="ae431-1274">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="ae431-1275">即使在单处理器系统上，<xref:System.Threading.Thread.VolatileRead%2A> 和 <xref:System.Threading.Thread.VolatileWrite%2A> 确保将值读取或写入内存，而不缓存（例如，在处理器寄存器中）。</span><span class="sxs-lookup"><span data-stu-id="ae431-1275">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="ae431-1276">因此，您可以使用它们来同步对可以由其他线程或硬件更新的字段的访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1276">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="ae431-1277">调用此方法只会影响单个内存访问。</span><span class="sxs-lookup"><span data-stu-id="ae431-1277">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="ae431-1278">若要为字段提供有效同步，对字段的所有访问都必须使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1278">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ae431-1279">在C#中，对字段使用 `volatile` 修饰符可保证对该字段的所有访问都使用 <xref:System.Threading.Thread.VolatileRead%2A> 或 <xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="ae431-1279">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; bool" Usage="System.Threading.Thread.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ae431-1280">导致调用线程执行准备好在当前处理器上运行的另一个线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-1280">Causes the calling thread to yield execution to another thread that is ready to run on the current processor.</span></span> <span data-ttu-id="ae431-1281">由操作系统选择要执行的线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-1281">The operating system selects the thread to yield to.</span></span></summary>
        <returns><span data-ttu-id="ae431-1282">如果操作系统转而执行另一个线程，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ae431-1282"><see langword="true" /> if the operating system switched execution to another thread; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ae431-1283">如果此方法成功，则会生成线程当前时间片的剩余部分。</span><span class="sxs-lookup"><span data-stu-id="ae431-1283">If this method succeeds, the rest of the thread's current time slice is yielded.</span></span> <span data-ttu-id="ae431-1284">操作系统根据其优先级和其他可运行的线程的状态，为另一个时间段计划调用线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-1284">The operating system schedules the calling thread for another time slice, according to its priority and the status of other threads that are available to run.</span></span>  
  
 <span data-ttu-id="ae431-1285">生成仅限于执行调用线程的处理器。</span><span class="sxs-lookup"><span data-stu-id="ae431-1285">Yielding is limited to the processor that is executing the calling thread.</span></span> <span data-ttu-id="ae431-1286">操作系统不会将执行切换到另一个处理器，即使该处理器处于空闲状态或正在运行较低优先级的线程。</span><span class="sxs-lookup"><span data-stu-id="ae431-1286">The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority.</span></span> <span data-ttu-id="ae431-1287">如果没有其他线程准备好在当前处理器上执行，操作系统将不会执行，并且此方法返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="ae431-1287">If there are no other threads that are ready to execute on the current processor, the operating system does not yield execution, and this method returns `false`.</span></span>  
  
 <span data-ttu-id="ae431-1288">此方法等效于使用平台调用来调用本机 Win32 `SwitchToThread` 函数。</span><span class="sxs-lookup"><span data-stu-id="ae431-1288">This method is equivalent to using platform invoke to call the native Win32 `SwitchToThread` function.</span></span> <span data-ttu-id="ae431-1289">应调用 <xref:System.Threading.Thread.Yield%2A> 方法，而不是使用平台调用，因为平台调用会绕过主机请求的任何自定义线程行为。</span><span class="sxs-lookup"><span data-stu-id="ae431-1289">You should call the <xref:System.Threading.Thread.Yield%2A> method instead of using platform invoke, because platform invoke bypasses any custom threading behavior the host has requested.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
