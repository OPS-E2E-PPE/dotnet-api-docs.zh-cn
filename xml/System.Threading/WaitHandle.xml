<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="107e6ef6e51385d5827461c353aa32b70f721838" /><Meta Name="ms.sourcegitcommit" Value="1403e40e1f487577d6846a42664d2e74b78a08b7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="01/29/2020" /><Meta Name="ms.locfileid" Value="76824749" /></Metadata><TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="f330e-101">封装等待对共享资源进行独占访问的操作系统特定的对象。</span><span class="sxs-lookup"><span data-stu-id="f330e-101">Encapsulates operating system-specific objects that wait for exclusive access to shared resources.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-102"><xref:System.Threading.WaitHandle> 类封装本机操作系统同步句柄，并用于表示运行时中允许多个等待操作的所有同步对象。</span><span class="sxs-lookup"><span data-stu-id="f330e-102">The <xref:System.Threading.WaitHandle> class encapsulates a native operating system synchronization handle and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</span></span> <span data-ttu-id="f330e-103">有关等待句柄与其他同步对象的比较，请参阅[同步基元概述](~/docs/standard/threading/overview-of-synchronization-primitives.md)。</span><span class="sxs-lookup"><span data-stu-id="f330e-103">For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="f330e-104"><xref:System.Threading.WaitHandle> 类本身是抽象的。</span><span class="sxs-lookup"><span data-stu-id="f330e-104">The <xref:System.Threading.WaitHandle> class itself is abstract.</span></span> <span data-ttu-id="f330e-105">派生自 <xref:System.Threading.WaitHandle> 的类定义用于指示获取或释放对共享资源的访问权限的信号机制，但它们使用继承的 <xref:System.Threading.WaitHandle> 方法在等待访问共享资源时被阻止。</span><span class="sxs-lookup"><span data-stu-id="f330e-105">Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources.</span></span> <span data-ttu-id="f330e-106">派生自 <xref:System.Threading.WaitHandle> 的类包括：</span><span class="sxs-lookup"><span data-stu-id="f330e-106">The classes derived from <xref:System.Threading.WaitHandle> include:</span></span>  
  
-   <span data-ttu-id="f330e-107"><xref:System.Threading.Mutex> 类。</span><span class="sxs-lookup"><span data-stu-id="f330e-107">The <xref:System.Threading.Mutex> class.</span></span> <span data-ttu-id="f330e-108">请参阅[mutex](~/docs/standard/threading/mutexes.md)。</span><span class="sxs-lookup"><span data-stu-id="f330e-108">See [Mutexes](~/docs/standard/threading/mutexes.md).</span></span>  
  
-   <span data-ttu-id="f330e-109"><xref:System.Threading.EventWaitHandle> 类及其派生类 <xref:System.Threading.AutoResetEvent> 和 <xref:System.Threading.ManualResetEvent>。</span><span class="sxs-lookup"><span data-stu-id="f330e-109">The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span>  
  
-   <span data-ttu-id="f330e-110"><xref:System.Threading.Semaphore> 类。</span><span class="sxs-lookup"><span data-stu-id="f330e-110">The <xref:System.Threading.Semaphore> class.</span></span> <span data-ttu-id="f330e-111">请参阅[信号灯和 SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md)。</span><span class="sxs-lookup"><span data-stu-id="f330e-111">See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="f330e-112">线程可以通过调用实例方法来阻止单个等待句柄，该方法由派生自 <xref:System.Threading.WaitHandle>的类继承 <xref:System.Threading.WaitHandle.WaitOne%2A>。</span><span class="sxs-lookup"><span data-stu-id="f330e-112">Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.</span></span>  
  
 <span data-ttu-id="f330e-113"><xref:System.Threading.WaitHandle> 的派生类在其线程关联中有所不同。</span><span class="sxs-lookup"><span data-stu-id="f330e-113">The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity.</span></span> <span data-ttu-id="f330e-114">事件等待句柄（<xref:System.Threading.EventWaitHandle>、<xref:System.Threading.AutoResetEvent>和 <xref:System.Threading.ManualResetEvent>）和信号量不具有线程关联;任何线程都可以通知事件等待句柄或信号量。</span><span class="sxs-lookup"><span data-stu-id="f330e-114">Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</span></span> <span data-ttu-id="f330e-115">另一方面，互斥体确实具有线程关联;拥有互斥体的线程必须释放它，如果线程对不属于它的互斥体调用 <xref:System.Threading.Mutex.ReleaseMutex%2A> 方法，则将引发异常。</span><span class="sxs-lookup"><span data-stu-id="f330e-115">Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.</span></span>  
  
 <span data-ttu-id="f330e-116">由于 <xref:System.Threading.WaitHandle> 类派生自 <xref:System.MarshalByRefObject>，因此这些类可用于跨应用程序域边界同步线程的活动。</span><span class="sxs-lookup"><span data-stu-id="f330e-116">Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="f330e-117">除派生类外，<xref:System.Threading.WaitHandle> 类还具有许多静态方法，这些方法阻止线程，直到一个或多个同步对象收到信号。</span><span class="sxs-lookup"><span data-stu-id="f330e-117">In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal.</span></span> <span data-ttu-id="f330e-118">这些方法包括：</span><span class="sxs-lookup"><span data-stu-id="f330e-118">These include:</span></span>  
  
-   <span data-ttu-id="f330e-119"><xref:System.Threading.WaitHandle.SignalAndWait%2A>，它允许线程向一个等待句柄发出信号，并立即等待另一个等待句柄。</span><span class="sxs-lookup"><span data-stu-id="f330e-119"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.</span></span>  
  
-   <span data-ttu-id="f330e-120"><xref:System.Threading.WaitHandle.WaitAll%2A>，它允许线程等待，直到数组中的所有等待句柄都收到信号。</span><span class="sxs-lookup"><span data-stu-id="f330e-120"><xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.</span></span>  
  
-   <span data-ttu-id="f330e-121"><xref:System.Threading.WaitHandle.WaitAny%2A>，它允许线程等待，直到指定的一组等待句柄发出信号。</span><span class="sxs-lookup"><span data-stu-id="f330e-121"><xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled.</span></span>  
  
 <span data-ttu-id="f330e-122">这些方法的重载提供了放弃等待的超时间隔，以及在进入等待前退出同步上下文的机会，从而允许其他线程使用同步上下文。</span><span class="sxs-lookup"><span data-stu-id="f330e-122">The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f330e-123">此类型实现 <xref:System.IDisposable> 接口。</span><span class="sxs-lookup"><span data-stu-id="f330e-123">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="f330e-124">使用完类型或派生自该类型的类型后，应直接或间接释放它。</span><span class="sxs-lookup"><span data-stu-id="f330e-124">When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="f330e-125">若要直接释放类型，请在 `try`/`catch` 块中调用其 <xref:System.Threading.WaitHandle.Close%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f330e-125">To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="f330e-126">若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。</span><span class="sxs-lookup"><span data-stu-id="f330e-126">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="f330e-127">有关详细信息，请参阅 <xref:System.IDisposable> 接口主题中的“使用实现 IDisposable 的对象”一节。</span><span class="sxs-lookup"><span data-stu-id="f330e-127">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="f330e-128"><xref:System.Threading.WaitHandle> 实现 <xref:System.IDisposable.Dispose%2A> 模式。</span><span class="sxs-lookup"><span data-stu-id="f330e-128"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="f330e-129">请参阅 [实现 Dispose 方法] （~/docs/standard/garbage-collection/implementing-dispose）。</span><span class="sxs-lookup"><span data-stu-id="f330e-129">See [Implementing a Dispose method](~/docs/standard/garbage-collection/implementing-dispose .md).</span></span> <span data-ttu-id="f330e-130">从 <xref:System.Threading.WaitHandle>派生时，使用 <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> 属性存储本机操作系统句柄。</span><span class="sxs-lookup"><span data-stu-id="f330e-130">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native operating system handle.</span></span> <span data-ttu-id="f330e-131">除非使用其他非托管资源，否则不需要重写受保护的 <xref:System.Threading.WaitHandle.Dispose%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f330e-131">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f330e-132">下面的代码示例演示两个线程如何在主线程使用 <xref:System.Threading.WaitHandle> 类的静态 <xref:System.Threading.WaitHandle.WaitAny%2A> 和 <xref:System.Threading.WaitHandle.WaitAll%2A> 方法等待任务完成时执行后台任务。</span><span class="sxs-lookup"><span data-stu-id="f330e-132">The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="f330e-133">此类型是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="f330e-133">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="f330e-134">线程</span><span class="sxs-lookup"><span data-stu-id="f330e-134">Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md"><span data-ttu-id="f330e-135">线程处理对象和功能</span><span class="sxs-lookup"><span data-stu-id="f330e-135">Threading Objects and Features</span></span></related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="f330e-136">Mutexes</span><span class="sxs-lookup"><span data-stu-id="f330e-136">Mutexes</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d"><span data-ttu-id="f330e-137">EventWaitHandle、AutoResetEvent 和 anualResetEvent</span><span class="sxs-lookup"><span data-stu-id="f330e-137">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span></span></related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="f330e-138">信号量</span><span class="sxs-lookup"><span data-stu-id="f330e-138">Semaphores</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public WaitHandle ();" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WaitHandle();" FrameworkAlternate="netframework-1.1" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f330e-139">初始化 <see cref="T:System.Threading.WaitHandle" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="f330e-139">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f330e-140">释放由当前 <see cref="T:System.Threading.WaitHandle" /> 占用的所有资源。</span><span class="sxs-lookup"><span data-stu-id="f330e-140">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-141">此方法是 <xref:System.Threading.WaitHandle> 类及其派生类的 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> 方法的公共实现。</span><span class="sxs-lookup"><span data-stu-id="f330e-141">This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method for the <xref:System.Threading.WaitHandle> class and its derived classes.</span></span> <span data-ttu-id="f330e-142">它提供了一个标准实现，该实现使用 `true` 参数调用 `Dispose(Boolean)` 重载，然后调用 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="f330e-142">It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f330e-143">调用此方法可释放 `WaitHandle` 或派生类的实例所持有的所有资源。</span><span class="sxs-lookup"><span data-stu-id="f330e-143">Call this method to release all resources held by an instance of `WaitHandle` or a derived class.</span></span>  
  
 <span data-ttu-id="f330e-144">调用此方法后，对当前实例的引用将导致未定义的行为。</span><span class="sxs-lookup"><span data-stu-id="f330e-144">Once this method is called, references to the current instance cause undefined behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f330e-145">在释放对 <xref:System.Threading.WaitHandle>的最后一个引用之前，请始终调用 <xref:System.Threading.WaitHandle.Close%2A> 或 <xref:System.Threading.WaitHandle.Dispose>。</span><span class="sxs-lookup"><span data-stu-id="f330e-145">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="f330e-146">否则，将不会释放它所使用的资源。</span><span class="sxs-lookup"><span data-stu-id="f330e-146">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="f330e-147">应重写 <see langword="Dispose(Boolean)" /> 方法，以释放派生类中分配的资源。</span><span class="sxs-lookup"><span data-stu-id="f330e-147">You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</span></span></para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md"><span data-ttu-id="f330e-148">实现 Dispose 方法</span><span class="sxs-lookup"><span data-stu-id="f330e-148">Implementing a Dispose Method</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f330e-149">释放 <see cref="T:System.Threading.WaitHandle" /> 类的当前实例所使用的所有资源。</span><span class="sxs-lookup"><span data-stu-id="f330e-149">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f330e-150">释放 <see cref="T:System.Threading.WaitHandle" /> 类的当前实例所使用的所有资源。</span><span class="sxs-lookup"><span data-stu-id="f330e-150">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-151">此方法等效于 <xref:System.Threading.WaitHandle.Close%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f330e-151">This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f330e-152">在释放对 <xref:System.Threading.WaitHandle>的最后一个引用之前，请始终调用 <xref:System.Threading.WaitHandle.Close%2A> 或 <xref:System.Threading.WaitHandle.Dispose>。</span><span class="sxs-lookup"><span data-stu-id="f330e-152">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="f330e-153">否则，将不会释放它所使用的资源。</span><span class="sxs-lookup"><span data-stu-id="f330e-153">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md"><span data-ttu-id="f330e-154">清理非托管资源</span><span class="sxs-lookup"><span data-stu-id="f330e-154">Cleaning Up Unmanaged Resources</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing"><span data-ttu-id="f330e-155"><see langword="true" /> 表示释放托管资源和非托管资源；<see langword="false" /> 表示仅释放非托管资源。</span><span class="sxs-lookup"><span data-stu-id="f330e-155"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="f330e-156">当在派生类中重写时，释放 <see cref="T:System.Threading.WaitHandle" /> 使用的非托管资源，并且可选择释放托管资源。</span><span class="sxs-lookup"><span data-stu-id="f330e-156">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-157">此方法由 <xref:System.Threading.WaitHandle.Close%2A> 和 <xref:System.Threading.WaitHandle.Dispose> 方法调用，其 `explicitDisposing` 参数设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="f330e-157">This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.</span></span>  <span data-ttu-id="f330e-158">当 `true``explicitDisposing` 参数时，此方法将释放此 <xref:System.Threading.WaitHandle> 对象引用的任何托管对象所持有的所有资源。</span><span class="sxs-lookup"><span data-stu-id="f330e-158">When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="f330e-159">应重写 <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> 方法，以释放派生类中分配的资源。</span><span class="sxs-lookup"><span data-stu-id="f330e-159">You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.</span></span>  
  
<span data-ttu-id="f330e-160"><see cref="M:System.Threading.WaitHandle.Close" /> 或 <see cref="M:System.Threading.WaitHandle.Dispose" /> 方法可由其他对象多次调用。</span><span class="sxs-lookup"><span data-stu-id="f330e-160">The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects.</span></span> <span data-ttu-id="f330e-161">重写此方法时，请注意不要引用先前在调用 <see langword="Dispose" /> 或 <see langword="Close" />之前已释放的对象。</span><span class="sxs-lookup"><span data-stu-id="f330e-161">When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</span></span></para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md"><span data-ttu-id="f330e-162">实现 Dispose 方法</span><span class="sxs-lookup"><span data-stu-id="f330e-162">Implementing a Dispose Method</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f330e-163">释放由当前实例所持有的资源。</span><span class="sxs-lookup"><span data-stu-id="f330e-163">Releases the resources held by the current instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  

> [!NOTE]
> <span data-ttu-id="f330e-164">此成员已从 .NET Framework 版本2.0 和后续版本中删除。</span><span class="sxs-lookup"><span data-stu-id="f330e-164">This member has been removed from the .NET Framework version 2.0 and subsequent versions.</span></span> <span data-ttu-id="f330e-165">本主题仅适用于本主题后面的 "版本信息" 中列出的版本。</span><span class="sxs-lookup"><span data-stu-id="f330e-165">This topic applies only to the versions listed in "Version Information" later in this topic.</span></span>


<span data-ttu-id="f330e-166">应用程序代码不会调用此方法;它在垃圾回收期间自动调用，除非已禁用垃圾回收器的终止。</span><span class="sxs-lookup"><span data-stu-id="f330e-166">Application code does not call this method; it is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled.</span></span> <span data-ttu-id="f330e-167">有关详细信息，请参阅 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 和 <xref:System.Object.Finalize>。</span><span class="sxs-lookup"><span data-stu-id="f330e-167">For more information, see <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> and <xref:System.Object.Finalize>.</span></span> <span data-ttu-id="f330e-168">此方法重写 <xref:System.Object.Finalize>。</span><span class="sxs-lookup"><span data-stu-id="f330e-168">This method overrides <xref:System.Object.Finalize>.</span></span>

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f330e-169">获取或设置本机操作系统句柄。</span><span class="sxs-lookup"><span data-stu-id="f330e-169">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="f330e-170"><see langword="IntPtr" />，它表示本机操作系统句柄。</span><span class="sxs-lookup"><span data-stu-id="f330e-170">An <see langword="IntPtr" /> representing the native operating system handle.</span></span> <span data-ttu-id="f330e-171">默认为 <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> 字段的值。</span><span class="sxs-lookup"><span data-stu-id="f330e-171">The default is the value of the <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> field.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-172">为 <xref:System.Threading.WaitHandle.Handle%2A> 属性指定新值不会关闭上一个句柄。</span><span class="sxs-lookup"><span data-stu-id="f330e-172">Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle.</span></span> <span data-ttu-id="f330e-173">这可能会导致句柄泄露。</span><span class="sxs-lookup"><span data-stu-id="f330e-173">This can result in a leaked handle.</span></span>  
  
 <span data-ttu-id="f330e-174">请不要在 .NET Framework 版本2.0 或更高版本中使用此属性;请改用 <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="f330e-174">Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead.</span></span> <span data-ttu-id="f330e-175">如果将此属性设置为有效的句柄，则还会设置 <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> 属性，但将其设置为 <xref:System.Threading.WaitHandle.InvalidHandle> 会导致泄漏句柄。</span><span class="sxs-lookup"><span data-stu-id="f330e-175">Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f330e-176">需要对直接调用方的完全信任才能设置属性值。</span><span class="sxs-lookup"><span data-stu-id="f330e-176">Requires full trust for the immediate caller to set the property value.</span></span> <span data-ttu-id="f330e-177">此成员不能由部分受信任的或透明的代码设置。</span><span class="sxs-lookup"><span data-stu-id="f330e-177">This member cannot be set by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="f330e-178">派生的类型必须具有 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> 才能设置属性值。</span><span class="sxs-lookup"><span data-stu-id="f330e-178">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f330e-179">表示无效的本机操作系统句柄。</span><span class="sxs-lookup"><span data-stu-id="f330e-179">Represents an invalid native operating system handle.</span></span> <span data-ttu-id="f330e-180">此字段为只读。</span><span class="sxs-lookup"><span data-stu-id="f330e-180">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-181">在内部用于初始化 <xref:System.Threading.WaitHandle.Handle%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="f330e-181">Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="f330e-182">可以使用此值确定 <see cref="P:System.Threading.WaitHandle.Handle" /> 属性是否包含有效的本机操作系统句柄。</span><span class="sxs-lookup"><span data-stu-id="f330e-182">You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f330e-183">获取或设置本机操作系统句柄。</span><span class="sxs-lookup"><span data-stu-id="f330e-183">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="f330e-184"><see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />，它表示本机操作系统句柄。</span><span class="sxs-lookup"><span data-stu-id="f330e-184">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> representing the native operating system handle.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-185">向 <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> 属性分配新值时，将在收集上一个 <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 对象时关闭前一个句柄。</span><span class="sxs-lookup"><span data-stu-id="f330e-185">When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected.</span></span> <span data-ttu-id="f330e-186">请勿手动关闭句柄，因为当 <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> 尝试关闭句柄时，这会导致 <xref:System.ObjectDisposedException>。</span><span class="sxs-lookup"><span data-stu-id="f330e-186">Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.</span></span>  
  
 <span data-ttu-id="f330e-187"><xref:System.Threading.WaitHandle> 实现 <xref:System.IDisposable.Dispose%2A> 模式。</span><span class="sxs-lookup"><span data-stu-id="f330e-187"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="f330e-188">请参阅[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。</span><span class="sxs-lookup"><span data-stu-id="f330e-188">See [Implementing a Dispose method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span> <span data-ttu-id="f330e-189">从 <xref:System.Threading.WaitHandle>派生时，使用 <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> 属性存储本机句柄操作系统句柄。</span><span class="sxs-lookup"><span data-stu-id="f330e-189">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="f330e-190">除非使用其他非托管资源，否则不需要重写受保护的 <xref:System.Threading.WaitHandle.Dispose%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f330e-190">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f330e-191">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="f330e-191">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="f330e-192">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="f330e-192">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="f330e-193">派生的类型必须具有调用此成员的 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-193">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f330e-194">向一个 <see cref="T:System.Threading.WaitHandle" /> 发出信号并等待另一个。</span><span class="sxs-lookup"><span data-stu-id="f330e-194">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="f330e-195">要发出信号的 <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-195">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="f330e-196">要等待的 <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-196">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <summary><span data-ttu-id="f330e-197">向一个 <see cref="T:System.Threading.WaitHandle" /> 发出信号并等待另一个。</span><span class="sxs-lookup"><span data-stu-id="f330e-197">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
        <returns><span data-ttu-id="f330e-198">如果信号和等待都成功完成，则为 <see langword="true" />；如果等待没有完成，则此方法不返回。</span><span class="sxs-lookup"><span data-stu-id="f330e-198"><see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-199">不保证此操作为原子操作。</span><span class="sxs-lookup"><span data-stu-id="f330e-199">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="f330e-200">在当前线程发出信号并 `toSignal` 等待 `toWaitOn`之前，另一个处理器上运行的线程可能会发出信号 `toWaitOn` 或等待。</span><span class="sxs-lookup"><span data-stu-id="f330e-200">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f330e-201">下面的代码示例使用 <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> 方法重载，以允许主线程向阻止的线程发出信号，并等待线程完成任务。</span><span class="sxs-lookup"><span data-stu-id="f330e-201">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="f330e-202">该示例启动五个线程，使其可以在使用 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> 标志创建的 <xref:System.Threading.EventWaitHandle> 上阻塞，然后在每次用户按 ENTER 键时释放一个线程。</span><span class="sxs-lookup"><span data-stu-id="f330e-202">The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, and then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="f330e-203">然后，该示例将另一线程排队，并使用使用 <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> 标志创建的 <xref:System.Threading.EventWaitHandle> 来释放它们。</span><span class="sxs-lookup"><span data-stu-id="f330e-203">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f330e-204"><paramref name="toSignal" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-204"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f330e-205">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-205">-or-</span></span> 
 <span data-ttu-id="f330e-206"><paramref name="toWaitOn" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-206"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f330e-207">在一个处于 <see cref="F:System.Threading.ApartmentState.STA" /> 状态的线程上调用了该方法。</span><span class="sxs-lookup"><span data-stu-id="f330e-207">The method was called on a thread in <see cref="F:System.Threading.ApartmentState.STA" /> state.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f330e-208"><paramref name="toSignal" /> 是信号量，已达到最大计数。</span><span class="sxs-lookup"><span data-stu-id="f330e-208"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f330e-209">等待结束，因为线程在未释放互斥的情况下退出。</span><span class="sxs-lookup"><span data-stu-id="f330e-209">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f330e-210">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span><span class="sxs-lookup"><span data-stu-id="f330e-210">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="f330e-211">要发出信号的 <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-211">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="f330e-212">要等待的 <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-212">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="f330e-213">一个整数，表示要等待的间隔。</span><span class="sxs-lookup"><span data-stu-id="f330e-213">An integer that represents the interval to wait.</span></span> <span data-ttu-id="f330e-214">如果值是 <see cref="F:System.Threading.Timeout.Infinite" />，即 -1，则等待是无限期的。</span><span class="sxs-lookup"><span data-stu-id="f330e-214">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span></span></param>
        <param name="exitContext"><span data-ttu-id="f330e-215">如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-215"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f330e-216">向一个 <see cref="T:System.Threading.WaitHandle" /> 发出信号并等待另一个，指定超时间隔为 32 位有符号整数，并指定在进入等待前是否退出上下文的同步域。</span><span class="sxs-lookup"><span data-stu-id="f330e-216">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns><span data-ttu-id="f330e-217">如果信号发送和等待均成功完成，则为 <see langword="true" />；如果信号发送完成，但等待超时，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-217"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-218">不保证此操作为原子操作。</span><span class="sxs-lookup"><span data-stu-id="f330e-218">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="f330e-219">在当前线程发出信号并 `toSignal` 等待 `toWaitOn`之前，另一个处理器上运行的线程可能会发出信号 `toWaitOn` 或等待。</span><span class="sxs-lookup"><span data-stu-id="f330e-219">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="f330e-220">如果 `millisecondsTimeout` 为零，则该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="f330e-220">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f330e-221">它将测试 `toWaitOn` 的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="f330e-221">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f330e-222">有关退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="f330e-222">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f330e-223">除非从非默认托管上下文内调用 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 方法，否则 `exitContext` 参数不起作用。</span><span class="sxs-lookup"><span data-stu-id="f330e-223">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f330e-224">如果线程位于从 <xref:System.ContextBoundObject>派生的类的实例中，则会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="f330e-224">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f330e-225">即使当前正在对不是派生自 <xref:System.ContextBoundObject>的类执行方法，如 <xref:System.String>，如果 <xref:System.ContextBoundObject> 在当前应用程序域中的堆栈上，则可以在非默认上下文中执行。</span><span class="sxs-lookup"><span data-stu-id="f330e-225">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f330e-226">当代码在非默认上下文中执行时，为 `exitContext` 指定 `true` 会导致线程在执行 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 方法之前退出非默认托管上下文（即转换为默认上下文）。</span><span class="sxs-lookup"><span data-stu-id="f330e-226">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="f330e-227">调用 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 方法完成后，线程返回到原始的非默认上下文。</span><span class="sxs-lookup"><span data-stu-id="f330e-227">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="f330e-228">当上下文绑定类 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>时，这会很有用。</span><span class="sxs-lookup"><span data-stu-id="f330e-228">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f330e-229">在这种情况下，对类成员的所有调用都将自动同步，同步域是类的整个代码正文。</span><span class="sxs-lookup"><span data-stu-id="f330e-229">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f330e-230">如果成员的调用堆栈中的代码调用 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 方法并指定 `exitContext`的 `true`，则线程将退出同步域，从而允许在对对象的任何成员的调用上被阻止的线程继续。</span><span class="sxs-lookup"><span data-stu-id="f330e-230">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f330e-231">当 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 方法返回时，进行调用的线程必须等待重新进入同步域。</span><span class="sxs-lookup"><span data-stu-id="f330e-231">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f330e-232"><paramref name="toSignal" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-232"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f330e-233">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-233">-or-</span></span> 
 <span data-ttu-id="f330e-234"><paramref name="toWaitOn" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-234"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f330e-235">对处于 <see cref="F:System.Threading.ApartmentState.STA" /> 状态的线程调用了此方法。</span><span class="sxs-lookup"><span data-stu-id="f330e-235">The method is called on a thread in <see cref="F:System.Threading.ApartmentState.STA" /> state.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f330e-236">无法终止 <see cref="T:System.Threading.WaitHandle" />，因为它将超过其最大计数。</span><span class="sxs-lookup"><span data-stu-id="f330e-236">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f330e-237"><paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span><span class="sxs-lookup"><span data-stu-id="f330e-237"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f330e-238">等待结束，因为线程在未释放互斥的情况下退出。</span><span class="sxs-lookup"><span data-stu-id="f330e-238">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f330e-239">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span><span class="sxs-lookup"><span data-stu-id="f330e-239">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="f330e-240">要发出信号的 <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-240">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="f330e-241">要等待的 <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-241">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="timeout"><span data-ttu-id="f330e-242">一个 <see cref="T:System.TimeSpan" />，表示要等待的间隔。</span><span class="sxs-lookup"><span data-stu-id="f330e-242">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span></span> <span data-ttu-id="f330e-243">如果值是 -1，则等待是无限期的。</span><span class="sxs-lookup"><span data-stu-id="f330e-243">If the value is -1, the wait is infinite.</span></span></param>
        <param name="exitContext"><span data-ttu-id="f330e-244">如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-244"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f330e-245">向一个 <see cref="T:System.Threading.WaitHandle" /> 发出信号并等待另一个，指定超时间隔为 <see cref="T:System.TimeSpan" />，并指定在进入等待前是否退出上下文的同步域。</span><span class="sxs-lookup"><span data-stu-id="f330e-245">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns><span data-ttu-id="f330e-246">如果信号发送和等待均成功完成，则为 <see langword="true" />；如果信号发送完成，但等待超时，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-246"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-247">不保证此操作为原子操作。</span><span class="sxs-lookup"><span data-stu-id="f330e-247">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="f330e-248">在当前线程发出信号并 `toSignal` 等待 `toWaitOn`之前，另一个处理器上运行的线程可能会发出信号 `toWaitOn` 或等待。</span><span class="sxs-lookup"><span data-stu-id="f330e-248">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="f330e-249"><xref:System.Int32.MaxValue?displayProperty=nameWithType>`timeout` 的最大值。</span><span class="sxs-lookup"><span data-stu-id="f330e-249">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f330e-250">如果 `timeout` 为零，则该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="f330e-250">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f330e-251">它将测试 `toWaitOn` 的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="f330e-251">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f330e-252">有关退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="f330e-252">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f330e-253">除非从非默认托管上下文内调用 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 方法，否则 `exitContext` 参数不起作用。</span><span class="sxs-lookup"><span data-stu-id="f330e-253">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f330e-254">如果线程位于从 <xref:System.ContextBoundObject>派生的类的实例中，则会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="f330e-254">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f330e-255">即使当前正在对不是派生自 <xref:System.ContextBoundObject>的类执行方法，如 <xref:System.String>，如果 <xref:System.ContextBoundObject> 在当前应用程序域中的堆栈上，则可以在非默认上下文中执行。</span><span class="sxs-lookup"><span data-stu-id="f330e-255">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f330e-256">当代码在非默认上下文中执行时，为 `exitContext` 指定 `true` 会导致线程在执行 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 方法之前退出非默认托管上下文（即转换为默认上下文）。</span><span class="sxs-lookup"><span data-stu-id="f330e-256">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="f330e-257">调用 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 方法完成后，线程返回到原始的非默认上下文。</span><span class="sxs-lookup"><span data-stu-id="f330e-257">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="f330e-258">当上下文绑定类 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>时，这会很有用。</span><span class="sxs-lookup"><span data-stu-id="f330e-258">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f330e-259">在这种情况下，对类成员的所有调用都将自动同步，同步域是类的整个代码正文。</span><span class="sxs-lookup"><span data-stu-id="f330e-259">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f330e-260">如果成员的调用堆栈中的代码调用 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 方法并指定 `exitContext`的 `true`，则线程将退出同步域，从而允许在对对象的任何成员的调用上被阻止的线程继续。</span><span class="sxs-lookup"><span data-stu-id="f330e-260">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f330e-261">当 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 方法返回时，进行调用的线程必须等待重新进入同步域。</span><span class="sxs-lookup"><span data-stu-id="f330e-261">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f330e-262"><paramref name="toSignal" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-262"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f330e-263">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-263">-or-</span></span> 
 <span data-ttu-id="f330e-264"><paramref name="toWaitOn" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-264"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f330e-265">在一个处于 <see cref="F:System.Threading.ApartmentState.STA" /> 状态的线程上调用了该方法。</span><span class="sxs-lookup"><span data-stu-id="f330e-265">The method was called on a thread in <see cref="F:System.Threading.ApartmentState.STA" /> state.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f330e-266"><paramref name="toSignal" /> 是信号量，已达到最大计数。</span><span class="sxs-lookup"><span data-stu-id="f330e-266"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f330e-267"><paramref name="timeout" /> 计算为 -1 以外的负毫秒数。</span><span class="sxs-lookup"><span data-stu-id="f330e-267"><paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span></span>  
  
<span data-ttu-id="f330e-268">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-268">-or-</span></span> 
 <span data-ttu-id="f330e-269"><paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-269"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f330e-270">等待结束，因为线程在未释放互斥的情况下退出。</span><span class="sxs-lookup"><span data-stu-id="f330e-270">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f330e-271">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span><span class="sxs-lookup"><span data-stu-id="f330e-271">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f330e-272">释放由 <see cref="T:System.Threading.WaitHandle" /> 使用的所有资源。</span><span class="sxs-lookup"><span data-stu-id="f330e-272">Releases all resources used by the <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="f330e-273">调用 `Dispose` 允许出于其他目的重新分配 <xref:System.Threading.WaitHandle> 所使用的资源。</span><span class="sxs-lookup"><span data-stu-id="f330e-273">Calling `Dispose` allows the resources used by the <xref:System.Threading.WaitHandle> to be reallocated for other purposes.</span></span> <span data-ttu-id="f330e-274">有关 `Dispose`的详细信息，请参阅[清理非托管资源](~/docs/standard/garbage-collection/unmanaged.md)。</span><span class="sxs-lookup"><span data-stu-id="f330e-274">For more information about `Dispose`, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f330e-275">等待指定数组中的所有元素都收到信号。</span><span class="sxs-lookup"><span data-stu-id="f330e-275">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="f330e-276">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span><span class="sxs-lookup"><span data-stu-id="f330e-276">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="f330e-277">此数组不能包含对同一对象的多个引用。</span><span class="sxs-lookup"><span data-stu-id="f330e-277">This array cannot contain multiple references to the same object.</span></span></param>
        <summary><span data-ttu-id="f330e-278">等待指定数组中的所有元素都收到信号。</span><span class="sxs-lookup"><span data-stu-id="f330e-278">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
        <returns><span data-ttu-id="f330e-279">如果 <see langword="true" /> 中的每个元素都收到信号，则返回 <paramref name="waitHandles" />；否则该方法永不返回。</span><span class="sxs-lookup"><span data-stu-id="f330e-279"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-280"><xref:System.Threading.AbandonedMutexException> 是 .NET Framework 版本2.0 中的新版本。</span><span class="sxs-lookup"><span data-stu-id="f330e-280"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f330e-281">在以前的版本中，在放弃互斥体时，<xref:System.Threading.WaitHandle.WaitAll%2A> 方法返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="f330e-281">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="f330e-282">被放弃的 mutex 通常表明出现了严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="f330e-282">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f330e-283">对于系统范围内的互斥体，它可能指示应用程序突然终止（例如，使用 Windows 任务管理器）。</span><span class="sxs-lookup"><span data-stu-id="f330e-283">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f330e-284">此异常包含用于调试的信息。</span><span class="sxs-lookup"><span data-stu-id="f330e-284">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f330e-285">当所有句柄都收到信号时，<xref:System.Threading.WaitHandle.WaitAll%2A> 方法返回。</span><span class="sxs-lookup"><span data-stu-id="f330e-285">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled.</span></span> <span data-ttu-id="f330e-286">如果传递的句柄超过64，则会引发 <xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="f330e-286">If more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="f330e-287">如果数组包含重复项，则调用失败，并出现 <xref:System.DuplicateWaitObjectException>。</span><span class="sxs-lookup"><span data-stu-id="f330e-287">If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>
  
> [!NOTE]
>  <span data-ttu-id="f330e-288"><xref:System.Threading.ApartmentState.STA> 状态的线程不支持 <xref:System.Threading.WaitHandle.WaitAll%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f330e-288">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads in <xref:System.Threading.ApartmentState.STA> state.</span></span>
  
 <span data-ttu-id="f330e-289">调用此方法重载等效于调用 <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> 方法重载，并为 `exitContext`的 `millisecondsTimeout` 和 `true` 指定-1 （或 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>）。</span><span class="sxs-lookup"><span data-stu-id="f330e-289">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f330e-290">下面的代码示例演示如何使用线程池异步创建和写入一组文件。</span><span class="sxs-lookup"><span data-stu-id="f330e-290">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="f330e-291">每个写入操作都作为工作项排队，并在完成后发出信号。</span><span class="sxs-lookup"><span data-stu-id="f330e-291">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="f330e-292">主线程等待所有项发出信号，然后退出。</span><span class="sxs-lookup"><span data-stu-id="f330e-292">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f330e-293"><paramref name="waitHandles" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-293">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span> <span data-ttu-id="f330e-294">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-294">-or-</span></span> 
<span data-ttu-id="f330e-295"><paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-295">One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span></span>  
  
<span data-ttu-id="f330e-296">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-296">-or-</span></span> 
 <span data-ttu-id="f330e-297"><paramref name="waitHandles" /> 为不具有元素的数组且 .NET Framework 版本为 2.0 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="f330e-297"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="f330e-298">在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.ArgumentException" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-298">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="f330e-299"><paramref name="waitHandles" /> 数组包含重复的元素。</span><span class="sxs-lookup"><span data-stu-id="f330e-299">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f330e-300"><paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span><span class="sxs-lookup"><span data-stu-id="f330e-300">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="f330e-301">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-301">-or-</span></span> 
<span data-ttu-id="f330e-302">当前线程为 <see cref="F:System.Threading.ApartmentState.STA" /> 状态，且 <paramref name="waitHandles" /> 包含多个元素。</span><span class="sxs-lookup"><span data-stu-id="f330e-302">The current thread is <see cref="F:System.Threading.ApartmentState.STA" /> state, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="f330e-303"><paramref name="waitHandles" /> 数组不含任何元素，并且 .NET Framework 版本为 1.0 或 1.1。</span><span class="sxs-lookup"><span data-stu-id="f330e-303"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f330e-304">等待终止，因为线程在未释放互斥的情况下退出。</span><span class="sxs-lookup"><span data-stu-id="f330e-304">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f330e-305">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span><span class="sxs-lookup"><span data-stu-id="f330e-305">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f330e-306"><paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span><span class="sxs-lookup"><span data-stu-id="f330e-306">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="f330e-307">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span><span class="sxs-lookup"><span data-stu-id="f330e-307">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="f330e-308">此数组不能包含对同一对象的多个引用（重复的元素）。</span><span class="sxs-lookup"><span data-stu-id="f330e-308">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="f330e-309">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</span><span class="sxs-lookup"><span data-stu-id="f330e-309">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f330e-310">等待指定数组中的所有元素接收信号，同时使用 <see cref="T:System.Int32" /> 值指定时间间隔。</span><span class="sxs-lookup"><span data-stu-id="f330e-310">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="f330e-311">如果 <paramref name="waitHandles" /> 中的每个元素都已收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-311"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-312">如果 `millisecondsTimeout` 为零，则该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="f330e-312">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f330e-313">它将测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="f330e-313">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f330e-314">当等待终止时，<xref:System.Threading.WaitHandle.WaitAll%2A> 方法返回，这意味着在所有句柄都发出信号或发生超时时。</span><span class="sxs-lookup"><span data-stu-id="f330e-314">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="f330e-315">如果传递的句柄超过64，则会引发 <xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="f330e-315">If more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="f330e-316">如果数组中有重复项，调用将失败，并出现 <xref:System.DuplicateWaitObjectException>。</span><span class="sxs-lookup"><span data-stu-id="f330e-316">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f330e-317"><xref:System.Threading.ApartmentState.STA> 状态的线程不支持 <xref:System.Threading.WaitHandle.WaitAll%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f330e-317">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads in <xref:System.Threading.ApartmentState.STA> state.</span></span>
  
 <span data-ttu-id="f330e-318">调用此方法重载与调用 <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> 重载和指定 `exitContext`的 `false` 相同。</span><span class="sxs-lookup"><span data-stu-id="f330e-318">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f330e-319"><paramref name="waitHandles" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-319">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f330e-320">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-320">-or-</span></span> 
<span data-ttu-id="f330e-321"><paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-321">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f330e-322">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-322">-or-</span></span> 
 <span data-ttu-id="f330e-323"><paramref name="waitHandles" /> 是一个不含任何元素的数组。</span><span class="sxs-lookup"><span data-stu-id="f330e-323"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="f330e-324">在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.ArgumentException" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-324">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="f330e-325"><paramref name="waitHandles" /> 数组包含重复的元素。</span><span class="sxs-lookup"><span data-stu-id="f330e-325">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f330e-326"><paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span><span class="sxs-lookup"><span data-stu-id="f330e-326">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="f330e-327">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-327">-or-</span></span> 
<span data-ttu-id="f330e-328">当前线程处于 <see cref="F:System.Threading.ApartmentState.STA" /> 状态，且 <paramref name="waitHandles" /> 包含多个元素。</span><span class="sxs-lookup"><span data-stu-id="f330e-328">The current thread is in <see cref="F:System.Threading.ApartmentState.STA" /> state, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f330e-329"><paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span><span class="sxs-lookup"><span data-stu-id="f330e-329"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f330e-330">等待结束，因为线程在未释放互斥的情况下退出。</span><span class="sxs-lookup"><span data-stu-id="f330e-330">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f330e-331">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span><span class="sxs-lookup"><span data-stu-id="f330e-331">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f330e-332"><paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span><span class="sxs-lookup"><span data-stu-id="f330e-332">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="f330e-333">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span><span class="sxs-lookup"><span data-stu-id="f330e-333">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="f330e-334">此数组不能包含对同一对象的多个引用。</span><span class="sxs-lookup"><span data-stu-id="f330e-334">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="f330e-335">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-335">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f330e-336">等待指定数组中的所有元素接收信号，同时使用 <see cref="T:System.TimeSpan" /> 值指定时间间隔。</span><span class="sxs-lookup"><span data-stu-id="f330e-336">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="f330e-337">如果 <paramref name="waitHandles" /> 中的每个元素都已收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-337"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-338">如果 `timeout` 为零，则该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="f330e-338">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f330e-339">它将测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="f330e-339">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f330e-340">当等待终止时，<xref:System.Threading.WaitHandle.WaitAll%2A> 方法返回，这意味着所有句柄都已终止或发生超时。</span><span class="sxs-lookup"><span data-stu-id="f330e-340">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="f330e-341">如果传递的句柄超过64，则会引发 <xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="f330e-341">If more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="f330e-342">如果数组包含重复项，则调用将失败。</span><span class="sxs-lookup"><span data-stu-id="f330e-342">If the array contains duplicates, the call will fail.</span></span>
  
> [!NOTE]
>  <span data-ttu-id="f330e-343"><xref:System.Threading.ApartmentState.STA> 状态的线程不支持 <xref:System.Threading.WaitHandle.WaitAll%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f330e-343">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads in <xref:System.Threading.ApartmentState.STA> state.</span></span>
  
 <span data-ttu-id="f330e-344"><xref:System.Int32.MaxValue?displayProperty=nameWithType>`timeout` 的最大值。</span><span class="sxs-lookup"><span data-stu-id="f330e-344">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f330e-345">调用此方法重载与调用 <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> 重载和指定 `exitContext`的 `false` 相同。</span><span class="sxs-lookup"><span data-stu-id="f330e-345">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f330e-346"><paramref name="waitHandles" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-346">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f330e-347">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-347">-or-</span></span> 
<span data-ttu-id="f330e-348"><paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-348">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f330e-349">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-349">-or-</span></span> 
 <span data-ttu-id="f330e-350"><paramref name="waitHandles" /> 是一个不含任何元素的数组。</span><span class="sxs-lookup"><span data-stu-id="f330e-350"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="f330e-351">在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.ArgumentException" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-351">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="f330e-352"><paramref name="waitHandles" /> 数组包含重复的元素。</span><span class="sxs-lookup"><span data-stu-id="f330e-352">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f330e-353"><paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span><span class="sxs-lookup"><span data-stu-id="f330e-353">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="f330e-354">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-354">-or-</span></span> 
<span data-ttu-id="f330e-355">当前线程处于 <see cref="F:System.Threading.ApartmentState.STA" /> 状态，且 <paramref name="waitHandles" /> 包含多个元素。</span><span class="sxs-lookup"><span data-stu-id="f330e-355">The current thread is in <see cref="F:System.Threading.ApartmentState.STA" /> state, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f330e-356"><paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。</span><span class="sxs-lookup"><span data-stu-id="f330e-356"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="f330e-357">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-357">-or-</span></span> 
 <span data-ttu-id="f330e-358"><paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-358"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f330e-359">等待终止，因为线程在未释放互斥的情况下退出。</span><span class="sxs-lookup"><span data-stu-id="f330e-359">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f330e-360">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span><span class="sxs-lookup"><span data-stu-id="f330e-360">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f330e-361"><paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span><span class="sxs-lookup"><span data-stu-id="f330e-361">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="f330e-362">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span><span class="sxs-lookup"><span data-stu-id="f330e-362">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="f330e-363">此数组不能包含对同一对象的多个引用（重复的元素）。</span><span class="sxs-lookup"><span data-stu-id="f330e-363">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="f330e-364">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</span><span class="sxs-lookup"><span data-stu-id="f330e-364">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="f330e-365">如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-365"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f330e-366">等待指定数组中的所有元素收到信号，使用 <see cref="T:System.Int32" /> 值指定时间间隔，并指定是否在等待之前退出同步域。</span><span class="sxs-lookup"><span data-stu-id="f330e-366">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="f330e-367">如果 <paramref name="waitHandles" /> 中的每个元素都已收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-367"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-368">如果 `millisecondsTimeout` 为零，则该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="f330e-368">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f330e-369">它将测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="f330e-369">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f330e-370"><xref:System.Threading.AbandonedMutexException> 是 .NET Framework 版本2.0 中的新版本。</span><span class="sxs-lookup"><span data-stu-id="f330e-370"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f330e-371">在以前的版本中，在放弃互斥体时，<xref:System.Threading.WaitHandle.WaitAll%2A> 方法返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="f330e-371">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="f330e-372">被放弃的 mutex 通常表明出现了严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="f330e-372">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f330e-373">对于系统范围内的互斥体，它可能指示应用程序突然终止（例如，使用 Windows 任务管理器）。</span><span class="sxs-lookup"><span data-stu-id="f330e-373">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f330e-374">此异常包含用于调试的信息。</span><span class="sxs-lookup"><span data-stu-id="f330e-374">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f330e-375">当等待终止时，<xref:System.Threading.WaitHandle.WaitAll%2A> 方法返回，这意味着在所有句柄都发出信号或发生超时时。</span><span class="sxs-lookup"><span data-stu-id="f330e-375">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="f330e-376">如果传递的句柄超过64，则会引发 <xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="f330e-376">If more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="f330e-377">如果数组中有重复项，调用将失败，并出现 <xref:System.DuplicateWaitObjectException>。</span><span class="sxs-lookup"><span data-stu-id="f330e-377">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>
  
> [!NOTE]
>  <span data-ttu-id="f330e-378"><xref:System.Threading.ApartmentState.STA> 状态的线程不支持 <xref:System.Threading.WaitHandle.WaitAll%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f330e-378">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads in <xref:System.Threading.ApartmentState.STA> state.</span></span>
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f330e-379">有关退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="f330e-379">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f330e-380">除非从非默认托管上下文内调用 <xref:System.Threading.WaitHandle.WaitAll%2A> 方法，否则 `exitContext` 参数不起作用。</span><span class="sxs-lookup"><span data-stu-id="f330e-380">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f330e-381">如果线程位于从 <xref:System.ContextBoundObject>派生的类的实例中，则会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="f330e-381">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f330e-382">即使当前正在对不是从 <xref:System.ContextBoundObject>派生的类（如 <xref:System.String>）执行方法，如果 <xref:System.ContextBoundObject> 在当前应用程序域中的堆栈上，也可以在非默认上下文中。</span><span class="sxs-lookup"><span data-stu-id="f330e-382">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f330e-383">当代码在非默认上下文中执行时，为 `exitContext` 指定 `true` 会导致线程在执行 <xref:System.Threading.WaitHandle.WaitAll%2A> 方法之前退出非默认托管上下文（即转换为默认上下文）。</span><span class="sxs-lookup"><span data-stu-id="f330e-383">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="f330e-384">调用 <xref:System.Threading.WaitHandle.WaitAll%2A> 方法完成后，线程返回到原始的非默认上下文。</span><span class="sxs-lookup"><span data-stu-id="f330e-384">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="f330e-385">当上下文绑定类具有 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> 特性时，这会很有用。</span><span class="sxs-lookup"><span data-stu-id="f330e-385">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute.</span></span> <span data-ttu-id="f330e-386">在这种情况下，对类成员的所有调用都将自动同步，同步域是类的整个代码正文。</span><span class="sxs-lookup"><span data-stu-id="f330e-386">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f330e-387">如果成员的调用堆栈中的代码调用 <xref:System.Threading.WaitHandle.WaitAll%2A> 方法并指定 `exitContext`的 `true`，则线程将退出同步域，从而允许在对对象的任何成员的调用上被阻止的线程继续。</span><span class="sxs-lookup"><span data-stu-id="f330e-387">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f330e-388">当 <xref:System.Threading.WaitHandle.WaitAll%2A> 方法返回时，进行调用的线程必须等待重新进入同步域。</span><span class="sxs-lookup"><span data-stu-id="f330e-388">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f330e-389">下面的代码示例演示如何使用线程池异步创建和写入一组文件。</span><span class="sxs-lookup"><span data-stu-id="f330e-389">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="f330e-390">每个写入操作都作为工作项排队，并在完成后发出信号。</span><span class="sxs-lookup"><span data-stu-id="f330e-390">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="f330e-391">主线程等待所有项发出信号，然后退出。</span><span class="sxs-lookup"><span data-stu-id="f330e-391">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f330e-392"><paramref name="waitHandles" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-392">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f330e-393">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-393">-or-</span></span> 
<span data-ttu-id="f330e-394"><paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-394">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f330e-395">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-395">-or-</span></span> 
 <span data-ttu-id="f330e-396"><paramref name="waitHandles" /> 为不具有元素的数组且 .NET Framework 版本为 2.0 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="f330e-396"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="f330e-397"><paramref name="waitHandles" /> 数组包含重复的元素。</span><span class="sxs-lookup"><span data-stu-id="f330e-397">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f330e-398"><paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span><span class="sxs-lookup"><span data-stu-id="f330e-398">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="f330e-399">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-399">-or-</span></span> 
<span data-ttu-id="f330e-400">当前线程处于 <see cref="F:System.Threading.ApartmentState.STA" /> 状态，且 <paramref name="waitHandles" /> 包含多个元素。</span><span class="sxs-lookup"><span data-stu-id="f330e-400">The current thread is in <see cref="F:System.Threading.ApartmentState.STA" /> state, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="f330e-401"><paramref name="waitHandles" /> 数组不含任何元素，并且 .NET Framework 版本为 1.0 或 1.1。</span><span class="sxs-lookup"><span data-stu-id="f330e-401"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f330e-402"><paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span><span class="sxs-lookup"><span data-stu-id="f330e-402"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f330e-403">等待结束，因为线程在未释放互斥的情况下退出。</span><span class="sxs-lookup"><span data-stu-id="f330e-403">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f330e-404">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span><span class="sxs-lookup"><span data-stu-id="f330e-404">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f330e-405"><paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span><span class="sxs-lookup"><span data-stu-id="f330e-405">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="f330e-406">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span><span class="sxs-lookup"><span data-stu-id="f330e-406">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="f330e-407">此数组不能包含对同一对象的多个引用。</span><span class="sxs-lookup"><span data-stu-id="f330e-407">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="f330e-408">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-408">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="f330e-409">如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-409"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f330e-410">等待指定数组中的所有元素收到信号，使用 <see cref="T:System.TimeSpan" /> 值指定时间间隔，并指定是否在等待之前退出同步域。</span><span class="sxs-lookup"><span data-stu-id="f330e-410">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="f330e-411">如果 <paramref name="waitHandles" /> 中的每个元素都收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-411"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-412">如果 `timeout` 为零，则该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="f330e-412">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f330e-413">它将测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="f330e-413">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f330e-414"><xref:System.Threading.AbandonedMutexException> 是 .NET Framework 版本2.0 中的新版本。</span><span class="sxs-lookup"><span data-stu-id="f330e-414"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f330e-415">在以前的版本中，在放弃互斥体时，<xref:System.Threading.WaitHandle.WaitAll%2A> 方法返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="f330e-415">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="f330e-416">被放弃的 mutex 通常表明出现了严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="f330e-416">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f330e-417">对于系统范围内的互斥体，它可能指示应用程序突然终止（例如，使用 Windows 任务管理器）。</span><span class="sxs-lookup"><span data-stu-id="f330e-417">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f330e-418">此异常包含用于调试的信息。</span><span class="sxs-lookup"><span data-stu-id="f330e-418">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f330e-419">当等待终止时，<xref:System.Threading.WaitHandle.WaitAll%2A> 方法返回，这意味着所有句柄都已终止或发生超时。</span><span class="sxs-lookup"><span data-stu-id="f330e-419">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="f330e-420">如果传递的句柄超过64，则会引发 <xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="f330e-420">If more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="f330e-421">如果数组包含重复项，则调用将失败。</span><span class="sxs-lookup"><span data-stu-id="f330e-421">If the array contains duplicates, the call will fail.</span></span>
  
> [!NOTE]
>  <span data-ttu-id="f330e-422"><xref:System.Threading.ApartmentState.STA> 状态的线程不支持 <xref:System.Threading.WaitHandle.WaitAll%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f330e-422">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads in <xref:System.Threading.ApartmentState.STA> state.</span></span>
  
 <span data-ttu-id="f330e-423"><xref:System.Int32.MaxValue?displayProperty=nameWithType>`timeout` 的最大值。</span><span class="sxs-lookup"><span data-stu-id="f330e-423">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f330e-424">有关退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="f330e-424">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f330e-425">除非从非默认托管上下文内调用 <xref:System.Threading.WaitHandle.WaitAll%2A> 方法，否则 `exitContext` 参数不起作用。</span><span class="sxs-lookup"><span data-stu-id="f330e-425">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f330e-426">如果线程位于从 <xref:System.ContextBoundObject>派生的类的实例中，则会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="f330e-426">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f330e-427">即使当前正在对不是从 <xref:System.ContextBoundObject>派生的类（如 <xref:System.String>）执行方法，如果 <xref:System.ContextBoundObject> 在当前应用程序域中的堆栈上，也可以在非默认上下文中。</span><span class="sxs-lookup"><span data-stu-id="f330e-427">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f330e-428">当代码在非默认上下文中执行时，为 `exitContext` 指定 `true` 会导致线程在执行 <xref:System.Threading.WaitHandle.WaitAll%2A> 方法之前退出非默认托管上下文（即转换为默认上下文）。</span><span class="sxs-lookup"><span data-stu-id="f330e-428">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="f330e-429">此方法在调用 <xref:System.Threading.WaitHandle.WaitAll%2A> 方法完成后返回到原始的非默认上下文。</span><span class="sxs-lookup"><span data-stu-id="f330e-429">It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="f330e-430">当上下文绑定类 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>时，这会很有用。</span><span class="sxs-lookup"><span data-stu-id="f330e-430">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f330e-431">在这种情况下，对类成员的所有调用都将自动同步，同步域是类的整个代码正文。</span><span class="sxs-lookup"><span data-stu-id="f330e-431">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f330e-432">如果成员的调用堆栈中的代码调用 <xref:System.Threading.WaitHandle.WaitAll%2A> 方法并指定 `exitContext`的 `true`，则线程将退出同步域，从而允许在对对象的任何成员的调用上被阻止的线程继续。</span><span class="sxs-lookup"><span data-stu-id="f330e-432">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f330e-433">当 <xref:System.Threading.WaitHandle.WaitAll%2A> 方法返回时，进行调用的线程必须等待重新进入同步域。</span><span class="sxs-lookup"><span data-stu-id="f330e-433">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f330e-434">下面的代码示例演示如何使用线程池异步创建和写入一组文件。</span><span class="sxs-lookup"><span data-stu-id="f330e-434">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="f330e-435">每个写入操作都作为工作项排队，并在完成后发出信号。</span><span class="sxs-lookup"><span data-stu-id="f330e-435">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="f330e-436">主线程等待所有项发出信号，然后退出。</span><span class="sxs-lookup"><span data-stu-id="f330e-436">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f330e-437"><paramref name="waitHandles" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-437">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f330e-438">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-438">-or-</span></span> 
<span data-ttu-id="f330e-439"><paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-439">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f330e-440">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-440">-or-</span></span> 
 <span data-ttu-id="f330e-441"><paramref name="waitHandles" /> 为不具有元素的数组且 .NET Framework 版本为 2.0 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="f330e-441"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="f330e-442"><paramref name="waitHandles" /> 数组包含重复的元素。</span><span class="sxs-lookup"><span data-stu-id="f330e-442">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f330e-443"><paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span><span class="sxs-lookup"><span data-stu-id="f330e-443">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="f330e-444">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-444">-or-</span></span> 
<span data-ttu-id="f330e-445"><see cref="T:System.STAThreadAttribute" /> 属性应用于当前线程的线程过程且 <paramref name="waitHandles" /> 包含多个元素。</span><span class="sxs-lookup"><span data-stu-id="f330e-445">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="f330e-446"><paramref name="waitHandles" /> 数组不含任何元素，并且 .NET Framework 版本为 1.0 或 1.1。</span><span class="sxs-lookup"><span data-stu-id="f330e-446"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f330e-447"><paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。</span><span class="sxs-lookup"><span data-stu-id="f330e-447"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="f330e-448">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-448">-or-</span></span> 
 <span data-ttu-id="f330e-449"><paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-449"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f330e-450">等待终止，因为线程在未释放互斥的情况下退出。</span><span class="sxs-lookup"><span data-stu-id="f330e-450">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f330e-451">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span><span class="sxs-lookup"><span data-stu-id="f330e-451">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f330e-452"><paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span><span class="sxs-lookup"><span data-stu-id="f330e-452">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f330e-453">等待指定数组中的任一元素收到信号。</span><span class="sxs-lookup"><span data-stu-id="f330e-453">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="f330e-454">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span><span class="sxs-lookup"><span data-stu-id="f330e-454">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <summary><span data-ttu-id="f330e-455">等待指定数组中的任一元素收到信号。</span><span class="sxs-lookup"><span data-stu-id="f330e-455">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
        <returns><span data-ttu-id="f330e-456">满足等待的对象的数组索引。</span><span class="sxs-lookup"><span data-stu-id="f330e-456">The array index of the object that satisfied the wait.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-457"><xref:System.Threading.AbandonedMutexException> 是 .NET Framework 版本2.0 中的新版本。</span><span class="sxs-lookup"><span data-stu-id="f330e-457"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f330e-458">在以前的版本中，如果等待因放弃互斥体而完成，则 <xref:System.Threading.WaitHandle.WaitAny%2A> 方法返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="f330e-458">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="f330e-459">被放弃的 mutex 通常表明出现了严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="f330e-459">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f330e-460">对于系统范围内的互斥体，它可能指示应用程序突然终止（例如，使用 Windows 任务管理器）。</span><span class="sxs-lookup"><span data-stu-id="f330e-460">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f330e-461">此异常包含用于调试的信息。</span><span class="sxs-lookup"><span data-stu-id="f330e-461">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f330e-462">仅当等待因被放弃的互斥体而完成时，<xref:System.Threading.WaitHandle.WaitAny%2A> 方法才会引发 <xref:System.Threading.AbandonedMutexException>。</span><span class="sxs-lookup"><span data-stu-id="f330e-462">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="f330e-463">如果 `waitHandles` 包含的释放互斥体的索引号小于被放弃的互斥体，则 <xref:System.Threading.WaitHandle.WaitAny%2A> 方法将正常完成，且不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="f330e-463">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f330e-464">在早于版本2.0 的 .NET Framework 版本中，如果线程退出或中止，而不显式释放 <xref:System.Threading.Mutex>，并且 `Mutex` 在另一个线程上的 `WaitAny` 数组中的索引为0（零），则 `WaitAny` 返回的索引为128，而不是0。</span><span class="sxs-lookup"><span data-stu-id="f330e-464">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="f330e-465">当任何句柄终止时，此方法将返回。</span><span class="sxs-lookup"><span data-stu-id="f330e-465">This method returns when any handle is signaled.</span></span> <span data-ttu-id="f330e-466">如果在调用过程中有多个对象收到信号，则返回值为带有所有已发出信号的对象的最小索引值的信号对象的数组索引。</span><span class="sxs-lookup"><span data-stu-id="f330e-466">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span>

 <span data-ttu-id="f330e-467">等待句柄的最大数目为64，如果当前线程处于 <xref:System.Threading.ApartmentState.STA> 状态，则为63。</span><span class="sxs-lookup"><span data-stu-id="f330e-467">The maximum number of the wait handles is 64, and 63 if the current thread is in <xref:System.Threading.ApartmentState.STA> state.</span></span>

 <span data-ttu-id="f330e-468">调用此方法重载等效于调用 <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> 方法重载，并为 `exitContext`的 `millisecondsTimeout` 和 `true` 指定-1 （或 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>）。</span><span class="sxs-lookup"><span data-stu-id="f330e-468">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f330e-469">下面的代码示例演示如何调用 <xref:System.Threading.WaitHandle.WaitAny%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f330e-469">The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f330e-470"><paramref name="waitHandles" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-470">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f330e-471">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-471">-or-</span></span> 
<span data-ttu-id="f330e-472"><paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-472">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f330e-473"><paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span><span class="sxs-lookup"><span data-stu-id="f330e-473">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="f330e-474"><paramref name="waitHandles" /> 是不含元素的数组，并且 .NET Framework 的版本为 1.0 或 1.1。</span><span class="sxs-lookup"><span data-stu-id="f330e-474"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f330e-475">等待结束，因为线程在未释放互斥的情况下退出。</span><span class="sxs-lookup"><span data-stu-id="f330e-475">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f330e-476">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span><span class="sxs-lookup"><span data-stu-id="f330e-476">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f330e-477"><paramref name="waitHandles" /> 是不含元素的数组，并且 .NET Framework 的版本为 2.0 或更高。</span><span class="sxs-lookup"><span data-stu-id="f330e-477"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f330e-478"><paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span><span class="sxs-lookup"><span data-stu-id="f330e-478">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="f330e-479">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span><span class="sxs-lookup"><span data-stu-id="f330e-479">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="f330e-480">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</span><span class="sxs-lookup"><span data-stu-id="f330e-480">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f330e-481">等待指定数组中的任意元素接收信号，同时使用 32 位有符号整数指定时间间隔。</span><span class="sxs-lookup"><span data-stu-id="f330e-481">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="f330e-482">满足等待的对象的数组索引；如果没有任何对象满足等待，并且等效于 <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> 的时间间隔已过，则为 <paramref name="millisecondsTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-482">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-483">如果 `millisecondsTimeout` 为零，则该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="f330e-483">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f330e-484">它将测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="f330e-484">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f330e-485">仅当等待因被放弃的互斥体而完成时，<xref:System.Threading.WaitHandle.WaitAny%2A> 方法才会引发 <xref:System.Threading.AbandonedMutexException>。</span><span class="sxs-lookup"><span data-stu-id="f330e-485">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="f330e-486">如果 `waitHandles` 包含的释放互斥体的索引号小于被放弃的互斥体，则 <xref:System.Threading.WaitHandle.WaitAny%2A> 方法将正常完成，且不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="f330e-486">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="f330e-487">当等待终止时，此方法将返回，无论是在任何句柄收到信号，还是发生超时。</span><span class="sxs-lookup"><span data-stu-id="f330e-487">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="f330e-488">如果在调用过程中有多个对象收到信号，则返回值为带有所有已发出信号的对象的最小索引值的信号对象的数组索引。</span><span class="sxs-lookup"><span data-stu-id="f330e-488">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span>

 <span data-ttu-id="f330e-489">等待句柄的最大数目为64，如果当前线程处于 <xref:System.Threading.ApartmentState.STA> 状态，则为63。</span><span class="sxs-lookup"><span data-stu-id="f330e-489">The maximum number of the wait handles is 64, and 63 if the current thread is in <xref:System.Threading.ApartmentState.STA> state.</span></span>
  
 <span data-ttu-id="f330e-490">调用此方法重载与调用 <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> 重载和指定 `exitContext`的 `false` 相同。</span><span class="sxs-lookup"><span data-stu-id="f330e-490">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f330e-491"><paramref name="waitHandles" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-491">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f330e-492">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-492">-or-</span></span> 
<span data-ttu-id="f330e-493"><paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-493">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f330e-494"><paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span><span class="sxs-lookup"><span data-stu-id="f330e-494">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f330e-495"><paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span><span class="sxs-lookup"><span data-stu-id="f330e-495"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f330e-496">等待结束，因为线程在未释放互斥的情况下退出。</span><span class="sxs-lookup"><span data-stu-id="f330e-496">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f330e-497">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span><span class="sxs-lookup"><span data-stu-id="f330e-497">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f330e-498"><paramref name="waitHandles" /> 是一个不含任何元素的数组。</span><span class="sxs-lookup"><span data-stu-id="f330e-498"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f330e-499"><paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span><span class="sxs-lookup"><span data-stu-id="f330e-499">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="f330e-500">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span><span class="sxs-lookup"><span data-stu-id="f330e-500">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="f330e-501">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-501">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f330e-502">等待指定数组中的任意元素接收信号，同时使用 <see cref="T:System.TimeSpan" /> 指定时间间隔。</span><span class="sxs-lookup"><span data-stu-id="f330e-502">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="f330e-503">满足等待的对象的数组索引；如果没有任何对象满足等待，并且等效于 <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> 的时间间隔已过，则为 <paramref name="timeout" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-503">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-504">如果 `timeout` 为零，则该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="f330e-504">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f330e-505">它将测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="f330e-505">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f330e-506">仅当等待因被放弃的互斥体而完成时，<xref:System.Threading.WaitHandle.WaitAny%2A> 方法才会引发 <xref:System.Threading.AbandonedMutexException>。</span><span class="sxs-lookup"><span data-stu-id="f330e-506">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="f330e-507">如果 `waitHandles` 包含的释放互斥体的索引号小于被放弃的互斥体，则 <xref:System.Threading.WaitHandle.WaitAny%2A> 方法将正常完成，且不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="f330e-507">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="f330e-508">当等待终止时，此方法将返回，无论是在任何句柄收到信号时，还是发生超时。</span><span class="sxs-lookup"><span data-stu-id="f330e-508">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="f330e-509">如果在调用过程中有多个对象收到信号，则返回值为带有所有已发出信号的对象的最小索引值的信号对象的数组索引。</span><span class="sxs-lookup"><span data-stu-id="f330e-509">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span>

 <span data-ttu-id="f330e-510">等待句柄的最大数目为64，如果当前线程处于 <xref:System.Threading.ApartmentState.STA> 状态，则为63。</span><span class="sxs-lookup"><span data-stu-id="f330e-510">The maximum number of the wait handles is 64, and 63 if the current thread is in <xref:System.Threading.ApartmentState.STA> state.</span></span>

 <span data-ttu-id="f330e-511"><xref:System.Int32.MaxValue?displayProperty=nameWithType>`timeout` 的最大值。</span><span class="sxs-lookup"><span data-stu-id="f330e-511">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f330e-512">调用此方法重载与调用 <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> 重载和指定 `exitContext`的 `false` 相同。</span><span class="sxs-lookup"><span data-stu-id="f330e-512">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f330e-513"><paramref name="waitHandles" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-513">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f330e-514">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-514">-or-</span></span> 
<span data-ttu-id="f330e-515"><paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-515">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f330e-516"><paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span><span class="sxs-lookup"><span data-stu-id="f330e-516">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f330e-517"><paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。</span><span class="sxs-lookup"><span data-stu-id="f330e-517"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="f330e-518">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-518">-or-</span></span> 
 <span data-ttu-id="f330e-519"><paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-519"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f330e-520">等待结束，因为线程在未释放互斥的情况下退出。</span><span class="sxs-lookup"><span data-stu-id="f330e-520">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f330e-521">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span><span class="sxs-lookup"><span data-stu-id="f330e-521">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f330e-522"><paramref name="waitHandles" /> 是一个不含任何元素的数组。</span><span class="sxs-lookup"><span data-stu-id="f330e-522"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f330e-523"><paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span><span class="sxs-lookup"><span data-stu-id="f330e-523">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="f330e-524">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span><span class="sxs-lookup"><span data-stu-id="f330e-524">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="f330e-525">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</span><span class="sxs-lookup"><span data-stu-id="f330e-525">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="f330e-526">如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-526"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f330e-527">等待指定数组中的任一元素收到信号，使用 32 位带符号整数指定时间间隔并指定是否在等待之前退出同步域。</span><span class="sxs-lookup"><span data-stu-id="f330e-527">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="f330e-528">满足等待的对象的数组索引；如果没有任何对象满足等待，并且等效于 <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> 的时间间隔已过，则为 <paramref name="millisecondsTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-528">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-529">如果 `millisecondsTimeout` 为零，则该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="f330e-529">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f330e-530">它将测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="f330e-530">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f330e-531"><xref:System.Threading.AbandonedMutexException> 是 .NET Framework 版本2.0 中的新版本。</span><span class="sxs-lookup"><span data-stu-id="f330e-531"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f330e-532">在以前的版本中，如果等待因放弃互斥体而完成，则 <xref:System.Threading.WaitHandle.WaitAny%2A> 方法返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="f330e-532">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="f330e-533">被放弃的 mutex 通常表明出现了严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="f330e-533">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f330e-534">对于系统范围内的互斥体，它可能指示应用程序突然终止（例如，使用 Windows 任务管理器）。</span><span class="sxs-lookup"><span data-stu-id="f330e-534">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f330e-535">此异常包含用于调试的信息。</span><span class="sxs-lookup"><span data-stu-id="f330e-535">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f330e-536">仅当等待因被放弃的互斥体而完成时，<xref:System.Threading.WaitHandle.WaitAny%2A> 方法才会引发 <xref:System.Threading.AbandonedMutexException>。</span><span class="sxs-lookup"><span data-stu-id="f330e-536">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="f330e-537">如果 `waitHandles` 包含的释放互斥体的索引号小于被放弃的互斥体，则 <xref:System.Threading.WaitHandle.WaitAny%2A> 方法将正常完成，且不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="f330e-537">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f330e-538">在早于版本2.0 的 .NET Framework 版本中，如果线程退出或中止，而不显式释放 <xref:System.Threading.Mutex>，并且 `Mutex` 在另一个线程上的 `WaitAny` 数组中的索引为0（零），则 `WaitAny` 返回的索引为128，而不是0。</span><span class="sxs-lookup"><span data-stu-id="f330e-538">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="f330e-539">当等待终止时，此方法将返回，无论是在任何句柄收到信号，还是发生超时。</span><span class="sxs-lookup"><span data-stu-id="f330e-539">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="f330e-540">如果在调用过程中有多个对象收到信号，则返回值为带有所有已发出信号的对象的最小索引值的信号对象的数组索引。</span><span class="sxs-lookup"><span data-stu-id="f330e-540">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span>

 <span data-ttu-id="f330e-541">等待句柄的最大数目为64，如果当前线程处于 <xref:System.Threading.ApartmentState.STA> 状态，则为63。</span><span class="sxs-lookup"><span data-stu-id="f330e-541">The maximum number of the wait handles is 64, and 63 if the current thread is in <xref:System.Threading.ApartmentState.STA> state.</span></span>
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f330e-542">有关退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="f330e-542">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f330e-543">除非从非默认托管上下文内调用 <xref:System.Threading.WaitHandle.WaitAny%2A> 方法，否则 `exitContext` 参数不起作用。</span><span class="sxs-lookup"><span data-stu-id="f330e-543">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f330e-544">如果线程位于从 <xref:System.ContextBoundObject>派生的类的实例中，则会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="f330e-544">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f330e-545">即使当前正在对不是派生自 <xref:System.ContextBoundObject>的类执行方法，如 <xref:System.String>，如果 <xref:System.ContextBoundObject> 在当前应用程序域中的堆栈上，则可以在非默认上下文中执行。</span><span class="sxs-lookup"><span data-stu-id="f330e-545">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f330e-546">当代码在非默认上下文中执行时，为 `exitContext` 指定 `true` 会导致线程在执行 <xref:System.Threading.WaitHandle.WaitAny%2A> 方法之前退出非默认托管上下文（即转换为默认上下文）。</span><span class="sxs-lookup"><span data-stu-id="f330e-546">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="f330e-547">调用 <xref:System.Threading.WaitHandle.WaitAny%2A> 方法完成后，线程返回到原始的非默认上下文。</span><span class="sxs-lookup"><span data-stu-id="f330e-547">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="f330e-548">当上下文绑定类 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>时，这会很有用。</span><span class="sxs-lookup"><span data-stu-id="f330e-548">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f330e-549">在这种情况下，对类成员的所有调用都将自动同步，同步域是类的整个代码正文。</span><span class="sxs-lookup"><span data-stu-id="f330e-549">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f330e-550">如果成员的调用堆栈中的代码调用 <xref:System.Threading.WaitHandle.WaitAny%2A> 方法并指定 `exitContext`的 `true`，则线程将退出同步域，从而允许在对对象的任何成员的调用上被阻止的线程继续。</span><span class="sxs-lookup"><span data-stu-id="f330e-550">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f330e-551">当 <xref:System.Threading.WaitHandle.WaitAny%2A> 方法返回时，进行调用的线程必须等待重新进入同步域。</span><span class="sxs-lookup"><span data-stu-id="f330e-551">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f330e-552">下面的代码示例演示如何使用线程池同时搜索多个磁盘上的文件。</span><span class="sxs-lookup"><span data-stu-id="f330e-552">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="f330e-553">出于空间考虑，只会搜索每个磁盘的根目录。</span><span class="sxs-lookup"><span data-stu-id="f330e-553">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f330e-554"><paramref name="waitHandles" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-554">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f330e-555">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-555">-or-</span></span> 
<span data-ttu-id="f330e-556"><paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-556">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f330e-557"><paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span><span class="sxs-lookup"><span data-stu-id="f330e-557">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="f330e-558"><paramref name="waitHandles" /> 是不含元素的数组，并且 .NET Framework 的版本为 1.0 或 1.1。</span><span class="sxs-lookup"><span data-stu-id="f330e-558"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f330e-559"><paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span><span class="sxs-lookup"><span data-stu-id="f330e-559"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f330e-560">等待结束，因为线程在未释放互斥的情况下退出。</span><span class="sxs-lookup"><span data-stu-id="f330e-560">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f330e-561">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span><span class="sxs-lookup"><span data-stu-id="f330e-561">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f330e-562"><paramref name="waitHandles" /> 是不含元素的数组，并且 .NET Framework 的版本为 2.0 或更高。</span><span class="sxs-lookup"><span data-stu-id="f330e-562"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f330e-563"><paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span><span class="sxs-lookup"><span data-stu-id="f330e-563">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="f330e-564">一个 <see langword="WaitHandle" /> 数组，包含当前实例将等待的对象。</span><span class="sxs-lookup"><span data-stu-id="f330e-564">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="f330e-565">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-565">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="f330e-566">如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-566"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f330e-567">等待指定数组中的任一元素收到信号，使用 <see cref="T:System.TimeSpan" /> 指定时间间隔并指定是否在等待之前退出同步域。</span><span class="sxs-lookup"><span data-stu-id="f330e-567">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="f330e-568">满足等待的对象的数组索引；如果没有任何对象满足等待，并且等效于 <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> 的时间间隔已过，则为 <paramref name="timeout" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-568">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-569">如果 `timeout` 为零，则该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="f330e-569">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f330e-570">它将测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="f330e-570">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f330e-571"><xref:System.Threading.AbandonedMutexException> 是 .NET Framework 版本2.0 中的新版本。</span><span class="sxs-lookup"><span data-stu-id="f330e-571"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f330e-572">在以前的版本中，如果等待因放弃互斥体而完成，则 <xref:System.Threading.WaitHandle.WaitAny%2A> 方法返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="f330e-572">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="f330e-573">被放弃的 mutex 通常表明出现了严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="f330e-573">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f330e-574">对于系统范围内的互斥体，它可能指示应用程序突然终止（例如，使用 Windows 任务管理器）。</span><span class="sxs-lookup"><span data-stu-id="f330e-574">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f330e-575">此异常包含用于调试的信息。</span><span class="sxs-lookup"><span data-stu-id="f330e-575">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f330e-576">仅当等待因被放弃的互斥体而完成时，<xref:System.Threading.WaitHandle.WaitAny%2A> 方法才会引发 <xref:System.Threading.AbandonedMutexException>。</span><span class="sxs-lookup"><span data-stu-id="f330e-576">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="f330e-577">如果 `waitHandles` 包含的释放互斥体的索引号小于被放弃的互斥体，则 <xref:System.Threading.WaitHandle.WaitAny%2A> 方法将正常完成，且不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="f330e-577">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f330e-578">在早于版本2.0 的 .NET Framework 版本中，如果线程退出或中止，而不显式释放 <xref:System.Threading.Mutex>，并且 `Mutex` 在另一个线程上的 `WaitAny` 数组中的索引为0（零），则 `WaitAny` 返回的索引为128，而不是0。</span><span class="sxs-lookup"><span data-stu-id="f330e-578">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="f330e-579">当等待终止时，此方法将返回，无论是在任何句柄收到信号时，还是发生超时。</span><span class="sxs-lookup"><span data-stu-id="f330e-579">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="f330e-580">如果在调用过程中有多个对象收到信号，则返回值为带有所有已发出信号的对象的最小索引值的信号对象的数组索引。</span><span class="sxs-lookup"><span data-stu-id="f330e-580">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span>

 <span data-ttu-id="f330e-581">等待句柄的最大数目为64，如果当前线程处于 <xref:System.Threading.ApartmentState.STA> 状态，则为63。</span><span class="sxs-lookup"><span data-stu-id="f330e-581">The maximum number of the wait handles is 64, and 63 if the current thread is in <xref:System.Threading.ApartmentState.STA> state.</span></span>

 <span data-ttu-id="f330e-582"><xref:System.Int32.MaxValue?displayProperty=nameWithType>`timeout` 的最大值。</span><span class="sxs-lookup"><span data-stu-id="f330e-582">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f330e-583">有关退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="f330e-583">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f330e-584">除非从非默认托管上下文内调用 <xref:System.Threading.WaitHandle.WaitAny%2A> 方法，否则 `exitContext` 参数不起作用。</span><span class="sxs-lookup"><span data-stu-id="f330e-584">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f330e-585">如果线程位于从 <xref:System.ContextBoundObject>派生的类的实例中，则会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="f330e-585">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f330e-586">即使当前正在对不是派生自 <xref:System.ContextBoundObject>的类执行方法，如 <xref:System.String>，如果 <xref:System.ContextBoundObject> 在当前应用程序域中的堆栈上，则可以在非默认上下文中执行。</span><span class="sxs-lookup"><span data-stu-id="f330e-586">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f330e-587">当代码在非默认上下文中执行时，为 `exitContext` 指定 `true` 会导致线程在执行 <xref:System.Threading.WaitHandle.WaitAny%2A> 方法之前退出非默认托管上下文（即转换为默认上下文）。</span><span class="sxs-lookup"><span data-stu-id="f330e-587">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="f330e-588">调用 <xref:System.Threading.WaitHandle.WaitAny%2A> 方法完成后，线程返回到原始的非默认上下文。</span><span class="sxs-lookup"><span data-stu-id="f330e-588">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="f330e-589">当上下文绑定类 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>时，这会很有用。</span><span class="sxs-lookup"><span data-stu-id="f330e-589">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f330e-590">在这种情况下，对类成员的所有调用都将自动同步，同步域是类的整个代码正文。</span><span class="sxs-lookup"><span data-stu-id="f330e-590">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f330e-591">如果成员的调用堆栈中的代码调用 <xref:System.Threading.WaitHandle.WaitAny%2A> 方法并指定 `exitContext`的 `true`，则线程将退出同步域，从而允许在对对象的任何成员的调用上被阻止的线程继续。</span><span class="sxs-lookup"><span data-stu-id="f330e-591">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f330e-592">当 <xref:System.Threading.WaitHandle.WaitAny%2A> 方法返回时，进行调用的线程必须等待重新进入同步域。</span><span class="sxs-lookup"><span data-stu-id="f330e-592">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f330e-593">下面的代码示例演示如何使用线程池同时搜索多个磁盘上的文件。</span><span class="sxs-lookup"><span data-stu-id="f330e-593">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="f330e-594">出于空间考虑，只会搜索每个磁盘的根目录。</span><span class="sxs-lookup"><span data-stu-id="f330e-594">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f330e-595"><paramref name="waitHandles" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-595">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f330e-596">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-596">-or-</span></span> 
<span data-ttu-id="f330e-597"><paramref name="waitHandles" /> 数组中一个或多个对象为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-597">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f330e-598"><paramref name="waitHandles" /> 中的对象数大于系统允许的数量。</span><span class="sxs-lookup"><span data-stu-id="f330e-598">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="f330e-599"><paramref name="waitHandles" /> 是不含元素的数组，并且 .NET Framework 的版本为 1.0 或 1.1。</span><span class="sxs-lookup"><span data-stu-id="f330e-599"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f330e-600"><paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。</span><span class="sxs-lookup"><span data-stu-id="f330e-600"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="f330e-601">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-601">-or-</span></span> 
 <span data-ttu-id="f330e-602"><paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-602"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f330e-603">等待结束，因为线程在未释放互斥的情况下退出。</span><span class="sxs-lookup"><span data-stu-id="f330e-603">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f330e-604">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span><span class="sxs-lookup"><span data-stu-id="f330e-604">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f330e-605"><paramref name="waitHandles" /> 是不含元素的数组，并且 .NET Framework 的版本为 2.0 或更高。</span><span class="sxs-lookup"><span data-stu-id="f330e-605"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f330e-606"><paramref name="waitHandles" /> 数组包含其他应用程序域中 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span><span class="sxs-lookup"><span data-stu-id="f330e-606">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f330e-607">阻止当前线程，直到当前 <see cref="T:System.Threading.WaitHandle" /> 收到信号。</span><span class="sxs-lookup"><span data-stu-id="f330e-607">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f330e-608">阻止当前线程，直到当前 <see cref="T:System.Threading.WaitHandle" /> 收到信号。</span><span class="sxs-lookup"><span data-stu-id="f330e-608">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
        <returns><span data-ttu-id="f330e-609">如果当前实例收到信号，则为 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-609"><see langword="true" /> if the current instance receives a signal.</span></span> <span data-ttu-id="f330e-610">如果当前实例永不发出信号，则 <see cref="M:System.Threading.WaitHandle.WaitOne" /> 永不返回。</span><span class="sxs-lookup"><span data-stu-id="f330e-610">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne" /> never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-611"><xref:System.Threading.AbandonedMutexException> 是 .NET Framework 版本2.0 中的新版本。</span><span class="sxs-lookup"><span data-stu-id="f330e-611"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f330e-612">在以前的版本中，在放弃互斥体时，<xref:System.Threading.WaitHandle.WaitOne%2A> 方法返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="f330e-612">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="f330e-613">被放弃的 mutex 通常表明出现了严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="f330e-613">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f330e-614">对于系统范围内的互斥体，它可能指示应用程序突然终止（例如，使用 Windows 任务管理器）。</span><span class="sxs-lookup"><span data-stu-id="f330e-614">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f330e-615">此异常包含用于调试的信息。</span><span class="sxs-lookup"><span data-stu-id="f330e-615">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f330e-616">此方法的调用方会无限期阻止，直到当前实例收到信号。</span><span class="sxs-lookup"><span data-stu-id="f330e-616">The caller of this method blocks indefinitely until the current instance receives a signal.</span></span> <span data-ttu-id="f330e-617">使用此方法可在 <xref:System.Threading.WaitHandle> 接收来自另一个线程的信号（例如，在异步操作完成时生成）。</span><span class="sxs-lookup"><span data-stu-id="f330e-617">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="f330e-618">有关详细信息，请参阅 <xref:System.IAsyncResult> 接口。</span><span class="sxs-lookup"><span data-stu-id="f330e-618">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="f330e-619">调用此方法重载等效于调用 <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> 方法重载，并为第一个参数指定-1 或 <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>，为第二个参数指定 `false`。</span><span class="sxs-lookup"><span data-stu-id="f330e-619">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the first parameter and `false` for the second parameter.</span></span>  
  
 <span data-ttu-id="f330e-620">重写此方法以自定义派生类的行为。</span><span class="sxs-lookup"><span data-stu-id="f330e-620">Override this method to customize the behavior of derived classes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f330e-621">下面的代码示例演示如何使用等待句柄来防止进程在等待后台线程完成执行时终止。</span><span class="sxs-lookup"><span data-stu-id="f330e-621">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f330e-622">已释放当前实例。</span><span class="sxs-lookup"><span data-stu-id="f330e-622">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f330e-623">等待结束，因为线程在未释放互斥的情况下退出。</span><span class="sxs-lookup"><span data-stu-id="f330e-623">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f330e-624">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span><span class="sxs-lookup"><span data-stu-id="f330e-624">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f330e-625">当前实例是另一个应用程序域中的 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span><span class="sxs-lookup"><span data-stu-id="f330e-625">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="f330e-626">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</span><span class="sxs-lookup"><span data-stu-id="f330e-626">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f330e-627">阻止当前线程，直到当前 <see cref="T:System.Threading.WaitHandle" /> 收到信号，同时使用 32 位带符号整数指定时间间隔（以毫秒为单位）。</span><span class="sxs-lookup"><span data-stu-id="f330e-627">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="f330e-628">如果当前实例收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-628"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-629">如果 `millisecondsTimeout` 为零，则该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="f330e-629">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f330e-630">它将测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="f330e-630">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="f330e-631">此方法的调用方会一直阻止，直到当前实例收到信号或发生超时。</span><span class="sxs-lookup"><span data-stu-id="f330e-631">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="f330e-632">使用此方法可在 <xref:System.Threading.WaitHandle> 接收来自另一个线程的信号（例如，在异步操作完成时生成）。</span><span class="sxs-lookup"><span data-stu-id="f330e-632">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="f330e-633">有关详细信息，请参阅 <xref:System.IAsyncResult> 接口。</span><span class="sxs-lookup"><span data-stu-id="f330e-633">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="f330e-634">重写此方法以自定义派生类的行为。</span><span class="sxs-lookup"><span data-stu-id="f330e-634">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="f330e-635">调用此方法重载与调用 <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> 重载和指定 `exitContext`的 `false` 相同。</span><span class="sxs-lookup"><span data-stu-id="f330e-635">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f330e-636">下面的代码示例演示如何使用等待句柄来防止进程在等待后台线程完成执行时终止。</span><span class="sxs-lookup"><span data-stu-id="f330e-636">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f330e-637">已释放当前实例。</span><span class="sxs-lookup"><span data-stu-id="f330e-637">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f330e-638"><paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span><span class="sxs-lookup"><span data-stu-id="f330e-638"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f330e-639">等待结束，因为线程在未释放互斥的情况下退出。</span><span class="sxs-lookup"><span data-stu-id="f330e-639">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f330e-640">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span><span class="sxs-lookup"><span data-stu-id="f330e-640">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f330e-641">当前实例是另一个应用程序域中的 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span><span class="sxs-lookup"><span data-stu-id="f330e-641">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="f330e-642">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-642">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f330e-643">阻止当前线程，直到当前实例收到信号，同时使用 <see cref="T:System.TimeSpan" /> 指定时间间隔。</span><span class="sxs-lookup"><span data-stu-id="f330e-643">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="f330e-644">如果当前实例收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-644"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-645">如果 `timeout` 为零，则该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="f330e-645">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f330e-646">它将测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="f330e-646">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="f330e-647">此方法的调用方会一直阻止，直到当前实例收到信号或发生超时。</span><span class="sxs-lookup"><span data-stu-id="f330e-647">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="f330e-648">使用此方法可在 <xref:System.Threading.WaitHandle> 接收来自另一个线程的信号（例如，在异步操作完成时生成）。</span><span class="sxs-lookup"><span data-stu-id="f330e-648">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="f330e-649">有关详细信息，请参阅 <xref:System.IAsyncResult> 接口。</span><span class="sxs-lookup"><span data-stu-id="f330e-649">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="f330e-650">重写此方法以自定义派生类的行为。</span><span class="sxs-lookup"><span data-stu-id="f330e-650">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="f330e-651"><xref:System.Int32.MaxValue?displayProperty=nameWithType>`timeout` 的最大值。</span><span class="sxs-lookup"><span data-stu-id="f330e-651">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f330e-652">调用此方法重载与调用 <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> 重载和指定 `exitContext`的 `false` 相同。</span><span class="sxs-lookup"><span data-stu-id="f330e-652">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f330e-653">已释放当前实例。</span><span class="sxs-lookup"><span data-stu-id="f330e-653">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f330e-654"><paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。</span><span class="sxs-lookup"><span data-stu-id="f330e-654"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="f330e-655">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-655">-or-</span></span> 
 <span data-ttu-id="f330e-656"><paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-656"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f330e-657">等待结束，因为线程在未释放互斥的情况下退出。</span><span class="sxs-lookup"><span data-stu-id="f330e-657">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f330e-658">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span><span class="sxs-lookup"><span data-stu-id="f330e-658">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f330e-659">当前实例是另一个应用程序域中的 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span><span class="sxs-lookup"><span data-stu-id="f330e-659">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="f330e-660">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</span><span class="sxs-lookup"><span data-stu-id="f330e-660">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="f330e-661">如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-661"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f330e-662">阻止当前线程，直到当前的 <see cref="T:System.Threading.WaitHandle" /> 收到信号为止，同时使用 32 位带符号整数指定时间间隔，并指定是否在等待之前退出同步域。</span><span class="sxs-lookup"><span data-stu-id="f330e-662">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="f330e-663">如果当前实例收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-663"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-664">如果 `millisecondsTimeout` 为零，则该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="f330e-664">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f330e-665">它将测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="f330e-665">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="f330e-666"><xref:System.Threading.AbandonedMutexException> 是 .NET Framework 版本2.0 中的新版本。</span><span class="sxs-lookup"><span data-stu-id="f330e-666"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f330e-667">在以前的版本中，在放弃互斥体时，<xref:System.Threading.WaitHandle.WaitOne%2A> 方法返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="f330e-667">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="f330e-668">被放弃的 mutex 通常表明出现了严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="f330e-668">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f330e-669">对于系统范围内的互斥体，它可能指示应用程序突然终止（例如，使用 Windows 任务管理器）。</span><span class="sxs-lookup"><span data-stu-id="f330e-669">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f330e-670">此异常包含用于调试的信息。</span><span class="sxs-lookup"><span data-stu-id="f330e-670">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f330e-671">此方法的调用方会一直阻止，直到当前实例收到信号或发生超时。</span><span class="sxs-lookup"><span data-stu-id="f330e-671">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="f330e-672">使用此方法可在 <xref:System.Threading.WaitHandle> 接收来自另一个线程的信号（例如，在异步操作完成时生成）。</span><span class="sxs-lookup"><span data-stu-id="f330e-672">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="f330e-673">有关详细信息，请参阅 <xref:System.IAsyncResult> 接口。</span><span class="sxs-lookup"><span data-stu-id="f330e-673">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="f330e-674">重写此方法以自定义派生类的行为。</span><span class="sxs-lookup"><span data-stu-id="f330e-674">Override this method to customize the behavior of derived classes.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f330e-675">有关退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="f330e-675">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f330e-676">除非从非默认托管上下文内调用 <xref:System.Threading.WaitHandle.WaitOne%2A> 方法，否则 `exitContext` 参数不起作用。</span><span class="sxs-lookup"><span data-stu-id="f330e-676">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f330e-677">如果线程位于从 <xref:System.ContextBoundObject>派生的类的实例中，则会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="f330e-677">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f330e-678">即使当前正在对不是派生自 <xref:System.ContextBoundObject>的类执行方法，如 <xref:System.String>，如果 <xref:System.ContextBoundObject> 在当前应用程序域中的堆栈上，则可以在非默认上下文中执行。</span><span class="sxs-lookup"><span data-stu-id="f330e-678">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f330e-679">当代码在非默认上下文中执行时，为 `exitContext` 指定 `true` 会导致线程在执行 <xref:System.Threading.WaitHandle.WaitOne%2A> 方法之前退出非默认托管上下文（即转换为默认上下文）。</span><span class="sxs-lookup"><span data-stu-id="f330e-679">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="f330e-680">调用 <xref:System.Threading.WaitHandle.WaitOne%2A> 方法完成后，线程返回到原始的非默认上下文。</span><span class="sxs-lookup"><span data-stu-id="f330e-680">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="f330e-681">当上下文绑定类 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>时，这会很有用。</span><span class="sxs-lookup"><span data-stu-id="f330e-681">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f330e-682">在这种情况下，对类成员的所有调用都将自动同步，同步域是类的整个代码正文。</span><span class="sxs-lookup"><span data-stu-id="f330e-682">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f330e-683">如果成员的调用堆栈中的代码调用 <xref:System.Threading.WaitHandle.WaitOne%2A> 方法并指定 `exitContext`的 `true`，则线程将退出同步域，从而允许在对对象的任何成员的调用上被阻止的线程继续。</span><span class="sxs-lookup"><span data-stu-id="f330e-683">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f330e-684">当 <xref:System.Threading.WaitHandle.WaitOne%2A> 方法返回时，进行调用的线程必须等待重新进入同步域。</span><span class="sxs-lookup"><span data-stu-id="f330e-684">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f330e-685">下面的示例演示 <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> 方法重载在同步域中调用时的行为方式。</span><span class="sxs-lookup"><span data-stu-id="f330e-685">The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain.</span></span> <span data-ttu-id="f330e-686">首先，线程等待 `exitContext` 设置为 `false` 并在等待超时过期之前进行阻止。</span><span class="sxs-lookup"><span data-stu-id="f330e-686">First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires.</span></span> <span data-ttu-id="f330e-687">第一个线程在第一个线程终止后执行，并等待 `exitContext` 设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="f330e-687">A second thread executes after the first thread terminates and waits with `exitContext` set to `true`.</span></span> <span data-ttu-id="f330e-688">对此第二个线程的等待句柄发出信号的调用未被阻止，线程在等待超时前完成。</span><span class="sxs-lookup"><span data-stu-id="f330e-688">The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f330e-689">已释放当前实例。</span><span class="sxs-lookup"><span data-stu-id="f330e-689">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f330e-690"><paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span><span class="sxs-lookup"><span data-stu-id="f330e-690"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f330e-691">等待结束，因为线程在未释放互斥的情况下退出。</span><span class="sxs-lookup"><span data-stu-id="f330e-691">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f330e-692">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span><span class="sxs-lookup"><span data-stu-id="f330e-692">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f330e-693">当前实例是另一个应用程序域中的 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span><span class="sxs-lookup"><span data-stu-id="f330e-693">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="f330e-694">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-694">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="f330e-695">如果等待之前先退出上下文的同步域（如果在同步上下文中），并在稍后重新获取它，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-695"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f330e-696">阻止当前线程，直到当前实例收到信号为止，同时使用 <see cref="T:System.TimeSpan" /> 指定时间间隔，并指定是否在等待之前退出同步域。</span><span class="sxs-lookup"><span data-stu-id="f330e-696">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="f330e-697">如果当前实例收到信号，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-697"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-698">如果 `timeout` 为零，则该方法不会阻止。</span><span class="sxs-lookup"><span data-stu-id="f330e-698">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f330e-699">它将测试等待句柄的状态并立即返回。</span><span class="sxs-lookup"><span data-stu-id="f330e-699">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="f330e-700"><xref:System.Threading.AbandonedMutexException> 是 .NET Framework 版本2.0 中的新版本。</span><span class="sxs-lookup"><span data-stu-id="f330e-700"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f330e-701">在以前的版本中，在放弃互斥体时，<xref:System.Threading.WaitHandle.WaitOne%2A> 方法返回 `true`。</span><span class="sxs-lookup"><span data-stu-id="f330e-701">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="f330e-702">被放弃的 mutex 通常表明出现了严重的编码错误。</span><span class="sxs-lookup"><span data-stu-id="f330e-702">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f330e-703">对于系统范围内的互斥体，它可能指示应用程序突然终止（例如，使用 Windows 任务管理器）。</span><span class="sxs-lookup"><span data-stu-id="f330e-703">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f330e-704">此异常包含用于调试的信息。</span><span class="sxs-lookup"><span data-stu-id="f330e-704">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f330e-705">此方法的调用方会一直阻止，直到当前实例收到信号或发生超时。</span><span class="sxs-lookup"><span data-stu-id="f330e-705">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="f330e-706">使用此方法可在 <xref:System.Threading.WaitHandle> 接收来自另一个线程的信号（例如，在异步操作完成时生成）。</span><span class="sxs-lookup"><span data-stu-id="f330e-706">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="f330e-707">有关详细信息，请参阅 <xref:System.IAsyncResult> 接口。</span><span class="sxs-lookup"><span data-stu-id="f330e-707">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="f330e-708">重写此方法以自定义派生类的行为。</span><span class="sxs-lookup"><span data-stu-id="f330e-708">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="f330e-709"><xref:System.Int32.MaxValue?displayProperty=nameWithType>`timeout` 的最大值。</span><span class="sxs-lookup"><span data-stu-id="f330e-709">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f330e-710">有关退出上下文的说明</span><span class="sxs-lookup"><span data-stu-id="f330e-710">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f330e-711">除非从非默认托管上下文内调用 <xref:System.Threading.WaitHandle.WaitOne%2A> 方法，否则 `exitContext` 参数不起作用。</span><span class="sxs-lookup"><span data-stu-id="f330e-711">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f330e-712">如果线程位于从 <xref:System.ContextBoundObject>派生的类的实例中，则会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="f330e-712">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f330e-713">即使当前正在对不是派生自 <xref:System.ContextBoundObject>的类执行方法，如 <xref:System.String>，如果 <xref:System.ContextBoundObject> 在当前应用程序域中的堆栈上，则可以在非默认上下文中执行。</span><span class="sxs-lookup"><span data-stu-id="f330e-713">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f330e-714">当代码在非默认上下文中执行时，为 `exitContext` 指定 `true` 会导致线程在执行 <xref:System.Threading.WaitHandle.WaitOne%2A> 方法之前退出非默认托管上下文（即转换为默认上下文）。</span><span class="sxs-lookup"><span data-stu-id="f330e-714">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="f330e-715">调用 <xref:System.Threading.WaitHandle.WaitOne%2A> 方法完成后，线程返回到原始的非默认上下文。</span><span class="sxs-lookup"><span data-stu-id="f330e-715">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="f330e-716">当上下文绑定类 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>时，这会很有用。</span><span class="sxs-lookup"><span data-stu-id="f330e-716">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f330e-717">在这种情况下，对类成员的所有调用都将自动同步，同步域是类的整个代码正文。</span><span class="sxs-lookup"><span data-stu-id="f330e-717">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f330e-718">如果成员的调用堆栈中的代码调用 <xref:System.Threading.WaitHandle.WaitOne%2A> 方法并指定 `exitContext`的 `true`，则线程将退出同步域，从而允许在对对象的任何成员的调用上被阻止的线程继续。</span><span class="sxs-lookup"><span data-stu-id="f330e-718">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f330e-719">当 <xref:System.Threading.WaitHandle.WaitOne%2A> 方法返回时，进行调用的线程必须等待重新进入同步域。</span><span class="sxs-lookup"><span data-stu-id="f330e-719">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f330e-720">下面的代码示例演示如何使用等待句柄来防止进程在等待后台线程完成执行时终止。</span><span class="sxs-lookup"><span data-stu-id="f330e-720">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f330e-721">已释放当前实例。</span><span class="sxs-lookup"><span data-stu-id="f330e-721">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f330e-722"><paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。</span><span class="sxs-lookup"><span data-stu-id="f330e-722"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="f330e-723">- 或 -</span><span class="sxs-lookup"><span data-stu-id="f330e-723">-or-</span></span> 
 <span data-ttu-id="f330e-724"><paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="f330e-724"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f330e-725">等待结束，因为线程在未释放互斥的情况下退出。</span><span class="sxs-lookup"><span data-stu-id="f330e-725">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f330e-726">在 Windows 98 或 Windows Millennium Edition 上不会引发此异常。</span><span class="sxs-lookup"><span data-stu-id="f330e-726">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f330e-727">当前实例是另一个应用程序域中的 <see cref="T:System.Threading.WaitHandle" /> 的透明代理。</span><span class="sxs-lookup"><span data-stu-id="f330e-727">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary><span data-ttu-id="f330e-728">指示在任何等待句柄终止之前 <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> 操作已超时。</span><span class="sxs-lookup"><span data-stu-id="f330e-728">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span></span> <span data-ttu-id="f330e-729">此字段为常数。</span><span class="sxs-lookup"><span data-stu-id="f330e-729">This field is constant.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f330e-730">此字段是 `WaitAny`的可能返回值之一。</span><span class="sxs-lookup"><span data-stu-id="f330e-730">This field is one of the possible return values of `WaitAny`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f330e-731">下面的代码示例演示如何使用线程池同时搜索多个磁盘上的文件。</span><span class="sxs-lookup"><span data-stu-id="f330e-731">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="f330e-732">出于空间考虑，只会搜索每个磁盘的根目录。</span><span class="sxs-lookup"><span data-stu-id="f330e-732">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
