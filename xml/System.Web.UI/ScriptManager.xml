<Type Name="ScriptManager" FullName="System.Web.UI.ScriptManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="63dcee8091a26fe76fcd4b1142448d8e98bdf526" /><Meta Name="ms.sourcegitcommit" Value="f9576bf8c61e3d46834aeeff50f858359f2a99ba" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="02/09/2020" /><Meta Name="ms.locfileid" Value="77105895" /></Metadata><TypeSignature Language="C#" Value="public class ScriptManager : System.Web.UI.Control, System.Web.UI.IPostBackDataHandler, System.Web.UI.IPostBackEventHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ScriptManager extends System.Web.UI.Control implements class System.Web.UI.IPostBackDataHandler, class System.Web.UI.IPostBackEventHandler" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.ScriptManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ScriptManager&#xA;Inherits Control&#xA;Implements IPostBackDataHandler, IPostBackEventHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class ScriptManager : System::Web::UI::Control, System::Web::UI::IPostBackDataHandler, System::Web::UI::IPostBackEventHandler" />
  <TypeSignature Language="F#" Value="type ScriptManager = class&#xA;    inherit Control&#xA;    interface IPostBackDataHandler&#xA;    interface IPostBackEventHandler" />
  <AssemblyInfo>
    <AssemblyName>System.Web.Extensions</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.UI.IPostBackDataHandler</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IPostBackEventHandler</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Scripts")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ScriptManagerDesigner, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Drawing.ToolboxBitmap(typeof(EmbeddedResourceFinder), "System.Web.Resources.ScriptManager.bmp")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ScriptManagerDesigner, System.Web.Extensions.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5">
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Web.Extensions, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", System.ComponentModel.ToolboxItemFilterType.Require)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>为 Web 和应用程序服务管理 ASP.NET Ajax 脚本库和脚本文件、局部页面呈现以及客户端代理类生成。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 本主题内容：  
  
-   [介绍](#introduction)  
  
-   [部分页呈现](#partial_page_rendering)  
  
-   [结合使用 ScriptManager 控件和母版页、用户控件和其他子组件](#using_the_scriptmanager_control_with_master_pages__user_controls__and_other_child_components)  
  
-   [脚本管理和注册](#script_management_and_registration)  
  
-   [Web 服务引用](#web_service_references)  
  
-   [本地化](#localization)  
  
-   [错误处理](#error_handling)  
  
-   [声明性语法](#declarative_syntax)  
  
<a name="introduction"></a>   
## <a name="introduction"></a>介绍  
 <xref:System.Web.UI.ScriptManager> 控件是 ASP.NET 中 Ajax 功能的核心。 控件管理页面上的所有 ASP.NET Ajax 资源。 这包括将 Microsoft Ajax Library 脚本下载到浏览器并协调通过使用 <xref:System.Web.UI.UpdatePanel> 控件启用的部分页面更新。 此外，<xref:System.Web.UI.ScriptManager> 控件使您能够执行以下操作：  
  
-   注册与部分页面更新兼容的脚本。 为了管理脚本和核心库之间的依赖关系，你注册的任何脚本都将加载到 Microsoft Ajax 库脚本之后。  
  
-   指定发布或调试脚本是否发送到浏览器。  
  
-   通过向 <xref:System.Web.UI.ScriptManager> 控件注册 Web 服务，提供对脚本中的 Web 服务方法的访问。  
  
-   通过向 <xref:System.Web.UI.ScriptManager> 控件注册这些服务，提供对客户端脚本中的 ASP.NET authentication、role 和 profile 应用程序服务的访问权限。  
  
-   在浏览器中启用 ECMAScript （JavaScript）、和[字符串](https://msdn.microsoft.com/library/517a1992-3295-484e-9b9c-07ebfd8fe4db)函数的区域性特定显示。  
  
-   通过使用 <xref:System.Web.UI.ScriptReference> 控件的 <xref:System.Web.UI.ScriptReferenceBase.ResourceUICultures%2A> 属性，为嵌入的脚本文件或独立脚本文件访问本地化资源。  
  
-   使用 <xref:System.Web.UI.ScriptManager> 控件注册实现 <xref:System.Web.UI.IExtenderControl> 或 <xref:System.Web.UI.IScriptControl> 接口的服务器控件，以便呈现客户端组件和行为所需的脚本。  
  
<a name="partial_page_rendering"></a>   
## <a name="partial-page-rendering"></a>部分页呈现  
 ASP.NET 页支持部分页面呈现的能力由以下因素控制：  
  
-   必须 `true` <xref:System.Web.UI.ScriptManager> 控件的 <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> 属性（默认值）。  
  
-   页面上必须至少有一个 <xref:System.Web.UI.UpdatePanel> 控件。  
  
-   <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> 属性必须是 `true` （默认值）。 如果未显式设置 <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> 属性，则其值基于浏览器功能。  
  
 可以在运行时或在页面的 <xref:System.Web.UI.Control.Init> 事件发生之前，重写 <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> 属性的值。 如果尝试在页面的 <xref:System.Web.UI.Control.Init> 事件发生后更改此属性，则会引发 <xref:System.InvalidOperationException> 异常。  
  
 支持部分页面呈现时，<xref:System.Web.UI.ScriptManager> 控件将呈现脚本，以启用异步回发和部分页面更新。 将使用 <xref:System.Web.UI.UpdatePanel> 控件指定要更新的页面区域。 <xref:System.Web.UI.ScriptManager> 控件处理异步回发并仅刷新必须更新的页面区域。 有关部分页面呈现的详细信息，请参阅[部分页呈现概述](https://docs.microsoft.com/previous-versions/aspnet/bb386573(v=vs.100))。 有关导致更新的条件的详细信息，请参阅[UpdatePanel 控件概述](https://docs.microsoft.com/previous-versions/aspnet/bb386454(v=vs.100))。  
  
<a name="using_the_scriptmanager_control_with_master_pages__user_controls__and_other_child_components"></a>   
## <a name="using-the-scriptmanager-control-with-master-pages-user-controls-and-other-child-components"></a>结合使用 ScriptManager 控件和母版页、用户控件和其他子组件  
 一页在其层次结构中只能包含一个 <xref:System.Web.UI.ScriptManager> 控件。 若要在父页已有 <xref:System.Web.UI.ScriptManager> 控件时为嵌套页、用户控件或组件注册服务和脚本，请使用 <xref:System.Web.UI.ScriptManagerProxy> 控件。 有关详细信息，请参阅[将 UpdatePanel 控件与母版页一起使用](https://msdn.microsoft.com/library/b1c974d5-a6b2-4bb3-a3cc-61dd9dc0e1d6)  
  
<a name="script_management_and_registration"></a>   
## <a name="script-management-and-registration"></a>脚本管理和注册  
 利用 <xref:System.Web.UI.ScriptManager> 控件，你可以注册随后呈现为页的一部分的脚本。 <xref:System.Web.UI.ScriptManager> 控件注册方法可分为以下三个类别：  
  
-   保证在 Microsoft Ajax 库上维护脚本依赖项的注册方法。  
  
-   不依赖于 Microsoft Ajax 库，但与 <xref:System.Web.UI.UpdatePanel> 控件兼容的注册方法。  
  
-   支持使用 <xref:System.Web.UI.UpdatePanel> 控件的注册方法。  
  
 有关如何在 ASP.NET 中创建和使用 Ajax 脚本的详细信息，请参阅[使用 Microsoft Ajax Library 创建自定义客户端脚本](https://msdn.microsoft.com/library/285e3a65-b42e-42c5-952d-baf184057899)。  
  
### <a name="registering-script-that-is-dependent-on-the-microsoft-ajax-library"></a>注册依赖于 Microsoft Ajax 库的脚本  
 你可以使用以下方法来注册脚本文件，以保证保留 Microsoft Ajax 库上的任何依赖项。  
  
|方法|定义|  
|------------|----------------|  
|<xref:System.Web.UI.ScriptManager.RegisterScriptControl%2A>|注册一个服务器控件，该控件实现用于定义[sys.databases](https://msdn.microsoft.com/library/6fba3595-e425-4e48-b4e9-fc16a0272381)客户端对象的 <xref:System.Web.UI.IScriptControl> 接口。 <xref:System.Web.UI.ScriptManager> 控件呈现支持客户端对象的脚本。|  
|<xref:System.Web.UI.ScriptManager.RegisterExtenderControl%2A>|注册一个服务器控件，该控件实现用于定义[sys.databases](https://msdn.microsoft.com/library/6fba3595-e425-4e48-b4e9-fc16a0272381)客户端对象的 <xref:System.Web.UI.IExtenderControl> 接口。 <xref:System.Web.UI.ScriptManager> 控件呈现支持客户端对象的脚本。|  
  
### <a name="registering-partial-page-update-compatible-scripts"></a>注册部分页面更新兼容脚本  
 你可以使用以下方法来注册不依赖于 Microsoft Ajax 库但与 <xref:System.Web.UI.UpdatePanel> 控件兼容的脚本文件。 这些方法与 <xref:System.Web.UI.ClientScriptManager> 控件的类似方法相对应。 如果要渲染要在 <xref:System.Web.UI.UpdatePanel> 控件内使用的脚本，请确保调用 <xref:System.Web.UI.ScriptManager> 控件的方法。  
  
|方法|定义|  
|------------|----------------|  
|<xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A>|向 JavaScript 数组添加一个值。 如果数组不存在，则创建它。|  
|<xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A>|在页的打开 `<form>` 标记后呈现 `script` 元素。 此脚本指定为字符串参数。|  
|<xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A>|在页的打开 `<form>` 标记后呈现 `script` 元素。 脚本内容通过将 `src` 特性设置为指向脚本文件的 URL 来指定。|  
|<xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A>|在页的打开 `<form>` 标记后呈现 `script` 元素。 脚本内容是使用程序集中的资源名称指定的。 通过调用从程序集检索命名脚本的 HTTP 处理程序，使用 URL 自动填充 `src` 特性。|  
|<xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A>|呈现指定控件的标记中的自定义名称/值特性对（expando）。|  
|<xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A>|呈现隐藏的字段。|  
|<xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A>|注册为响应 `form` 元素的 `submit` 事件而执行的脚本。 `onSubmit` 特性引用指定脚本。|  
|<xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A>|在页面结束 `</form>` 标记之前呈现启动脚本块。 要呈现的脚本指定为字符串参数。|  
  
 注册方法时，为该脚本指定类型/密钥对。 如果已注册了具有相同类型/密钥对的脚本，则不会注册新的脚本。 同样，如果使用已存在的类型/资源名称对注册脚本，则不会再次添加引用资源的 `script` 元素。 在注册以前注册的属性的 expando 特性时，将引发异常。 允许重复注册数组值。  
  
 调用 <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> 或 <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> 方法时，请避免注册执行内联函数的脚本。 相反，注册包含函数定义（如事件处理程序）或应用程序的自定义类定义的脚本。  
  
### <a name="registration-methods-for-updatepanel-controls"></a>UpdatePanel 控件的注册方法  
 使用 <xref:System.Web.UI.UpdatePanel> 控件时，可以使用以下方法自定义部分页面更新。  
  
|方法|定义|  
|------------|----------------|  
|<xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A>|将控件注册为异步回发的触发器。|  
|<xref:System.Web.UI.ScriptManager.RegisterDataItem%2A>|在局部页面呈现期间将自定义数据发送到多个控件。|  
|<xref:System.Web.UI.ScriptManager.RegisterDispose%2A>|为位于 <xref:System.Web.UI.UpdatePanel> 控件内的控件注册释放脚本。 在更新或删除 <xref:System.Web.UI.UpdatePanel> 控件时会执行脚本。 Dispose 方法用于作为 Microsoft Ajax 库一部分的客户端组件，并且在不再使用某个组件时必须释放资源。|  
|<xref:System.Web.UI.ScriptManager.RegisterPostBackControl%2A>|将控件注册为完全回发的触发器。 此方法用于 <xref:System.Web.UI.UpdatePanel> 控件内执行异步回发的控件。|  
  
<a name="web_service_references"></a>   
## <a name="web-service-references"></a>Web 服务引用  
 可以通过创建 <xref:System.Web.UI.ServiceReference> 对象并将其添加到 <xref:System.Web.UI.ScriptManager> 控件的 <xref:System.Web.UI.ScriptManager.Services%2A> 集合，来注册要从客户端脚本调用的 Web 服务。 ASP.NET 为 <xref:System.Web.UI.ScriptManager.Services%2A> 集合中的每个 <xref:System.Web.UI.ServiceReference> 对象生成客户端代理对象。 可以通过编程方式将 <xref:System.Web.UI.ServiceReference> 对象添加到 <xref:System.Web.UI.ScriptManager.Services%2A> 集合，以便在运行时注册 Web 服务。  
  
 有关如何在脚本中访问 Web 服务的详细信息，请参阅在[ASP.NET ajax 中向客户端脚本公开 Web 服务](https://msdn.microsoft.com/library/fe3f6e9e-0acd-44c9-bf0f-0a8598fc13b8)和[通过 ASP.NET AJAX 中的客户端脚本调用 web 服务](https://msdn.microsoft.com/library/fc06c224-f01a-45be-94af-bd71afbc07b0)。  
  
<a name="localization"></a>   
## <a name="localization"></a>本地化  
 <xref:System.Web.UI.ScriptManager> 控件在呈现的页面中生成指向相应的本地化脚本文件的引用，这些文件是嵌入在程序集或独立脚本文件中的脚本文件。  
  
 <xref:System.Web.UI.ScriptManager.EnableScriptLocalization%2A> 属性设置为 `true`时，<xref:System.Web.UI.ScriptManager> 控件将检索当前区域性的本地化资源（例如，本地化字符串）（如果存在）。 <xref:System.Web.UI.ScriptManager> 控件为使用本地化资源提供了以下功能：  
  
-   **嵌入在程序集中的脚本文件**。 <xref:System.Web.UI.ScriptManager> 控件确定要发送到浏览器的区域性特定或回退区域性脚本文件。 它通过使用特定于区域性的 <xref:System.Resources.NeutralResourcesLanguageAttribute> 程序集特性、使用程序集打包的资源以及浏览器（如果有）的 UI 区域性来实现此功能。  
  
-   **独立的脚本文件**。 <xref:System.Web.UI.ScriptManager> 控件定义通过使用 <xref:System.Web.UI.ScriptReference> 对象的 <xref:System.Web.UI.ScriptReferenceBase.ResourceUICultures%2A> 属性支持的 UI 区域性列表。  
  
-   **处于调试模式**。 <xref:System.Web.UI.ScriptManager> 控件尝试呈现包含调试信息的特定于区域性的脚本文件。 例如，如果页处于调试模式，并且当前区域性设置为 en-MX，则该控件将呈现一个具有名称（`scriptname`如 en-MX）的脚本文件（如果该文件存在）。 如果该文件不存在，则将呈现适当回退区域性的调试文件  
  
 有关如何本地化资源的详细信息，请参阅[为组件库本地化资源概述](https://msdn.microsoft.com/library/e6b15435-57c1-4dd1-9bd3-5d4c509685bb)。  
  
<a name="error_handling"></a>   
## <a name="error-handling"></a>错误处理  
 当异步回发期间出现页面错误时，将引发 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> 事件。 将服务器上的错误发送到客户端的方式取决于 Web.config 文件的 <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> 属性、<xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> 属性和自定义错误部分。 有关详细信息，请参阅[为 UpdatePanel 控件自定义错误处理](https://msdn.microsoft.com/library/e15e7ffb-e4b2-4a89-b99e-16624a5861d0)。  
  
<a name="declarative_syntax"></a>   
## <a name="declarative-syntax"></a>声明性语法  
  
```  
<asp:ScriptManager  
    AllowCustomErrorsRedirect="True|False"  
    AsyncPostBackErrorMessage="string"  
    AsyncPostBackTimeout="integer"  
    AuthenticationService-Path="uri"  
    EnablePageMethods="True|False"  
    EnablePartialRendering="True|False"  
    EnableScriptGlobalization="True|False"  
    EnableScriptLocalization="True|False"  
    EnableTheming="True|False"  
    EnableViewState="True|False"  
    ID="string"  
    LoadScriptsBeforeUI="True|False"  
    OnAsyncPostBackError="AsyncPostBackError event handler"  
    OnDataBinding="DataBinding event handler"  
    OnDisposed="Disposed event handler"  
    OnInit="Init event handler"  
    OnLoad="Load event handler"  
    OnPreRender="PreRender event handler"  
    OnResolveScriptReference="ResolveScriptReference event handler"  
    OnUnload="Unload event handler"  
    ProfileService-LoadProperties="string"  
    ProfileService-Path="uri"  
    RoleService-LoadRoles="True|False"  
    RoleService-Path="uri"  
    runat="server"  
    ScriptMode="Auto|Inherit|Debug|Release"  
    ScriptPath="string"  
    SkinID="string"  
    SupportsPartialRendering="True|False"  
    Visible="True|False"  
>  
        <AuthenticationService  
            Path="uri"  
        />  
        <ProfileService  
            LoadProperties="string"  
            Path="uri"  
        />  
        <RoleService  
            LoadRoles="True|False"  
            Path="uri"  
        />  
        <Scripts>  
            <asp:ScriptReference  
                Assembly="string"  
                IgnoreScriptPath="True|False"  
                Name="string"  
                NotifyScriptLoaded="True|False"  
                Path="string"  
                ResourceUICultures="string"  
                ScriptMode="Auto|Debug|Inherit|Release"  
            />  
        </Scripts>  
        <Services>  
            <asp:ServiceReference  
                InlineScript="True|False"  
                Path="string"  
            />  
        </Services>  
</asp:ScriptManager>  
```  
  
   
  
## Examples  
 下面的示例演示使用 <xref:System.Web.UI.ScriptManager> 控件的不同方案。  
  
 **启用部分页面更新**  
  
 下面的示例演示如何使用 <xref:System.Web.UI.ScriptManager> 控件启用部分页面更新。 在此示例中，<xref:System.Web.UI.WebControls.Calendar> 和 <xref:System.Web.UI.WebControls.DropDownList> 控件位于 <xref:System.Web.UI.UpdatePanel> 控件中。 默认情况下，将 <xref:System.Web.UI.UpdatePanelUpdateMode.Always><xref:System.Web.UI.UpdatePanel.UpdateMode%2A> 属性的值，并 `true`<xref:System.Web.UI.UpdatePanel.ChildrenAsTriggers%2A> 属性的值。 因此，面板的子控件导致异步回发。  
  
 [!code-aspx-csharp[System.Web.UI.UpdatePanel#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.UpdatePanel/CS/UpdatePanelExample1CS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.UpdatePanel#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.UpdatePanel/VB/UpdatePanelExample1VB.aspx#1)]  
  
 **处理部分页面更新错误并注册脚本**  
  
 下面的示例演示如何在部分页面更新过程中提供自定义错误处理。 默认情况下，当在部分页更新期间发生错误时，将显示 JavaScript 消息框。 此示例演示如何通过为 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> 事件提供处理程序，并在事件处理程序中设置 <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> 属性，来使用自定义错误处理。 还可以设置 <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> 属性，以指定在部分页面更新过程中发生错误时如何使用 Web.config 文件的自定义错误部分。 在此示例中，将使用 <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> 属性的默认值。 这意味着，如果 web.config 文件包含[customErrors](https://msdn.microsoft.com/library/6c3b53ec-00df-4967-b0fb-351c02867650)元素，该元素将确定如何显示错误。 有关详细信息，请参阅[CustomErrors 元素（ASP.NET Settings Schema）](https://msdn.microsoft.com/library/288c32e2-df1f-4548-abda-de6b4cb989a6)。  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.OnAsyncPostBackError#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.OnAsyncPostBackError/CS/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.OnAsyncPostBackError#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.OnAsyncPostBackError/VB/default.aspx#1)]  
  
 **全球化浏览器中显示的日期和时间**  
  
 下面的示例演示如何设置 <xref:System.Web.UI.ScriptManager.EnableScriptGlobalization%2A> 属性，以便客户端脚本可以在浏览器中显示特定于区域性的日期和时间。 在此示例中， [@ Page](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ydy4x04a(v=vs.100))指令的 `Culture` 属性设置为 `auto`。 因此，在当前浏览器设置中指定的第一种语言将确定页面的区域性和 UI 区域性。 有关详细信息，请参阅[如何：为 ASP.NET 网页全球化设置区域性和 UI 区域性](https://msdn.microsoft.com/library/76091f86-f967-4687-a40f-de87bd8cc9a0)。  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.EnableScriptGlobalization#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.EnableScriptGlobalization/CS/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.EnableScriptGlobalization#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.EnableScriptGlobalization/VB/default.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.ScriptManagerProxy" />
    <altmember cref="T:System.Web.UI.UpdatePanel" />
    <altmember cref="T:System.Web.UI.ClientScriptManager" />
    <altmember cref="T:System.Web.UI.ScriptMode" />
    <altmember cref="T:System.Web.UI.ScriptReference" />
    <altmember cref="T:System.Web.UI.ServiceReference" />
    <related type="Article" href="https://msdn.microsoft.com/library/fceeb3c5-c59f-46a9-af4f-b0d7155a1efc">WebForms. PageRequestManager 类</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ScriptManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ScriptManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Web.UI.ScriptManager" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数初始化 <xref:System.Web.UI.ScriptManager> 控件用于跟踪页面、控件和部署信息的内部字段。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddHistoryPoint">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建一个历史时间点，并将其添加到浏览器的历史记录堆栈中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这些方法重载使你能够定义服务器状态，并且可以选择浏览器中历史记录项的标题。 创建历史记录点时，会将序列化和加密的数据追加到网页的 URL，并在浏览器的历史记录堆栈中包含一个条目。 当引发任何后续的服务器导航事件时，可以使用状态数据来重新创建页面。 有关详细信息，请参阅[使用服务器控件管理浏览器历史记录](https://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddHistoryPoint">
      <MemberSignature Language="C#" Value="public void AddHistoryPoint (System.Collections.Specialized.NameValueCollection state, string title);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHistoryPoint(class System.Collections.Specialized.NameValueCollection state, string title) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.AddHistoryPoint(System.Collections.Specialized.NameValueCollection,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHistoryPoint (state As NameValueCollection, title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHistoryPoint(System::Collections::Specialized::NameValueCollection ^ state, System::String ^ title);" />
      <MemberSignature Language="F#" Value="member this.AddHistoryPoint : System.Collections.Specialized.NameValueCollection * string -&gt; unit" Usage="scriptManager.AddHistoryPoint (state, title)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Collections.Specialized.NameValueCollection" />
        <Parameter Name="title" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="state">包含状态数据的键/值对的集合。</param>
        <param name="title">将作为此状态的标题添加到浏览器的历史记录堆栈中的文本。</param>
        <summary>使用指定的状态数据集合和状态标题创建历史时间点，然后将它添加到浏览器的历史记录堆栈中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要为状态数据保存多个键/值对，请使用此方法创建历史记录点。 创建历史记录点时，会将序列化和加密的数据追加到网页的 URL，并在浏览器的历史记录堆栈中包含一个条目。 如果 `title` 参数 `null`，则网页标题将用作历史记录堆栈中状态条目的标题。  
  
 当引发任何后续的服务器导航事件时，可以使用状态数据来重新创建页面。 有关详细信息，请参阅[使用服务器控件管理浏览器历史记录](https://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHistoryPoint">
      <MemberSignature Language="C#" Value="public void AddHistoryPoint (string key, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHistoryPoint(string key, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.AddHistoryPoint(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHistoryPoint (key As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHistoryPoint(System::String ^ key, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AddHistoryPoint : string * string -&gt; unit" Usage="scriptManager.AddHistoryPoint (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">标识网页状态的键/值对的键部分。</param>
        <param name="value">标识网页状态的键/值对的值部分。</param>
        <summary>使用指定的状态键和状态值创建历史时间点，然后将它添加到浏览器的历史记录堆栈中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果只想保存值以标识状态，请使用此方法创建历史记录点。 创建历史记录点时，会将序列化和加密的数据追加到网页的 URL，并在浏览器的历史记录堆栈中包含一个条目。 网页标题用作历史记录堆栈中状态条目的标题。  
  
 当引发任何后续的服务器导航事件时，可以使用状态数据来重新创建页面。 有关详细信息，请参阅[使用服务器控件管理浏览器历史记录](https://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHistoryPoint">
      <MemberSignature Language="C#" Value="public void AddHistoryPoint (string key, string value, string title);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHistoryPoint(string key, string value, string title) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.AddHistoryPoint(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHistoryPoint (key As String, value As String, title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHistoryPoint(System::String ^ key, System::String ^ value, System::String ^ title);" />
      <MemberSignature Language="F#" Value="member this.AddHistoryPoint : string * string * string -&gt; unit" Usage="scriptManager.AddHistoryPoint (key, value, title)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="title" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">标识网页状态的键/值对的键部分。</param>
        <param name="value">标识网页状态的键/值对的值部分。</param>
        <param name="title">将作为此状态的标题添加到浏览器的历史记录堆栈中的文本。</param>
        <summary>使用指定的状态键、状态值和状态标题创建历史时间点，然后将它添加到浏览器的历史记录堆栈中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要保存值以标识状态和状态的标题，请使用此方法创建历史记录点。 创建历史记录点时，会将序列化和加密的数据追加到网页的 URL，并在浏览器的历史记录堆栈中包含一个条目。 如果 `title` 参数 `null`，则网页标题将用作历史记录堆栈中状态条目的标题。  
  
 当引发任何后续的服务器导航事件时，可以使用状态数据来重新创建页面。 有关详细信息，请参阅[使用服务器控件管理浏览器历史记录](https://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AjaxFrameworkAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly AjaxFrameworkAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly AjaxFrameworkAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AjaxFrameworkAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AjaxFrameworkAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ AjaxFrameworkAssembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AjaxFrameworkAssembly : System.Reflection.Assembly" Usage="System.Web.UI.ScriptManager.AjaxFrameworkAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取页上组件所使用的 Ajax framework 程序集。</summary>
        <value>Ajax framework 程序集。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AjaxFrameworkMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.AjaxFrameworkMode AjaxFrameworkMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.AjaxFrameworkMode AjaxFrameworkMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AjaxFrameworkMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AjaxFrameworkMode As AjaxFrameworkMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::AjaxFrameworkMode AjaxFrameworkMode { System::Web::UI::AjaxFrameworkMode get(); void set(System::Web::UI::AjaxFrameworkMode value); };" />
      <MemberSignature Language="F#" Value="member this.AjaxFrameworkMode : System.Web.UI.AjaxFrameworkMode with get, set" Usage="System.Web.UI.ScriptManager.AjaxFrameworkMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.AjaxFrameworkMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定将如何将 Microsoft Ajax 客户端库的客户端脚本包括到客户端上。</summary>
        <value>一个 <see cref="T:System.Web.UI.AjaxFrameworkMode" /> 枚举值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Web.UI.ScriptManager.AjaxFrameworkMode%2A> 属性启用所有 Microsoft Ajax 脚本文件，禁用所有 Microsoft Ajax 脚本文件，或显式包含单独的脚本文件。  
  
   
  
## Examples  
 下面的示例演示如何将 <xref:System.Web.UI.ScriptManager.AjaxFrameworkMode%2A> 属性设置为 `Explicit`，以指示可以显式指定脚本。  
  
```  
<asp:ScriptManager ID="sm1" AjaxFrameworkMode="Explicit" runat="server">   
<Scripts>   
    <asp:ScriptReference Name="MicrosoftAjaxCore.js" />   
    <asp:ScriptReference Name="MicrosoftAjaxComponentModel.js" />    
    <asp:ScriptReference Name="MicrosoftAjaxSerialization.js" />   
    <asp:ScriptReference Name="MicrosoftAjaxNetwork.js" />       
</Scripts>   
</asp:ScriptManager>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.AjaxFrameworkMode" />
      </Docs>
    </Member>
    <Member MemberName="AllowCustomErrorsRedirect">
      <MemberSignature Language="C#" Value="public bool AllowCustomErrorsRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowCustomErrorsRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowCustomErrorsRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowCustomErrorsRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowCustomErrorsRedirect : bool with get, set" Usage="System.Web.UI.ScriptManager.AllowCustomErrorsRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值确定异步回发出现错误时是否使用 Web.config 文件的自定义错误部分。</summary>
        <value>如果使用 Web.config 文件中的自定义错误设置来确定异步回发期间的错误行为，则为 <see langword="true" />；否则为 <see langword="false" />。 默认为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当异步回发期间出现页面错误时，将引发 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> 事件。 服务器上的错误发送到客户端的方式取决于 <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> 属性、<xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> 属性和 web.config 文件的自定义错误部分。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackError">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt; AsyncPostBackError;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.AsyncPostBackErrorEventArgs&gt; AsyncPostBackError" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.AsyncPostBackError" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AsyncPostBackError As EventHandler(Of AsyncPostBackErrorEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::AsyncPostBackErrorEventArgs ^&gt; ^ AsyncPostBackError;" />
      <MemberSignature Language="F#" Value="member this.AsyncPostBackError : EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt; " Usage="member this.AsyncPostBackError : System.EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当异步回发期间出现页面错误时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当异步回发期间出现页面错误时，将引发 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> 事件。 服务器上的错误发送到客户端的方式取决于 <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> 属性、<xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> 属性和 web.config 文件的自定义错误部分。  
  
   
  
## Examples  
 下面的示例演示如何处理 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> 事件，以将 <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> 属性（发送到客户端）设置为服务器异常错误消息。  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/CS/ScriptManager_AsyncPostBackErrorMessageCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/VB/ScriptManager_AsyncPostBackErrorMessageVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.OnAsyncPostBackError(System.Web.UI.AsyncPostBackErrorEventArgs)" />
        <altmember cref="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackErrorMessage">
      <MemberSignature Language="C#" Value="public string AsyncPostBackErrorMessage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AsyncPostBackErrorMessage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPostBackErrorMessage As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AsyncPostBackErrorMessage { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPostBackErrorMessage : string with get, set" Usage="System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置异步回发期间发生未处理的服务器异常时发送到客户端的错误消息。</summary>
        <value>错误消息。 默认值为空字符串("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当异步回发期间出现页面错误时，将引发 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> 事件。 服务器上的错误发送到客户端的方式取决于 <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> 属性、<xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> 属性和 web.config 文件的自定义错误部分。  
  
   
  
## Examples  
 下面的示例演示如何处理 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> 事件，以将 <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> 属性（发送到客户端）设置为服务器异常错误消息。  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/CS/ScriptManager_AsyncPostBackErrorMessageCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/VB/ScriptManager_AsyncPostBackErrorMessageVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.ScriptManager.AsyncPostBackError" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackSourceElementID">
      <MemberSignature Language="C#" Value="public string AsyncPostBackSourceElementID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AsyncPostBackSourceElementID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AsyncPostBackSourceElementID" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsyncPostBackSourceElementID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AsyncPostBackSourceElementID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPostBackSourceElementID : string" Usage="System.Web.UI.ScriptManager.AsyncPostBackSourceElementID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取引发异步回发的控件的唯一 ID。</summary>
        <value>如果控件具有 ID，则为它的唯一 ID；否则，为空字符串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.AsyncPostBackSourceElementID%2A> 属性包含导致异步回发的控件 ID 的值，可以是下列值之一：  
  
-   从控件的回发 <xref:System.Web.UI.UpdatePanel> 控件中的 <xref:System.Web.UI.UpdatePanel.ChildrenAsTriggers%2A> 属性设置为 `true` （默认值）。  
  
-   作为 <xref:System.Web.UI.UpdatePanel> 控件的触发器的控件的回发。  
  
-   通过调用 <xref:System.Web.UI.ScriptManager> 控件的 <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> 方法来注册的控件的回发。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackTimeout">
      <MemberSignature Language="C#" Value="public int AsyncPostBackTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AsyncPostBackTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AsyncPostBackTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPostBackTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AsyncPostBackTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPostBackTimeout : int with get, set" Usage="System.Web.UI.ScriptManager.AsyncPostBackTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(90)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示在未收到响应时异步回发超时前的时间（以秒为单位）。</summary>
        <value>一个表示超时的整数（以秒为单位）。 默认值为90秒。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationService">
      <MemberSignature Language="C#" Value="public System.Web.UI.AuthenticationServiceManager AuthenticationService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.AuthenticationServiceManager AuthenticationService" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AuthenticationService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AuthenticationService As AuthenticationServiceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::AuthenticationServiceManager ^ AuthenticationService { System::Web::UI::AuthenticationServiceManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationService : System.Web.UI.AuthenticationServiceManager" Usage="System.Web.UI.ScriptManager.AuthenticationService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.AuthenticationServiceManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与当前 <see cref="T:System.Web.UI.AuthenticationServiceManager" /> 实例关联的 <see cref="T:System.Web.UI.ScriptManager" /> 对象。</summary>
        <value>当前 <see cref="T:System.Web.UI.AuthenticationServiceManager" /> 实例的 <see cref="T:System.Web.UI.ScriptManager" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回的 <xref:System.Web.UI.AuthenticationServiceManager> 对象表示向页面注册的身份验证服务。 身份验证服务可以在 <xref:System.Web.UI.ScriptManager> 控件中或关联的 <xref:System.Web.UI.ScriptManagerProxy> 控件中定义。  
  
 你可以使用 ASP.NET authentication 服务或使用自定义身份验证服务。 可以通过在页面上的 `asp:ScriptManager` 元素内包含一个 `AuthenticationService` 元素，在标记中添加自定义服务，如以下示例中所示。  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <AuthenticationService Path="MyAuthenticationService.asmx" />  
</asp:ScriptManager>  
```  
  
 还可以通过编程方式配置 <xref:System.Web.UI.AuthenticationServiceManager> 对象。 在页面的 <xref:System.Web.UI.Control.PreRender> 生命周期阶段，会向 <xref:System.Web.UI.ScriptManager> 控件注册服务。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientNavigateHandler">
      <MemberSignature Language="C#" Value="public string ClientNavigateHandler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientNavigateHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ClientNavigateHandler" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientNavigateHandler As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ClientNavigateHandler { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientNavigateHandler : string with get, set" Usage="System.Web.UI.ScriptManager.ClientNavigateHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在客户端上处理 <see href="https://msdn.microsoft.com/library/79ac04af-18b4-4106-9ab7-9cb10fbd0b93">Sys.Application.navigate</see> 事件的方法的名称。</summary>
        <value>用于在客户端上处理 [Sys.Application.navigate](https://msdn.microsoft.com/library/79ac04af-18b4-4106-9ab7-9cb10fbd0b93) 事件的方法的名称。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompositeScript">
      <MemberSignature Language="C#" Value="public System.Web.UI.CompositeScriptReference CompositeScript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.CompositeScriptReference CompositeScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.CompositeScript" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompositeScript As CompositeScriptReference" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::CompositeScriptReference ^ CompositeScript { System::Web::UI::CompositeScriptReference ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompositeScript : System.Web.UI.CompositeScriptReference" Usage="System.Web.UI.ScriptManager.CompositeScript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.CompositeScriptReference</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对支持网页的复合脚本的引用。</summary>
        <value>对复合脚本的引用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[将客户端脚本合并到复合脚本中](https://msdn.microsoft.com/library/d0f608d0-b4c8-4795-990b-ede68c1239b3)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyPageUrl">
      <MemberSignature Language="C#" Value="public virtual string EmptyPageUrl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EmptyPageUrl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EmptyPageUrl" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EmptyPageUrl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EmptyPageUrl { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EmptyPageUrl : string with get, set" Usage="System.Web.UI.ScriptManager.EmptyPageUrl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor(typeof(System.Web.UI.Design.UrlEditor), typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.UrlProperty</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置空白网页的 URL。</summary>
        <value>要在目标网页为空时使用的 URL。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.EmptyPageUrl%2A> 属性支持 Ajax 浏览器历史记录。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableCdn">
      <MemberSignature Language="C#" Value="public bool EnableCdn { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableCdn" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableCdn" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableCdn As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableCdn { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableCdn : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableCdn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>确定当前页是否从 CDN（内容分发网络）路径加载客户端脚本引用。</summary>
        <value>如果从 CDN 路径加载客户端脚本引用，则为 <see langword="true" />，否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果已将 <xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A> 设置为 `true`，则不要将此属性设置为 `true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableCdnFallback">
      <MemberSignature Language="C#" Value="public bool EnableCdnFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableCdnFallback" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableCdnFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableCdnFallback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableCdnFallback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableCdnFallback : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableCdnFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在无法访问 CDN（内容分发网络）的情况下启动脚本本地副本加载。</summary>
        <value>如果启用了回退 CDN 值，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableHistory">
      <MemberSignature Language="C#" Value="public bool EnableHistory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableHistory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableHistory" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableHistory As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableHistory { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableHistory : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableHistory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示网页是否支持历史时间点管理。</summary>
        <value>如果网页支持将历史时间点添加到浏览器的历史记录堆栈中，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Web.UI.ScriptManager.EnableHistory%2A> 属性启用网页中的历史记录管理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnablePageMethods">
      <MemberSignature Language="C#" Value="public bool EnablePageMethods { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnablePageMethods" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnablePageMethods" />
      <MemberSignature Language="VB.NET" Value="Public Property EnablePageMethods As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnablePageMethods { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnablePageMethods : bool with get, set" Usage="System.Web.UI.ScriptManager.EnablePageMethods" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示能否从客户端脚本调用 ASP.NET 页中公共静态页方法。</summary>
        <value>如果可以从客户端脚本将 ASP.NET 页上的静态页方法作为 Web 方法调用，则为 <see langword="true" />；否则为 <see langword="false" />。 默认为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以将静态页面方法添加到 ASP.NET 页面，并将其标记为 Web 方法。 然后，可以从脚本中调用这些方法，就好像它们是 Web 服务的一部分，而不创建单独的 .asmx 文件。 若要在页面上创建 Web 方法，请导入 <xref:System.Web.Services> 命名空间，并将 <xref:System.Web.Services.WebMethodAttribute> 特性添加到要公开的每个静态方法。 这些方法必须标记为公共。  
  
 有关详细信息，请参阅[在 ASP.NET AJAX 中向客户端脚本公开 Web 服务](https://msdn.microsoft.com/library/fe3f6e9e-0acd-44c9-bf0f-0a8598fc13b8)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnablePartialRendering">
      <MemberSignature Language="C#" Value="public bool EnablePartialRendering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnablePartialRendering" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnablePartialRendering" />
      <MemberSignature Language="VB.NET" Value="Public Property EnablePartialRendering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnablePartialRendering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnablePartialRendering : bool with get, set" Usage="System.Web.UI.ScriptManager.EnablePartialRendering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个可部分呈现页面的值，该操作转而使你可以使用 <see cref="T:System.Web.UI.UpdatePanel" /> 控件来单独更新页面区域。</summary>
        <value>如果启用了部分呈现且禁止了整页更新，则为 <see langword="true" />；否则为 <see langword="false" />。 默认为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 即使 <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> 属性是 `true`的，也可能不会发生部分页面呈现。 浏览器可能不支持部分页面呈现，或 <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> 属性设置为 `false`。  
  
 可以在运行时或在页面的 <xref:System.Web.UI.Control.Init> 事件发生之前，重写 <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> 属性的值。 如果尝试在页面的 <xref:System.Web.UI.Control.Init> 事件发生后更改此属性，则会引发 <xref:System.InvalidOperationException> 异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">发生页面的 <see cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" /> 事件后，设置 <see cref="E:System.Web.UI.Control.Init" /> 属性。</exception>
        <altmember cref="T:System.Web.UI.UpdatePanel" />
        <altmember cref="P:System.Web.UI.ScriptManager.SupportsPartialRendering" />
      </Docs>
    </Member>
    <Member MemberName="EnableScriptGlobalization">
      <MemberSignature Language="C#" Value="public bool EnableScriptGlobalization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableScriptGlobalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableScriptGlobalization" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableScriptGlobalization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableScriptGlobalization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableScriptGlobalization : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableScriptGlobalization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示 <see cref="T:System.Web.UI.ScriptManager" /> 控件是否呈现支持分析和格式化区域性特定的信息的脚本。</summary>
        <value>如果可以显示区域性特定的信息，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.EnableScriptGlobalization%2A> 属性设置为 `true`时，全球化 ECMAScript （JavaScript）函数（例如 `Date.localeFormat` 方法）显示特定于区域性的信息。 可以在浏览器、服务器代码或网站的配置文件中设置区域性。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/69b34e6d-d590-4d03-a763-b7ae54b47d74">使用客户端脚本本地化日期</related>
      </Docs>
    </Member>
    <Member MemberName="EnableScriptLocalization">
      <MemberSignature Language="C#" Value="public bool EnableScriptLocalization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableScriptLocalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableScriptLocalization" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableScriptLocalization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableScriptLocalization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableScriptLocalization : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableScriptLocalization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示 <see cref="T:System.Web.UI.ScriptManager" /> 控件是否呈现脚本文件的本地化版本。</summary>
        <value>如果将呈现本地化脚本文件，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值是 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.EnableScriptLocalization%2A> 属性设置为 `true`时，<xref:System.Web.UI.ScriptManager> 对象将检索当前区域性的脚本文件（如果存在）。 例如，页可能指定名为 CustomScript 的脚本文件。 如果将区域性设置为 fr-CA，则 <xref:System.Web.UI.ScriptManager> 对象将尝试检索名为 CustomScript.fr-CA 的脚本文件。  
  
> [!NOTE]
>  若要防止脚本文件被呈现两次，则不能在异步回发过程中修改 <xref:System.Web.UI.ScriptManager.EnableScriptLocalization%2A> 属性。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/e6b15435-57c1-4dd1-9bd3-5d4c509685bb">组件库的本地化资源概述</related>
      </Docs>
    </Member>
    <Member MemberName="EnableSecureHistoryState">
      <MemberSignature Language="C#" Value="public bool EnableSecureHistoryState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableSecureHistoryState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableSecureHistoryState" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableSecureHistoryState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableSecureHistoryState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableSecureHistoryState : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableSecureHistoryState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否加密历史记录状态字符串。</summary>
        <value>如果应加密历史记录状态字符串，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值是 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  ***不***应将此属性设置为在生产网站上 `false`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrent">
      <MemberSignature Language="C#" Value="public static System.Web.UI.ScriptManager GetCurrent (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.ScriptManager GetCurrent(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetCurrent(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::ScriptManager ^ GetCurrent(System::Web::UI::Page ^ page);" />
      <MemberSignature Language="F#" Value="static member GetCurrent : System.Web.UI.Page -&gt; System.Web.UI.ScriptManager" Usage="System.Web.UI.ScriptManager.GetCurrent page" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">要从中检索 <see cref="T:System.Web.UI.ScriptManager" /> 的页实例。</param>
        <summary>获取给定 <see cref="T:System.Web.UI.ScriptManager" /> 对象的 <see cref="T:System.Web.UI.Page" /> 实例。</summary>
        <returns>选定 <see cref="T:System.Web.UI.ScriptManager" /> 对象的当前 <see cref="T:System.Web.UI.Page" /> 实例；如果未定义实例，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此静态方法来确定某个 <xref:System.Web.UI.ScriptManager> 控件是否位于某个页面上，或在您不知道其 ID 时访问 <xref:System.Web.UI.ScriptManager> 控件的属性和方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="page" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredArrayDeclarations">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredArrayDeclaration&gt; GetRegisteredArrayDeclarations ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredArrayDeclaration&gt; GetRegisteredArrayDeclarations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredArrayDeclarations" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredArrayDeclarations () As ReadOnlyCollection(Of RegisteredArrayDeclaration)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredArrayDeclaration ^&gt; ^ GetRegisteredArrayDeclarations();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredArrayDeclarations : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredArrayDeclaration&gt;" Usage="scriptManager.GetRegisteredArrayDeclarations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredArrayDeclaration&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索先前已向 <see cref="T:System.Web.UI.Page" /> 对象注册的 ECMAScript (JavaScript) 数组声明的只读集合。</summary>
        <returns>一个包含数组声明的泛型集合。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="Overload:System.Web.UI.ScriptManager.RegisterArrayDeclaration" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredClientScriptBlocks">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt; GetRegisteredClientScriptBlocks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredScript&gt; GetRegisteredClientScriptBlocks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredClientScriptBlocks" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredClientScriptBlocks () As ReadOnlyCollection(Of RegisteredScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredScript ^&gt; ^ GetRegisteredClientScriptBlocks();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredClientScriptBlocks : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;" Usage="scriptManager.GetRegisteredClientScriptBlocks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索先前已向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册的客户端脚本块的只读集合。</summary>
        <returns>一个包含客户端脚本块的泛型集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 向 <xref:System.Web.UI.ScriptManager> 控件注册客户端脚本块，以便与 <xref:System.Web.UI.UpdatePanel> 控件内的控件一起使用。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredDisposeScripts">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredDisposeScript&gt; GetRegisteredDisposeScripts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredDisposeScript&gt; GetRegisteredDisposeScripts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredDisposeScripts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredDisposeScripts () As ReadOnlyCollection(Of RegisteredDisposeScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredDisposeScript ^&gt; ^ GetRegisteredDisposeScripts();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredDisposeScripts : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredDisposeScript&gt;" Usage="scriptManager.GetRegisteredDisposeScripts " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredDisposeScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索先前已向 <see langword="dispose" /> 对象注册的 <see cref="T:System.Web.UI.Page" /> 脚本的只读集合。</summary>
        <returns>一个包含 <see langword="dispose" /> 脚本的泛型集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `dispose` 脚本在 <xref:System.Web.UI.UpdatePanel> 控件更新或删除时执行。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterDispose(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredExpandoAttributes">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredExpandoAttribute&gt; GetRegisteredExpandoAttributes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredExpandoAttribute&gt; GetRegisteredExpandoAttributes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredExpandoAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredExpandoAttributes () As ReadOnlyCollection(Of RegisteredExpandoAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredExpandoAttribute ^&gt; ^ GetRegisteredExpandoAttributes();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredExpandoAttributes : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredExpandoAttribute&gt;" Usage="scriptManager.GetRegisteredExpandoAttributes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredExpandoAttribute&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索先前已向 <see cref="T:System.Web.UI.Page" /> 对象注册的自定义 (expando) 特性的只读集合。</summary>
        <returns>一个包含自定义特性的泛型集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 自定义属性是可以由客户端脚本读取和设置的名称/值对。  
  
   
  
## Examples  
 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A>  
  
 <xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A>  
  
 <xref:System.Web.UI.RegisteredExpandoAttribute>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredHiddenFields">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredHiddenField&gt; GetRegisteredHiddenFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredHiddenField&gt; GetRegisteredHiddenFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredHiddenFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredHiddenFields () As ReadOnlyCollection(Of RegisteredHiddenField)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredHiddenField ^&gt; ^ GetRegisteredHiddenFields();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredHiddenFields : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredHiddenField&gt;" Usage="scriptManager.GetRegisteredHiddenFields " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredHiddenField&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索先前已向 <see cref="T:System.Web.UI.Page" /> 对象注册的隐藏字段的只读集合。</summary>
        <returns>一个包含隐藏字段的泛型集合。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.UI.RegisteredHiddenField" />
        <altmember cref="Overload:System.Web.UI.ScriptManager.RegisterHiddenField" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterHiddenField(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredOnSubmitStatements">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt; GetRegisteredOnSubmitStatements ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredScript&gt; GetRegisteredOnSubmitStatements() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredOnSubmitStatements" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredOnSubmitStatements () As ReadOnlyCollection(Of RegisteredScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredScript ^&gt; ^ GetRegisteredOnSubmitStatements();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredOnSubmitStatements : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;" Usage="scriptManager.GetRegisteredOnSubmitStatements " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索先前已向 <see langword="onsubmit" /> 对象注册的 <see cref="T:System.Web.UI.Page" /> 语句的只读集合。</summary>
        <returns>一个包含 <see langword="onsubmit" /> 语句的泛型集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `onsubmit` 语句是在提交窗体时执行的 ECMAScript （JavaScript）。  
  
   
  
## Examples  
 <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A>  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredStartupScripts">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt; GetRegisteredStartupScripts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredScript&gt; GetRegisteredStartupScripts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredStartupScripts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredStartupScripts () As ReadOnlyCollection(Of RegisteredScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredScript ^&gt; ^ GetRegisteredStartupScripts();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredStartupScripts : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;" Usage="scriptManager.GetRegisteredStartupScripts " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索先前已向 <see cref="T:System.Web.UI.Page" /> 对象注册的启动脚本的只读集合。</summary>
        <returns>一个包含启动脚本的泛型集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 启动脚本是与控件启动时执行的控件相关联的客户端脚本。  
  
   
  
## Examples  
 <xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A>  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>  
  
 <xref:System.Web.UI.ScriptManager.GetRegisteredStartupScripts%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetStateString">
      <MemberSignature Language="C#" Value="public string GetStateString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetStateString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetStateString" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStateString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetStateString();" />
      <MemberSignature Language="F#" Value="member this.GetStateString : unit -&gt; string" Usage="scriptManager.GetStateString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索包含表示网页状态的键/值对的字符串。</summary>
        <returns>一个字符串，其中包含表示网页状态的键/值对。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.IsDebuggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDebuggingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDebuggingEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDebuggingEnabled : bool" Usage="System.Web.UI.ScriptManager.IsDebuggingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，它指示是否将呈现客户端脚本库的调试版本。</summary>
        <value>如果要在调试模式下执行当前请求，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果满足以下任一条件，则 <xref:System.Web.UI.ScriptManager.IsDebuggingEnabled%2A> 属性将返回 `false`：  
  
-   在配置文件的[deployment](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms228298(v%3dvs.100))元素中，`retail` 特性设置为 `true`。 这将覆盖所有其他设置。  
  
-   <xref:System.Web.UI.ScriptManager.ScriptMode%2A> 属性设置为 `Auto` 或 `Inherit`，并且未在应用程序根 web.config 文件的 `compilation` 部分中启用调试。  
  
-   <xref:System.Web.UI.ScriptManager.ScriptMode%2A> 属性设置为 `Release`。  
  
    > [!NOTE]
    >  [@ Page](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ydy4x04a(v=vs.100))指令的 `debug` 属性不影响启用了 Ajax 的 ASP.NET 应用程序。 <xref:System.Web.UI.ScriptManager> 控件只使用 web.config 文件及其 <xref:System.Web.UI.ScriptManager.IsDebuggingEnabled%2A> 中的设置，并 <xref:System.Web.UI.ScriptManager.ScriptMode%2A> 属性来确定是否呈现调试脚本。  
  
 有关详细信息，请参阅[调试和跟踪 Ajax 应用程序概述](https://msdn.microsoft.com/library/92684ea0-7bb4-4a34-9203-3aa6394ce375)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.IsDebuggingEnabled" />
      </Docs>
    </Member>
    <Member MemberName="IsInAsyncPostBack">
      <MemberSignature Language="C#" Value="public bool IsInAsyncPostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInAsyncPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.IsInAsyncPostBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInAsyncPostBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInAsyncPostBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInAsyncPostBack : bool" Usage="System.Web.UI.ScriptManager.IsInAsyncPostBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否要在部分呈现模式下执行当前回发。</summary>
        <value>如果要在部分呈现模式下执行当前回发，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 结合使用 <xref:System.Web.UI.ScriptManager.IsInAsyncPostBack%2A> 属性和 <xref:System.Web.UI.Page.IsPostBack%2A> 属性可以区分初始页面负载、部分页面更新和 <xref:System.Web.UI.Control.Load>、<xref:System.Web.UI.Page.InitComplete>或 <xref:System.Web.UI.Control.PreRender> 事件中的整页更新。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" />
      </Docs>
    </Member>
    <Member MemberName="IsNavigating">
      <MemberSignature Language="C#" Value="public bool IsNavigating { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNavigating" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.IsNavigating" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNavigating As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNavigating { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNavigating : bool" Usage="System.Web.UI.ScriptManager.IsNavigating" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前是否正在处理 <see cref="E:System.Web.UI.ScriptManager.Navigate" /> 事件。</summary>
        <value>如果正在处理 <see langword="true" />，则为 <see cref="E:System.Web.UI.ScriptManager.Navigate" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Web.UI.ScriptManager.IsNavigating%2A> 属性来确定是否引发了 <xref:System.Web.UI.ScriptManager.Navigate> 事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPostData">
      <MemberSignature Language="C#" Value="protected virtual bool LoadPostData (string postDataKey, System.Collections.Specialized.NameValueCollection postCollection);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LoadPostData(string postDataKey, class System.Collections.Specialized.NameValueCollection postCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LoadPostData (postDataKey As String, postCollection As NameValueCollection) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LoadPostData(System::String ^ postDataKey, System::Collections::Specialized::NameValueCollection ^ postCollection);" />
      <MemberSignature Language="F#" Value="abstract member LoadPostData : string * System.Collections.Specialized.NameValueCollection -&gt; bool&#xA;override this.LoadPostData : string * System.Collections.Specialized.NameValueCollection -&gt; bool" Usage="scriptManager.LoadPostData (postDataKey, postCollection)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackDataHandler.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="postDataKey" Type="System.String" />
        <Parameter Name="postCollection" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="postDataKey">控件的主要标识符。</param>
        <param name="postCollection">所有传入的后期数据的集合。</param>
        <summary>读取从浏览器发送到服务器的表单数据，并确定异步回发的源。</summary>
        <returns>如果 <see langword="true" /> 控件的状态已因回发而更改，则为 <see cref="T:System.Web.UI.ScriptManager" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.LoadPostData%2A> 方法主要由控件开发人员用来扩展 <xref:System.Web.UI.ScriptManager> 控件的功能。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
      </Docs>
    </Member>
    <Member MemberName="LoadScriptsBeforeUI">
      <MemberSignature Language="C#" Value="public bool LoadScriptsBeforeUI { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LoadScriptsBeforeUI" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.LoadScriptsBeforeUI" />
      <MemberSignature Language="VB.NET" Value="Public Property LoadScriptsBeforeUI As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool LoadScriptsBeforeUI { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.LoadScriptsBeforeUI : bool with get, set" Usage="System.Web.UI.ScriptManager.LoadScriptsBeforeUI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是在加载页 UI 的标记之前还是在之后加载脚本。</summary>
        <value>如果在加载 UI 标记前加载脚本，则为 <see langword="true" />；如果在加载 UI 标记后加载脚本，则为 <see langword="false" />。 默认为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A> 属性确定如何相对于页面 UI 的标记加载 <xref:System.Web.UI.ScriptManager.Scripts%2A> 集合中的脚本。  
  
 当 `true`<xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A> 属性时，在加载页面的 UI 标记之前，将呈现 `script` 元素。 在这种情况下，如果 UI 元素是在脚本中定义的，则 UI 将在加载时完全正常运行。 但是，如果脚本访问标记中尚未创建实例的 UI 元素，则可能会发生错误。 若要确保 UI 元素在访问之前加载，请处理 `Sys.Application` 类的 `load` 事件。  
  
 当 `false`<xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A> 属性时，呈现页面的 UI 标记后，将呈现 `script` 元素。 在这种情况下，UI 加载速度更快，但如果定义其他 UI 元素的脚本尚未完成加载，则它可能无法完全正常运行。  
  
 如果已将 <xref:System.Web.UI.ScriptManager.EnableCdn%2A> 设置为 `true`，则不要将此属性设置为 `true`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.ScriptManager.Scripts" />
        <altmember cref="T:System.Web.UI.ScriptReference" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.HistoryEventArgs&gt; Navigate;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.HistoryEventArgs&gt; Navigate" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.Navigate" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigate As EventHandler(Of HistoryEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::HistoryEventArgs ^&gt; ^ Navigate;" />
      <MemberSignature Language="F#" Value="member this.Navigate : EventHandler&lt;System.Web.UI.HistoryEventArgs&gt; " Usage="member this.Navigate : System.EventHandler&lt;System.Web.UI.HistoryEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.HistoryEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户点击浏览器的“后退”或“前进”按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当用户单击浏览器的 "**后退**" 按钮时，浏览器将导航到以前查看过的 url，其中可能包括包含历史记录点状态数据的 url。 如果网页中的客户端代码检测到 URL 包含历史记录状态数据，则会向服务器页发出请求。 这作为回发事件，<xref:System.Web.UI.ScriptManagerProxy> 服务器控件引发 `Navigate` 事件。 可以通过使用随事件传递的状态数据来处理此事件，并根据需要在 Web 应用程序中重新创建页面。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAsyncPostBackError">
      <MemberSignature Language="C#" Value="protected internal virtual void OnAsyncPostBackError (System.Web.UI.AsyncPostBackErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnAsyncPostBackError(class System.Web.UI.AsyncPostBackErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnAsyncPostBackError(System.Web.UI.AsyncPostBackErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnAsyncPostBackError (e As AsyncPostBackErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnAsyncPostBackError(System::Web::UI::AsyncPostBackErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAsyncPostBackError : System.Web.UI.AsyncPostBackErrorEventArgs -&gt; unit&#xA;override this.OnAsyncPostBackError : System.Web.UI.AsyncPostBackErrorEventArgs -&gt; unit" Usage="scriptManager.OnAsyncPostBackError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.AsyncPostBackErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">错误事件数据。</param>
        <summary>引发 <see cref="E:System.Web.UI.ScriptManager.AsyncPostBackError" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当异步回发期间出现页面错误时，将引发 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> 事件。 服务器上的错误发送到客户端的方式取决于 <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> 属性、<xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> 属性和 web.config 文件的自定义错误部分。  
  
   
  
## Examples  
 下面的示例演示如何处理 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> 事件，以将 <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> 属性（发送到客户端）设置为服务器异常错误消息。  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/CS/ScriptManager_AsyncPostBackErrorMessageCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/VB/ScriptManager_AsyncPostBackErrorMessageVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.ScriptManager.AsyncPostBackError" />
        <altmember cref="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnInit : EventArgs -&gt; unit" Usage="scriptManager.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件数据。</param>
        <summary>引发 <see cref="E:System.Web.UI.Control.Init" /> 事件并确保页面上只有一个 <see cref="T:System.Web.UI.ScriptManager" /> 控件。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">页面上存在多个 <see cref="T:System.Web.UI.ScriptManager" /> 实例。</exception>
        <block subset="none" type="overrides"><para>重写此方法时，调用基 <see cref="M:System.Web.UI.ScriptManager.OnInit(System.EventArgs)" /> 方法，以便正确处理脚本文件以进行部分页面呈现。</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 页生命周期概述</related>
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal override void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPreRender : EventArgs -&gt; unit" Usage="scriptManager.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件数据。</param>
        <summary>引发 <see cref="E:System.Web.UI.Control.PreRender" /> 事件，并为部分页面更新注册脚本文件和服务。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关 DOM 的信息，请参阅万维网联合会（W3C）网站上的[文档对象模型（DOM）级别1规范](https://go.microsoft.com/fwlink/?LinkId=73305)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">发出部分页面请求的浏览器至少不支持 DOM Level 1.0。</exception>
        <block subset="none" type="overrides"><para>重写此方法时，调用基 <see cref="M:System.Web.UI.ScriptManager.OnPreRender(System.EventArgs)" /> 方法，以便正确处理脚本块和服务，以便进行部分页面呈现。</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 页生命周期概述</related>
      </Docs>
    </Member>
    <Member MemberName="OnResolveCompositeScriptReference">
      <MemberSignature Language="C#" Value="protected virtual void OnResolveCompositeScriptReference (System.Web.UI.CompositeScriptReferenceEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResolveCompositeScriptReference(class System.Web.UI.CompositeScriptReferenceEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnResolveCompositeScriptReference(System.Web.UI.CompositeScriptReferenceEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResolveCompositeScriptReference (e As CompositeScriptReferenceEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResolveCompositeScriptReference(System::Web::UI::CompositeScriptReferenceEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnResolveCompositeScriptReference : System.Web.UI.CompositeScriptReferenceEventArgs -&gt; unit&#xA;override this.OnResolveCompositeScriptReference : System.Web.UI.CompositeScriptReferenceEventArgs -&gt; unit" Usage="scriptManager.OnResolveCompositeScriptReference e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.CompositeScriptReferenceEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">一个表示复合脚本引用的对象。</param>
        <summary>引发 <see cref="E:System.Web.UI.ScriptManager.ResolveCompositeScriptReference" /> 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnResolveScriptReference">
      <MemberSignature Language="C#" Value="protected virtual void OnResolveScriptReference (System.Web.UI.ScriptReferenceEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResolveScriptReference(class System.Web.UI.ScriptReferenceEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnResolveScriptReference(System.Web.UI.ScriptReferenceEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResolveScriptReference (e As ScriptReferenceEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResolveScriptReference(System::Web::UI::ScriptReferenceEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnResolveScriptReference : System.Web.UI.ScriptReferenceEventArgs -&gt; unit&#xA;override this.OnResolveScriptReference : System.Web.UI.ScriptReferenceEventArgs -&gt; unit" Usage="scriptManager.OnResolveScriptReference e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.ScriptReferenceEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">一个表示当前脚本的对象。</param>
        <summary>为 <see cref="E:System.Web.UI.ScriptManager.ResolveScriptReference" /> 控件托管的每个脚本引用引发 <see cref="T:System.Web.UI.ScriptManager" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法由 <xref:System.Web.UI.ScriptManager.OnPreRender%2A> 事件处理程序为 <xref:System.Web.UI.ScriptManager.Scripts%2A> 集合中的每个 <xref:System.Web.UI.ScriptReference> 调用一次。  
  
 解析重复的脚本条目后引发 <xref:System.Web.UI.ScriptManager.ResolveScriptReference> 事件。  
  
 重写此方法以影响回发或部分页更新期间各个脚本块的行为。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProfileService">
      <MemberSignature Language="C#" Value="public System.Web.UI.ProfileServiceManager ProfileService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ProfileServiceManager ProfileService" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ProfileService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProfileService As ProfileServiceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ProfileServiceManager ^ ProfileService { System::Web::UI::ProfileServiceManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProfileService : System.Web.UI.ProfileServiceManager" Usage="System.Web.UI.ScriptManager.ProfileService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ProfileServiceManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与当前 <see cref="T:System.Web.UI.ProfileServiceManager" /> 实例关联的 <see cref="T:System.Web.UI.ScriptManager" /> 对象。</summary>
        <value>当前 <see cref="T:System.Web.UI.ProfileServiceManager" /> 实例的 <see cref="T:System.Web.UI.ScriptManager" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回的 <xref:System.Web.UI.ProfileServiceManager> 对象表示向页面注册的配置文件服务。 可以在 <xref:System.Web.UI.ScriptManager> 控件或关联的 <xref:System.Web.UI.ScriptManagerProxy> 控件中定义配置文件服务。  
  
 你可以使用 ASP.NET profile 服务或使用自定义配置文件服务。 可以通过在页面上的 `asp:ScriptManager` 元素内包含一个 `ProfileService` 元素，在标记中添加自定义服务，如下面的示例中所示。  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <ProfileService LoadProperties="propertyA,propertyB"  
    Path="MyProfileService.asmx" />  
</asp:ScriptManager>  
```  
  
 还可以通过编程方式配置 <xref:System.Web.UI.ProfileServiceManager> 对象。 在页面的 <xref:System.Web.UI.Control.PreRender> 生命周期阶段，会向 <xref:System.Web.UI.ScriptManager> 控件注册服务。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePostBackEvent">
      <MemberSignature Language="C#" Value="protected virtual void RaisePostBackEvent (string eventArgument);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RaisePostBackEvent(string eventArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RaisePostBackEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RaisePostBackEvent (eventArgument As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RaisePostBackEvent(System::String ^ eventArgument);" />
      <MemberSignature Language="F#" Value="abstract member RaisePostBackEvent : string -&gt; unit&#xA;override this.RaisePostBackEvent : string -&gt; unit" Usage="scriptManager.RaisePostBackEvent eventArgument" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventArgument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventArgument">表示网页历史记录状态的键/值对的字符串。</param>
        <summary>处理由 <see cref="T:System.Web.UI.ScriptManager" /> 控件引发的回发事件，并加载网页的历史记录状态。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePostDataChangedEvent">
      <MemberSignature Language="C#" Value="protected virtual void RaisePostDataChangedEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RaisePostDataChangedEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RaisePostDataChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RaisePostDataChangedEvent ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RaisePostDataChangedEvent();" />
      <MemberSignature Language="F#" Value="abstract member RaisePostDataChangedEvent : unit -&gt; unit&#xA;override this.RaisePostDataChangedEvent : unit -&gt; unit" Usage="scriptManager.RaisePostDataChangedEvent " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当 <see cref="T:System.Web.UI.ScriptManager" /> 控件回发到服务器时引发此控件的事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.RaisePostDataChangedEvent%2A> 方法主要由控件开发人员用来扩展 <xref:System.Web.UI.ScriptManager> 控件的功能。 对于 <xref:System.Web.UI.ScriptManager> 控件的默认实现，不会引发任何事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterArrayDeclaration">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册一个 ECMAScript (JavaScript) 数组声明以与 <see cref="T:System.Web.UI.UpdatePanel" /> 控件内的某个控件一起使用，并将此数组添加到页面中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public static void RegisterArrayDeclaration (System.Web.UI.Control control, string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterArrayDeclaration(class System.Web.UI.Control control, string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterArrayDeclaration(System::Web::UI::Control ^ control, System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="static member RegisterArrayDeclaration : System.Web.UI.Control * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterArrayDeclaration (control, arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">正在注册数组的控件。</param>
        <param name="arrayName">要注册的数组的名称。</param>
        <param name="arrayValue">要注册的一个或多个数组值。</param>
        <summary>向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册一个 ECMAScript (JavaScript) 数组声明以与 <see cref="T:System.Web.UI.UpdatePanel" /> 控件内的某个控件一起使用，并将此数组添加到页面中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A> 方法来注册与部分页面呈现兼容且没有 Microsoft Ajax 库依赖项的客户端脚本数组。 当 `control` 表示正在更新的 <xref:System.Web.UI.UpdatePanel> 控件内的控件时，此方法将注册数组。 若要在每次发生异步回发时都注册数组，请使用此方法的 <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%28System.Web.UI.Page%2CSystem.String%2CSystem.String%29> 重载。  
  
 如果要注册不与部分页更新相关的数组，并且想要在初始页面呈现期间只注册一次数组，请使用 <xref:System.Web.UI.ClientScriptManager> 类的 <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> 方法。 可以从页的 <xref:System.Web.UI.Page.ClientScript%2A> 属性中获取对 <xref:System.Web.UI.ClientScriptManager> 对象的引用。  
  
 <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A> 方法确定是否已注册了具有在 `arrayName` 参数中指定的名称的数组。 如果是这样，则方法将添加在 `arrayValue`中指定的值。 由于要注册的数组基于 <xref:System.Collections.ArrayList> 类，因此允许重复项。 如果 `arrayName` 中名为的已注册数组不存在，则将创建数组，并将 `arrayValue` 中的值添加到该数组。  
  
 若要在数组中包含字符串文本，请在 `arrayValue`中使用单引号（'）或转义双引号（\\"）。  
  
 请注意，JavaScript 将逗号（，）视为数组中的分隔符。 可以指定多个数组值，方法是在 `arrayValue`中传递以逗号分隔的字符串。 在 `arrayValue` 中用逗号分隔两个项等效于对每个项调用 <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A> 方法两次。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="arrayName" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Page,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public static void RegisterArrayDeclaration (System.Web.UI.Page page, string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterArrayDeclaration(class System.Web.UI.Page page, string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Page,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterArrayDeclaration(System::Web::UI::Page ^ page, System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="static member RegisterArrayDeclaration : System.Web.UI.Page * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterArrayDeclaration (page, arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">正在注册该数组的页对象。</param>
        <param name="arrayName">要注册的数组的名称。</param>
        <param name="arrayValue">要注册的一个或多个数组值。</param>
        <summary>向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册一个 ECMAScript (JavaScript) 数组声明以与 <see cref="T:System.Web.UI.UpdatePanel" /> 控件内的某个控件一起使用，并将此数组添加到页面中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A> 方法来注册与部分页面呈现兼容且没有 Microsoft Ajax 库依赖项的客户端脚本数组。 此方法在每次发生异步回发时都注册数组。 若要为位于 <xref:System.Web.UI.UpdatePanel> 控件内的控件注册数组以便仅在更新面板时注册该数组，请使用此方法的 <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%28System.Web.UI.Control%2CSystem.String%2CSystem.String%29> 重载。  
  
 如果要注册不与部分页更新相关的数组，并且想要在初始页面呈现期间只注册一次数组，请使用 <xref:System.Web.UI.ClientScriptManager> 类的 <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> 方法。 可以从页的 <xref:System.Web.UI.Page.ClientScript%2A> 属性中获取对 <xref:System.Web.UI.ClientScriptManager> 对象的引用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="arrayName" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAsyncPostBackControl">
      <MemberSignature Language="C#" Value="public void RegisterAsyncPostBackControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterAsyncPostBackControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterAsyncPostBackControl(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member RegisterAsyncPostBackControl : System.Web.UI.Control -&gt; unit&#xA;override this.RegisterAsyncPostBackControl : System.Web.UI.Control -&gt; unit" Usage="scriptManager.RegisterAsyncPostBackControl control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">要为异步回发注册的控件。</param>
        <summary>将控件注册为异步回发的触发器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 利用 <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> 方法，你可以将 Web 服务器控件注册为触发器，以便它们执行异步回发而不是同步回发。 当 <xref:System.Web.UI.UpdatePanel> 控件的 <xref:System.Web.UI.UpdatePanel.ChildrenAsTriggers%2A> 属性设置为 `true` （默认值）时，<xref:System.Web.UI.UpdatePanel> 控件内的回发控件会自动注册为异步回发控件。  
  
 使用 <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> 方法将 <xref:System.Web.UI.UpdatePanel> 控件之外的控件注册为异步回发的触发器，并可能更新更新面板的内容。 若要以编程方式更新 <xref:System.Web.UI.UpdatePanel> 控件，请调用 <xref:System.Web.UI.UpdatePanel.Update%2A> 方法。  
  
 您可以使用 <xref:System.Web.UI.UpdatePanel> 控件的 `Triggers` 元素以声明方式添加触发器。 在 Visual Studio 中，使用设计器的 " **UpdatePanelTrigger 集合编辑器**" 对话框。  
  
   
  
## Examples  
 下面的示例演示如何调用 <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> 方法来注册 <xref:System.Web.UI.WebControls.Button> 控件，以便更新 <xref:System.Web.UI.UpdatePanel> 控件的内容。 <xref:System.Web.UI.WebControls.Button> 控件不在 <xref:System.Web.UI.UpdatePanel> 控件中。 将显示两个按钮： `Button1` 和 `Button2`。 `Button1` 刷新面板的内容，`Button2` 刷新整个页面。  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/CS/ScriptManager1CS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/VB/ScriptManager1VB.aspx#1)]  
  
 下面的示例演示如何调用 <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> 方法来注册用户控件，以便更新 <xref:System.Web.UI.UpdatePanel> 控件内容。 第一个示例演示使用用户控件的页。 第二个示例演示用户控件。  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#2](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/CS/ScriptManager2CS.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#2](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/VB/ScriptManager2VB.aspx#2)]  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">将页面注册为异步回发控件。

-或-

注册的控件不实现 <see cref="T:System.Web.UI.INamingContainer" />、<see cref="T:System.Web.UI.IPostBackDataHandler" /> 或 <see cref="T:System.Web.UI.IPostBackEventHandler" /> 接口。</exception>
        <altmember cref="P:System.Web.UI.UpdatePanel.Triggers" />
        <altmember cref="M:System.Web.UI.UpdatePanel.Update" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptBlock">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册一个客户端脚本块以与 <see cref="T:System.Web.UI.UpdatePanel" /> 控件中的某个控件一起使用，然后将该此脚本块添加到页面中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptBlock (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptBlock(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptBlock(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptBlock : System.Web.UI.Control * Type * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptBlock (control, type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">正在注册客户端脚本块的控件。</param>
        <param name="type">客户端脚本块的类型。 通常使用 <see langword="typeof" /> 运算符 (C#) 或 <see langword="GetType" /> 运算符 (Visual Basic) 来指定此参数，以检索正在注册此脚本的控件的类型。</param>
        <param name="key">脚本块的唯一标识符。</param>
        <param name="script">脚本。</param>
        <param name="addScriptTags">如果要用 <see langword="true" /> 和 <see langword="&lt;script&gt;" /> 标记括起脚本块，则为 <see langword="&lt;/script&gt;" />；否则为 <see langword="false" />。</param>
        <summary>向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册一个客户端脚本块以与 <see cref="T:System.Web.UI.UpdatePanel" /> 控件中的某个控件一起使用，然后将该此脚本块添加到页面中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A> 方法来注册与部分页面呈现兼容且没有 Microsoft Ajax 库依赖项的客户端脚本块。 使用此方法注册的客户端脚本块仅在 `control` 表示正在更新的 <xref:System.Web.UI.UpdatePanel> 控件内的控件时发送到页面。 若要在每次发生异步回发时注册脚本块，请使用此方法的 <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 重载。  
  
 如果要注册不与部分页更新相关的脚本块，并且在初始页面呈现期间只需注册脚本块一次，请使用 <xref:System.Web.UI.ClientScriptManager> 类的 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 方法。 可以从页的 <xref:System.Web.UI.Page.ClientScript%2A> 属性中获取对 <xref:System.Web.UI.ClientScriptManager> 对象的引用。  
  
 如果 `true``addScriptTags`，则 <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A> 方法会在脚本块周围添加 `<script>` 标记。 如果要自行创建 `<script>` 标记，请传递 `false` （例如，当你想要设置特定 `<script>` 标记的属性时）。 如果 `addScriptTags` `false` 并且 `script` 参数包含多个脚本块，则会引发异常。  
  
 <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A> 方法将脚本块添加到开始 `<form>` 标记之后的页中。 不保证脚本块的输出顺序与它们的注册顺序相同。 如果脚本块的顺序很重要，请将脚本块连接到单个字符串（例如，通过使用 <xref:System.Text.StringBuilder> 对象），然后将其注册为单个客户端脚本块。  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptBlock/CS/ScriptManager_RegisterClientScriptBlockCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptBlock/vb/ScriptManager_RegisterClientScriptBlockVB.aspx#1)]  
  
 [!code-xml[System.Web.UI.ScriptManager.RegisterClientScriptBlock#2](~/samples/snippets/common/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptBlock/Common/App_Data/Contacts.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">该客户端脚本块的 <paramref name="type" /> 为 <see langword="null" />。  
  
-或- 
正在注册该脚本块的控件为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">正在注册该脚本块的控件不在页面的控件树中。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptBlock (System.Web.UI.Page page, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptBlock(class System.Web.UI.Page page, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptBlock(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptBlock : System.Web.UI.Page * Type * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptBlock (page, type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="page">正在注册客户端脚本块的页对象。</param>
        <param name="type">客户端脚本块的类型。 通常使用 <see langword="typeof" /> 运算符 (C#) 或 <see langword="GetType" /> 运算符 (Visual Basic) 来指定此参数，以检索正在注册此脚本的控件的类型。</param>
        <param name="key">脚本块的唯一标识符。</param>
        <param name="script">要注册的脚本。</param>
        <param name="addScriptTags">如果要用 <see langword="true" /> 和 <see langword="&lt;script&gt;" /> 标记括起脚本块，则为 <see langword="&lt;/script&gt;" />；否则为 <see langword="false" />。</param>
        <summary>向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册一个客户端脚本块以与 <see cref="T:System.Web.UI.UpdatePanel" /> 控件中的某个控件一起使用，然后将该此脚本块添加到页面中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用此方法注册脚本块，则每次发生异步回发时都会呈现该脚本。 若要为位于 <xref:System.Web.UI.UpdatePanel> 控件内的控件注册脚本块，以便仅在更新 <xref:System.Web.UI.UpdatePanel> 控件时注册脚本，请使用此方法的 <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 重载。  
  
 如果要注册不与部分页更新相关的脚本块，并且在初始页面呈现期间只需注册脚本块一次，请使用 <xref:System.Web.UI.ClientScriptManager> 类的 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 方法。 可以从页的 <xref:System.Web.UI.Page.ClientScript%2A> 属性中获取对 <xref:System.Web.UI.ClientScriptManager> 对象的引用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">该脚本块的 <paramref name="type" /> 为 <see langword="null" />。  
  
-或- 
正在注册该脚本块的页为 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptInclude">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册一个客户端脚本文件，以便和 <see cref="T:System.Web.UI.UpdatePanel" /> 控件中的某个控件一起使用，然后将脚本文件引用添加到页面中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptInclude (System.Web.UI.Control control, Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptInclude(class System.Web.UI.Control control, class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptInclude(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptInclude(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptInclude : System.Web.UI.Control * Type * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptInclude (control, type, key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">正在注册客户端脚本文件的控件。</param>
        <param name="type">客户端脚本文件的类型。 通常使用 typeof 运算符 (C#) 或 GetType 运算符 (Visual Basic) 来指定此参数，以检索正在注册脚本的控件的类型。</param>
        <param name="key">脚本文件的唯一标识符。</param>
        <param name="url">脚本文件的 URL。</param>
        <summary>向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册一个客户端脚本文件，以便和 <see cref="T:System.Web.UI.UpdatePanel" /> 控件中的某个控件一起使用，然后将脚本文件引用添加到页面中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> 方法为参与部分页面更新的页面或部分页面注册客户端脚本文件。 仅当 `control` 表示正在更新的 <xref:System.Web.UI.UpdatePanel> 控件内的控件时，才会将使用此方法注册的客户端脚本文件发送到页面。 若要在每次发生异步回发时注册脚本文件，请使用此方法的 <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%29> 重载。  
  
 如果要注册不与部分页更新相关的脚本块，并且在初始页面呈现期间只需注册脚本块一次，请使用 <xref:System.Web.UI.ClientScriptManager> 类的 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 方法。 可以从页的 <xref:System.Web.UI.Page.ClientScript%2A> 属性中获取对 <xref:System.Web.UI.ClientScriptManager> 对象的引用。  
  
 <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> 方法通过呈现 `script` 元素（其开始标记包含 `src` 特性）在页面上注册客户端脚本文件。 `url` 参数用于设置 `src` 特性。 若要解析 Url，请使用 <xref:System.Web.UI.Control.ResolveClientUrl%2A> 方法。 此方法使用对其调用的 URL 的上下文来解析路径。  
  
 <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> 和 <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> 方法都将脚本文件呈现到浏览器。 如果已呈现具有相同类型和键的脚本（对于脚本文件）或相同的类型和资源名称（对于嵌入的资源），则不会再次呈现该脚本。  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterClientScriptInclude#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptInclude/CS/ScriptManager_RegisterClientScriptIncludeCS.aspx#1)]  
  
 [!code-javascript[System.Web.UI.ScriptManager.RegisterClientScriptInclude#2](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptInclude/CS/scripts/script_alertdiv.js#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">该客户端脚本文件的 <paramref name="type" /> 为 <see langword="null" />。  
  
-或- 
正在注册该脚本文件的控件为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">正在注册该脚本文件的控件不在页面的控件树中。  
  
-或- 
 <paramref name="url" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="url" /> 为空。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptInclude(System.Web.UI.Page,System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptInclude (System.Web.UI.Page page, Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptInclude(class System.Web.UI.Page page, class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptInclude(System.Web.UI.Page,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptInclude(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptInclude : System.Web.UI.Page * Type * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptInclude (page, type, key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">正在注册客户端脚本文件的页对象。</param>
        <param name="type">客户端脚本文件的类型。 通常使用 typeof 运算符 (C#) 或 GetType 运算符 (Visual Basic) 来指定此参数，以检索正在注册脚本的控件的类型。</param>
        <param name="key">脚本文件的唯一标识符。</param>
        <param name="url">脚本文件的 URL。</param>
        <summary>每次发生异步回发时都向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册客户端脚本，然后将一个脚本文件引用添加到页面中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法注册脚本文件时，将在每次发生异步回发时呈现该脚本。 若要为位于 <xref:System.Web.UI.UpdatePanel> 控件内的控件注册脚本文件，以便仅在更新 <xref:System.Web.UI.UpdatePanel> 控件时注册脚本，请使用此方法的 <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%29> 重载。  
  
 如果要注册不与部分页更新相关的脚本块，并且在初始页面呈现期间只需注册脚本块一次，请使用 <xref:System.Web.UI.ClientScriptManager> 类的 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 方法。 可以从页的 <xref:System.Web.UI.Page.ClientScript%2A> 属性中获取对 <xref:System.Web.UI.ClientScriptManager> 对象的引用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">该客户端脚本文件的 <paramref name="type" /> 为 <see langword="null" />。  
  
-或- 
正在注册该脚本文件的页为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="url" /> 为空。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptResource">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册嵌入程序集中的客户端脚本，以便和正在参与局部页面呈现的控件一起使用。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptResource (System.Web.UI.Control control, Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptResource(class System.Web.UI.Control control, class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptResource(System::Web::UI::Control ^ control, Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptResource : System.Web.UI.Control * Type * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptResource (control, type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">正在注册脚本的控件。</param>
        <param name="type">客户端脚本的类型。 通常使用 typeof 运算符 (C#) 或 GetType 运算符 (Visual Basic) 来指定此参数，以检索正在注册脚本的控件的类型。</param>
        <param name="resourceName">资源的标识符。</param>
        <summary>向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册嵌入程序集中的客户端脚本，以便和正在参与局部页面呈现的控件一起使用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> 方法来注册与部分页面呈现兼容且没有 Microsoft Ajax 库依赖项的脚本。 仅当 `control` 表示已更新 <xref:System.Web.UI.UpdatePanel> 控件内的控件时，才注册使用此方法注册的脚本资源。 若要在每次发生异步回发时注册脚本，请使用此方法的 <xref:System.Web.UI.ScriptManager.RegisterStartupScript%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 重载。  
  
 如果要注册不与部分页更新相关的脚本块，并且在初始页面呈现期间只需注册脚本块一次，请使用 <xref:System.Web.UI.ClientScriptManager> 类的 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 方法。 可以从页的 <xref:System.Web.UI.Page.ClientScript%2A> 属性中获取对 <xref:System.Web.UI.ClientScriptManager> 对象的引用。  
  
 当通过 HTTP 处理程序访问程序集中的资源时，将使用 <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> 方法。 此方法包括 `script` 元素中资源 URL 的内容。  
  
 <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> 和 <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> 方法均将脚本文件加载到浏览器中。 如果已加载具有相同类型和键的脚本（对于脚本文件）或相同的类型和资源名称（对于嵌入的资源），则不会重新加载该脚本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">该客户端资源的 <paramref name="type" /> 为 <see langword="null" />。  
  
-或- 
正在注册该脚本的控件为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">正在注册该脚本的控件不在页面的控件树中。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Page,System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptResource (System.Web.UI.Page page, Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptResource(class System.Web.UI.Page page, class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Page,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptResource(System::Web::UI::Page ^ page, Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptResource : System.Web.UI.Page * Type * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptResource (page, type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">正在注册脚本的页对象。</param>
        <param name="type">客户端脚本的类型。 通常使用 typeof 运算符 (C#) 或 GetType 运算符 (Visual Basic) 来指定此参数，以检索正在注册脚本的控件的类型。</param>
        <param name="resourceName">资源的标识符。</param>
        <summary>每次发生回发时都向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册嵌入程序集中的客户端脚本文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法注册脚本文件时，将在每次发生异步回发时呈现该脚本。 若要为位于 <xref:System.Web.UI.UpdatePanel> 控件内的控件注册脚本，以便仅在更新 <xref:System.Web.UI.UpdatePanel> 控件时注册该脚本，请使用此方法的 <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%29> 重载。  
  
 如果要注册不与部分页更新相关的脚本块，并且在初始页面呈现期间只需注册脚本块一次，请使用 <xref:System.Web.UI.ClientScriptManager> 类的 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 方法。 可以从页的 <xref:System.Web.UI.Page.ClientScript%2A> 属性中获取对 <xref:System.Web.UI.ClientScriptManager> 对象的引用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">该客户端资源的 <paramref name="type" /> 为 <see langword="null" />。  
  
-或- 
正在注册该脚本的页为 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterDataItem">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在局部页面呈现期间将自定义数据发送到多个控件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterDataItem">
      <MemberSignature Language="C#" Value="public void RegisterDataItem (System.Web.UI.Control control, string dataItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDataItem(class System.Web.UI.Control control, string dataItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDataItem(System::Web::UI::Control ^ control, System::String ^ dataItem);" />
      <MemberSignature Language="F#" Value="member this.RegisterDataItem : System.Web.UI.Control * string -&gt; unit" Usage="scriptManager.RegisterDataItem (control, dataItem)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="dataItem" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">正在接收数据的控件。</param>
        <param name="dataItem">发送到控件的数据。</param>
        <summary>在局部页面呈现期间将自定义数据发送到某个控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在异步回发期间使用 <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> 方法将数据从服务器发送到客户端，而不管接收数据的控件是否在 <xref:System.Web.UI.UpdatePanel> 控件中。  
  
 只能在异步回发期间调用 <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> 方法。 若要确定回发是否是异步的，请使用 <xref:System.Web.UI.ScriptManager.IsInAsyncPostBack%2A> 属性。 此方法调用重载，该重载采用设置为 `false`的名为 `isJsonSerialized` 的参数。 如果 `isJsonSerialized` 参数设置为 `false`，则字符串不会序列化为 JavaScript 对象表示法（JSON）。 有关 JSON 格式的详细信息，请参阅[json 网站简介](https://go.microsoft.com/fwlink/?LinkId=77297)。  
  
 在 `PageRequestManager` 对象的 `pageLoading`、`pageLoaded`和 `endRequest` 事件期间，可以在客户端脚本中访问注册到 <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> 方法的数据项。 处理这些事件时，将在事件参数对象中传递自定义数据。 例如，如果为 `pageLoading` 事件提供处理程序，则会在 `PageLoadingEventArgs` 类中传递自定义数据，这将公开一个属性。  
  
   
  
## Examples  
 下面的示例演示如何在异步回发期间将数据发送到页面上的两个 <xref:System.Web.UI.WebControls.Label> 控件。 <xref:System.Web.UI.WebControls.Label> 控件不在 <xref:System.Web.UI.UpdatePanel> 控件中。  
  
> [!NOTE]
>  在此示例中发送的数据仅用于说明。 在实际应用程序中，可以使用 <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> 方法从服务器发送自定义数据。  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/CS/ScriptManagerRegisterDataItemCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/VB/ScriptManagerRegisterDataItemVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在回发期间调用 <see cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" /> 方法。</exception>
        <exception cref="T:System.ArgumentException">已为 <paramref name="dataItem" /> 注册 <paramref name="control" />。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDataItem">
      <MemberSignature Language="C#" Value="public void RegisterDataItem (System.Web.UI.Control control, string dataItem, bool isJsonSerialized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDataItem(class System.Web.UI.Control control, string dataItem, bool isJsonSerialized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDataItem(System::Web::UI::Control ^ control, System::String ^ dataItem, bool isJsonSerialized);" />
      <MemberSignature Language="F#" Value="member this.RegisterDataItem : System.Web.UI.Control * string * bool -&gt; unit" Usage="scriptManager.RegisterDataItem (control, dataItem, isJsonSerialized)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="dataItem" Type="System.String" />
        <Parameter Name="isJsonSerialized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">正在接收数据的页控件。</param>
        <param name="dataItem">发送到控件的数据。</param>
        <param name="isJsonSerialized">如果要将 <see langword="true" /> 序列化为 JSON，则为 <paramref name="dataItem" />；否则为 <see langword="false" />。</param>
        <summary>在局部页面呈现期间，将自定义数据发送到某个控件，并指示数据是否为 JavaScript 对象表示法 (JSON) 格式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在异步回发过程中，可以使用 <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> 方法将数据从服务器发送到客户端，而不管接收数据的控件是否在 <xref:System.Web.UI.UpdatePanel> 控件中。  
  
 如果为 `control` 注册的 `dataItem` 参数未序列化为 JSON，请将 `isJsonSerialized` 参数设置为 `false`。 这就不必为发送到客户端的每个字符串使用 `eval` 函数。 有关 JSON 格式的详细信息，请参阅[json 网站简介](https://go.microsoft.com/fwlink/?LinkId=77297)。  
  
 只能在异步回发期间调用 <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> 方法。 若要确定回发是否是异步的，请使用 <xref:System.Web.UI.ScriptManager.IsInAsyncPostBack%2A> 属性。  
  
 在 `PageRequestManager` 对象的 `pageLoading`、`pageLoaded`和 `endRequest` 事件期间，可以在客户端脚本中访问通过使用 <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> 方法注册的数据项。 处理这些事件时，将在事件参数对象中传递自定义数据。 例如，如果为 `pageLoading` 事件提供处理程序，则会在 `PageLoadingEventArgs` 类中传递自定义数据，这将公开一个属性。  
  
   
  
## Examples  
 下面的示例演示如何在异步回发期间将数据发送到页面上的两个 <xref:System.Web.UI.WebControls.Label> 控件。 <xref:System.Web.UI.WebControls.Label> 控件不在 <xref:System.Web.UI.UpdatePanel> 控件中。 此示例显示不采用 `isJsonSerialized` 参数的重载。 否则，检索 `PageLoadingEventArgs` 对象的 `dataItems` 属性的过程与使用该重载时相同。  
  
> [!NOTE]
>  在此示例中发送的数据仅用于说明。 在实际应用程序中，可以使用 <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> 方法从服务器发送自定义数据。 例如，您可以使用数据项发送有关是否隐藏或显示不在 <xref:System.Web.UI.UpdatePanel> 控件中的客户端元素的信息。  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/CS/ScriptManagerRegisterDataItemCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/VB/ScriptManagerRegisterDataItemVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在回发期间调用 <see cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" /> 方法。</exception>
        <exception cref="T:System.ArgumentException">已为 <paramref name="dataItem" /> 注册 <paramref name="control" />。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDispose">
      <MemberSignature Language="C#" Value="public void RegisterDispose (System.Web.UI.Control control, string disposeScript);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDispose(class System.Web.UI.Control control, string disposeScript) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterDispose(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDispose(System::Web::UI::Control ^ control, System::String ^ disposeScript);" />
      <MemberSignature Language="F#" Value="member this.RegisterDispose : System.Web.UI.Control * string -&gt; unit" Usage="scriptManager.RegisterDispose (control, disposeScript)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="disposeScript" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">使用 <see langword="dispose" /> 脚本的控件。</param>
        <param name="disposeScript"><see langword="dispose" /> 脚本。</param>
        <summary>为 <see langword="dispose" /> 控件内的某个控件注册一个 <see cref="T:System.Web.UI.UpdatePanel" /> 脚本。 在更新或删除 <see cref="T:System.Web.UI.UpdatePanel" /> 控件时会执行脚本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> 方法为 <xref:System.Web.UI.UpdatePanel> 控件内的控件注册 `dispose` 脚本。 在异步回发期间，可以更新、删除或创建 <xref:System.Web.UI.UpdatePanel> 控件。 更新或删除面板时，将调用为 <xref:System.Web.UI.UpdatePanel> 中的控件注册的任何 `dispose` 脚本。 在典型的页开发方案中，您不必调用 <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> 方法。  
  
 <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> 方法旨在供控件开发人员用来注册脚本，或创建从 <xref:System.Web.UI.IScriptControl> 接口继承的控件。 例如，如果您通过使用撰写来开发客户端控件，则可以使用 `dispose` 脚本。 在控件中，您可以实现 <xref:System.Web.UI.IScriptControl> 并呈现单个控件。 注册与已定义的客户端组件（如 `Sys.TextBox`）不对应的任何项的 `dispose` 方法。 如果自定义控件组合了与 Microsoft Ajax 库中的客户端组件相对应的元素，则无需注册 `dispose` 脚本，因为 `dispose` 会自动调用。 因此，请将 <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> 方法用于作为 Microsoft Ajax 库一部分的客户端组件，并且在不再使用某个组件时必须释放资源。  
  
 对于控件，可以多次调用 <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> 方法。 聚合多个脚本。 释放脚本的顺序与脚本的注册顺序相匹配。  
  
 如果为不在 <xref:System.Web.UI.UpdatePanel> 控件中的控件注册 `dispose` 脚本，则会引发异常。 在 `PageRequestManager` 类的 `pageLoading` 和 `pageLoaded` 事件之间调用 `dispose` 脚本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="disposeScript" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">页面上找不到 <paramref name="control" />。  
  
-或- 
 <paramref name="control" /> 不在 <see cref="T:System.Web.UI.UpdatePanel" /> 控件内。</exception>
        <altmember cref="T:System.Web.UI.IScriptControl" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public static void RegisterExpandoAttribute (System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterExpandoAttribute(class System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterExpandoAttribute(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterExpandoAttribute(System::Web::UI::Control ^ control, System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode);" />
      <MemberSignature Language="F#" Value="static member RegisterExpandoAttribute : System.Web.UI.Control * string * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterExpandoAttribute (control, controlId, attributeName, attributeValue, encode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">正在注册 expando 特性的控件。</param>
        <param name="controlId">页中包含自定义特性的控件。</param>
        <param name="attributeName">要注册的自定义特性的名称。</param>
        <param name="attributeValue">自定义特性的值。</param>
        <param name="encode">如果要编码正在注册的自定义特性，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>在 <see cref="T:System.Web.UI.ScriptManager" /> 控件中，将名称/值对注册为指定控件的自定义 (expando) 特性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A> 方法为与部分页面呈现兼容且没有 Microsoft Ajax 库依赖项的控件注册自定义（expando）属性。  
  
 <xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A> 方法将名称/值对注册为指定控件的自定义特性。 该属性是从 ECMAScript （JavaScript）动态设置的，以便为呈现的控件的标记保留 XHTML 兼容性。 如果必须对动态属性的值中的任何字符进行转义，请将 `encode` 设置为 `true`。  
  
 如果未找到动态属性将添加到的控件，则会出现脚本错误。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" /> 不在该页面的控件树中。  
  
-或- 
 <paramref name="controlId" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="controlId" /> 为空。  
  
-或- 
 <paramref name="attributeName" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="attributeName" /> 为空。  
  
-或- 
 已注册 <paramref name="attributeName" />。</exception>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExtenderControl&lt;TExtenderControl&gt;">
      <MemberSignature Language="C#" Value="public void RegisterExtenderControl&lt;TExtenderControl&gt; (TExtenderControl extenderControl, System.Web.UI.Control targetControl) where TExtenderControl : System.Web.UI.Control, System.Web.UI.IExtenderControl;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterExtenderControl&lt;(class System.Web.UI.Control, class System.Web.UI.IExtenderControl) TExtenderControl&gt;(!!TExtenderControl extenderControl, class System.Web.UI.Control targetControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterExtenderControl``1(``0,System.Web.UI.Control)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExtenderControl(Of TExtenderControl As {Control, IExtenderControl}) (extenderControl As TExtenderControl, targetControl As Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TExtenderControl&gt;&#xA; where TExtenderControl : System::Web::UI::Control, System::Web::UI::IExtenderControl virtual void RegisterExtenderControl(TExtenderControl extenderControl, System::Web::UI::Control ^ targetControl);" />
      <MemberSignature Language="F#" Value="abstract member RegisterExtenderControl : 'ExtenderControl * System.Web.UI.Control -&gt; unit (requires 'ExtenderControl :&gt; System.Web.UI.Control and 'ExtenderControl :&gt; System.Web.UI.IExtenderControl)&#xA;override this.RegisterExtenderControl : 'ExtenderControl * System.Web.UI.Control -&gt; unit (requires 'ExtenderControl :&gt; System.Web.UI.Control and 'ExtenderControl :&gt; System.Web.UI.IExtenderControl)" Usage="scriptManager.RegisterExtenderControl (extenderControl, targetControl)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TExtenderControl">
          <Constraints>
            <BaseTypeName>System.Web.UI.Control</BaseTypeName>
            <InterfaceName>System.Web.UI.IExtenderControl</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="extenderControl" Type="TExtenderControl" />
        <Parameter Name="targetControl" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <typeparam name="TExtenderControl">实现 <see cref="T:System.Web.UI.IExtenderControl" /> 接口的控件。</typeparam>
        <param name="extenderControl">要注册的扩展程序控件。</param>
        <param name="targetControl">扩展程序控件扩展的脚本控件。</param>
        <summary>向当前 <see cref="T:System.Web.UI.ScriptManager" /> 实例注册扩展程序控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法主要由控件开发人员使用。 在其 `onInit` 事件处理程序中从自定义 ASP.NET Ajax 扩展程序控件调用 <xref:System.Web.UI.ScriptManager.RegisterExtenderControl%2A> 方法，以将该控件注册到页面。 必须注册 ASP.NET Ajax 扩展程序控件，才能参与部分页面呈现。  
  
 <xref:System.Web.UI.ScriptManager.RegisterExtenderControl%2A> 方法将指定的扩展程序控件添加到扩展程序控件的内部列表和它们扩展的目标脚本控件。 此列表在 <xref:System.Web.UI.Control.PreRender> 事件期间进行处理。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="extenderControl" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="targetControl" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterHiddenField">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>注册隐藏字段。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public static void RegisterHiddenField (System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterHiddenField(class System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterHiddenField(System::Web::UI::Control ^ control, System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="static member RegisterHiddenField : System.Web.UI.Control * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterHiddenField (control, hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">正在注册隐藏字段的控件。</param>
        <param name="hiddenFieldName">要注册的隐藏字段的名称。</param>
        <param name="hiddenFieldInitialValue">隐藏字段的初始值。</param>
        <summary>针对 <see cref="T:System.Web.UI.ScriptManager" /> 控件内的控件，向 <see cref="T:System.Web.UI.UpdatePanel" /> 控件注册隐藏字段。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A> 方法来注册与部分页面呈现兼容且没有 Microsoft Ajax 库依赖项的隐藏字段。 当注册字段的控件位于正在更新的 <xref:System.Web.UI.UpdatePanel> 控件中时，此方法将注册隐藏的字段。 若要在每次发生异步回发时注册隐藏的字段，请使用此方法的 <xref:System.Web.UI.ScriptManager.RegisterHiddenField%28System.Web.UI.Page%2CSystem.String%2CSystem.String%29> 重载。  
  
 如果要注册不与部分页更新相关的隐藏字段，并且想要在初始页面呈现期间只注册一次隐藏的字段，请使用 <xref:System.Web.UI.ClientScriptManager> 类的 <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> 方法。 可以从页的 <xref:System.Web.UI.Page.ClientScript%2A> 属性中获取对 <xref:System.Web.UI.ClientScriptManager> 对象的引用。  
  
 <xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A> 方法在呈现的 HTML 页上创建隐藏的 `input` 元素。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="hiddenFieldName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" /> 不在该页面的控件树中。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Page,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public static void RegisterHiddenField (System.Web.UI.Page page, string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterHiddenField(class System.Web.UI.Page page, string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Page,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterHiddenField(System::Web::UI::Page ^ page, System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="static member RegisterHiddenField : System.Web.UI.Page * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterHiddenField (page, hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">正在注册隐藏字段的页对象。</param>
        <param name="hiddenFieldName">要注册的隐藏字段的名称。</param>
        <param name="hiddenFieldInitialValue">隐藏字段的初始值。</param>
        <summary>在每次异步回发期间向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册隐藏字段。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A> 方法来注册与部分页面呈现兼容且没有 Microsoft Ajax 库依赖项的隐藏字段。 此方法会在每次发生异步回发时注册隐藏的字段。 若要为位于 <xref:System.Web.UI.UpdatePanel> 控件内的控件注册隐藏字段以便仅在更新面板时注册该字段，请使用此方法的 <xref:System.Web.UI.ScriptManager.RegisterHiddenField%28System.Web.UI.Control%2CSystem.String%2CSystem.String%29> 重载。  
  
 如果要注册不与部分页更新相关的隐藏字段，并且想要在初始页面呈现期间只注册一次隐藏的字段，请使用 <xref:System.Web.UI.ClientScriptManager> 类的 <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> 方法。 可以从页的 <xref:System.Web.UI.Page.ClientScript%2A> 属性中获取对 <xref:System.Web.UI.ClientScriptManager> 对象的引用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="page" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="hiddenFieldName" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Control,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterNamedClientScriptResource">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>按资源名称向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册嵌入程序集中的客户端脚本，以便和正在参与局部页面呈现的控件一起使用。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterNamedClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterNamedClientScriptResource (System.Web.UI.Control control, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterNamedClientScriptResource(class System.Web.UI.Control control, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterNamedClientScriptResource(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterNamedClientScriptResource(System::Web::UI::Control ^ control, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="static member RegisterNamedClientScriptResource : System.Web.UI.Control * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterNamedClientScriptResource (control, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="control">正在注册脚本的控件。</param>
        <param name="resourceName">资源的标识符。</param>
        <summary>按资源名称向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册嵌入程序集中的客户端脚本，以便和正在参与局部页面呈现的控件一起使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterNamedClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterNamedClientScriptResource (System.Web.UI.Page page, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterNamedClientScriptResource(class System.Web.UI.Page page, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterNamedClientScriptResource(System.Web.UI.Page,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterNamedClientScriptResource(System::Web::UI::Page ^ page, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="static member RegisterNamedClientScriptResource : System.Web.UI.Page * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterNamedClientScriptResource (page, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="page">正在注册脚本的页对象。</param>
        <param name="resourceName">资源的标识符。</param>
        <summary>按资源名称向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册嵌入程序集中的客户端脚本，以便和正在参与局部页面呈现的控件一起使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterOnSubmitStatement">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>注册在提交表单时执行的 ECMAScript (JavaScript) 代码。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public static void RegisterOnSubmitStatement (System.Web.UI.Control control, Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterOnSubmitStatement(class System.Web.UI.Control control, class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterOnSubmitStatement(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="static member RegisterOnSubmitStatement : System.Web.UI.Control * Type * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterOnSubmitStatement (control, type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">正在注册 <see langword="onsubmit" /> 语句的控件。</param>
        <param name="type">客户端脚本语句的类型。 通常使用 typeof 运算符 (C#) 或 GetType 运算符 (Visual Basic) 来指定此参数，以检索正在注册脚本的控件的类型。</param>
        <param name="key">脚本语句的唯一标识符。</param>
        <param name="script">要注册的脚本。</param>
        <summary>针对与 <see cref="T:System.Web.UI.ScriptManager" /> 控件一起使用的控件，向 <see cref="T:System.Web.UI.UpdatePanel" /> 控件注册提交表单时执行的 ECMAScript (JavaScript) 代码。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A> 添加在提交窗体之前执行的脚本，该脚本允许你修改或取消该提交。  
  
 使用 <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A> 方法可呈现与部分页面呈现兼容且没有 Microsoft Ajax 库依赖项的 `onsubmit` 语句。 仅当注册语句的控件位于正在更新的 <xref:System.Web.UI.UpdatePanel> 控件中时，才会将使用此方法注册的 JavaScript 代码发送到页面。 若要在每次异步回发时注册代码，请使用此方法的 <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%29> 重载。  
  
 如果要注册不与部分页更新相关的 JavaScript 代码，并且在初始页面呈现期间只需注册一次代码，请使用 <xref:System.Web.UI.ClientScriptManager> 类的 <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> 方法。 可以从页的 <xref:System.Web.UI.Page.ClientScript%2A> 属性中获取对 <xref:System.Web.UI.ClientScriptManager> 对象的引用。  
  
 <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A> 方法的*script*参数可包含多个用分号（;) 分隔的脚本命令。  
  
 有关 HTML 窗体和 `onsubmit` 事件的详细信息，请参阅[万维网联合会（W3C）](https://go.microsoft.com/fwlink/?linkid=37125)网站。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="type" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" /> 不在该页面的控件树中。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Page,System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public static void RegisterOnSubmitStatement (System.Web.UI.Page page, Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterOnSubmitStatement(class System.Web.UI.Page page, class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Page,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterOnSubmitStatement(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="static member RegisterOnSubmitStatement : System.Web.UI.Page * Type * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterOnSubmitStatement (page, type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">正在注册 <see langword="onsubmit" /> 语句的页对象。</param>
        <param name="type">客户端脚本语句的类型。 通常使用 typeof 运算符 (C#) 或 GetType 运算符 (Visual Basic) 来指定此参数，以检索正在注册脚本的控件的类型。</param>
        <param name="key">脚本语句的唯一标识符。</param>
        <param name="script">要注册的脚本。</param>
        <summary>针对与 <see cref="T:System.Web.UI.ScriptManager" /> 控件一起使用的控件，向 <see cref="T:System.Web.UI.UpdatePanel" /> 控件注册提交表单时执行的 ECMAScript (JavaScript) 代码。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法注册 JavaScript 代码会导致在每次发生异步回发时都包含脚本。  
  
> [!NOTE]
>  不会删除任何较早的异步回发中的代码。 新的异步回发将代码追加到 `onsubmit` 语句的任何现有代码。  
  
 若要为位于 <xref:System.Web.UI.UpdatePanel> 控件内的控件注册代码，以便仅在更新 <xref:System.Web.UI.UpdatePanel> 控件时注册代码，请使用此方法的 <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%29> 重载。  
  
 如果要注册不与部分页更新相关的 JavaScript 代码，并且在初始页面呈现期间只需注册一次代码，请使用 <xref:System.Web.UI.ClientScriptManager> 类的 <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> 方法。 可以从页的 <xref:System.Web.UI.Page.ClientScript%2A> 属性中获取对 <xref:System.Web.UI.ClientScriptManager> 对象的引用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="page" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="type" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterPostBackControl">
      <MemberSignature Language="C#" Value="public void RegisterPostBackControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterPostBackControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterPostBackControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterPostBackControl(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member RegisterPostBackControl : System.Web.UI.Control -&gt; unit&#xA;override this.RegisterPostBackControl : System.Web.UI.Control -&gt; unit" Usage="scriptManager.RegisterPostBackControl control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">要为回发注册的控件。</param>
        <summary>将控件注册为回发的触发器。 此方法用于配置 <see cref="T:System.Web.UI.UpdatePanel" /> 控件内的回发控件，若未配置，此控件将执行异步回发。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Web.UI.ScriptManager.RegisterPostBackControl%2A> 方法将 <xref:System.Web.UI.UpdatePanel> 控件内的回发控件注册为触发器。 使用此方法注册的控件更新整个页面，而不是仅更新 <xref:System.Web.UI.UpdatePanel> 控件的内容。 在 <xref:System.Web.UI.UpdatePanel> 控件之外使用此方法注册回发控件没有影响，因为默认情况下，这些控件不会执行异步回发。  
  
 您可以使用 <xref:System.Web.UI.UpdatePanel> 控件的 `Triggers` 元素以声明方式添加触发器。 在 Visual Studio 中，使用设计器的 " **UpdatePanelTrigger 集合编辑器**" 对话框。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.UpdatePanel.Triggers" />
      </Docs>
    </Member>
    <Member MemberName="RegisterScriptControl&lt;TScriptControl&gt;">
      <MemberSignature Language="C#" Value="public void RegisterScriptControl&lt;TScriptControl&gt; (TScriptControl scriptControl) where TScriptControl : System.Web.UI.Control, System.Web.UI.IScriptControl;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterScriptControl&lt;(class System.Web.UI.Control, class System.Web.UI.IScriptControl) TScriptControl&gt;(!!TScriptControl scriptControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterScriptControl``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterScriptControl(Of TScriptControl As {Control, IScriptControl}) (scriptControl As TScriptControl)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TScriptControl&gt;&#xA; where TScriptControl : System::Web::UI::Control, System::Web::UI::IScriptControl virtual void RegisterScriptControl(TScriptControl scriptControl);" />
      <MemberSignature Language="F#" Value="abstract member RegisterScriptControl : 'ScriptControl -&gt; unit (requires 'ScriptControl :&gt; System.Web.UI.Control and 'ScriptControl :&gt; System.Web.UI.IScriptControl)&#xA;override this.RegisterScriptControl : 'ScriptControl -&gt; unit (requires 'ScriptControl :&gt; System.Web.UI.Control and 'ScriptControl :&gt; System.Web.UI.IScriptControl)" Usage="scriptManager.RegisterScriptControl scriptControl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TScriptControl">
          <Constraints>
            <BaseTypeName>System.Web.UI.Control</BaseTypeName>
            <InterfaceName>System.Web.UI.IScriptControl</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="scriptControl" Type="TScriptControl" />
      </Parameters>
      <Docs>
        <typeparam name="TScriptControl">实现 <see cref="T:System.Web.UI.IScriptControl" /> 接口的控件。</typeparam>
        <param name="scriptControl">要注册的脚本控件。</param>
        <summary>向当前 <see cref="T:System.Web.UI.ScriptManager" /> 实例注册脚本控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法主要由控件开发人员使用。 在自定义 ASP.NET Ajax 脚本控件 `onInit` 事件处理程序中调用 <xref:System.Web.UI.ScriptManager.RegisterScriptControl%2A> 方法，将该控件注册到页面。 必须注册 ASP.NET Ajax 脚本控件，才能参与部分页面呈现。  
  
 <xref:System.Web.UI.ScriptManager.RegisterScriptControl%2A> 方法将指定的扩展程序控件添加到 <xref:System.Web.UI.Control.PreRender> 事件期间处理的脚本控件的内部列表。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="scriptControl" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterScriptDescriptors">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指示 <see cref="T:System.Web.UI.ScriptManager" /> 控件回调到 <see cref="T:System.Web.UI.ScriptControl" /> 或 <see cref="T:System.Web.UI.ExtenderControl" /> 类，以便返回支持表示客户端控件、组件或行为的客户端对象的脚本。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterScriptDescriptors">
      <MemberSignature Language="C#" Value="public void RegisterScriptDescriptors (System.Web.UI.IExtenderControl extenderControl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterScriptDescriptors(class System.Web.UI.IExtenderControl extenderControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IExtenderControl)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterScriptDescriptors (extenderControl As IExtenderControl)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterScriptDescriptors(System::Web::UI::IExtenderControl ^ extenderControl);" />
      <MemberSignature Language="F#" Value="abstract member RegisterScriptDescriptors : System.Web.UI.IExtenderControl -&gt; unit&#xA;override this.RegisterScriptDescriptors : System.Web.UI.IExtenderControl -&gt; unit" Usage="scriptManager.RegisterScriptDescriptors extenderControl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extenderControl" Type="System.Web.UI.IExtenderControl" />
      </Parameters>
      <Docs>
        <param name="extenderControl">将为其注册脚本描述符的扩展程序控件。</param>
        <summary>回调到 <see cref="T:System.Web.UI.ExtenderControl" /> 类以返回为支持表示客户端控件、组件或行为的客户端对象而必须呈现的实例脚本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ExtenderControl> 类在其 <xref:System.Web.UI.Control.Render%2A> 方法中调用 <xref:System.Web.UI.ScriptManager.RegisterScriptDescriptors%2A> 方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果从 <see cref="T:System.Web.UI.ExtenderControl" /> 类派生并重写 <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> 方法，但不调用基类方法，则必须调用 <see cref="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IExtenderControl)" /> 方法。 这使得 <see cref="T:System.Web.UI.ScriptManager" /> 控件可以呈现支持控件所表示的客户端对象的实例脚本。</para></block>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterExtenderControl``1(``0,System.Web.UI.Control)" />
        <altmember cref="T:System.Web.UI.ScriptDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="RegisterScriptDescriptors">
      <MemberSignature Language="C#" Value="public void RegisterScriptDescriptors (System.Web.UI.IScriptControl scriptControl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterScriptDescriptors(class System.Web.UI.IScriptControl scriptControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IScriptControl)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterScriptDescriptors (scriptControl As IScriptControl)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterScriptDescriptors(System::Web::UI::IScriptControl ^ scriptControl);" />
      <MemberSignature Language="F#" Value="abstract member RegisterScriptDescriptors : System.Web.UI.IScriptControl -&gt; unit&#xA;override this.RegisterScriptDescriptors : System.Web.UI.IScriptControl -&gt; unit" Usage="scriptManager.RegisterScriptDescriptors scriptControl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptControl" Type="System.Web.UI.IScriptControl" />
      </Parameters>
      <Docs>
        <param name="scriptControl">将为其注册脚本描述符的脚本控件。</param>
        <summary>调用 <see cref="T:System.Web.UI.ScriptControl" /> 类以返回为支持表示客户端控件、组件或行为的客户端对象而必须呈现的实例脚本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptControl> 类在其 <xref:System.Web.UI.Control.Render%2A> 事件中调用 <xref:System.Web.UI.ScriptManager.RegisterScriptDescriptors%2A> 方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果从 <see cref="T:System.Web.UI.ScriptControl" /> 类派生并重写 <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> 方法，但不调用基类方法，则必须调用 <see cref="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IScriptControl)" /> 方法。 这使得 <see cref="T:System.Web.UI.ScriptManager" /> 控件可以呈现支持控件所表示的客户端对象的实例脚本。</para></block>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterScriptControl``1(``0)" />
        <altmember cref="T:System.Web.UI.ScriptDescriptor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterStartupScript">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册一个启动脚本块并将此脚本块添加到页面中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public static void RegisterStartupScript (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterStartupScript(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterStartupScript(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="static member RegisterStartupScript : System.Web.UI.Control * Type * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterStartupScript (control, type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">正在注册客户端脚本块的控件。</param>
        <param name="type">客户端脚本块的类型。 通常使用 typeof 运算符 (C#) 或 GetType 运算符 (Visual Basic) 来指定此参数，以检索正在注册脚本的控件的类型。</param>
        <param name="key">脚本块的唯一标识符。</param>
        <param name="script">要注册的脚本。</param>
        <param name="addScriptTags">如果用 <see langword="true" /> 和 <see langword="&lt;script&gt;" /> 标记括起此脚本块，则为 <see langword="&lt;/script&gt;" />；否则为 <see langword="false" />。</param>
        <summary>使用 <see cref="T:System.Web.UI.UpdatePanel" /> 控件为 <see cref="T:System.Web.UI.ScriptManager" /> 中的某个控件注册一个启动脚本块，并将此脚本块添加到页面中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A> 方法来注册与部分页面呈现兼容且没有 Microsoft Ajax 库依赖项的页的启动脚本块。 仅当正在注册块的控件位于正在更新的 <xref:System.Web.UI.UpdatePanel> 控件中时，才会将使用此方法注册的启动脚本块发送到页面。 若要在每次发生异步回发时注册一个启动脚本块，请使用此方法的 <xref:System.Web.UI.ScriptManager.RegisterStartupScript%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 重载。  
  
 如果要注册的启动脚本与部分页面更新不相关，并且要在初始页面呈现期间只注册一次脚本，请使用 <xref:System.Web.UI.ClientScriptManager> 类的 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 方法。 可以从页的 <xref:System.Web.UI.Page.ClientScript%2A> 属性中获取对 <xref:System.Web.UI.ClientScriptManager> 对象的引用。  
  
 当页面完成加载但在引发页面的客户端 `onload` 事件之前，将执行 <xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A> 方法所呈现的脚本块。 启动脚本块位于呈现的 ASP.NET 页面的底部，紧靠在 `</form>` 标记之前。  
  
 不保证使用 <xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A> 注册的启动脚本块的输出顺序与它们的注册顺序相同。 如果启动脚本块的顺序很重要，请使用 <xref:System.Text.StringBuilder> 对象以单个字符串的形式收集脚本块，然后将它们全部注册为一个启动脚本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> 为 <see langword="null" />。  
  
-或- 
 <paramref name="type" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" /> 不在该页面的控件树中。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public static void RegisterStartupScript (System.Web.UI.Page page, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterStartupScript(class System.Web.UI.Page page, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterStartupScript(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="static member RegisterStartupScript : System.Web.UI.Page * Type * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterStartupScript (page, type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="page">正在注册客户端脚本块的页对象。</param>
        <param name="type">客户端脚本块的类型。 通常使用 typeof 运算符 (C#) 或 GetType 运算符 (Visual Basic) 来指定此参数，以检索正在注册脚本的控件的类型。</param>
        <param name="key">脚本块的唯一标识符。</param>
        <param name="script">要注册的脚本。</param>
        <param name="addScriptTags">如果用 <see langword="true" /> 和 <see langword="&lt;script&gt;" /> 标记括起此脚本块，则为 <see langword="&lt;/script&gt;" />；否则为 <see langword="false" />。</param>
        <summary>为每个异步回发向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册一个启动脚本块，并将此脚本块添加到页面中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法来注册每次发生异步回发时都包含的启动脚本块。 若要为位于 <xref:System.Web.UI.UpdatePanel> 控件内的控件注册脚本块，以便仅在更新 <xref:System.Web.UI.UpdatePanel> 控件时注册脚本块，请使用此方法的 <xref:System.Web.UI.ScriptManager.RegisterStartupScript%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 重载。  
  
 如果要注册的启动脚本与部分页面更新不相关，并且要在初始页面呈现期间只注册一次脚本，请使用 <xref:System.Web.UI.ClientScriptManager> 类的 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 方法。 可以从页的 <xref:System.Web.UI.Page.ClientScript%2A> 属性中获取对 <xref:System.Web.UI.ClientScriptManager> 对象的引用。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="scriptManager.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">一个接收要写入页面的控件内容的对象。</param>
        <summary>使用指定的 <see cref="T:System.Web.UI.ScriptManager" /> 对象将 <see cref="T:System.Web.UI.HtmlTextWriter" /> 控件的内容呈现给浏览器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控件开发人员使用此方法来扩展 <xref:System.Web.UI.ScriptManager> 控件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>重写此方法时，调用基 <see cref="M:System.Web.UI.ScriptManager.Render(System.Web.UI.HtmlTextWriter)" /> 方法，以便在页面上呈现定义 `Sys.WebForms.PageRequestManager` 类的客户端脚本。</para></block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="ResolveCompositeScriptReference">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt; ResolveCompositeScriptReference;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.CompositeScriptReferenceEventArgs&gt; ResolveCompositeScriptReference" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.ResolveCompositeScriptReference" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResolveCompositeScriptReference As EventHandler(Of CompositeScriptReferenceEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::CompositeScriptReferenceEventArgs ^&gt; ^ ResolveCompositeScriptReference;" />
      <MemberSignature Language="F#" Value="member this.ResolveCompositeScriptReference : EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt; " Usage="member this.ResolveCompositeScriptReference : System.EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册复合脚本时发生。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveScriptReference">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt; ResolveScriptReference;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.ScriptReferenceEventArgs&gt; ResolveScriptReference" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.ResolveScriptReference" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResolveScriptReference As EventHandler(Of ScriptReferenceEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::ScriptReferenceEventArgs ^&gt; ^ ResolveScriptReference;" />
      <MemberSignature Language="F#" Value="member this.ResolveScriptReference : EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt; " Usage="member this.ResolveScriptReference : System.EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在向 <see cref="P:System.Web.UI.ScriptManager.Scripts" /> 控件注册 <see cref="T:System.Web.UI.ScriptManager" /> 集合的成员时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在页面的 <xref:System.Web.UI.Control.PreRender> 事件期间，为 <xref:System.Web.UI.ScriptManager.Scripts%2A> 集合中的每个成员引发一次此事件。 使用此事件来执行任何更新，然后将脚本呈现到页面。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RoleService">
      <MemberSignature Language="C#" Value="public System.Web.UI.RoleServiceManager RoleService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.RoleServiceManager RoleService" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.RoleService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RoleService As RoleServiceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::RoleServiceManager ^ RoleService { System::Web::UI::RoleServiceManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RoleService : System.Web.UI.RoleServiceManager" Usage="System.Web.UI.ScriptManager.RoleService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.RoleServiceManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与当前 <see cref="T:System.Web.UI.RoleServiceManager" /> 实例关联的 <see cref="T:System.Web.UI.ScriptManager" /> 对象。</summary>
        <value>当前 <see cref="T:System.Web.UI.RoleServiceManager" /> 实例的 <see cref="T:System.Web.UI.ScriptManager" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回的 <xref:System.Web.UI.RoleServiceManager> 对象表示向页面注册的角色服务。 角色服务可以在 <xref:System.Web.UI.ScriptManager> 控件中或关联的 <xref:System.Web.UI.ScriptManagerProxy> 控件中定义。 你可以使用 ASP.NET 角色服务或使用自定义角色服务。 可以通过在页面上的 `asp:ScriptManager` 元素内包含一个 `RoleService` 元素，在标记中添加自定义服务，如以下示例中所示：  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <RoleService Path="MyRoleService.asmx" LoadRoles="True" />  
</asp:ScriptManager>  
```  
  
 还可以通过编程方式配置 <xref:System.Web.UI.RoleServiceManager> 对象。 在页面的 <xref:System.Web.UI.Control.PreRender> 生命周期阶段，会向 <xref:System.Web.UI.ScriptManager> 控件注册服务。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScriptMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.ScriptMode ScriptMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ScriptMode ScriptMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ScriptMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptMode As ScriptMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ScriptMode ScriptMode { System::Web::UI::ScriptMode get(); void set(System::Web::UI::ScriptMode value); };" />
      <MemberSignature Language="F#" Value="member this.ScriptMode : System.Web.UI.ScriptMode with get, set" Usage="System.Web.UI.ScriptManager.ScriptMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定是呈现客户端脚本库的调试版本还是发布版本。</summary>
        <value>指示当前模式的枚举值。 默认为 <see cref="F:System.Web.UI.ScriptMode.Auto" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.ScriptMode%2A> 属性指定 <xref:System.Web.UI.ScriptManager> 控件应呈现客户端脚本库的调试版本还是发布版本。 此值可由配置文件和页面指令中设置的值取代。  
  
 下表列出了此属性的有效值。  
  
|值|定义|  
|-----------|----------------|  
|<xref:System.Web.UI.ScriptMode.Auto>|如果将[部署](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms228298(v%3dvs.100))配置元素的 `retail` 属性设置为 `false`，则在网页中使用客户端脚本库的调试版本。 否则，将使用客户端脚本库的发行版。|  
|<xref:System.Web.UI.ScriptMode.Inherit>|当应用于 <xref:System.Web.UI.ScriptManager> 对象的 <xref:System.Web.UI.ScriptManager.ScriptMode%2A> 属性时，此值与 <xref:System.Web.UI.ScriptMode.Auto>相同。|  
|<xref:System.Web.UI.ScriptMode.Debug>|在网页中使用客户端脚本库的调试版本，除非[部署](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms228298(v%3dvs.100))配置元素的 `retail` 属性设置为 `true`。|  
|<xref:System.Web.UI.ScriptMode.Release>|在网页中使用客户端脚本库的发布版本，除非[部署](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms228298(v%3dvs.100))配置元素的 `retail` 属性设置为 `false`。|  
  
> [!NOTE]
>  [@ Page](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ydy4x04a(v=vs.100))指令的 `debug` 属性不影响启用了 Ajax 的 ASP.NET 应用程序。 <xref:System.Web.UI.ScriptManager> 控件只使用 web.config 文件及其 <xref:System.Web.UI.ScriptManager.IsDebuggingEnabled%2A> 中的设置，并 <xref:System.Web.UI.ScriptManager.ScriptMode%2A> 属性来确定是否呈现调试脚本。  
  
 有关详细信息，请参阅[调试和跟踪 Ajax 应用程序概述](https://msdn.microsoft.com/library/92684ea0-7bb4-4a34-9203-3aa6394ce375)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Web.UI.ScriptManager.ScriptMode" /> 属性不是 <see cref="T:System.Web.UI.ScriptMode" /> 值中的其中一个。</exception>
        <altmember cref="T:System.Web.UI.ScriptMode" />
      </Docs>
    </Member>
    <Member MemberName="ScriptPath">
      <MemberSignature Language="C#" Value="public string ScriptPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScriptPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ScriptPath" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ScriptPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ScriptPath : string with get, set" Usage="System.Web.UI.ScriptManager.ScriptPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This property is obsolete. Set the Path property on each individual ScriptReference instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置位置的根路径，该位置用来生成指向 ASP.NET Ajax 和自定义脚本文件的路径。</summary>
        <value>存储脚本文件的位置。 默认值为解释为相对路径的空字符串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 利用 <xref:System.Web.UI.ScriptManager.ScriptPath%2A> 属性，您可以为页上的所有脚本块指定绝对、相对或相对于应用程序的 URL。 这包括向当前 <xref:System.Web.UI.ScriptManager> 实例注册的自定义和第三方脚本块。 <xref:System.Web.UI.ScriptManager.ScriptPath%2A> 属性通常以声明方式设置为页面上 `ScriptManager` 元素的属性，但也可以在代码中设置该属性。  
  
 如果为 <xref:System.Web.UI.ScriptManager.Scripts%2A> 集合中的 <xref:System.Web.UI.ScriptReference> 对象设置了 `path` 特性或 <xref:System.Web.UI.ScriptReferenceBase.Path%2A> 属性，则该路径值将覆盖该 <xref:System.Web.UI.ScriptManager.ScriptPath%2A> 实例的 <xref:System.Web.UI.ScriptReference> 值。  
  
 如果未指定 <xref:System.Web.UI.ScriptReferenceBase.Path%2A> 值，则 <xref:System.Web.UI.ScriptManager> 控件会搜索 <xref:System.Web.UI.ScriptManager.ScriptPath%2A> 属性定义的目录，并按其 <xref:System.Web.UI.ScriptReference.Name%2A> 或 <xref:System.Web.UI.ScriptReference.Assembly%2A> 属性解析脚本引用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScriptResourceMapping">
      <MemberSignature Language="C#" Value="public static System.Web.UI.ScriptResourceMapping ScriptResourceMapping { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.UI.ScriptResourceMapping ScriptResourceMapping" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ScriptResourceMapping" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ScriptResourceMapping As ScriptResourceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::UI::ScriptResourceMapping ^ ScriptResourceMapping { System::Web::UI::ScriptResourceMapping ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ScriptResourceMapping : System.Web.UI.ScriptResourceMapping" Usage="System.Web.UI.ScriptManager.ScriptResourceMapping" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptResourceMapping</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Web.UI.ScriptResourceMapping" /> 对象。</summary>
        <value><see cref="T:System.Web.UI.ScriptResourceMapping" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Static <xref:System.Web.UI.ScriptManager.ScriptResourceMapping%2A> 属性返回一个 <xref:System.Web.UI.ScriptResourceMapping> 对象，该对象可包含表示脚本资源位置（脚本重定向）的映射集合。 此映射集合可以基于名称或名称/程序集对进行映射，并且它可以指向 <xref:System.Web.UI.ScriptResourceDefinition> 的对象。  
  
   
  
## Examples  
 下面的示例演示如何添加 <xref:System.Web.UI.ScriptManager> 对象可以引用的 <xref:System.Web.UI.ScriptResourceDefinition> 对象。 在 `Application_Start` 事件中，将以下代码添加到 global.asax 文件中。  
  
```csharp  
ScriptResourceDefinition myScriptResDef = new ScriptResourceDefinition();  
myScriptResDef.Path = "~/Scripts/jquery-1.4.2.min.js";  
myScriptResDef.DebugPath = "~/Scripts/jquery-1.4.2.js";  
myScriptResDef.CdnPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.min.js";  
myScriptResDef.CdnDebugPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.js";  
ScriptManager.ScriptResourceMapping.AddDefinition("jquery", null, myScriptResDef);  
```  
  
```vb  
Dim myScriptResDef As New ScriptResourceDefinition()  
myScriptResDef.Path = "~/Scripts/jquery-1.4.2.min.js"  
myScriptResDef.DebugPath = "~/Scripts/jquery-1.4.2.js"  
myScriptResDef.CdnPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.min.js"  
myScriptResDef.CdnDebugPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.js"  
ScriptManager.ScriptResourceMapping.AddDefinition("jquery", Nothing, myScriptResDef)  
```  
  
 在 ASP.NET Web 窗体页（.aspx 文件）的标记中，将以下标记添加到 `form` 元素内和使用 jQuery 脚本的任何元素或代码之前。  
  
```  
<asp:ScriptManager ID="sm1" runat="server">  
  <Scripts>  
    <asp:ScriptReference Name="jquery"/>  
  </Scripts>  
</asp:ScriptManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Scripts">
      <MemberSignature Language="C#" Value="public System.Web.UI.ScriptReferenceCollection Scripts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ScriptReferenceCollection Scripts" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.Scripts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scripts As ScriptReferenceCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ScriptReferenceCollection ^ Scripts { System::Web::UI::ScriptReferenceCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scripts : System.Web.UI.ScriptReferenceCollection" Usage="System.Web.UI.ScriptManager.Scripts" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.CollectionEditorBase, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.CollectionEditorBase, System.Web.Extensions.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptReferenceCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个包含 <see cref="T:System.Web.UI.ScriptReferenceCollection" /> 对象（每个对象表示一个呈现给客户端的脚本文件）的 <see cref="T:System.Web.UI.ScriptReference" /> 对象。</summary>
        <value><see cref="T:System.Web.UI.ScriptReferenceCollection" /> 实例的 <see cref="T:System.Web.UI.ScriptManager" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回的 <xref:System.Web.UI.ScriptReferenceCollection> 对象是 <xref:System.Web.UI.ScriptReference> 对象的集合，其中每个对象都表示一个脚本文件。 集合包括对 ASP.NET 的所有脚本文件的引用，这些文件对 Ajax 功能和自定义脚本文件都是必需的。 可在 <xref:System.Web.UI.ScriptManager> 控件或关联的 <xref:System.Web.UI.ScriptManagerProxy> 控件中定义要呈现的自定义脚本文件。  
  
 可以通过将 `asp:ScriptReference` 元素添加到页面上的 `asp:ScriptManager` 元素中的 `Scripts` 节点，将脚本文件添加到标记的集合中，如下面的示例中所示。  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <Scripts>  
    <asp:ScriptReference Name="Script.js" />  
  </Scripts>  
</asp:ScriptManager>  
```  
  
 还可以使用 <xref:System.Web.UI.ScriptReferenceCollection> 类的 <xref:System.Collections.ObjectModel.Collection%601.Add%2A> 方法，以编程方式将 <xref:System.Web.UI.ScriptReference> 对象添加到 <xref:System.Web.UI.ScriptManager.Scripts%2A> 集合。  
  
 <xref:System.Web.UI.ScriptManager> 控件在控件的 <xref:System.Web.UI.Control.PreRender> 事件期间注册脚本文件。  
  
 <xref:System.Web.UI.ScriptManager.Scripts%2A> 集合不包含核心 Microsoft Ajax Library 脚本。 核心库中的脚本会自动呈现;不需要向 <xref:System.Web.UI.ScriptManager> 控件注册这些控件。 但是，如果您想要替代核心脚本或任何控制脚本并替换不同版本的脚本，则可以将您的版本添加到 <xref:System.Web.UI.ScriptManager.Scripts%2A> 集合中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Services">
      <MemberSignature Language="C#" Value="public System.Web.UI.ServiceReferenceCollection Services { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ServiceReferenceCollection Services" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.Services" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Services As ServiceReferenceCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ServiceReferenceCollection ^ Services { System::Web::UI::ServiceReferenceCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Services : System.Web.UI.ServiceReferenceCollection" Usage="System.Web.UI.ScriptManager.Services" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.ServiceReferenceCollectionEditor, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.CollectionEditorBase, System.Web.Extensions.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ServiceReferenceCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Web.UI.ServiceReferenceCollection" /> 对象，该对象包含 ASP.NET 在客户端上针对 Ajax 功能公开的每个 Web 服务的 <see cref="T:System.Web.UI.ServiceReference" /> 对象。</summary>
        <value>当前 <see cref="T:System.Web.UI.ServiceReferenceCollection" /> 实例的 <see cref="T:System.Web.UI.ScriptManager" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回的 <xref:System.Web.UI.ServiceReferenceCollection> 对象是 <xref:System.Web.UI.ServiceReference> 对象的集合，其中每个对象都表示一个注册到 <xref:System.Web.UI.ScriptManager> 控件的 Web 服务。 可以在 <xref:System.Web.UI.ScriptManager> 控件或关联的 <xref:System.Web.UI.ScriptManagerProxy> 控件中定义服务。  
  
 可以通过将 `asp:ServiceReference` 元素添加到页面上的 `asp:ScriptManager` 实例中的 `Services` 元素，将服务添加到标记的集合中，如下面的示例中所示。  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <Services>  
    <asp:ServiceReference Path="Service.asmx" />  
  </Services>  
</asp:ScriptManager>  
```  
  
 还可以通过使用 <xref:System.Web.UI.ServiceReferenceCollection> 类的 <xref:System.Collections.ObjectModel.Collection%601.Add%2A> 方法，以编程方式将 <xref:System.Web.UI.ServiceReference> 对象添加到 <xref:System.Web.UI.ScriptManager.Services%2A> 集合。  
  
 在页面的 <xref:System.Web.UI.Control.PreRender> 生命周期阶段，会将服务注册到 <xref:System.Web.UI.ScriptManager>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetFocus">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将浏览器焦点设置为指定控件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (string clientID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(string clientID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.SetFocus(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetFocus (clientID As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::String ^ clientID);" />
      <MemberSignature Language="F#" Value="member this.SetFocus : string -&gt; unit" Usage="scriptManager.SetFocus clientID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clientID">要接收焦点的控件的 ID。</param>
        <summary>将浏览器焦点设置为由 ID 指定的控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.SetFocus%2A> 方法的工作方式类似于 <xref:System.Web.UI.Page> 类的 <xref:System.Web.UI.Page.SetFocus%2A> 方法。 这两种方法都使具有指定 ID 的控件成为网页上的活动控件。 <xref:System.Web.UI.ScriptManager> 类的 <xref:System.Web.UI.ScriptManager.SetFocus%2A> 方法用于在异步回发过程中设置焦点。 在回发期间以及第一次呈现页面时，<xref:System.Web.UI.ScriptManager.SetFocus%2A> 方法会调用 <xref:System.Web.UI.Page> 类的 <xref:System.Web.UI.Page.SetFocus%2A> 方法。  
  
 如果有多个对 <xref:System.Web.UI.ScriptManager.SetFocus%2A> 方法的调用，则最后一个调用中的控件将接收焦点。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.SetFocus(System.String)" />
        <altmember cref="M:System.Web.UI.ScriptManager.SetFocus(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.SetFocus(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.SetFocus : System.Web.UI.Control -&gt; unit" Usage="scriptManager.SetFocus control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">要接收焦点的控件。</param>
        <summary>将浏览器焦点设置为指定控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.SetFocus%2A> 方法的工作方式类似于 <xref:System.Web.UI.Page> 类的 <xref:System.Web.UI.Page.SetFocus%2A> 方法。 这两种方法都使指定控件成为网页上的活动控件。 <xref:System.Web.UI.ScriptManager> 类的 <xref:System.Web.UI.ScriptManager.SetFocus%2A> 方法用于在异步回发过程中设置焦点。 在回发期间以及第一次呈现页面时，<xref:System.Web.UI.ScriptManager.SetFocus%2A> 方法会调用 <xref:System.Web.UI.Page> 类的 <xref:System.Web.UI.Page.SetFocus%2A> 方法。  
  
 如果有多个对 <xref:System.Web.UI.ScriptManager.SetFocus%2A> 方法的调用，则最后一个调用中指定的控件将接收焦点。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
        <altmember cref="M:System.Web.UI.ScriptManager.SetFocus(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SupportsPartialRendering">
      <MemberSignature Language="C#" Value="public bool SupportsPartialRendering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsPartialRendering" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.SupportsPartialRendering" />
      <MemberSignature Language="VB.NET" Value="Public Property SupportsPartialRendering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsPartialRendering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SupportsPartialRendering : bool with get, set" Usage="System.Web.UI.ScriptManager.SupportsPartialRendering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个指示客户端是否支持局部页面呈现的值。</summary>
        <value>如果客户端支持局部页面呈现，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值是 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> 属性设置为 `false`，则 <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> 属性返回 `false`。  
  
 如果满足以下条件，则默认检查以确定是否支持部分页面呈现 `true` 返回：  
  
-   <xref:System.Web.Configuration.HttpCapabilitiesBase.W3CDomVersion%2A> 属性值必须大于或等于1.0。  
  
-   <xref:System.Web.Configuration.HttpCapabilitiesBase.EcmaScriptVersion%2A> 属性值必须大于或等于1.0。  
  
-   <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> 属性值必须设置为 `true`。  
  
 如果显式设置了 <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> 属性，则不会使用这些检查。  
  
 控件开发人员应使用 <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> 属性来确定它们是否应支持部分页面呈现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" /> 属性为 <see langword="false" />，而 <see cref="P:System.Web.UI.ScriptManager.SupportsPartialRendering" /> 属性原来设置为 <see langword="true" />。  
  
-或- 
发生 <see cref="P:System.Web.UI.ScriptManager.SupportsPartialRendering" /> 事件之后设置 <see cref="E:System.Web.UI.Control.Init" /> 属性。</exception>
        <altmember cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IPostBackDataHandler.LoadPostData">
      <MemberSignature Language="C#" Value="bool IPostBackDataHandler.LoadPostData (string postDataKey, System.Collections.Specialized.NameValueCollection postCollection);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Web.UI.IPostBackDataHandler.LoadPostData(string postDataKey, class System.Collections.Specialized.NameValueCollection postCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IPostBackDataHandler#LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Function LoadPostData (postDataKey As String, postCollection As NameValueCollection) As Boolean Implements IPostBackDataHandler.LoadPostData" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Web.UI.IPostBackDataHandler.LoadPostData(System::String ^ postDataKey, System::Collections::Specialized::NameValueCollection ^ postCollection) = System::Web::UI::IPostBackDataHandler::LoadPostData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackDataHandler.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="postDataKey" Type="System.String" />
        <Parameter Name="postCollection" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="postDataKey">控件的密钥标识符。</param>
        <param name="postCollection">所有传入的后期数据的集合。</param>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.Web.UI.IPostBackDataHandler.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />。</summary>
        <returns>如果 <see langword="true" /> 控件的状态已因回发而更改，则为 <see cref="T:System.Web.UI.ScriptManager" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员实现。 它只能在 <xref:System.Web.UI.ScriptManager> 实例被强制转换为 <xref:System.Web.UI.IPostBackDataHandler> 接口时使用。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
        <altmember cref="M:System.Web.UI.ScriptManager.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent">
      <MemberSignature Language="C#" Value="void IPostBackDataHandler.RaisePostDataChangedEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IPostBackDataHandler#RaisePostDataChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Sub RaisePostDataChangedEvent () Implements IPostBackDataHandler.RaisePostDataChangedEvent" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent() = System::Web::UI::IPostBackDataHandler::RaisePostDataChangedEvent;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员实现。 它只能在 <xref:System.Web.UI.ScriptManager> 实例被强制转换为 <xref:System.Web.UI.IPostBackDataHandler> 接口时使用。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
        <altmember cref="M:System.Web.UI.ScriptManager.RaisePostDataChangedEvent" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IPostBackEventHandler.RaisePostBackEvent">
      <MemberSignature Language="C#" Value="void IPostBackEventHandler.RaisePostBackEvent (string eventArgument);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(string eventArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IPostBackEventHandler#RaisePostBackEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub RaisePostBackEvent (eventArgument As String) Implements IPostBackEventHandler.RaisePostBackEvent" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System::String ^ eventArgument) = System::Web::UI::IPostBackEventHandler::RaisePostBackEvent;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventArgument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventArgument">表示网页历史记录状态的键/值对的字符串。</param>
        <summary>启用 <see cref="T:System.Web.UI.ScriptManager" /> 控件以处理回发事件，并加载网页的历史记录状态。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.IsSecureConnection">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IScriptManager.IsSecureConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IScriptManager.IsSecureConnection" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#IsSecureConnection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSecureConnection As Boolean Implements IScriptManager.IsSecureConnection" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::IScriptManager::IsSecureConnection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IScriptManager.IsSecureConnection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterArrayDeclaration (System.Web.UI.Control control, string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterArrayDeclaration(class System.Web.UI.Control control, string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterArrayDeclaration(System::Web::UI::Control ^ control, System::String ^ arrayName, System::String ^ arrayValue) = System::Web::UI::IScriptManager::RegisterArrayDeclaration;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="arrayName">To be added.</param>
        <param name="arrayValue">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterClientScriptBlock (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterClientScriptBlock(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterClientScriptBlock(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags) = System::Web::UI::IScriptManager::RegisterClientScriptBlock;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="script">To be added.</param>
        <param name="addScriptTags">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterClientScriptInclude (System.Web.UI.Control control, Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterClientScriptInclude(class System.Web.UI.Control control, class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterClientScriptInclude(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterClientScriptInclude(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ url) = System::Web::UI::IScriptManager::RegisterClientScriptInclude;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="url">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterClientScriptResource (System.Web.UI.Control control, Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterClientScriptResource(class System.Web.UI.Control control, class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterClientScriptResource(System::Web::UI::Control ^ control, Type ^ type, System::String ^ resourceName) = System::Web::UI::IScriptManager::RegisterClientScriptResource;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="resourceName">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterDispose">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterDispose (System.Web.UI.Control control, string disposeScript);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterDispose(class System.Web.UI.Control control, string disposeScript) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterDispose(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterDispose(System::Web::UI::Control ^ control, System::String ^ disposeScript) = System::Web::UI::IScriptManager::RegisterDispose;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="disposeScript" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="disposeScript">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterExpandoAttribute (System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterExpandoAttribute(class System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterExpandoAttribute(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterExpandoAttribute(System::Web::UI::Control ^ control, System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode) = System::Web::UI::IScriptManager::RegisterExpandoAttribute;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="controlId">To be added.</param>
        <param name="attributeName">To be added.</param>
        <param name="attributeValue">To be added.</param>
        <param name="encode">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterHiddenField">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterHiddenField (System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldValue);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterHiddenField(class System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterHiddenField(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterHiddenField(System::Web::UI::Control ^ control, System::String ^ hiddenFieldName, System::String ^ hiddenFieldValue) = System::Web::UI::IScriptManager::RegisterHiddenField;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="hiddenFieldName">To be added.</param>
        <param name="hiddenFieldValue">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterOnSubmitStatement (System.Web.UI.Control control, Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterOnSubmitStatement(class System.Web.UI.Control control, class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterOnSubmitStatement(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script) = System::Web::UI::IScriptManager::RegisterOnSubmitStatement;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="script">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterPostBackControl">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterPostBackControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterPostBackControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterPostBackControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterPostBackControl(System::Web::UI::Control ^ control) = System::Web::UI::IScriptManager::RegisterPostBackControl;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterStartupScript">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterStartupScript (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterStartupScript(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterStartupScript(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags) = System::Web::UI::IScriptManager::RegisterStartupScript;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="script">To be added.</param>
        <param name="addScriptTags">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.SetFocusInternal">
      <MemberSignature Language="C#" Value="void IScriptManager.SetFocusInternal (string clientID);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.SetFocusInternal(string clientID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#SetFocusInternal(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub SetFocusInternal (clientID As String) Implements IScriptManager.SetFocusInternal" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.SetFocusInternal(System::String ^ clientID) = System::Web::UI::IScriptManager::SetFocusInternal;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clientID">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.ScriptManager.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>重写从 <see cref="P:System.Web.UI.Control.Visible" /> 基类继承的 <see cref="T:System.Web.UI.Control" /> 属性以防止设置此值。</summary>
        <value>所有情况下均为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.Visible%2A> 属性在 <xref:System.Web.UI.ScriptManager> 类中被重写，以防止设置此值。 如果将值分配给此属性，则会发生 <xref:System.NotImplementedException> 错误。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">将一个值分配给 <see cref="P:System.Web.UI.ScriptManager.Visible" /> 属性。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
