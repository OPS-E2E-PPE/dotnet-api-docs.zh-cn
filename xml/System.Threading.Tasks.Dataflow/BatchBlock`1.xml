<Type Name="BatchBlock&lt;T&gt;" FullName="System.Threading.Tasks.Dataflow.BatchBlock&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="975ab10c7d0219bc1d09f85ba1e689f82bd745f4" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82405054" /></Metadata><TypeSignature Language="C#" Value="public sealed class BatchBlock&lt;T&gt; : System.Threading.Tasks.Dataflow.IPropagatorBlock&lt;T,T[]&gt;, System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;T[]&gt;, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;, System.Threading.Tasks.Dataflow.ITargetBlock&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit BatchBlock`1&lt;T&gt; extends System.Object implements class System.Threading.Tasks.Dataflow.IDataflowBlock, class System.Threading.Tasks.Dataflow.IPropagatorBlock`2&lt;!T, !T[]&gt;, class System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&lt;!T[]&gt;, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!T[]&gt;, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Dataflow.BatchBlock`1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class BatchBlock(Of T)&#xA;Implements IPropagatorBlock(Of T, T()), IReceivableSourceBlock(Of T()), ISourceBlock(Of T()), ITargetBlock(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class BatchBlock sealed : System::Threading::Tasks::Dataflow::IPropagatorBlock&lt;T, cli::array &lt;T&gt; ^&gt;, System::Threading::Tasks::Dataflow::IReceivableSourceBlock&lt;cli::array &lt;T&gt; ^&gt;, System::Threading::Tasks::Dataflow::ISourceBlock&lt;cli::array &lt;T&gt; ^&gt;, System::Threading::Tasks::Dataflow::ITargetBlock&lt;T&gt;" />
  <TypeSignature Language="F#" Value="type BatchBlock&lt;'T&gt; = class&#xA;    interface IPropagatorBlock&lt;'T, 'T[]&gt;&#xA;    interface ITargetBlock&lt;'T&gt;&#xA;    interface IDataflowBlock&#xA;    interface ISourceBlock&lt;'T[]&gt;&#xA;    interface IReceivableSourceBlock&lt;'T[]&gt;" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1" />
  <TypeSignature Language="F#" Value="type BatchBlock&lt;'T&gt; = class&#xA;    interface IDataflowBlock&#xA;    interface IPropagatorBlock&lt;'T, 'T[]&gt;&#xA;    interface ISourceBlock&lt;'T[]&gt;&#xA;    interface ITargetBlock&lt;'T&gt;&#xA;    interface IReceivableSourceBlock&lt;'T[]&gt;" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
    <AssemblyVersion>4.5.25.0</AssemblyVersion>
    <AssemblyVersion>4.6.0.0</AssemblyVersion>
    <AssemblyVersion>4.6.1.0</AssemblyVersion>
    <AssemblyVersion>4.6.2.0</AssemblyVersion>
    <AssemblyVersion>4.6.3.0</AssemblyVersion>
    <AssemblyVersion>4.6.4.0</AssemblyVersion>
    <AssemblyVersion>4.6.5.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.IDataflowBlock</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.IPropagatorBlock&lt;T,T[]&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;T[]&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.ITargetBlock&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;dotnet-uwp-10.0">
      <AttributeName>System.Diagnostics.DebuggerDisplay("{DebuggerDisplayContent,nq}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;dotnet-uwp-10.0">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.Dataflow.BatchBlock`1/DebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T"><span data-ttu-id="e4f38-101">指定数据的类型将放置于多个批。</span><span class="sxs-lookup"><span data-stu-id="e4f38-101">Specifies the type of data put into batches.</span></span></typeparam>
    <summary><span data-ttu-id="e4f38-102">提供将输入批处理到数组中的数据流。</span><span class="sxs-lookup"><span data-stu-id="e4f38-102">Provides a dataflow block that batches inputs into arrays.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [tpl-install-instructions](~/includes/tpl-install-instructions.md)]
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BatchBlock (int batchSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 batchSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (batchSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BatchBlock(int batchSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Dataflow.BatchBlock&lt;'T&gt; : int -&gt; System.Threading.Tasks.Dataflow.BatchBlock&lt;'T&gt;" Usage="new System.Threading.Tasks.Dataflow.BatchBlock&lt;'T&gt; batchSize" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="batchSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="batchSize"><span data-ttu-id="e4f38-103">分组为批的项数。</span><span class="sxs-lookup"><span data-stu-id="e4f38-103">The number of items to group into a batch.</span></span></param>
        <summary><span data-ttu-id="e4f38-104">初始化指定批次大小的新 <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-104">Initializes a new <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" /> with the specified batch size.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e4f38-105"><paramref name="batchSize" /> 必须是正数。</span><span class="sxs-lookup"><span data-stu-id="e4f38-105">The <paramref name="batchSize" /> must be positive.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BatchBlock (int batchSize, System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions dataflowBlockOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 batchSize, class System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions dataflowBlockOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.#ctor(System.Int32,System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (batchSize As Integer, dataflowBlockOptions As GroupingDataflowBlockOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BatchBlock(int batchSize, System::Threading::Tasks::Dataflow::GroupingDataflowBlockOptions ^ dataflowBlockOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Dataflow.BatchBlock&lt;'T&gt; : int * System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions -&gt; System.Threading.Tasks.Dataflow.BatchBlock&lt;'T&gt;" Usage="new System.Threading.Tasks.Dataflow.BatchBlock&lt;'T&gt; (batchSize, dataflowBlockOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="batchSize" Type="System.Int32" />
        <Parameter Name="dataflowBlockOptions" Type="System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions" />
      </Parameters>
      <Docs>
        <param name="batchSize"><span data-ttu-id="e4f38-106">分组为批的项数。</span><span class="sxs-lookup"><span data-stu-id="e4f38-106">The number of items to group into a batch.</span></span></param>
        <param name="dataflowBlockOptions"><span data-ttu-id="e4f38-107">用来配置此 <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" />的选项。</span><span class="sxs-lookup"><span data-stu-id="e4f38-107">The options with which to configure this <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" />.</span></span></param>
        <summary><span data-ttu-id="e4f38-108">用指定的批大小、定义选项和块选项初始化新的 <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-108">Initializes a new <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" /> with the specified batch size, declining option, and block options.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="e4f38-109"><paramref name="batchSize" /> 必须是正数。</span><span class="sxs-lookup"><span data-stu-id="e4f38-109">The <paramref name="batchSize" /> must be positive.</span></span>  
  
<span data-ttu-id="e4f38-110">- 或 -</span><span class="sxs-lookup"><span data-stu-id="e4f38-110">-or-</span></span> 
<span data-ttu-id="e4f38-111">如果已设置非默认值，则 <paramref name="batchSize" /> 必定小于 <see cref="P:System.Threading.Tasks.Dataflow.DataflowBlockOptions.BoundedCapacity" /> 选项的值。</span><span class="sxs-lookup"><span data-stu-id="e4f38-111">The <paramref name="batchSize" /> must be smaller than the value of the <see cref="P:System.Threading.Tasks.Dataflow.DataflowBlockOptions.BoundedCapacity" /> option if a non-default value has been set.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e4f38-112"><paramref name="dataflowBlockOptions" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-112">The <paramref name="dataflowBlockOptions" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BatchSize">
      <MemberSignature Language="C#" Value="public int BatchSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BatchSize" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.BatchBlock`1.BatchSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BatchSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BatchSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BatchSize : int" Usage="System.Threading.Tasks.Dataflow.BatchBlock&lt;'T&gt;.BatchSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e4f38-113">获取由此 <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" /> 生成的批的大小。</span><span class="sxs-lookup"><span data-stu-id="e4f38-113">Gets the size of the batches generated by this  <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" />.</span></span></summary>
        <value><span data-ttu-id="e4f38-114">批次大小。</span><span class="sxs-lookup"><span data-stu-id="e4f38-114">The batch size.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4f38-115">如果为块的构造函数提供的批大小无法将提供给块的项的数量整除，则该块的最终批处理包含的项数可能少于请求的项数。</span><span class="sxs-lookup"><span data-stu-id="e4f38-115">If the number of items provided to the block is not evenly divisible by the batch size provided to the block's constructor, the block's final batch may contain fewer than the requested number of items.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Complete">
      <MemberSignature Language="C#" Value="public void Complete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Complete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.Complete" />
      <MemberSignature Language="VB.NET" Value="Public Sub Complete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Complete();" />
      <MemberSignature Language="F#" Value="abstract member Complete : unit -&gt; unit&#xA;override this.Complete : unit -&gt; unit" Usage="batchBlock.Complete " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e4f38-116">通知 <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />，告知其不应该生成任何更多的消息也不应使用任何更多的延迟消息。</span><span class="sxs-lookup"><span data-stu-id="e4f38-116">Signals to the <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> that it should not accept nor produce any more messages nor consume any more postponed messages.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4f38-117">在数据流块上调用 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.Complete%2A> 后，该块将完成，并且其 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.Completion%2A> 任务在处理所有以前可用的数据后将进入最终状态。</span><span class="sxs-lookup"><span data-stu-id="e4f38-117">After <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.Complete%2A> has been called on a dataflow block, that block will complete, and its <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.Completion%2A> task will enter a final state after it has processed all previously available data.</span></span> <span data-ttu-id="e4f38-118"><xref:System.Threading.Tasks.Dataflow.BatchBlock%601.Complete%2A> 不会阻止等待完成，而是会启动请求;若要等待完成，可以使用 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.Completion%2A> 任务。</span><span class="sxs-lookup"><span data-stu-id="e4f38-118"><xref:System.Threading.Tasks.Dataflow.BatchBlock%601.Complete%2A> will not block waiting for completion to occur, but rather will initiate the request; to wait for completion to occur, the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.Completion%2A> task may be used.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Completion">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task Completion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.Task Completion" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.BatchBlock`1.Completion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Completion As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::Task ^ Completion { System::Threading::Tasks::Task ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Completion : System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Dataflow.BatchBlock&lt;'T&gt;.Completion" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e4f38-119">获取 <see cref="T:System.Threading.Tasks.Task" />，其表示数据流块的操作和完成。</span><span class="sxs-lookup"><span data-stu-id="e4f38-119">Gets a <see cref="T:System.Threading.Tasks.Task" /> that represents the asynchronous operation and completion of the dataflow block.</span></span></summary>
        <value><span data-ttu-id="e4f38-120">任务。</span><span class="sxs-lookup"><span data-stu-id="e4f38-120">The task.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4f38-121">数据流块在当前未处理消息时，将被视为已完成，并保证其不会再处理其他消息。</span><span class="sxs-lookup"><span data-stu-id="e4f38-121">A dataflow block is considered completed when it is not currently processing a message and when it has guaranteed that it will not process any more messages.</span></span> <span data-ttu-id="e4f38-122">关联的块完成后，返回的 <xref:System.Threading.Tasks.Task> 将转换为已完成状态。</span><span class="sxs-lookup"><span data-stu-id="e4f38-122">The returned <xref:System.Threading.Tasks.Task> will transition to a completed state when the associated block has completed.</span></span> <span data-ttu-id="e4f38-123">当块根据数据流块的定义语义成功完成其处理时，它将转换为 <xref:System.Threading.Tasks.TaskStatus><xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 状态。</span><span class="sxs-lookup"><span data-stu-id="e4f38-123">It will transition to the <xref:System.Threading.Tasks.TaskStatus><xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state when the block completes its processing successfully according to the dataflow block's defined semantics.</span></span> <span data-ttu-id="e4f38-124">当数据流块由于未经处理的异常而提前完成处理时，它将转换为 <xref:System.Threading.Tasks.TaskStatus><xref:System.Threading.Tasks.TaskStatus.Faulted> 状态，并且当数据流块由于接收取消请求而提前完成处理时，它将转换为 <xref:System.Threading.Tasks.TaskStatus><xref:System.Threading.Tasks.TaskStatus.Canceled> 状态。</span><span class="sxs-lookup"><span data-stu-id="e4f38-124">It will transition to the <xref:System.Threading.Tasks.TaskStatus><xref:System.Threading.Tasks.TaskStatus.Faulted> state when the dataflow block has completed processing prematurely due to an unhandled exception, and it will transition to the <xref:System.Threading.Tasks.TaskStatus><xref:System.Threading.Tasks.TaskStatus.Canceled> state when the dataflow block has completed processing prematurely due to receiving a cancellation request.</span></span> <span data-ttu-id="e4f38-125">如果任务在 <xref:System.Threading.Tasks.TaskStatus.Faulted> 状态中完成，则其 `Exception` 属性将返回一个 <xref:System.AggregateException>，其中包含导致块失败的一个或多个异常。</span><span class="sxs-lookup"><span data-stu-id="e4f38-125">If the task completes in the <xref:System.Threading.Tasks.TaskStatus.Faulted> state, its `Exception` property will return an <xref:System.AggregateException> containing the one or more exceptions that caused the block to fail.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkTo">
      <MemberSignature Language="C#" Value="public IDisposable LinkTo (System.Threading.Tasks.Dataflow.ITargetBlock&lt;T[]&gt; target, System.Threading.Tasks.Dataflow.DataflowLinkOptions linkOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IDisposable LinkTo(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T[]&gt; target, class System.Threading.Tasks.Dataflow.DataflowLinkOptions linkOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`0[]},System.Threading.Tasks.Dataflow.DataflowLinkOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function LinkTo (target As ITargetBlock(Of T()), linkOptions As DataflowLinkOptions) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IDisposable ^ LinkTo(System::Threading::Tasks::Dataflow::ITargetBlock&lt;cli::array &lt;T&gt; ^&gt; ^ target, System::Threading::Tasks::Dataflow::DataflowLinkOptions ^ linkOptions);" />
      <MemberSignature Language="F#" Value="abstract member LinkTo : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T[]&gt; * System.Threading.Tasks.Dataflow.DataflowLinkOptions -&gt; IDisposable&#xA;override this.LinkTo : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T[]&gt; * System.Threading.Tasks.Dataflow.DataflowLinkOptions -&gt; IDisposable" Usage="batchBlock.LinkTo (target, linkOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Threading.Tasks.Dataflow.DataflowLinkOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;T[]&gt;" />
        <Parameter Name="linkOptions" Type="System.Threading.Tasks.Dataflow.DataflowLinkOptions" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="e4f38-126">要将此源连接到的 <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-126">The  <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> to which to connect this source.</span></span></param>
        <param name="linkOptions"><span data-ttu-id="e4f38-127"><see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" /> 实例，用于配置链接。</span><span class="sxs-lookup"><span data-stu-id="e4f38-127">A <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" /> instance that configures the link.</span></span></param>
        <summary><span data-ttu-id="e4f38-128">将 <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> 链接到指定的 <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-128">Links the  <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> to the specified  <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> .</span></span></summary>
        <returns><span data-ttu-id="e4f38-129">根据调用 Dispose 将取消与目标中源的链接的 IDisposable。</span><span class="sxs-lookup"><span data-stu-id="e4f38-129">An IDisposable that, upon calling Dispose, will unlink the source from the target.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e4f38-130"><paramref name="target" /> 为 null （在 Visual Basic 中为 Nothing）或 <paramref name="linkOptions" /> 为 null（在 Visual Basic 中为 Nothing）。</span><span class="sxs-lookup"><span data-stu-id="e4f38-130"><paramref name="target" /> is null (Nothing in Visual Basic) or  <paramref name="linkOptions" /> is null (Nothing in Visual Basic).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OutputCount">
      <MemberSignature Language="C#" Value="public int OutputCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 OutputCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.BatchBlock`1.OutputCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int OutputCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.OutputCount : int" Usage="System.Threading.Tasks.Dataflow.BatchBlock&lt;'T&gt;.OutputCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e4f38-131">获取可从此块中接收的输出项的数量。</span><span class="sxs-lookup"><span data-stu-id="e4f38-131">Gets the number of output items available to be received from this block.</span></span></summary>
        <value><span data-ttu-id="e4f38-132">输出项数。</span><span class="sxs-lookup"><span data-stu-id="e4f38-132">The number of output items.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.IDataflowBlock.Fault">
      <MemberSignature Language="C#" Value="void IDataflowBlock.Fault (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Sub Fault (exception As Exception) Implements IDataflowBlock.Fault" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception ^ exception) = System::Threading::Tasks::Dataflow::IDataflowBlock::Fault;" />
      <MemberSignature Language="F#" Value="abstract member System.Threading.Tasks.Dataflow.IDataflowBlock.Fault : Exception -&gt; unit&#xA;override this.System.Threading.Tasks.Dataflow.IDataflowBlock.Fault : Exception -&gt; unit" Usage="batchBlock.System.Threading.Tasks.Dataflow.IDataflowBlock.Fault exception" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(System.Exception)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception"><span data-ttu-id="e4f38-133">导致出错的 <see cref="T:System.Exception" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-133">The <see cref="T:System.Exception" /> that caused the faulting.</span></span></param>
        <summary><span data-ttu-id="e4f38-134">导致 <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> 在 <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> 状态下完成。</span><span class="sxs-lookup"><span data-stu-id="e4f38-134">Causes the <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> to complete in a  <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4f38-135">在数据流块上调用 <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Fault%2A> 后，该块将完成，并且其 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.Completion%2A> 任务将进入最终状态。</span><span class="sxs-lookup"><span data-stu-id="e4f38-135">After <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Fault%2A> has been called on a dataflow block, that block will complete, and its <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.Completion%2A> task will enter a final state.</span></span> <span data-ttu-id="e4f38-136">如果对块进行错误处理，就像取消块一样，导致缓冲消息（未处理的输入消息以及 unoffered 的输出消息）丢失。</span><span class="sxs-lookup"><span data-stu-id="e4f38-136">Faulting a block, as with canceling a block, causes buffered messages (unprocessed input messages as well as unoffered output messages) to be lost.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e4f38-137"><paramref name="exception" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-137">The <paramref name="exception" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ConsumeMessage">
      <MemberSignature Language="C#" Value="T[] ISourceBlock&lt;T[]&gt;.ConsumeMessage (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, System.Threading.Tasks.Dataflow.ITargetBlock&lt;T[]&gt; target, out bool messageConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance !T[] System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ConsumeMessage(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T[]&gt; target, [out] bool&amp; messageConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock&lt;T[]&gt;#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0[]},System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Function ConsumeMessage (messageHeader As DataflowMessageHeader, target As ITargetBlock(Of T()), ByRef messageConsumed As Boolean) As T() Implements ISourceBlock(Of T()).ConsumeMessage" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;T&gt; ^ System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ConsumeMessage(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, System::Threading::Tasks::Dataflow::ITargetBlock&lt;cli::array &lt;T&gt; ^&gt; ^ target, [Runtime::InteropServices::Out] bool % messageConsumed) = System::Threading::Tasks::Dataflow::ISourceBlock&lt;cli::array &lt;T&gt; ^&gt;::ConsumeMessage;" />
      <MemberSignature Language="F#" Value="abstract member System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ConsumeMessage : System.Threading.Tasks.Dataflow.DataflowMessageHeader * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T[]&gt; * bool -&gt; 'T[]&#xA;override this.System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ConsumeMessage : System.Threading.Tasks.Dataflow.DataflowMessageHeader * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T[]&gt; * bool -&gt; 'T[]" Usage="batchBlock.System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ConsumeMessage (messageHeader, target, messageConsumed)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;T[]&gt;" />
        <Parameter Name="messageConsumed" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="messageHeader"><span data-ttu-id="e4f38-138">要使用的消息的 <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-138">The <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> of the message being consumed.</span></span></param>
        <param name="target"><span data-ttu-id="e4f38-139">占用消息的 <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-139">The <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> consuming the message.</span></span></param>
        <param name="messageConsumed"><span data-ttu-id="e4f38-140">如果已成功使用该消息，则为 <see langword="true" />；否则，为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-140"><see langword="true" /> if the message was successfully consumed; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="e4f38-141">由链接的 <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> 调用，以接受并使用以前由此 <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> 提供的 <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-141">Called by a linked <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> to accept and consume a <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> previously offered by this <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> .</span></span></summary>
        <returns><span data-ttu-id="e4f38-142">所使用的消息的值。</span><span class="sxs-lookup"><span data-stu-id="e4f38-142">The value of the consumed message.</span></span> <span data-ttu-id="e4f38-143">这可能对应于一个 <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> 实例，该实例不同于之前保留并作为 <paramref name="messageHeader" /> 传递到 <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> 的实例。</span><span class="sxs-lookup"><span data-stu-id="e4f38-143">This may correspond to a different <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> instance than was previously reserved and passed as the <paramref name="messageHeader" /> to <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" />.</span></span> <span data-ttu-id="e4f38-144">使用的 <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> 必须使用返回值而不是通过 <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" /> 传递为 messageValue 的值。</span><span class="sxs-lookup"><span data-stu-id="e4f38-144">The consuming <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> must use the returned value instead of the value passed as messageValue through <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />.</span></span>  
  
<span data-ttu-id="e4f38-145">如果所需消息不可的，则返回值将是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-145">If the message requested is not available, the return value will be <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4f38-146">仅 [System.threading.tasks.dataflow.isourceblock （T\<x： System.threading.tasks.dataflow.itargetblock %601 > 实例链接到此 [System.threading.tasks.dataflow.isourceblock （T\<x： System.threading.tasks.dataflow.isourceblock %601 > 实例可使用 [System.threading.tasks.dataflow.isourceblock （T\<x： System.threading.tasks.dataflow.isourceblock %601. 601.Consumemessage% 2A >，并且它只能用于将此源之前提供的 [System.threading.tasks.dataflow.isourceblock （T\<x： > 实例一起使用到目标的实例。的实例，请使用该实例。</span><span class="sxs-lookup"><span data-stu-id="e4f38-146">Only [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> instances linked to this [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> instance may use [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A> , and it must only be used to consume [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.DataflowMessageHeader> instances previously offered by this source to the target.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e4f38-147"><paramref name="messageHeader" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="e4f38-147">The  <paramref name="messageHeader" /> is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e4f38-148"><paramref name="target" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-148">The <paramref name="target" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ReleaseReservation">
      <MemberSignature Language="C#" Value="void ISourceBlock&lt;T[]&gt;.ReleaseReservation (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, System.Threading.Tasks.Dataflow.ITargetBlock&lt;T[]&gt; target);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ReleaseReservation(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T[]&gt; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock&lt;T[]&gt;#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0[]})" />
      <MemberSignature Language="VB.NET" Value="Sub ReleaseReservation (messageHeader As DataflowMessageHeader, target As ITargetBlock(Of T())) Implements ISourceBlock(Of T()).ReleaseReservation" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ReleaseReservation(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, System::Threading::Tasks::Dataflow::ITargetBlock&lt;cli::array &lt;T&gt; ^&gt; ^ target) = System::Threading::Tasks::Dataflow::ISourceBlock&lt;cli::array &lt;T&gt; ^&gt;::ReleaseReservation;" />
      <MemberSignature Language="F#" Value="abstract member System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ReleaseReservation : System.Threading.Tasks.Dataflow.DataflowMessageHeader * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T[]&gt; -&gt; unit&#xA;override this.System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ReleaseReservation : System.Threading.Tasks.Dataflow.DataflowMessageHeader * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T[]&gt; -&gt; unit" Usage="batchBlock.System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ReleaseReservation (messageHeader, target)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;T[]&gt;" />
      </Parameters>
      <Docs>
        <param name="messageHeader"><span data-ttu-id="e4f38-149">要发布的已保留消息的 <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-149">The <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> of the reserved message being released.</span></span></param>
        <param name="target"><span data-ttu-id="e4f38-150">发布之前保留的消息的 <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-150">The <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> releasing the message it previously reserved.</span></span></param>
        <summary><span data-ttu-id="e4f38-151">由链接的 <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> 调用，以发布由此 <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> 发布的以前已保留的 <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-151">Called by a linked <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> to release a previously reserved <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> by this <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4f38-152">仅 [System.threading.tasks.dataflow.isourceblock （T\<x：链接到此 [System.threading.tasks.dataflow.isourceblock （T\<x： System.threading.tasks.dataflow.isourceblock %601 > 实例的 System.threading.tasks.dataflow.itargetblock %601 > 实例可以使用 `ReleaseReservation`，并且它必须仅用于释放目标为的 [System.threading.tasks.dataflow.isourceblock （T\<x： DataflowMessageHeader > 实例，并已成功保留该实例。）的所有实例都是必需的。</span><span class="sxs-lookup"><span data-stu-id="e4f38-152">Only [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> instances linked to this [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> instance may use `ReleaseReservation`, and it must only be used to release [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.DataflowMessageHeader> instances previously and successfully reserved by the target.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e4f38-153"><paramref name="messageHeader" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="e4f38-153">The <paramref name="messageHeader" /> is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e4f38-154"><paramref name="target" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-154">The <paramref name="target" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e4f38-155"><paramref name="target" />未保留消息。</span><span class="sxs-lookup"><span data-stu-id="e4f38-155">The <paramref name="target" /> did not have the message reserved.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ReserveMessage">
      <MemberSignature Language="C#" Value="bool ISourceBlock&lt;T[]&gt;.ReserveMessage (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, System.Threading.Tasks.Dataflow.ITargetBlock&lt;T[]&gt; target);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ReserveMessage(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T[]&gt; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock&lt;T[]&gt;#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0[]})" />
      <MemberSignature Language="VB.NET" Value="Function ReserveMessage (messageHeader As DataflowMessageHeader, target As ITargetBlock(Of T())) As Boolean Implements ISourceBlock(Of T()).ReserveMessage" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ReserveMessage(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, System::Threading::Tasks::Dataflow::ITargetBlock&lt;cli::array &lt;T&gt; ^&gt; ^ target) = System::Threading::Tasks::Dataflow::ISourceBlock&lt;cli::array &lt;T&gt; ^&gt;::ReserveMessage;" />
      <MemberSignature Language="F#" Value="abstract member System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ReserveMessage : System.Threading.Tasks.Dataflow.DataflowMessageHeader * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T[]&gt; -&gt; bool&#xA;override this.System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ReserveMessage : System.Threading.Tasks.Dataflow.DataflowMessageHeader * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T[]&gt; -&gt; bool" Usage="batchBlock.System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ReserveMessage (messageHeader, target)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;T[]&gt;" />
      </Parameters>
      <Docs>
        <param name="messageHeader"><span data-ttu-id="e4f38-156">要保留的消息的 <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-156">The <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> of the message being reserved.</span></span></param>
        <param name="target"><span data-ttu-id="e4f38-157">保留消息的 <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-157">The <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> reserving the message.</span></span></param>
        <summary><span data-ttu-id="e4f38-158">由链接的 <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> 调用，以保留以前由此 <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> 提供的 <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-158">Called by a linked <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> to reserve a previously offered <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> by this <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</span></span></summary>
        <returns><span data-ttu-id="e4f38-159">如果已成功保留该消息，则为 <see langword="true" />；否则，为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-159"><see langword="true" /> if the message was successfully reserved; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4f38-160">仅 [System.threading.tasks.dataflow.isourceblock （T\<x： System.threading.tasks.dataflow.itargetblock %601 > 实例链接到此 [System.threading.tasks.dataflow.isourceblock （T\<x： System.threading.tasks.dataflow.isourceblock %601 > 实例可使用 [System.threading.tasks.dataflow.isourceblock （T\<x： System.threading.tasks.dataflow.isourceblock %601. ReserveMessage% 2A >，并且它只能用于将此源之前提供的 [System.threading.tasks.dataflow.isourceblock （T\<x： DataflowMessageHeader > 实例保留到目标中的实例。的实例，请使用此。</span><span class="sxs-lookup"><span data-stu-id="e4f38-160">Only [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> instances linked to this [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> instance may use [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A>, and it must only be used to reserve [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.DataflowMessageHeader> instances previously offered by this source to the target.</span></span>  
  
 <span data-ttu-id="e4f38-161">如果返回 `true`，[System.threading.tasks.dataflow.isourceblock （T\<x： System.threading.tasks.dataflow.itargetblock %601 > 随后必须为此消息调用 [System.threading.tasks.dataflow.isourceblock （T\<x：% 2A > 或 [System.threading.tasks.dataflow.isourceblock （T\<601.consumemessage% system.threading.tasks.dataflow.isourceblock% x% 2A > 中的任何一种，则为此消息的或 system.threading.tasks.dataflow.isourceblock%。</span><span class="sxs-lookup"><span data-stu-id="e4f38-161">If `true` is returned, the  [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> must subsequently call either  [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A> or [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> for this message.</span></span> <span data-ttu-id="e4f38-162">如果不这样做，可能会导致源无法将任何进一步的消息传播到此目标或其他目标。</span><span class="sxs-lookup"><span data-stu-id="e4f38-162">Failure to do so may result in the source being unable to propagate any further messages to this or other targets.</span></span>  
  
 <span data-ttu-id="e4f38-163">[System.threading.tasks.dataflow.isourceblock （T\<x： System.threading.tasks.dataflow.isourceblock %601. ReserveMessage% 2A > 在目标持有任何内部锁时不得调用。</span><span class="sxs-lookup"><span data-stu-id="e4f38-163">[ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A> must not be called while the target is holding any internal locks.</span></span> <span data-ttu-id="e4f38-164">这样做将违反锁层次结构，以避免数据流网络中的死锁。</span><span class="sxs-lookup"><span data-stu-id="e4f38-164">Doing so will violate the lock hierarchy necessary to avoid deadlocks in a dataflow network.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e4f38-165"><paramref name="messageHeader" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="e4f38-165">The <paramref name="messageHeader" /> is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e4f38-166"><paramref name="target" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-166">The <paramref name="target" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ITargetBlock&lt;T&gt;.OfferMessage">
      <MemberSignature Language="C#" Value="System.Threading.Tasks.Dataflow.DataflowMessageStatus ITargetBlock&lt;T&gt;.OfferMessage (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, T messageValue, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T&gt; source, bool consumeToAccept);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Threading.Tasks.Dataflow.DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock&lt;T&gt;.OfferMessage(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, !T messageValue, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!T&gt; source, bool consumeToAccept) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.System#Threading#Tasks#Dataflow#ITargetBlock&lt;T&gt;#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function OfferMessage (messageHeader As DataflowMessageHeader, messageValue As T, source As ISourceBlock(Of T), consumeToAccept As Boolean) As DataflowMessageStatus Implements ITargetBlock(Of T).OfferMessage" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Threading::Tasks::Dataflow::DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock&lt;T&gt;.OfferMessage(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, T messageValue, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T&gt; ^ source, bool consumeToAccept) = System::Threading::Tasks::Dataflow::ITargetBlock&lt;T&gt;::OfferMessage;" />
      <MemberSignature Language="F#" Value="abstract member System.Threading.Tasks.Dataflow.ITargetBlock&lt;T&gt;.OfferMessage : System.Threading.Tasks.Dataflow.DataflowMessageHeader * 'T * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T&gt; * bool -&gt; System.Threading.Tasks.Dataflow.DataflowMessageStatus&#xA;override this.System.Threading.Tasks.Dataflow.ITargetBlock&lt;T&gt;.OfferMessage : System.Threading.Tasks.Dataflow.DataflowMessageHeader * 'T * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T&gt; * bool -&gt; System.Threading.Tasks.Dataflow.DataflowMessageStatus" Usage="batchBlock.System.Threading.Tasks.Dataflow.ITargetBlock&lt;T&gt;.OfferMessage (messageHeader, messageValue, source, consumeToAccept)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Dataflow.DataflowMessageStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="messageValue" Type="T" />
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T&gt;" />
        <Parameter Name="consumeToAccept" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="messageHeader"><span data-ttu-id="e4f38-167">表示要提供的消息的标头的 <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="e4f38-167">A <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> instance that represents the header of the message being offered.</span></span></param>
        <param name="messageValue"><span data-ttu-id="e4f38-168">要提供的消息值。</span><span class="sxs-lookup"><span data-stu-id="e4f38-168">The value of the message being offered.</span></span></param>
        <param name="source"><span data-ttu-id="e4f38-169">提供消息的 <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-169">The <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> offering the message.</span></span> <span data-ttu-id="e4f38-170">这可能为 null。</span><span class="sxs-lookup"><span data-stu-id="e4f38-170">This may be null.</span></span></param>
        <param name="consumeToAccept"><span data-ttu-id="e4f38-171">为使用此消息，设置为 <see langword="true" />，以指示目标于返回 <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> 前在进行对 <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" /> 调用间同步调用 <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-171">Set to <see langword="true" /> to instruct the target to call <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> synchronously during the call to <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />, prior to returning <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" />, in order to consume the message.</span></span></param>
        <summary><span data-ttu-id="e4f38-172">向 <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> 提供消息，向目标提供使用和延迟消息的机会。</span><span class="sxs-lookup"><span data-stu-id="e4f38-172">Offers a message to the <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, giving the target the opportunity to consume or postpone the message.</span></span></summary>
        <returns><span data-ttu-id="e4f38-173">所提供消息的状态。</span><span class="sxs-lookup"><span data-stu-id="e4f38-173">The status of the offered message.</span></span> <span data-ttu-id="e4f38-174">如果消息为该目标接受，则将返回 <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" />，将返回，并且源不应再使用提供的消息，因为其现在归目标所有。</span><span class="sxs-lookup"><span data-stu-id="e4f38-174">If the message was accepted by the target, <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" /> is returned, and the source should no longer use the offered message, because it is now owned by the target.</span></span> <span data-ttu-id="e4f38-175">如果消息因该目标延迟，则将以通知的形式返回 <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed" />，该通知是目标稍后可能会尝试使用或保留消息的通知；同时，源仍拥有消息并将其提供给其他块。</span><span class="sxs-lookup"><span data-stu-id="e4f38-175">If the message was postponed by the target, <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed" /> is returned as a notification that the target may later attempt to consume or reserve the message; in the meantime, the source still owns the message and may offer it to other blocks.</span></span>  
  
<span data-ttu-id="e4f38-176">如果目标应已推迟消息，但是 <paramref name="source" /> 是 <see langword="null" />，则将返回 <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> 替换。</span><span class="sxs-lookup"><span data-stu-id="e4f38-176">If the target would have otherwise postponed message, but <paramref name="source" /> was <see langword="null" />, <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> is instead returned.</span></span>  
  
<span data-ttu-id="e4f38-177">如果尝试了接受此则消息但由于将消息交付给另一目标或放弃该消息的源而错过该消息，则将返回 <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-177">If the target tried to accept the message but missed it due to the source delivering the message to another target or simply discarding it, <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable" /> is returned.</span></span>  
  
<span data-ttu-id="e4f38-178">如果目标选择不接受消息，则将返回 <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-178">If the target chose not to accept the message, <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> is returned.</span></span> <span data-ttu-id="e4f38-179">如果源选择不接受该消息并将从不从此源接受另一则消息，则将返回 <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-179">If the target chose not to accept the message and will never accept another message from this source, <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently" /> is returned.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e4f38-180"><paramref name="messageHeader" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="e4f38-180">The  <paramref name="messageHeader" /> is not valid.</span></span>  
  
<span data-ttu-id="e4f38-181">或者，如果被提供了非 null <paramref name="consumeToAccept" />，则 <paramref name="source" /> 只能为 true。</span><span class="sxs-lookup"><span data-stu-id="e4f38-181">-or- <paramref name="consumeToAccept" /> may only be true if provided with a non-null <paramref name="source" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="batchBlock.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e4f38-182">返回一个字符串，该字符串表示此 <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> 实例的格式化名称。</span><span class="sxs-lookup"><span data-stu-id="e4f38-182">Returns a string that represents the formatted name of this  <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> instance.</span></span></summary>
        <returns><span data-ttu-id="e4f38-183">一个字符串，该字符串表示此 <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> 实例的格式化名称。</span><span class="sxs-lookup"><span data-stu-id="e4f38-183">A string that represents the formatted name of this  <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4f38-184">从 <xref:System.Object> 继承。</span><span class="sxs-lookup"><span data-stu-id="e4f38-184">Inherited from <xref:System.Object>.</span></span> <span data-ttu-id="e4f38-185">使用 <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.NameFormat%2A> 选项。</span><span class="sxs-lookup"><span data-stu-id="e4f38-185">Uses the  <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.NameFormat%2A> option.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TriggerBatch">
      <MemberSignature Language="C#" Value="public void TriggerBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TriggerBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.TriggerBatch" />
      <MemberSignature Language="VB.NET" Value="Public Sub TriggerBatch ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TriggerBatch();" />
      <MemberSignature Language="F#" Value="member this.TriggerBatch : unit -&gt; unit" Usage="batchBlock.TriggerBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e4f38-186">触发 <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" /> 以启动批处理操作，即使当前排队或推迟项的数量小于 <see cref="P:System.Threading.Tasks.Dataflow.BatchBlock`1.BatchSize" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-186">Triggers the <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" /> to initiate a batching operation even if the number of currently queued or postponed items is less than the <see cref="P:System.Threading.Tasks.Dataflow.BatchBlock`1.BatchSize" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4f38-187">在贪婪模式下，即使少于批大小，也会从排队项生成批处理。</span><span class="sxs-lookup"><span data-stu-id="e4f38-187">In greedy mode, a batch will be generated from queued items even if fewer exist than the batch size.</span></span>  
  
 <span data-ttu-id="e4f38-188">在非贪婪模式下，即使不能使用批大小指定的项，也会以异步方式从已推迟的项生成批处理。</span><span class="sxs-lookup"><span data-stu-id="e4f38-188">In non-greedy mode, a batch will be generated asynchronously from postponed items even if fewer items than specified by the batch size can be consumed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReceive">
      <MemberSignature Language="C#" Value="public bool TryReceive (Predicate&lt;T[]&gt; filter, out T[] item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceive(class System.Predicate`1&lt;!T[]&gt; filter, [out] !T[]&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.TryReceive(System.Predicate{`0[]},`0[]@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceive (filter As Predicate(Of T()), ByRef item As T()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryReceive(Predicate&lt;cli::array &lt;T&gt; ^&gt; ^ filter, [Runtime::InteropServices::Out] cli::array &lt;T&gt; ^ % item);" />
      <MemberSignature Language="F#" Value="abstract member TryReceive : Predicate&lt;'T[]&gt; * T[] -&gt; bool&#xA;override this.TryReceive : Predicate&lt;'T[]&gt; * T[] -&gt; bool" Usage="batchBlock.TryReceive (filter, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Predicate&lt;T[]&gt;" />
        <Parameter Name="item" Type="T[]" RefType="out" />
      </Parameters>
      <Docs>
        <param name="filter"><span data-ttu-id="e4f38-189">为使值得到检索，必须成功传递值的谓词。</span><span class="sxs-lookup"><span data-stu-id="e4f38-189">The predicate a value must successfully pass in order for it to be received.</span></span>  <span data-ttu-id="e4f38-190"><paramref name="filter" /> 可能是 <see langword="null" /> ，在此情况下，所有项均将通过。</span><span class="sxs-lookup"><span data-stu-id="e4f38-190"><paramref name="filter" /> may be <see langword="null" />, in which case all items will pass.</span></span></param>
        <param name="item"><span data-ttu-id="e4f38-191">从源中检索到的项。</span><span class="sxs-lookup"><span data-stu-id="e4f38-191">The item received from the source.</span></span></param>
        <summary><span data-ttu-id="e4f38-192">从 <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" /> 中尝试同步接收可用输出项。</span><span class="sxs-lookup"><span data-stu-id="e4f38-192">Attempts to synchronously receive an available output item from the <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</span></span></summary>
        <returns><span data-ttu-id="e4f38-193">如果可以接收项，则为 <see langword="true" />，否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-193"><see langword="true" /> if an item could be received; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4f38-194">此方法不会阻止等待源提供项。</span><span class="sxs-lookup"><span data-stu-id="e4f38-194">This method does not block waiting for the source to provide an item.</span></span>  
  
 <span data-ttu-id="e4f38-195">它将在检查元素后返回，而不管元素是否可用。</span><span class="sxs-lookup"><span data-stu-id="e4f38-195">It will return after checking for an element, whether or not an element was available.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReceiveAll">
      <MemberSignature Language="C#" Value="public bool TryReceiveAll (out System.Collections.Generic.IList&lt;T[]&gt; items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceiveAll([out] class System.Collections.Generic.IList`1&lt;!T[]&gt;&amp; items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.TryReceiveAll(System.Collections.Generic.IList{`0[]}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceiveAll (ByRef items As IList(Of T())) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryReceiveAll([Runtime::InteropServices::Out] System::Collections::Generic::IList&lt;cli::array &lt;T&gt; ^&gt; ^ % items);" />
      <MemberSignature Language="F#" Value="abstract member TryReceiveAll : IList -&gt; bool&#xA;override this.TryReceiveAll : IList -&gt; bool" Usage="batchBlock.TryReceiveAll items" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="System.Collections.Generic.IList&lt;T[]&gt;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="items"><span data-ttu-id="e4f38-196">从源中接收的项。</span><span class="sxs-lookup"><span data-stu-id="e4f38-196">The items received from the source.</span></span></param>
        <summary><span data-ttu-id="e4f38-197">从 <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" /> 中尝试同步接收所有可用项。</span><span class="sxs-lookup"><span data-stu-id="e4f38-197">Attempts to synchronously receive all available items from the <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</span></span></summary>
        <returns><span data-ttu-id="e4f38-198">如果可以接收一个或多个项目，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="e4f38-198"><see langword="true" /> if one or more items could be received; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e4f38-199">此方法不会阻止等待源提供项。</span><span class="sxs-lookup"><span data-stu-id="e4f38-199">This method does not block waiting for the source to provide an item.</span></span>  
  
 <span data-ttu-id="e4f38-200">它将在检查元素后返回，而不管元素是否可用。</span><span class="sxs-lookup"><span data-stu-id="e4f38-200">It will return after checking for elements, whether or not an element was available.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
